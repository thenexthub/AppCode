// Signature format: 4.0
package androidx.xr.arcore.openxr {

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class AnchorState {
    ctor public AnchorState();
    ctor public AnchorState(optional androidx.xr.runtime.TrackingState trackingState, optional androidx.xr.runtime.math.Pose? pose);
    method public androidx.xr.runtime.TrackingState component1();
    method public androidx.xr.runtime.math.Pose? component2();
    method public androidx.xr.arcore.openxr.AnchorState copy(optional androidx.xr.runtime.TrackingState trackingState, optional androidx.xr.runtime.math.Pose? pose);
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose? getPose();
    method @InaccessibleFromKotlin public androidx.xr.runtime.TrackingState getTrackingState();
    property public androidx.xr.runtime.math.Pose? pose;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class HandState {
    ctor public HandState();
    ctor public HandState(optional androidx.xr.runtime.TrackingState trackingState, optional java.util.List<androidx.xr.runtime.math.Pose> handJoints);
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class HitData {
    ctor public HitData(androidx.xr.runtime.math.Pose pose, long id);
    method public androidx.xr.runtime.math.Pose component1();
    method public long component2();
    method public androidx.xr.arcore.openxr.HitData copy(optional androidx.xr.runtime.math.Pose pose, optional long id);
    method @InaccessibleFromKotlin public long getId();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose getPose();
    property public long id;
    property public androidx.xr.runtime.math.Pose pose;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrAnchor implements androidx.xr.arcore.runtime.ExportableAnchor {
    method public void detach();
    method @InaccessibleFromKotlin public android.os.IBinder getAnchorToken();
    method @InaccessibleFromKotlin public long getNativePointer();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Anchor.PersistenceState getPersistenceState();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose getPose();
    method @InaccessibleFromKotlin public androidx.xr.runtime.TrackingState getTrackingState();
    method @InaccessibleFromKotlin public java.util.UUID? getUuid();
    method public void persist();
    method public void update(long xrTime);
    property public android.os.IBinder anchorToken;
    property public long nativePointer;
    property public androidx.xr.arcore.runtime.Anchor.PersistenceState persistenceState;
    property public androidx.xr.runtime.math.Pose pose;
    property public androidx.xr.runtime.TrackingState trackingState;
    property public java.util.UUID? uuid;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrAugmentedObject implements androidx.xr.arcore.runtime.AugmentedObject {
    method public androidx.xr.arcore.runtime.Anchor createAnchor(androidx.xr.runtime.math.Pose pose);
    method @InaccessibleFromKotlin public androidx.xr.runtime.AugmentedObjectCategory getCategory();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose getCenterPose();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.FloatSize3d getExtents();
    method @InaccessibleFromKotlin public androidx.xr.runtime.TrackingState getTrackingState();
    method public void update(long xrTime);
    property public androidx.xr.runtime.AugmentedObjectCategory category;
    property public androidx.xr.runtime.math.Pose centerPose;
    property public androidx.xr.runtime.math.FloatSize3d extents;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrDepthMap implements androidx.xr.arcore.runtime.DepthMap {
    method @InaccessibleFromKotlin public int getHeight();
    method @InaccessibleFromKotlin public java.nio.ByteBuffer? getRawConfidenceMap();
    method @InaccessibleFromKotlin public java.nio.FloatBuffer? getRawDepthMap();
    method @InaccessibleFromKotlin public java.nio.ByteBuffer? getSmoothConfidenceMap();
    method @InaccessibleFromKotlin public java.nio.FloatBuffer? getSmoothDepthMap();
    method @InaccessibleFromKotlin public int getWidth();
    property public int height;
    property public java.nio.ByteBuffer? rawConfidenceMap;
    property public java.nio.FloatBuffer? rawDepthMap;
    property public java.nio.ByteBuffer? smoothConfidenceMap;
    property public java.nio.FloatBuffer? smoothDepthMap;
    property public int width;
    field public static final int CONFIDENCE_INDEX = 2; // 0x2
    field public static final int DEPTH_INDEX = 0; // 0x0
    field public static final int EXPECTED_RAW_BUFFER_COUNT = 4; // 0x4
    field public static final int EXPECTED_SMOOTH_BUFFER_COUNT = 4; // 0x4
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrDevice implements androidx.xr.arcore.runtime.ArDevice {
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose getDevicePose();
    method public void update(long xrTime);
    property public androidx.xr.runtime.math.Pose devicePose;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrEarth implements androidx.xr.arcore.runtime.Earth {
    method public androidx.xr.arcore.runtime.Anchor createAnchor(double latitude, double longitude, double altitude, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion);
    method public suspend Object? createAnchorOnSurface(double latitude, double longitude, double altitudeAboveSurface, androidx.xr.runtime.math.Quaternion eastUpSouthQuaternion, androidx.xr.arcore.runtime.Earth.Surface surface, kotlin.coroutines.Continuation<? super androidx.xr.arcore.runtime.Anchor>);
    method public androidx.xr.arcore.runtime.Earth.GeospatialPoseResult createGeospatialPoseFromDevicePose();
    method public androidx.xr.arcore.runtime.Earth.GeospatialPoseResult createGeospatialPoseFromPose(androidx.xr.runtime.math.Pose pose);
    method public androidx.xr.runtime.math.Pose createPoseFromGeospatialPose(androidx.xr.runtime.math.GeospatialPose geospatialPose);
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Earth.State getState();
    method public void update(long xrTime);
    property public androidx.xr.arcore.runtime.Earth.State state;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrEye implements androidx.xr.arcore.runtime.Eye {
    ctor public OpenXrEye();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose? getCoarsePose();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.EyeStatus? getCoarseStatus();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose? getFinePose();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.EyeStatus? getFineStatus();
    property public androidx.xr.runtime.math.Pose? coarsePose;
    property public androidx.xr.arcore.runtime.EyeStatus? coarseStatus;
    property public androidx.xr.runtime.math.Pose? finePose;
    property public androidx.xr.arcore.runtime.EyeStatus? fineStatus;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrFace implements androidx.xr.arcore.runtime.Face {
    ctor public OpenXrFace();
    method @InaccessibleFromKotlin public float[] getBlendShapeValues();
    method @InaccessibleFromKotlin public float[] getConfidenceValues();
    method @InaccessibleFromKotlin public androidx.xr.runtime.TrackingState getTrackingState();
    method @InaccessibleFromKotlin public boolean isValid();
    method @InaccessibleFromKotlin public void setValid(boolean);
    method public void update(long xrTime);
    property public float[] blendShapeValues;
    property public float[] confidenceValues;
    property public boolean isValid;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrHand implements androidx.xr.arcore.runtime.Hand {
    method @InaccessibleFromKotlin public java.nio.FloatBuffer getHandJointsBuffer();
    method @InaccessibleFromKotlin public androidx.xr.runtime.TrackingState getTrackingState();
    method public void update(long xrTime);
    property public java.nio.FloatBuffer handJointsBuffer;
    property public androidx.xr.runtime.TrackingState trackingState;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrManager implements androidx.xr.runtime.internal.LifecycleManager {
    method public void configure(androidx.xr.runtime.Config config);
    method public void create();
    method @InaccessibleFromKotlin public androidx.xr.runtime.Config getConfig();
    method public void pause();
    method public void resume();
    method public void stop();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark>);
    property public androidx.xr.runtime.Config config;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrPerceptionManager implements androidx.xr.arcore.runtime.PerceptionManager {
    method public suspend Object? checkVpsAvailability(double latitude, double longitude, kotlin.coroutines.Continuation<? super androidx.xr.runtime.VpsAvailabilityResult>);
    method public androidx.xr.arcore.runtime.Anchor createAnchor(androidx.xr.runtime.math.Pose pose);
    method @InaccessibleFromKotlin public androidx.xr.arcore.openxr.OpenXrDevice getArDevice();
    method @InaccessibleFromKotlin public androidx.xr.arcore.openxr.OpenXrEarth getEarth();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.DepthMap? getLeftDepthMap();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Eye getLeftEye();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Hand getLeftHand();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.RenderViewpoint? getLeftRenderViewpoint();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.DepthMap? getMonoDepthMap();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.RenderViewpoint? getMonoRenderViewpoint();
    method public java.util.List<java.util.UUID> getPersistedAnchorUuids();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.DepthMap? getRightDepthMap();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Eye getRightEye();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Hand getRightHand();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.RenderViewpoint? getRightRenderViewpoint();
    method @InaccessibleFromKotlin public java.util.Collection<androidx.xr.arcore.runtime.Trackable> getTrackables();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Face? getUserFace();
    method public java.util.List<androidx.xr.arcore.runtime.HitResult> hitTest(androidx.xr.runtime.math.Ray ray);
    method public androidx.xr.arcore.runtime.Anchor loadAnchor(java.util.UUID uuid);
    method public androidx.xr.arcore.runtime.Anchor loadAnchorFromNativePointer(long nativePointer);
    method public void unpersistAnchor(java.util.UUID uuid);
    method public void update(long xrTime);
    property public androidx.xr.arcore.openxr.OpenXrDevice arDevice;
    property public androidx.xr.arcore.openxr.OpenXrEarth earth;
    property public androidx.xr.arcore.runtime.DepthMap? leftDepthMap;
    property public androidx.xr.arcore.runtime.Eye leftEye;
    property public androidx.xr.arcore.runtime.Hand leftHand;
    property public androidx.xr.arcore.runtime.RenderViewpoint? leftRenderViewpoint;
    property public androidx.xr.arcore.runtime.DepthMap? monoDepthMap;
    property public androidx.xr.arcore.runtime.RenderViewpoint? monoRenderViewpoint;
    property public androidx.xr.arcore.runtime.DepthMap? rightDepthMap;
    property public androidx.xr.arcore.runtime.Eye rightEye;
    property public androidx.xr.arcore.runtime.Hand rightHand;
    property public androidx.xr.arcore.runtime.RenderViewpoint? rightRenderViewpoint;
    property public java.util.Collection<androidx.xr.arcore.runtime.Trackable> trackables;
    property public androidx.xr.arcore.runtime.Face? userFace;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrPlane implements androidx.xr.arcore.runtime.Plane {
    method public androidx.xr.arcore.runtime.Anchor createAnchor(androidx.xr.runtime.math.Pose pose);
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose getCenterPose();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.FloatSize2d getExtents();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Plane.Label getLabel();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Plane? getSubsumedBy();
    method @InaccessibleFromKotlin public androidx.xr.runtime.TrackingState getTrackingState();
    method @InaccessibleFromKotlin public androidx.xr.arcore.runtime.Plane.Type getType();
    method @InaccessibleFromKotlin public java.util.List<androidx.xr.runtime.math.Vector2> getVertices();
    method public void update(long xrTime);
    property public androidx.xr.runtime.math.Pose centerPose;
    property public androidx.xr.runtime.math.FloatSize2d extents;
    property public androidx.xr.arcore.runtime.Plane.Label label;
    property public androidx.xr.arcore.runtime.Plane? subsumedBy;
    property public androidx.xr.runtime.TrackingState trackingState;
    property public androidx.xr.arcore.runtime.Plane.Type type;
    property public java.util.List<androidx.xr.runtime.math.Vector2> vertices;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrRenderViewpoint implements androidx.xr.arcore.runtime.RenderViewpoint {
    method @InaccessibleFromKotlin public androidx.xr.runtime.FieldOfView getFieldOfView();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose getPose();
    property public androidx.xr.runtime.FieldOfView fieldOfView;
    property public androidx.xr.runtime.math.Pose pose;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrRuntime implements androidx.xr.arcore.runtime.PerceptionRuntime {
    method @InaccessibleFromKotlin public androidx.xr.arcore.openxr.OpenXrManager getLifecycleManager();
    method @InaccessibleFromKotlin public androidx.xr.arcore.openxr.OpenXrPerceptionManager getPerceptionManager();
    method public suspend Object? update(kotlin.coroutines.Continuation<? super kotlin.time.ComparableTimeMark?>);
    property public androidx.xr.arcore.openxr.OpenXrManager lifecycleManager;
    property public androidx.xr.arcore.openxr.OpenXrPerceptionManager perceptionManager;
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) public final class OpenXrRuntimeFactory implements androidx.xr.runtime.internal.PerceptionRuntimeFactory {
    ctor public OpenXrRuntimeFactory();
    method public androidx.xr.arcore.runtime.PerceptionRuntime createRuntime(android.app.Activity activity, kotlin.coroutines.CoroutineContext coroutineContext);
    method @InaccessibleFromKotlin public java.util.Set<androidx.xr.runtime.internal.Feature> getRequirements();
    property public java.util.Set<androidx.xr.runtime.internal.Feature> requirements;
    field public static final androidx.xr.arcore.openxr.OpenXrRuntimeFactory.Companion Companion;
  }

  public static final class OpenXrRuntimeFactory.Companion {
  }

  @RestrictTo(androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP_PREFIX) internal final class ViewCameraState {
    ctor public ViewCameraState();
    ctor public ViewCameraState(optional androidx.xr.runtime.math.Pose pose, optional androidx.xr.runtime.FieldOfView fieldOfView);
    method public androidx.xr.runtime.math.Pose component1();
    method public androidx.xr.runtime.FieldOfView component2();
    method public androidx.xr.arcore.openxr.ViewCameraState copy(optional androidx.xr.runtime.math.Pose pose, optional androidx.xr.runtime.FieldOfView fieldOfView);
    method internal boolean equals(Object? other);
    method @InaccessibleFromKotlin public androidx.xr.runtime.FieldOfView getFieldOfView();
    method @InaccessibleFromKotlin public androidx.xr.runtime.math.Pose getPose();
    method internal int hashCode();
    method internal String toString();
    property public androidx.xr.runtime.FieldOfView fieldOfView;
    property public androidx.xr.runtime.math.Pose pose;
  }

}

