// Signature format: 4.0
package androidx.tracing.driver {

  public final class ClockSource_androidKt {
    method public static inline long nanoTime();
  }

  public class CounterTrack extends androidx.tracing.driver.Track {
    ctor public CounterTrack(String name, androidx.tracing.driver.Track parent);
    method @InaccessibleFromKotlin public final String getName();
    method @InaccessibleFromKotlin public final androidx.tracing.driver.Track getParent();
    method public final void setCounter(double value);
    method public final void setCounter(long value);
    property public final String name;
    property public final androidx.tracing.driver.Track parent;
  }

  @SuppressCompatibility @kotlin.RequiresOptIn(message="Marks declarations in the Tracing API that are delicate.") @kotlin.annotation.Target(allowedTargets={kotlin.annotation.AnnotationTarget.CLASS, kotlin.annotation.AnnotationTarget.FUNCTION}) public @interface DelicateTracingApi {
  }

  @SuppressCompatibility @androidx.tracing.driver.DelicateTracingApi public final class MetadataEntry {
    method public void reset();
    property public boolean booleanValue;
    property public double doubleValue;
    property public long longValue;
    property public String? name;
    property public String stringValue;
    property public int type;
    field public boolean booleanValue;
    field public double doubleValue;
    field public long longValue;
    field public String? name;
    field public String stringValue;
    field public int type;
  }

  public abstract class Poolable<T extends androidx.tracing.driver.Poolable<T>> {
    method public abstract void recycle();
  }

  @SuppressCompatibility @androidx.tracing.driver.DelicateTracingApi public final class PooledTracePacketArray extends androidx.tracing.driver.Poolable<androidx.tracing.driver.PooledTracePacketArray> {
    method public inline void forEach(kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEvent,kotlin.Unit> block);
    method public void recycle();
    property public int fillCount;
    property public androidx.tracing.driver.TraceEvent[] packets;
    field public volatile int fillCount;
    field public final androidx.tracing.driver.TraceEvent[] packets;
  }

  public class ProcessTrack extends androidx.tracing.driver.SliceTrack {
    ctor public ProcessTrack(androidx.tracing.driver.TraceContext context, int id, String name);
    method @InaccessibleFromKotlin public final int getId();
    method @InaccessibleFromKotlin public final String getName();
    method public androidx.tracing.driver.CounterTrack getOrCreateCounterTrack(String name);
    method public androidx.tracing.driver.ThreadTrack getOrCreateThreadTrack(int id, String name);
    property public final int id;
    property public final String name;
  }

  public abstract class SliceTrack extends androidx.tracing.driver.Track {
    ctor public SliceTrack(androidx.tracing.driver.TraceContext context, long uuid);
    method public final inline void beginSection(String name);
    method public final inline void beginSection(String name, java.util.List<java.lang.Long> flowIds);
    method public final inline void beginSection(String name, java.util.List<java.lang.Long> flowIds, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock);
    method public final inline void beginSection(String name, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock);
    method public final inline void endSection();
    method public final void instant(String name);
    method public final inline <T> T trace(String name, kotlin.jvm.functions.Function0<? extends T> block);
    method public final inline <T> T trace(String name, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock, kotlin.jvm.functions.Function0<? extends T> block);
    method public final suspend inline <T> Object? traceCoroutine(String name, kotlin.jvm.functions.Function1<? super kotlin.coroutines.Continuation<? super T>,? extends java.lang.Object?> block, optional kotlin.coroutines.Continuation<? super T>);
    method public final suspend inline <T> Object? traceCoroutine(String name, optional long flowId, optional kotlin.jvm.functions.Function1<? super androidx.tracing.driver.TraceEventScope,kotlin.Unit> metadataBlock, kotlin.jvm.functions.Function1<? super kotlin.coroutines.Continuation<? super T>,? extends java.lang.Object?> block, kotlin.coroutines.Continuation<? super T>);
    method public final suspend inline <T> Object? traceCoroutine(String name, optional long flowId, kotlin.jvm.functions.Function1<? super kotlin.coroutines.Continuation<? super T>,? extends java.lang.Object?> block, kotlin.coroutines.Continuation<? super T>);
  }

  public class ThreadTrack extends androidx.tracing.driver.SliceTrack {
    ctor public ThreadTrack(int id, String name, androidx.tracing.driver.ProcessTrack process);
    method @InaccessibleFromKotlin public final int getId();
    method @InaccessibleFromKotlin public final String getName();
    method @InaccessibleFromKotlin public final androidx.tracing.driver.ProcessTrack getProcess();
    property public final int id;
    property public final String name;
    property public final androidx.tracing.driver.ProcessTrack process;
  }

  public class TraceContext implements java.lang.AutoCloseable {
    ctor public TraceContext(androidx.tracing.driver.TraceSink sink, boolean isEnabled);
    method public void close();
    method public final void flush();
    method public androidx.tracing.driver.ProcessTrack getOrCreateProcessTrack(int id, String name);
    method @InaccessibleFromKotlin public final androidx.tracing.driver.TraceSink getSink();
    method @InaccessibleFromKotlin public final boolean isEnabled();
    property public final boolean isEnabled;
    property public final androidx.tracing.driver.TraceSink sink;
  }

  public final class TraceDriver {
    ctor public TraceDriver(androidx.tracing.driver.TraceSink sink, optional boolean isEnabled);
    method public androidx.tracing.driver.ProcessTrack ProcessTrack(int id, String name);
    method @InaccessibleFromKotlin public androidx.tracing.driver.TraceContext getContext();
    property public androidx.tracing.driver.TraceContext context;
  }

  @SuppressCompatibility @androidx.tracing.driver.DelicateTracingApi public final class TraceEvent {
    ctor public TraceEvent();
    method public void reset();
    property public java.util.List<java.lang.String> categories;
    property public Double? counterDoubleValue;
    property public Long? counterLongValue;
    property public java.util.List<java.lang.Long> flowIds;
    property public int lastCategoryIndex;
    property public int lastMetadataEntryIndex;
    property public java.util.List<androidx.tracing.driver.MetadataEntry> metadataEntries;
    property public String? name;
    property public long timestamp;
    property public androidx.tracing.driver.TrackDescriptor? trackDescriptor;
    property public long trackUuid;
    property public int type;
    field public java.util.List<java.lang.String> categories;
    field public Double? counterDoubleValue;
    field public Long? counterLongValue;
    field public java.util.List<java.lang.Long> flowIds;
    field public int lastCategoryIndex;
    field public int lastMetadataEntryIndex;
    field public java.util.List<androidx.tracing.driver.MetadataEntry> metadataEntries;
    field public String? name;
    field public long timestamp;
    field public androidx.tracing.driver.TrackDescriptor? trackDescriptor;
    field public long trackUuid;
    field public int type;
  }

  public final class TraceEventScope {
    method public void addCategory(String name);
    method public void addMetadataEntry(String name, boolean value);
    method public void addMetadataEntry(String name, double value);
    method public void addMetadataEntry(String name, String value);
    method public void addMetadataEntry(String name, long value);
  }

  public abstract class TraceSink implements java.lang.AutoCloseable {
    ctor public TraceSink();
    method public abstract void close();
    method public abstract void enqueue(androidx.tracing.driver.PooledTracePacketArray pooledPacketArray);
    method public abstract void flush();
    method public abstract void onDroppedTraceEvent();
  }

  public final class Tracing_androidKt {
    method public static androidx.tracing.driver.ProcessTrack currentProcessTrack(android.content.Context context, androidx.tracing.driver.TraceDriver traceDriver);
  }

  public abstract class Track {
    ctor public Track(@kotlin.PublishedApi androidx.tracing.driver.TraceContext context, @kotlin.PublishedApi long uuid);
  }

  public final class TrackDescriptor {
    ctor public TrackDescriptor(String name, long uuid, long parentUuid, int type, int pid, int tid);
    method @InaccessibleFromKotlin public String getName();
    method @InaccessibleFromKotlin public long getParentUuid();
    method @InaccessibleFromKotlin public int getPid();
    method @InaccessibleFromKotlin public int getTid();
    method @InaccessibleFromKotlin public int getType();
    method @InaccessibleFromKotlin public long getUuid();
    method @InaccessibleFromKotlin public void setName(String);
    method @InaccessibleFromKotlin public void setParentUuid(long);
    method @InaccessibleFromKotlin public void setPid(int);
    method @InaccessibleFromKotlin public void setTid(int);
    method @InaccessibleFromKotlin public void setType(int);
    method @InaccessibleFromKotlin public void setUuid(long);
    property public String name;
    property public long parentUuid;
    property public int pid;
    property public int tid;
    property public int type;
    property public long uuid;
  }

  public typealias AtomicBoolean = java.util.concurrent.atomic.AtomicBoolean;

  public typealias AtomicInteger = java.util.concurrent.atomic.AtomicInteger;

  public typealias AtomicLong = java.util.concurrent.atomic.AtomicLong;

}

