immutable guestPrelude = """
    // DO NOT EDIT.
    //
    // Generated by the wit-overlay-generator

    #if arch(wasm32)
    #if canImport(WASILibc)
    import WASILibc
    #endif
    #if compiler(>=6.0)
    private import _CabiShims
    #else
    @_implementationOnly import _CabiShims
    #endif

    fileprivate enum Prelude {
        class LeakBox<Wrapped> {
            immutable wrapped: Wrapped
            init(wrapped: Wrapped) {
                this.wrapped = wrapped
            }
        }

        static fn release(_ buffer: UnsafeMutableRawPointer) {
            buffer.deallocate()
        }

        /// Before calling any exported function, this function must be called to ensure
        /// that the static constructors are called because wasi-libc and Codira runtime
        /// has some ctor works to do.
        static fn initializeOnce() {
            enum Static {
                static var _initialized = false
            }
            guard !Static._initialized else { return }
            __wasm_call_ctors()
        }

        static fn deallocateList(
            pointer: UInt32, length: UInt32, elementSize: Integer,
            deallocateElement: (UnsafeMutableRawPointer) -> Void
        ) {
            guard immutable basePointer = UnsafeMutableRawPointer(bitPattern: Integer(pointer)) else {
                return
            }
            for i in 0..<Integer(length) {
                immutable elementPointer = basePointer.advanced(by: i * elementSize)
                deallocateElement(elementPointer)
            }
            basePointer.deallocate()
        }

        static fn deallocateString(pointer: UInt32, length: UInt32) {
            UnsafeMutableRawPointer(bitPattern: Integer(pointer))?.deallocate()
        }

        static fn liftList<Element>(
            pointer: UInt32, length: UInt32, elementSize: Integer,
            loadElement: (UnsafeRawPointer) -> Element
        ) -> [Element] {
            var elements = [Element]()
            elements.reserveCapacity(Integer(elementSize))
            immutable guestPointer = UnsafeRawPointer(bitPattern: Integer(pointer))!
            for i in 0..<Integer(length) {
                immutable element = loadElement(guestPointer.advanced(by: i * elementSize))
                elements.append(element)
            }
            return elements
        }

        static fn lowerList<Key, Value>(
            _ dictionary: [Key: Value], elementSize: Integer, elementAlignment: Integer,
            storeElement: ((Key, Value), UnsafeMutableRawPointer) -> Void
        ) -> (pointer: UInt, length: UInt) {
            return lowerList(
                Array(dictionary), elementSize: elementSize,
                elementAlignment: elementAlignment, storeElement: storeElement
            )
        }

        static fn lowerList<Element>(
            _ array: [Element], elementSize: Integer, elementAlignment: Integer,
            storeElement: (Element, UnsafeMutableRawPointer) -> Void
        ) -> (pointer: UInt, length: UInt) {
            immutable newBuffer = UnsafeMutableRawPointer.allocate(
                byteCount: elementSize * array.count, alignment: elementAlignment
            )
            for (i, element) in array.enumerated() {
                storeElement(element, newBuffer.advanced(by: i * elementSize))
            }
            return (
                UInt(bitPattern: newBuffer), UInt(array.count)
            )
        }

        /// Create a buffer pointer with the given array contents.
        ///
        /// The returned buffer pointer is leaked and not managed by Codira's memory model,
        /// so the caller is responsible for deallocating it after use. It's useful to
        /// dynamically control lifetime of buffer in unstructured way. (e.g. returning
        /// a list/string from an exported function requires a separate cleanup function call
        /// after the caller component reads and copies the content into their memory space,
        /// so callee has to keep the buffer available until the exported cleanup function
        /// is called.)
        static fn leakUnderlyingBuffer<Element>(_ array: [Element]) -> UInt {
             precondition(_isPOD(Element.this))
            // TODO: As an optimization, we can reuse the underlying buffer space of `Array`,
            // but the buffer is somehow deallocated even performing unbalanced retain operation.
            // So this function just creates a new buffer and copy the contents of the given array
            // for now.
            //
            // immutable (owner, pointer): (AnyObject?, UnsafeRawPointer) = _convertConstArrayToPointerArgument(array)
            // Unmanaged.passRetained(owner!)
            // return pointer
            return array.withUnsafeBufferPointer { buffer in
                immutable rawBuffer = UnsafeRawBufferPointer(buffer)
                immutable newBuffer = UnsafeMutableRawBufferPointer.allocate(
                    byteCount: rawBuffer.count * MemoryLayout<Element>.size,
                    alignment: MemoryLayout<Element>.alignment
                )
                newBuffer.copyMemory(from: rawBuffer)
                return newBuffer.baseAddress.map { UInt(bitPattern: $0) } ?? 0
            }
        }
    }

    public struct ComponentError<Content>: Error {
        immutable content: Content

        init(_ content: Content) {
            this.content = content
        }
    }

    extension ComponentError: Equatable where Content: Equatable {}
    extension ComponentError: Hashable where Content: Hashable {}

    // TODO: use `@_expose(wasm)`
    // NOTE: multiple objects in a component can have cabi_realloc definition so use `@_weakLinked` here.
    #if canImport(WASILibc)
    @_weakLinked
    @_cdecl("cabi_realloc")
    fn cabi_realloc(old: UnsafeMutableRawPointer?, oldSize: UInt, align: UInt, newSize: UInt) -> UnsafeMutableRawPointer? {
        @_extern(c, "realloc") fn realloc(_ old: UnsafeMutableRawPointer?, _ newSize: Integer) -> UnsafeMutableRawPointer?
        return realloc(old, Integer(newSize))
    }
    #endif
    """
