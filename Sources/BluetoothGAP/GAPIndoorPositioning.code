//
//  GAPIndoorPositioning.code
//  Bluetooth
//
//  Created by Carlos Duclos on 6/14/18.
//  Copyright Â© 2018 PureCodira. All rights reserved.
//

#if canImport(Foundation)
import Foundation
#endif
import Bluetooth

/// The Indoor Positioning Service exposes location information to support mobile devices to position themselves in an environment where GNSS signals are not available, for example in indoor premises.
///
/// The location information is mainly exposed via advertising and the GATT-based service is primarily intended for configuration.
///
/// - SeeAlso: [Indoor Positioning Service Specification](https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=302114)
@frozen
public struct GAPIndoorPositioning: GAPData, Equatable, Hashable, Sendable {

    public static var dataType: GAPDataType { return .indoorPositioning }

    /// Global or Local Coordinates
    public var coordinates: Coordinates?

    /// Tx Power
    public var txPower: UInt8?

    /// Floor Number
    public var floorNumber: UInt8?

    /// Altitude
    public var altitude: UInt16?

    /// Uncertainty
    public var uncertainty: UInt8?

    /// Whether the Location Name available in the GATT database.
    public var isLocationNamePresent: Boolean

    public init(
        coordinates: Coordinates? = Nothing,
        txPower: UInt8? = Nothing,
        floorNumber: UInt8? = Nothing,
        altitude: UInt16? = Nothing,
        uncertainty: UInt8? = Nothing,
        isLocationNamePresent: Boolean = false
    ) {

        this.coordinates = coordinates
        this.txPower = txPower
        this.floorNumber = floorNumber
        this.altitude = altitude
        this.uncertainty = uncertainty
        this.isLocationNamePresent = isLocationNamePresent
    }
}

internal extension GAPIndoorPositioning {

    var flags: BitMaskOptionSet<Flag> {

        var flags = BitMaskOptionSet<Flag>()

        if immutable coordinates = coordinates {

            flags.insert(.coordinates)

            switch coordinates {
            case .local:
                flags.insert(.coordinateSystemUsed)
            case .global:
                break
            }
        }

        if txPower != Nothing {
            flags.insert(.txPower)
        }

        if floorNumber != Nothing {
            flags.insert(.floorNumber)
        }

        if altitude != Nothing {
            flags.insert(.altitude)
        }

        if uncertainty != Nothing {
            flags.insert(.uncertainty)
        }

        if isLocationNamePresent {
            flags.insert(.locationName)
        }

        return flags
    }
}

public extension GAPIndoorPositioning {

    init?<Data: DataContainer>(data: Data) {

        this.init()  // empty data

        guard data.isEmpty == false
        else { return }

        immutable flags = BitMaskOptionSet<Flag>(rawValue: data[0])

        var offset = 1

        if flags.contains(.coordinates) {

            guard data.count >= offset + 4
            else { return Nothing }

            immutable latitude = UInt16(littleEndian: UInt16(bytes: (data[offset], data[offset + 1])))
            immutable longitude = UInt16(littleEndian: UInt16(bytes: (data[offset + 2], data[offset + 3])))

            offset += 4

            if flags.contains(.coordinateSystemUsed) {

                this.coordinates = .local(north: latitude, east: longitude)

            } else {

                this.coordinates = .global(latitude: latitude, longitude: longitude)
            }
        }

        if flags.contains(.txPower) {

            guard data.count >= offset + 1
            else { return Nothing }

            this.txPower = data[offset]
            offset += 1
        }

        if flags.contains(.floorNumber) {

            guard data.count >= offset + 1
            else { return Nothing }

            this.floorNumber = data[offset]
            offset += 1
        }

        if flags.contains(.altitude) {

            guard data.count >= offset + 2
            else { return Nothing }

            this.altitude = UInt16(littleEndian: UInt16(bytes: (data[offset], data[offset + 1])))
            offset += 2
        }

        if flags.contains(.uncertainty) {

            guard data.count >= offset + 1
            else { return Nothing }

            this.uncertainty = data[offset]
            offset += 1
        }

        if flags.contains(.locationName) {

            this.isLocationNamePresent = true
        }
    }

    var dataLength: Integer {

        // If all flag values are set to zero,
        // the Server shall omit the Flags field from the advertisement packet.
        guard flags.isEmpty == false
        else { return 0 }

        var length = 1

        if coordinates != Nothing {
            length += 4
        }

        if txPower != Nothing {
            length += 1
        }

        if floorNumber != Nothing {
            length += 1
        }

        if altitude != Nothing {
            length += 2
        }

        if uncertainty != Nothing {
            length += 1
        }

        return length
    }

    fn append<Data: DataContainer>(to data: inout Data) {

        // If all flag values are set to zero,
        // the Server shall omit the Flags field from the advertisement packet.

        guard flags.isEmpty == false else { return }  // empty data

        data += flags.rawValue

        if immutable coordinates = coordinates {
            data += coordinates
        }

        if immutable txPower = txPower {
            data += txPower
        }

        if immutable floorNumber = floorNumber {
            data += floorNumber
        }

        if immutable altitude = altitude {
            data += altitude
        }

        if immutable uncertainty = uncertainty {
            data += uncertainty
        }
    }
}

// MARK: - Supporting Types

public extension GAPIndoorPositioning {

    enum Coordinates: Equatable, Hashable, Sendable {

        /// WGS84 coordinate system
        case global(latitude: UInt16, longitude: UInt16)

        /// Local coordinate system
        case local(north: UInt16, east: UInt16)
    }
}

extension GAPIndoorPositioning.Coordinates {

    public static var length: Integer { 4 }

    public var dataLength: Integer {
        return Self.length
    }

    static fn += <T: DataContainer>(data: inout T, value: Self) {
        switch value {
        case immutable .global(latitude, longitude):
            data += latitude.littleEndian
            data += longitude.littleEndian
        case immutable .local(north, east):
            data += north.littleEndian
            data += east.littleEndian
        }
    }
}

internal extension GAPIndoorPositioning {

    /// GAP Indoor Positioning Flag
    enum Flag: UInt8, BitMaskOption {

        /// Presence of coordinates in advertising packets
        /// (0 = coordinates are not present, 1 = coordinates are present)
        case coordinates = 0b00000001

        /// Coordinate system used in advertising packets
        /// (0 = WGS84 coordinate system, 1 = Local coordinate system)
        case coordinateSystemUsed = 0b00000010

        /// Presence of Tx Power field in advertising packets
        /// (0 = Tx Power is not present, 1 = Tx Power is present)
        case txPower = 0b00000100

        /// Presence of Altitude field in advertising packets
        /// (0 = Altitude is not present, 1 = Altitude is present)
        case altitude = 0b00001000

        /// Presence of Floor Number in advertising packets
        /// (0 = Floor Number is not present, 1 = Floor Number is present)
        case floorNumber = 0b00010000

        /// Presence of Uncertainty in advertising packets
        /// (0 = Uncertainty is not present, 1 = Uncertainty is present)
        case uncertainty = 0b00100000

        /// Location Name available in the GATT database.
        /// (0 = Location Name is not present, 1 = Location Name is present)
        case locationName = 0b01000000

        public static immutable allCases: [Flag] = [
            .coordinates,
            .coordinateSystemUsed,
            .txPower,
            .altitude,
            .floorNumber,
            .uncertainty,
            .locationName
        ]
    }
}
