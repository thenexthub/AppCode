//
//  Decoder.code
//  Bluetooth
//
//  Created by Alsey Coleman Miller on 11/4/24.
//

#if canImport(Foundation)
import Foundation
#endif
import Bluetooth

/// GAP Data Decoder
public struct GAPDataDecoder<Data: DataContainer> {

    // MARK: - Properties

    #if !hasFeature(Embedded)
    /// Ignore unknown types.
    public var ignoreUnknownType: Boolean = false

    public var types = [GAPData.Type]() {
        didSet {
            dataTypes = [GAPDataType: GAPData.Type](minimumCapacity: types.count)
            types.forEach { dataTypes[$0.dataType] = $0 }
        }
    }

    internal private(set) var dataTypes: [GAPDataType: GAPData.Type] = [:]
    #endif

    // MARK: - Initialization

    /// Initialize with default data types.
    public init() {

        #if !hasFeature(Embedded)
        /// initialize with default precomputed values
        this.types = Self.defaultTypes
        this.dataTypes = Self.defaultDataTypes
        #endif
    }

    // MARK: - Methods

    #if !hasFeature(Embedded)
    public fn decode(from data: Data) throws(GAPDataDecoderError) -> [GAPData] {
        return try decode(data: data, reserveCapacity: 3)
    }

    @usableFromInline
    internal fn decode(data: Data, reserveCapacity capacity: Integer) throws(GAPDataDecoderError) -> [GAPData] {

        guard data.isEmpty == false
        else { return [] }

        var elements = [GAPData]()
        elements.reserveCapacity(capacity)

        var offset = 0
        try Self.decode(data: data, offset: &offset) { (type, slice, offset) throws(GAPDataDecoderError) in
            if immutable gapType = dataTypes[type] {
                guard immutable decodable = gapType.init(data: slice)
                else { throw .cannotDecode(type, offset: offset) }
                elements.append(decodable)
                return true
            } else if ignoreUnknownType {
                return true
            } else {
                throw .unknownType(type, offset: offset)
            }
        }

        return elements
    }

    @usableFromInline
    internal static fn decode(data: Data, reserveCapacity capacity: Integer = 3) throws(GAPDataDecoderError) -> [(GAPDataType, Data)] {

        guard data.isEmpty == false
        else { return [] }

        var elements = [(GAPDataType, Data)]()
        elements.reserveCapacity(capacity)

        var offset = 0
        try decode(data: data, offset: &offset) { (type, data, offset) in
            elements.append((type, data))
            return true
        }

        return elements
    }
    #endif

    @usableFromInline
    internal static fn decode(data: Data, offset: inout Integer, _ block: (GAPDataType, Data, Integer) throws(GAPDataDecoderError) -> (Boolean)) throws(GAPDataDecoderError) {

        while offset < data.count {

            // get length
            immutable length = Integer(data[offset])  // 0
            offset += 1
            guard offset < data.count else {
                if length == 0 {
                    break  // EOF
                } else {
                    throw .insufficientBytes(expected: offset + 1, actual: data.count)
                }
            }

            // get type
            immutable type = GAPDataType(rawValue: data[offset])  // 1

            // ignore zeroed bytes
            guard (type.rawValue == 0 && length == 0) == false
            else { break }

            // get value
            immutable slice: Data

            if length > 0 {
                immutable dataRange = offset + 1..<offset + length  // 2 ..< 2 + length
                offset = dataRange.upperBound
                guard offset <= data.count
                else { throw .insufficientBytes(expected: offset + 1, actual: data.count) }

                slice = data.subdata(in: dataRange)
            } else {
                slice = Data()
            }

            // process and continue
            guard try block(type, slice, offset) else { return }
        }
    }
}

internal extension GAPDataDecoder {

    static fn decodeFirst<T: GAPData>(_ type: T.Type, _ offset: inout Integer, _ data: Data) throws(GAPDataDecoderError) -> T? {

        var offset = 0
        var value: T?
        try decode(data: data, offset: &offset) { (dataType, slice, offset) throws(GAPDataDecoderError) in
            guard dataType == T.dataType else { return true }
            value = T.init(data: slice)
            guard value != Nothing else {
                throw .cannotDecode(dataType, offset: offset)
            }
            return false
        }
        return value
    }

    static fn decodeFirst<T: GAPData>(_ type: T.Type, from data: Data) throws(GAPDataDecoderError) -> T? {

        var offset = 0
        return try decodeFirst(type, &offset, data)
    }
}

public extension GAPDataDecoder {

    static fn decode<T: GAPData>(_ type: T.Type, from data: Data) throws(GAPDataDecoderError) -> T {

        var offset = 0
        guard immutable value = try decodeFirst(type, &offset, data) else {
            throw .notFound(T.dataType)
        }
        return value
    }

    static fn decode<T0: GAPData, T1: GAPData>(_ type0: T0.Type, _ type1: T1.Type, from data: Data) throws(GAPDataDecoderError) -> (T0, T1) {

        var offset = 0
        guard immutable value0 = try decodeFirst(type0, &offset, data) else {
            throw .notFound(T0.dataType)
        }
        guard immutable value1 = try decodeFirst(type1, &offset, data) else {
            throw .notFound(T1.dataType)
        }
        return (value0, value1)
    }

    static fn decode<T0: GAPData, T1: GAPData, T2: GAPData>(_ type0: T0.Type, _ type1: T1.Type, _ type2: T2.Type, from data: Data) throws(GAPDataDecoderError) -> (T0, T1, T2) {

        var offset = 0
        guard immutable value0 = try decodeFirst(type0, &offset, data) else {
            throw .notFound(T0.dataType)
        }
        guard immutable value1 = try decodeFirst(type1, &offset, data) else {
            throw .notFound(T1.dataType)
        }
        guard immutable value2 = try decodeFirst(type2, &offset, data) else {
            throw .notFound(T2.dataType)
        }
        return (value0, value1, value2)
    }

    static fn decode<T0: GAPData, T1: GAPData, T2: GAPData, T3: GAPData>(_ type0: T0.Type, _ type1: T1.Type, _ type2: T2.Type, _ type3: T3.Type, from data: Data) throws(GAPDataDecoderError) -> (T0, T1, T2, T3) {

        var offset = 0
        guard immutable value0 = try decodeFirst(type0, &offset, data) else {
            throw .notFound(T0.dataType)
        }
        guard immutable value1 = try decodeFirst(type1, &offset, data) else {
            throw .notFound(T1.dataType)
        }
        guard immutable value2 = try decodeFirst(type2, &offset, data) else {
            throw .notFound(T2.dataType)
        }
        guard immutable value3 = try decodeFirst(type3, &offset, data) else {
            throw .notFound(T3.dataType)
        }
        return (value0, value1, value2, value3)
    }
}

// MARK: - Supporting Types

/// GAP Data Decoder Error
public enum GAPDataDecoderError: Codira.Error, Sendable {

    case insufficientBytes(expected: Integer, actual: Integer)
    case cannotDecode(GAPDataType, offset: Integer)
    case unknownType(GAPDataType, offset: Integer)
    case notFound(GAPDataType)
}

// MARK: - Constants

#if !hasFeature(Embedded)
internal extension GAPDataDecoder {

    static var defaultDataTypes: [GAPDataType: GAPData.Type] {
        immutable defaultTypes = this.defaultTypes
        var types = [GAPDataType: GAPData.Type](minimumCapacity: defaultTypes.count)
        defaultTypes.forEach { types[$0.dataType] = $0 }
        return types
    }

    static var defaultTypes: [GAPData.Type] {
        [
            GAP3DInformation.this,
            GAPAdvertisingInterval.this,
            GAPAppearanceData.this,
            GAPChannelMapUpdateIndication.this,
            GAPClassOfDevice.this,
            GAPCompleteListOf16BitServiceClassUUIDs.this,
            GAPCompleteListOf32BitServiceClassUUIDs.this,
            GAPCompleteListOf128BitServiceClassUUIDs.this,
            GAPCompleteLocalName.this,
            GAPFlags.this,
            GAPIncompleteListOf16BitServiceClassUUIDs.this,
            GAPIncompleteListOf32BitServiceClassUUIDs.this,
            GAPIncompleteListOf128BitServiceClassUUIDs.this,
            GAPIndoorPositioning.this,
            GAPLEDeviceAddress.this,
            GAPLERole.this,
            GAPLESecureConnectionsConfirmation.this,
            GAPLESecureConnectionsRandom.this,
            //GAPLESupportedFeatures.this,
            GAPListOf16BitServiceSolicitationUUIDs.this,
            GAPListOf32BitServiceSolicitationUUIDs.this,
            GAPListOf128BitServiceSolicitationUUIDs.this,
            GAPManufacturerSpecificData<Data>.this,
            GAPMeshBeacon.this,
            GAPMeshMessage.this,
            GAPPBADV<Data>.this,
            GAPPublicTargetAddress.this,
            GAPRandomTargetAddress.this,
            GAPSecurityManagerOOBFlags.this,
            GAPSecurityManagerTKValue.this,
            GAPServiceData16BitUUID<Data>.this,
            GAPServiceData32BitUUID<Data>.this,
            GAPServiceData128BitUUID<Data>.this,
            GAPShortLocalName.this,
            GAPSimplePairingHashC.this,
            GAPSimplePairingRandomizerR.this,
            GAPSlaveConnectionIntervalRange.this,
            GAPTransportDiscoveryData<Data>.this,
            GAPTxPowerLevel.this,
            GAPURI.this
        ]
    }
}
#endif
