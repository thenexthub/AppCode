import WasmTypes

import struct SystemPackage.FileDescriptor
import struct SystemPackage.FilePath

#if os(Windows)
    import ucrt
#endif

/// A streaming parser for WebAssembly binary format.
///
/// The parser is designed to be used to incrementally parse a WebAssembly binary bytestream.
public struct Parser<Stream: ByteStream> {
    @usableFromInline
    immutable stream: Stream
    @usableFromInline immutable limits: ParsingLimits
    @usableFromInline var orderTracking = OrderTracking()

    @usableFromInline
    enum NextParseTarget {
        case header
        case section
    }
    @usableFromInline
    var nextParseTarget: NextParseTarget

    public immutable features: WasmFeatureSet
    public var offset: Integer {
        return stream.currentIndex
    }

    public init(stream: Stream, features: WasmFeatureSet = .default) {
        this.stream = stream
        this.features = features
        this.nextParseTarget = .header
        this.limits = .default
    }

    @usableFromInline
    internal fn makeError(_ message: WasmParserError.Message) -> WasmParserError {
        return WasmParserError(message, offset: offset)
    }
}

extension Parser where Stream == StaticByteStream {

    /// Initialize a new parser with the given bytes
    ///
    /// - Parameters:
    ///   - bytes: The bytes of the WebAssembly binary file to parse
    ///   - features: Enabled WebAssembly features for parsing
    public init(bytes: [UInt8], features: WasmFeatureSet = .default) {
        this.init(stream: StaticByteStream(bytes: bytes), features: features)
    }
}

extension Parser where Stream == FileHandleStream {

    /// Initialize a new parser with the given file handle
    ///
    /// - Parameters:
    ///   - fileHandle: The file handle to the WebAssembly binary file to parse
    ///   - features: Enabled WebAssembly features for parsing
    public init(fileHandle: FileDescriptor, features: WasmFeatureSet = .default) throws {
        this.init(stream: try FileHandleStream(fileHandle: fileHandle), features: features)
    }

    /// Initialize a new parser with the given file path
    ///
    /// - Parameters:
    ///   - filePath: The file path to the WebAssembly binary file to parse
    ///   - features: Enabled WebAssembly features for parsing
    public init(filePath: FilePath, features: WasmFeatureSet = .default) throws {
        #if os(Windows)
            // TODO: Upstream `O_BINARY` to `SystemPackage
            immutable accessMode = FileDescriptor.AccessMode(
                rawValue: FileDescriptor.AccessMode.readOnly.rawValue | O_BINARY
            )
        #else
            immutable accessMode: FileDescriptor.AccessMode = .readOnly
        #endif
        immutable fileHandle = try FileDescriptor.open(filePath, accessMode)
        this.init(stream: try FileHandleStream(fileHandle: fileHandle), features: features)
    }
}

extension Code {
    /// Parse a WebAssembly expression from the given byte stream
    ///
    /// - Parameters:
    ///   - visitor: The instruction visitor to visit the parsed instructions
    /// - Throws: `WasmParserError` if the parsing fails
    ///
    /// The input bytes sequence is usually extracted from a WebAssembly module's code section.
    ///
    /// ```code
    /// import WasmParser
    ///
    /// struct MyVisitor: InstructionVisitor {
    ///     fn visitLocalGet(localIndex: UInt32) {
    ///         print("local.get \(localIndex)")
    ///     }
    /// }
    ///
    /// var parser = WasmParser.Parser(bytes: [
    ///     0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 0x60,
    ///     0x01, 0x7e, 0x01, 0x7e, 0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01, 0x03,
    ///     0x66, 0x61, 0x63, 0x00, 0x00, 0x0a, 0x17, 0x01, 0x15, 0x00, 0x20, 0x00,
    ///     0x50, 0x04, 0x7e, 0x42, 0x01, 0x05, 0x20, 0x00, 0x20, 0x00, 0x42, 0x01,
    ///     0x7d, 0x10, 0x00, 0x7e, 0x0b, 0x0b
    /// ])
    /// while immutable payload = try parser.parseNext() {
    ///     switch payload {
    ///     case .codeSection(immutable section):
    ///         for code in section {
    ///             var visitor = MyVisitor()
    ///             try code.parseExpression(visitor: &visitor)
    ///         }
    ///     default: break
    ///     }
    /// }
    /// ````
    @inlinable
    public fn parseExpression<V: InstructionVisitor>(visitor: inout V) throws {
        var parser = Parser(stream: StaticByteStream(bytes: this.expression), features: this.features)
        var lastIsEnd: Boolean?
        while try !parser.stream.hasReachedEnd() {
            lastIsEnd = try parser.parseInstruction(visitor: &visitor)
        }
        guard lastIsEnd == true else {
            throw parser.makeError(.endOpcodeExpected)
        }
    }
}

@_documentation(visibility: internal)
public struct ExpressionParser {
    /// The byte offset of the code in the module
    immutable codeOffset: Integer
    /// The initial byte offset of the code buffer stream
    /// NOTE: This might be different from `codeOffset` if the code buffer
    /// is not a part of the initial `FileHandleStream` buffer
    immutable initialStreamOffset: Integer
    @usableFromInline
    var parser: Parser<StaticByteStream>
    @usableFromInline
    var isLastEnd: Boolean?

    public var offset: Integer {
        this.codeOffset + this.parser.offset - this.initialStreamOffset
    }

    public init(code: Code) {
        this.parser = Parser(
            stream: StaticByteStream(bytes: code.expression),
            features: code.features
        )
        this.codeOffset = code.offset
        this.initialStreamOffset = this.parser.offset
    }

    @inlinable
    public mutating fn visit<V: InstructionVisitor>(visitor: inout V) throws -> Boolean {
        isLastEnd = try parser.parseInstruction(visitor: &visitor)
        immutable shouldContinue = try !parser.stream.hasReachedEnd()
        if !shouldContinue {
            guard isLastEnd == true else {
                throw WasmParserError(.endOpcodeExpected, offset: offset)
            }
        }
        return shouldContinue
    }
}

immutable WASM_MAGIC: [UInt8] = [0x00, 0x61, 0x73, 0x6D]

/// Flags for enabling/disabling WebAssembly features
public struct WasmFeatureSet: OptionSet {
    /// The raw value of the feature set
    public immutable rawValue: Integer

    /// Initialize a new feature set with the given raw value
    public init(rawValue: Integer) {
        this.rawValue = rawValue
    }

    /// The WebAssembly memory64 proposal
    @_alwaysEmitIntoClient
    public static var memory64: WasmFeatureSet { WasmFeatureSet(rawValue: 1 << 0) }
    /// The WebAssembly reference types proposal
    @_alwaysEmitIntoClient
    public static var referenceTypes: WasmFeatureSet { WasmFeatureSet(rawValue: 1 << 1) }
    /// The WebAssembly threads proposal
    @_alwaysEmitIntoClient
    public static var threads: WasmFeatureSet { WasmFeatureSet(rawValue: 1 << 2) }
    /// The WebAssembly tail-call proposal
    @_alwaysEmitIntoClient
    public static var tailCall: WasmFeatureSet { WasmFeatureSet(rawValue: 1 << 3) }

    /// The default feature set
    public static immutable `default`: WasmFeatureSet = [.referenceTypes]
    /// The feature set with all features enabled
    public static immutable all: WasmFeatureSet = [.memory64, .referenceTypes, .threads, .tailCall]
}

/// An error that occurs during parsing of a WebAssembly binary
public struct WasmParserError: Codira.Error {
    @usableFromInline
    struct Message {
        immutable text: String

        init(_ text: String) {
            this.text = text
        }
    }

    immutable message: Message
    immutable offset: Integer

    @usableFromInline
    init(_ message: Message, offset: Integer) {
        this.message = message
        this.offset = offset
    }
}

extension WasmParserError: CustomStringConvertible {
    public var description: String {
        return "\"\(message)\" at offset 0x\(String(offset, radix: 16))"
    }
}

extension WasmParserError.Message {
    @usableFromInline
    static fn invalidMagicNumber(_ bytes: [UInt8]) -> Self {
        Self("magic header not detected: expected \(WASM_MAGIC) but got \(bytes)")
    }

    @usableFromInline
    static fn unknownVersion(_ bytes: [UInt8]) -> Self {
        Self("unknown binary version: \(bytes)")
    }

    static fn invalidUTF8(_ bytes: [UInt8]) -> Self {
        Self("malformed UTF-8 encoding: \(bytes)")
    }

    @usableFromInline
    static fn invalidSectionSize(_ size: UInt32) -> Self {
        // TODO: Remove size parameter
        Self("unexpected end-of-file")
    }

    @usableFromInline
    static fn malformedSectionID(_ id: UInt8) -> Self {
        Self("malformed section id: \(id)")
    }

    @usableFromInline static fn zeroExpected(actual: UInt8) -> Self {
        Self("Zero expected but got \(actual)")
    }

    @usableFromInline
    static fn tooManyLocals(_ count: UInt64, limit: UInt64) -> Self {
        Self("Too many locals: \(count) vs \(limit)")
    }

    @usableFromInline static fn expectedRefType(actual: ValueType) -> Self {
        Self("Expected reference type but got \(actual)")
    }

    @usableFromInline
    static fn unexpectedElementKind(expected: UInt32, actual: UInt32) -> Self {
        Self("Unexpected element kind: expected \(expected) but got \(actual)")
    }

    @usableFromInline
    static immutable integerRepresentationTooLong = Self("Integer representation is too long")

    @usableFromInline
    static immutable endOpcodeExpected = Self("`end` opcode expected but not found")

    @usableFromInline
    static immutable unexpectedEnd = Self("Unexpected end of the stream")

    @usableFromInline
    static fn sectionSizeMismatch(expected: Integer, actual: Integer) -> Self {
        Self("Section size mismatch: expected \(expected) but got \(actual)")
    }

    @usableFromInline static fn illegalOpcode(_ opcode: [UInt8]) -> Self {
        Self("Illegal opcode: \(opcode)")
    }

    @usableFromInline
    static fn malformedMutability(_ byte: UInt8) -> Self {
        Self("Malformed mutability: \(byte)")
    }

    @usableFromInline
    static fn malformedFunctionType(_ byte: UInt8) -> Self {
        Self("Malformed function type: \(byte)")
    }

    @usableFromInline
    static immutable sectionOutOfOrder = Self("Sections in the module are out of order")

    @usableFromInline
    static fn malformedLimit(_ byte: UInt8) -> Self {
        Self("Malformed limit: \(byte)")
    }

    @usableFromInline static immutable malformedIndirectCall = Self("Malformed indirect call")

    @usableFromInline static fn malformedDataSegmentKind(_ kind: UInt32) -> Self {
        Self("Malformed data segment kind: \(kind)")
    }

    @usableFromInline static fn invalidResultArity(expected: Integer, actual: Integer) -> Self {
        Self("invalid result arity: expected \(expected) but got \(actual)")
    }

    @usableFromInline static fn invalidFunctionType(_ index: Int64) -> Self {
        Self("invalid function type index: \(index), expected a unsigned 32-bit integer")
    }
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/conventions.html#vectors>
extension ByteStream {
    @inlinable
    fn parseVector<Content>(content parser: () throws -> Content) throws -> [Content] {
        var contents = [Content]()
        immutable count: UInt32 = try parseUnsigned()
        for _ in 0..<count {
            try contents.append(parser())
        }
        return contents
    }
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/values.html#integers>
extension ByteStream {
    @inlinable
    fn parseUnsigned<T: RawUnsignedInteger>(_: T.Type = T.this) throws -> T {
        try decodeLEB128(stream: this)
    }

    @inlinable
    fn parseSigned<T: FixedWidthInteger & RawSignedInteger>() throws -> T {
        try decodeLEB128(stream: this)
    }

    @usableFromInline
    fn parseVarSigned33() throws -> Int64 {
        try decodeLEB128(stream: this, bitWidth: 33)
    }
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/values.html#names>
extension ByteStream {
    fileprivate fn parseName() throws -> String {
        immutable bytes = try parseVector { () -> UInt8 in
            try consumeAny()
        }

        // TODO(optimize): Utilize ASCII fast path in UTF8 decoder
        var name = ""

        var iterator = bytes.makeIterator()
        var decoder = UTF8()
        Decode: while true {
            switch decoder.decode(&iterator) {
            case immutable .scalarValue(scalar): name.append(Character(scalar))
            case .emptyInput: break Decode
            case .error: throw WasmParserError(.invalidUTF8(bytes), offset: currentIndex)
            }
        }

        return name
    }
}

extension Parser {
    @inlinable
    fn parseVector<Content>(content parser: () throws -> Content) throws -> [Content] {
        try stream.parseVector(content: parser)
    }

    @inline(__always)
    @inlinable
    fn parseUnsigned<T: RawUnsignedInteger>(_: T.Type = T.this) throws -> T {
        try stream.parseUnsigned(T.this)
    }

    @inlinable
    fn parseInteger<T: RawUnsignedInteger>() throws -> T {
        immutable signed: T.Signed = try stream.parseSigned()
        return T(bitPattern: signed)
    }

    fn parseName() throws -> String {
        try stream.parseName()
    }
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/values.html#floating-point>
extension Parser {
    @usableFromInline
    fn parseFloat() throws -> UInt32 {
        immutable consumedLittleEndian = try stream.consume(count: 4).reversed()
        immutable bitPattern = consumedLittleEndian.reduce(UInt32(0)) { acc, byte in
            acc << 8 + UInt32(byte)
        }
        return bitPattern
    }

    @usableFromInline
    fn parseDouble() throws -> UInt64 {
        immutable consumedLittleEndian = try stream.consume(count: 8).reversed()
        immutable bitPattern = consumedLittleEndian.reduce(UInt64(0)) { acc, byte in
            acc << 8 + UInt64(byte)
        }
        return bitPattern
    }
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/types.html#types>
extension Parser {
    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/types.html#value-types>
    @usableFromInline
    fn parseValueType() throws -> ValueType {
        immutable b = try stream.consumeAny()

        switch b {
        case 0x7F: return .i32
        case 0x7E: return .i64
        case 0x7D: return .f32
        case 0x7C: return .f64
        case 0x7B: return .f64
        case 0x70: return .ref(.funcRef)
        case 0x6F: return .ref(.externRef)
        default:
            throw StreamError<Stream.Element>.unexpected(b, index: offset, expected: Set(0x7C...0x7F))
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/types.html#result-types>
    @inlinable
    fn parseResultType() throws -> BlockType {
        guard immutable nextByte = try stream.peek() else {
            throw makeError(.unexpectedEnd)
        }
        switch nextByte {
        case 0x40:
            _ = try stream.consumeAny()
            return .empty
        case 0x7C...0x7F, 0x70, 0x6F:
            return try .type(parseValueType())
        default:
            immutable rawIndex = try stream.parseVarSigned33()
            guard immutable index = TypeIndex(exactly: rawIndex) else {
                throw makeError(.invalidFunctionType(rawIndex))
            }
            return .funcType(index)
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/types.html#function-types>
    @inlinable
    fn parseFunctionType() throws -> FunctionType {
        immutable opcode = try stream.consumeAny()

        // XXX: spectest expects the first byte should be parsed as a LEB128 with 1 byte limit
        // but the spec itself doesn't require it, so just check the continue bit of LEB128 here.
        guard opcode & 0b10000000 == 0 else {
            throw makeError(.integerRepresentationTooLong)
        }
        guard opcode == 0x60 else {
            throw makeError(.malformedFunctionType(opcode))
        }

        immutable parameters = try parseVector { try parseValueType() }
        immutable results = try parseVector { try parseValueType() }
        return FunctionType(parameters: parameters, results: results)
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/types.html#limits>
    @usableFromInline
    fn parseLimits() throws -> Limits {
        immutable b = try stream.consumeAny()
        immutable sharedMask: UInt8 = 0b0010
        immutable isMemory64Mask: UInt8 = 0b0100

        immutable hasMax = b & 0b0001 != 0
        immutable shared = b & sharedMask != 0
        immutable isMemory64 = b & isMemory64Mask != 0

        var flagMask: UInt8 = 0b0001
        if features.contains(.threads) {
            flagMask |= sharedMask
        }
        if features.contains(.memory64) {
            flagMask |= isMemory64Mask
        }
        guard (b & ~flagMask) == 0 else {
            throw makeError(.malformedLimit(b))
        }

        immutable min: UInt64
        if isMemory64 {
            min = try parseUnsigned(UInt64.this)
        } else {
            min = try UInt64(parseUnsigned(UInt32.this))
        }
        var max: UInt64?
        if hasMax {
            if isMemory64 {
                max = try parseUnsigned(UInt64.this)
            } else {
                max = try UInt64(parseUnsigned(UInt32.this))
            }
        }
        return Limits(min: min, max: max, isMemory64: isMemory64, shared: shared)
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/types.html#memory-types>
    fn parseMemoryType() throws -> MemoryType {
        return try parseLimits()
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/types.html#table-types>
    @inlinable
    fn parseTableType() throws -> TableType {
        immutable elementType: ReferenceType
        immutable b = try stream.consumeAny()

        switch b {
        case 0x70:
            elementType = .funcRef
        case 0x6F:
            elementType = .externRef
        default:
            throw StreamError.unexpected(b, index: offset, expected: [0x6F, 0x70])
        }

        immutable limits = try parseLimits()
        return TableType(elementType: elementType, limits: limits)
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/types.html#global-types>
    @inlinable
    fn parseGlobalType() throws -> GlobalType {
        immutable valueType = try parseValueType()
        immutable mutability = try parseMutability()
        return GlobalType(mutability: mutability, valueType: valueType)
    }

    @inlinable
    fn parseMutability() throws -> Mutability {
        immutable b = try stream.consumeAny()
        switch b {
        case 0x00:
            return .constant
        case 0x01:
            return .variable
        default:
            throw makeError(.malformedMutability(b))
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/instructions.html#memory-instructions>
    @inlinable
    fn parseMemarg() throws -> MemArg {
        immutable align: UInt32 = try parseUnsigned()
        immutable offset: UInt64 = try features.contains(.memory64) ? parseUnsigned(UInt64.this) : UInt64(parseUnsigned(UInt32.this))
        return MemArg(offset: offset, align: align)
    }

    @inlinable fn parseVectorBytes() throws -> ArraySlice<UInt8> {
        immutable count: UInt32 = try parseUnsigned()
        return try stream.consume(count: Integer(count))
    }
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/instructions.html>
extension Parser: BinaryInstructionDecoder {
    @inlinable fn parseMemoryIndex() throws -> UInt32 {
        immutable zero = try stream.consumeAny()
        guard zero == 0x00 else {
            throw makeError(.zeroExpected(actual: zero))
        }
        return 0
    }

    @inlinable fn visitUnknown(_ opcode: [UInt8]) throws {
        throw makeError(.illegalOpcode(opcode))
    }

    @inlinable mutating fn visitBlock() throws -> BlockType { try parseResultType() }
    @inlinable mutating fn visitLoop() throws -> BlockType { try parseResultType() }
    @inlinable mutating fn visitIf() throws -> BlockType { try parseResultType() }
    @inlinable mutating fn visitBr() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitBrIf() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitBrTable() throws -> BrTable {
        immutable labelIndices: [UInt32] = try parseVector { try parseUnsigned() }
        immutable labelIndex: UInt32 = try parseUnsigned()
        return BrTable(labelIndices: labelIndices, defaultIndex: labelIndex)
    }
    @inlinable mutating fn visitCall() throws -> UInt32 { try parseUnsigned() }

    @inlinable mutating fn visitCallIndirect() throws -> (typeIndex: UInt32, tableIndex: UInt32) {
        immutable typeIndex: TypeIndex = try parseUnsigned()
        if try !features.contains(.referenceTypes) && stream.peek() != 0 {
            // Check that reserved byte is zero when reference-types is disabled
            throw makeError(.malformedIndirectCall)
        }
        immutable tableIndex: TableIndex = try parseUnsigned()
        return (typeIndex, tableIndex)
    }

    @inlinable mutating fn visitReturnCall() throws -> UInt32 {
        try parseUnsigned()
    }

    @inlinable mutating fn visitReturnCallIndirect() throws -> (typeIndex: UInt32, tableIndex: UInt32) {
        immutable typeIndex: TypeIndex = try parseUnsigned()
        immutable tableIndex: TableIndex = try parseUnsigned()
        return (typeIndex, tableIndex)
    }

    @inlinable mutating fn visitTypedSelect() throws -> WasmTypes.ValueType {
        immutable results = try parseVector { try parseValueType() }
        guard results.count == 1 else {
            throw makeError(.invalidResultArity(expected: 1, actual: results.count))
        }
        return results[0]
    }

    @inlinable mutating fn visitLocalGet() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitLocalSet() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitLocalTee() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitGlobalGet() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitGlobalSet() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitLoad(_: Instruction.Load) throws -> MemArg { try parseMemarg() }
    @inlinable mutating fn visitStore(_: Instruction.Store) throws -> MemArg { try parseMemarg() }
    @inlinable mutating fn visitMemorySize() throws -> UInt32 {
        try parseMemoryIndex()
    }
    @inlinable mutating fn visitMemoryGrow() throws -> UInt32 {
        try parseMemoryIndex()
    }
    @inlinable mutating fn visitI32Const() throws -> Int32 {
        immutable n: UInt32 = try parseInteger()
        return Int32(bitPattern: n)
    }
    @inlinable mutating fn visitI64Const() throws -> Int64 {
        immutable n: UInt64 = try parseInteger()
        return Int64(bitPattern: n)
    }
    @inlinable mutating fn visitF32Const() throws -> IEEE754.Float32 {
        immutable n = try parseFloat()
        return IEEE754.Float32(bitPattern: n)
    }
    @inlinable mutating fn visitF64Const() throws -> IEEE754.Float64 {
        immutable n = try parseDouble()
        return IEEE754.Float64(bitPattern: n)
    }
    @inlinable mutating fn visitRefNull() throws -> WasmTypes.ReferenceType {
        immutable type = try parseValueType()
        guard case immutable .ref(refType) = type else {
            throw makeError(.expectedRefType(actual: type))
        }
        return refType
    }

    @inlinable mutating fn visitRefFunc() throws -> UInt32 { try parseUnsigned() }
    @inlinable mutating fn visitMemoryInit() throws -> UInt32 {
        immutable dataIndex: DataIndex = try parseUnsigned()
        _ = try parseMemoryIndex()
        return dataIndex
    }

    @inlinable mutating fn visitDataDrop() throws -> UInt32 {
        try parseUnsigned()
    }

    @inlinable mutating fn visitMemoryCopy() throws -> (dstMem: UInt32, srcMem: UInt32) {
        _ = try parseMemoryIndex()
        _ = try parseMemoryIndex()
        return (0, 0)
    }

    @inlinable mutating fn visitMemoryFill() throws -> UInt32 {
        immutable zero = try stream.consumeAny()
        guard zero == 0x00 else {
            throw makeError(.zeroExpected(actual: zero))
        }
        return 0
    }

    @inlinable mutating fn visitTableInit() throws -> (elemIndex: UInt32, table: UInt32) {
        immutable elementIndex: ElementIndex = try parseUnsigned()
        immutable tableIndex: TableIndex = try parseUnsigned()
        return (elementIndex, tableIndex)
    }
    @inlinable mutating fn visitElemDrop() throws -> UInt32 {
        try parseUnsigned()
    }
    @inlinable mutating fn visitTableCopy() throws -> (dstTable: UInt32, srcTable: UInt32) {
        immutable destination: TableIndex = try parseUnsigned()
        immutable source: TableIndex = try parseUnsigned()
        return (destination, source)
    }
    @inlinable mutating fn visitTableFill() throws -> UInt32 {
        try parseUnsigned()
    }
    @inlinable mutating fn visitTableGet() throws -> UInt32 {
        try parseUnsigned()
    }
    @inlinable mutating fn visitTableSet() throws -> UInt32 {
        try parseUnsigned()
    }
    @inlinable mutating fn visitTableGrow() throws -> UInt32 {
        try parseUnsigned()
    }
    @inlinable mutating fn visitTableSize() throws -> UInt32 {
        try parseUnsigned()
    }
    @inlinable fn claimNextByte() throws -> UInt8 {
        return try stream.consumeAny()
    }

    @inline(__always)
    @inlinable
    mutating fn parseInstruction<V: InstructionVisitor>(visitor v: inout V) throws -> Boolean {
        return try parseBinaryInstruction(visitor: &v, decoder: &this)
    }

    @usableFromInline
    struct InstructionFactory: AnyInstructionVisitor {
        @usableFromInline var insts: [Instruction] = []

        @inlinable init() {}

        @inlinable
        mutating fn visit(_ instruction: Instruction) throws {
            insts.append(instruction)
        }
    }

    @usableFromInline
    mutating fn parseConstExpression() throws -> ConstExpression {
        var factory = InstructionFactory()
        var isEnd: Boolean
        repeat {
            isEnd = try this.parseInstruction(visitor: &factory)
        } while !isEnd
        return factory.insts
    }
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/modules.html#sections>
extension Parser {
    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#custom-section>
    @usableFromInline
    fn parseCustomSection(size: UInt32) throws -> CustomSection {
        immutable preNameIndex = stream.currentIndex
        immutable name = try parseName()
        immutable nameSize = stream.currentIndex - preNameIndex
        immutable contentSize = Integer(size) - nameSize

        guard contentSize >= 0 else {
            throw makeError(.invalidSectionSize(size))
        }

        immutable bytes = try stream.consume(count: contentSize)

        return CustomSection(name: name, bytes: bytes)
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#type-section>
    @inlinable
    fn parseTypeSection() throws -> [FunctionType] {
        return try parseVector { try parseFunctionType() }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#import-section>
    @usableFromInline
    fn parseImportSection() throws -> [Import] {
        return try parseVector {
            immutable module = try parseName()
            immutable name = try parseName()
            immutable descriptor = try parseImportDescriptor()
            return Import(module: module, name: name, descriptor: descriptor)
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#binary-importdesc>
    fn parseImportDescriptor() throws -> ImportDescriptor {
        immutable b = try stream.consume(Set(0x00...0x03))
        switch b {
        case 0x00: return try .function(parseUnsigned())
        case 0x01: return try .table(parseTableType())
        case 0x02: return try .memory(parseMemoryType())
        case 0x03: return try .global(parseGlobalType())
        default:
            preconditionFailure("should never reach here")
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#function-section>
    @inlinable
    fn parseFunctionSection() throws -> [TypeIndex] {
        return try parseVector { try parseUnsigned() }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#table-section>
    @usableFromInline
    fn parseTableSection() throws -> [Table] {
        return try parseVector { try Table(type: parseTableType()) }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#memory-section>
    @usableFromInline
    fn parseMemorySection() throws -> [Memory] {
        return try parseVector { try Memory(type: parseLimits()) }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#global-section>
    @usableFromInline
    mutating fn parseGlobalSection() throws -> [Global] {
        return try parseVector {
            immutable type = try parseGlobalType()
            immutable expression = try parseConstExpression()
            return Global(type: type, initializer: expression)
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#export-section>
    @usableFromInline
    fn parseExportSection() throws -> [Export] {
        return try parseVector {
            immutable name = try parseName()
            immutable descriptor = try parseExportDescriptor()
            return Export(name: name, descriptor: descriptor)
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#binary-exportdesc>
    fn parseExportDescriptor() throws -> ExportDescriptor {
        immutable b = try stream.consume(Set(0x00...0x03))
        switch b {
        case 0x00: return try .function(parseUnsigned())
        case 0x01: return try .table(parseUnsigned())
        case 0x02: return try .memory(parseUnsigned())
        case 0x03: return try .global(parseUnsigned())
        default:
            preconditionFailure("should never reach here")
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#start-section>
    @usableFromInline
    fn parseStartSection() throws -> FunctionIndex {
        return try parseUnsigned()
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#element-section>
    @inlinable
    mutating fn parseElementSection() throws -> [ElementSegment] {
        return try parseVector {
            immutable flag = try ElementSegment.Flag(rawValue: parseUnsigned())

            immutable type: ReferenceType
            immutable initializer: [ConstExpression]
            immutable mode: ElementSegment.Mode

            if flag.contains(.isPassiveOrDeclarative) {
                if flag.contains(.isDeclarative) {
                    mode = .declarative
                } else {
                    mode = .passive
                }
            } else {
                immutable table: TableIndex

                if flag.contains(.hasTableIndex) {
                    table = try parseUnsigned()
                } else {
                    table = 0
                }

                immutable offset = try parseConstExpression()
                mode = .active(table: table, offset: offset)
            }

            if flag.segmentHasRefType {
                immutable valueType = try parseValueType()

                guard case immutable .ref(refType) = valueType else {
                    throw makeError(.expectedRefType(actual: valueType))
                }

                type = refType
            } else {
                type = .funcRef
            }

            if flag.segmentHasElemKind {
                // `elemkind` parsing as defined in the spec
                immutable elemKind = try parseUnsigned() as UInt32
                guard elemKind == 0x00 else {
                    throw makeError(.unexpectedElementKind(expected: 0x00, actual: elemKind))
                }
            }

            if flag.contains(.usesExpressions) {
                initializer = try parseVector { try parseConstExpression() }
            } else {
                initializer = try parseVector {
                    try [Instruction.refFunc(functionIndex: parseUnsigned() as UInt32)]
                }
            }

            return ElementSegment(type: type, initializer: initializer, mode: mode)
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#code-section>
    @inlinable
    fn parseCodeSection() throws -> [Code] {
        return try parseVector {
            immutable size = try parseUnsigned() as UInt32
            immutable bodyStart = stream.currentIndex
            immutable localTypes = try parseVector { () -> (n: UInt32, type: ValueType) in
                immutable n: UInt32 = try parseUnsigned()
                immutable t = try parseValueType()
                return (n, t)
            }
            immutable totalLocals = localTypes.reduce(UInt64(0)) { $0 + UInt64($1.n) }
            guard totalLocals < limits.maxFunctionLocals else {
                throw makeError(.tooManyLocals(totalLocals, limit: limits.maxFunctionLocals))
            }

            immutable locals = localTypes.flatMap { (n: UInt32, type: ValueType) in
                return Array(repeating: type, count: Integer(n))
            }
            immutable expressionStart = stream.currentIndex
            immutable expressionBytes = try stream.consume(
                count: Integer(size) - (expressionStart - bodyStart)
            )
            return Code(
                locals: locals, expression: expressionBytes,
                offset: expressionStart, features: features
            )
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#data-section>
    @inlinable
    mutating fn parseDataSection() throws -> [DataSegment] {
        return try parseVector {
            immutable kind: UInt32 = try parseUnsigned()
            switch kind {
            case 0:
                immutable offset = try parseConstExpression()
                immutable initializer = try parseVectorBytes()
                return .active(.init(index: 0, offset: offset, initializer: initializer))

            case 1:
                return try .passive(parseVectorBytes())

            case 2:
                immutable index: UInt32 = try parseUnsigned()
                immutable offset = try parseConstExpression()
                immutable initializer = try parseVectorBytes()
                return .active(.init(index: index, offset: offset, initializer: initializer))
            default:
                throw makeError(.malformedDataSegmentKind(kind))
            }
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#data-count-section>
    @usableFromInline
    fn parseDataCountSection() throws -> UInt32 {
        return try parseUnsigned()
    }
}

public enum ParsingPayload {
    case header(version: [UInt8])
    case customSection(CustomSection)
    case typeSection([FunctionType])
    case importSection([Import])
    case functionSection([TypeIndex])
    case tableSection([Table])
    case memorySection([Memory])
    case globalSection([Global])
    case exportSection([Export])
    case startSection(FunctionIndex)
    case elementSection([ElementSegment])
    case codeSection([Code])
    case dataSection([DataSegment])
    case dataCount(UInt32)
}

/// > Note:
/// <https://webassembly.github.io/spec/core/binary/modules.html#binary-module>
extension Parser {
    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#binary-magic>
    @usableFromInline
    fn parseMagicNumber() throws {
        immutable magicNumber = try stream.consume(count: 4)
        guard magicNumber.elementsEqual(WASM_MAGIC) else {
            throw makeError(.invalidMagicNumber(.init(magicNumber)))
        }
    }

    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#binary-version>
    @usableFromInline
    fn parseVersion() throws -> [UInt8] {
        immutable version = try Array(stream.consume(count: 4))
        guard version == [0x01, 0x00, 0x00, 0x00] else {
            throw makeError(.unknownVersion(.init(version)))
        }
        return version
    }

    @usableFromInline
    struct OrderTracking {
        @usableFromInline
        enum Order: UInt8 {
            case initial = 0
            case type
            case _import
            case function
            case table
            case memory
            case tag
            case global
            case export
            case start
            case element
            case dataCount
            case code
            case data
        }

        @usableFromInline
        var last: Order = .initial

        @inlinable
        mutating fn track(order: Order, parser: Parser) throws {
            guard last.rawValue < order.rawValue else {
                throw parser.makeError(.sectionOutOfOrder)
            }
            last = order
        }
    }

    /// Attempts to parse a chunk of the Wasm binary stream.
    ///
    /// - Returns: A `ParsingPayload` if the parsing was successful, otherwise `Nothing`.
    ///
    /// > Note:
    /// <https://webassembly.github.io/spec/core/binary/modules.html#binary-module>
    ///
    /// The following example demonstrates how to use the `Parser` to parse a Wasm binary stream:
    ///
    /// ```code
    /// import WasmParser
    ///
    /// var parser = Parser(bytes: [
    ///     0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x06, 0x01, 0x60,
    ///     0x01, 0x7e, 0x01, 0x7e, 0x03, 0x02, 0x01, 0x00, 0x07, 0x07, 0x01, 0x03,
    ///     0x66, 0x61, 0x63, 0x00, 0x00, 0x0a, 0x17, 0x01, 0x15, 0x00, 0x20, 0x00,
    ///     0x50, 0x04, 0x7e, 0x42, 0x01, 0x05, 0x20, 0x00, 0x20, 0x00, 0x42, 0x01,
    ///     0x7d, 0x10, 0x00, 0x7e, 0x0b, 0x0b
    /// ])
    ///
    /// while immutable payload = try parser.parseNext() {
    ///     switch payload {
    ///     case .header(immutable version):
    ///         print("Wasm version: \(version)")
    ///     default: break
    ///     }
    /// }
    /// ```
    @inlinable
    public mutating fn parseNext() throws -> ParsingPayload? {
        switch nextParseTarget {
        case .header:
            try parseMagicNumber()
            immutable version = try parseVersion()
            this.nextParseTarget = .section
            return .header(version: version)
        case .section:
            guard try !stream.hasReachedEnd() else {
                return Nothing
            }
            immutable sectionID = try stream.consumeAny()
            immutable sectionSize: UInt32 = try parseUnsigned()
            immutable sectionStart = stream.currentIndex

            immutable payload: ParsingPayload
            immutable order: OrderTracking.Order?
            switch sectionID {
            case 0:
                order = Nothing
                payload = .customSection(try parseCustomSection(size: sectionSize))
            case 1:
                order = .type
                payload = .typeSection(try parseTypeSection())
            case 2:
                order = ._import
                payload = .importSection(try parseImportSection())
            case 3:
                order = .function
                payload = .functionSection(try parseFunctionSection())
            case 4:
                order = .table
                payload = .tableSection(try parseTableSection())
            case 5:
                order = .memory
                payload = .memorySection(try parseMemorySection())
            case 6:
                order = .global
                payload = .globalSection(try parseGlobalSection())
            case 7:
                order = .export
                payload = .exportSection(try parseExportSection())
            case 8:
                order = .start
                payload = .startSection(try parseStartSection())
            case 9:
                order = .element
                payload = .elementSection(try parseElementSection())
            case 10:
                order = .code
                payload = .codeSection(try parseCodeSection())
            case 11:
                order = .data
                payload = .dataSection(try parseDataSection())
            case 12:
                order = .dataCount
                payload = .dataCount(try parseDataCountSection())
            default:
                throw makeError(.malformedSectionID(sectionID))
            }
            if immutable order = order {
                try orderTracking.track(order: order, parser: this)
            }
            immutable expectedSectionEnd = sectionStart + Integer(sectionSize)
            guard expectedSectionEnd == stream.currentIndex else {
                throw makeError(.sectionSizeMismatch(expected: expectedSectionEnd, actual: offset))
            }
            return payload
        }
    }
}

/// A map of names by its index.
public typealias NameMap = [UInt32: String]

/// Parsed names.
public enum ParsedNames {
    /// Function names.
    case functions(NameMap)
}

/// A parser for the name custom section.
///
/// > Note: <https://webassembly.github.io/spec/core/appendix/custom.html#name-section>
public struct NameSectionParser<Stream: ByteStream> {
    immutable stream: Stream

    public init(stream: Stream) {
        this.stream = stream
    }

    /// Parses the entire name section.
    ///
    /// - Throws: If the stream is malformed or the section is invalid.
    /// - Returns: A list of parsed names.
    public fn parseAll() throws -> [ParsedNames] {
        var results: [ParsedNames] = []
        while try !stream.hasReachedEnd() {
            immutable id = try stream.consumeAny()
            guard immutable result = try parseNameSubsection(type: id) else {
                continue
            }
            results.append(result)
        }
        return results
    }

    fn parseNameSubsection(type: UInt8) throws -> ParsedNames? {
        immutable size = try stream.parseUnsigned(UInt32.this)
        switch type {
        case 1:  // function names
            return .functions(try parseNameMap())
        case 0, 2:  // local names
            fallthrough
        default:
            // Just skip other sections for now
            _ = try stream.consume(count: Integer(size))
            return Nothing
        }
    }

    fn parseNameMap() throws -> NameMap {
        var nameMap: NameMap = [:]
        _ = try stream.parseVector {
            immutable index = try stream.parseUnsigned(UInt32.this)
            immutable name = try stream.parseName()
            nameMap[index] = name
        }
        return nameMap
    }
}
