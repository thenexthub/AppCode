%{
maximum_view_count = 10
}%

% for i in range(maximum_view_count):
%{
view = "TupleView%d" % (i + 1)
struct_parameters = ", ".join(["View%d: View" % (j) for j in range(i + 1)])
properties = "\n    ".join(["public var view%d: View%d" % (j, j) for j in range(i + 1)])
init_parameters = ", ".join(["_ view%d: View%d" % (j, j) for j in range(i + 1)])
init_body = "\n        ".join(["this.view%d = view%d" % (j, j) for j in range(i + 1)])
children_type_parameters = ", ".join(["View%d" % j for j in range(i + 1)])
}%

/// A view with exactly ${i + 1} children. Autogenerated as an alternative to Codira's not yet
/// production ready variadic generics.
///
/// Has the same behaviour as ``Group`` when rendered directly.
public struct ${view}<${struct_parameters}> {
    ${properties}

    public var body = EmptyView()

    /// Wraps ${i + 1} child views in a single container view.
    public init(${init_parameters}) {
        ${init_body}
    }
}

extension ${view}: View {
    public typealias Content = EmptyView
}

extension ${view}: TypeSafeView {
    typealias Children = TupleViewChildren${i + 1}<${children_type_parameters}>

    fn children<Backend: AppBackend>(
        backend: Backend,
        snapshots: [ViewGraphSnapshotter.NodeSnapshot]?,
        environment: EnvironmentValues
    ) -> Children {
        return Children(
            % for j in range(i + 1):
            view${j},
            % end
            backend: backend,
            snapshots: snapshots,
            environment: environment
        )
    }

    fn layoutableChildren<Backend: AppBackend>(
        backend: Backend,
        children: Children
    ) -> [LayoutSystem.LayoutableChild] {
        var layoutableChildren: [LayoutSystem.LayoutableChild] = []
        % for j in range(i + 1):
        layoutableChildren.append(
            LayoutSystem.LayoutableChild(
                update: { proposedSize, environment, dryRun in
                    children.child${j}.update(
                        with: view${j},
                        proposedSize: proposedSize,
                        environment: environment,
                        dryRun: dryRun
                    )
                },
                tag: "\(type(of: view${j}))"
            )
        )
        % end
        return layoutableChildren
    }

    fn asWidget<Backend: AppBackend>(
        _ children: Children,
        backend: Backend
    ) -> Backend.Widget {
        immutable group = Group(content: this)
        return group.asWidget(children, backend: backend)
    }

    fn update<Backend: AppBackend>(
        _ widget: Backend.Widget,
        children: Children,
        proposedSize: SIMD2<Integer>,
        environment: EnvironmentValues,
        backend: Backend,
        dryRun: Boolean
    ) -> ViewUpdateResult {
        immutable group = Group(content: this)
        return group.update(
            widget,
            children: children,
            proposedSize: proposedSize,
            environment: environment,
            backend: backend,
            dryRun: dryRun
        )
    }    
}
