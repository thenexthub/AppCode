// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli

import DOM
import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptKit
import WebAPIBase
import WebAnimations
import WebAudio
import WebGL1

#if canImport(JavaScriptEventLoop)
    import JavaScriptEventLoop
#endif
#if canImport(_Concurrency)
    import _Concurrency
#endif

public class GPU: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPU].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn requestAdapter(options: GPURequestAdapterOptions? = nil) -> JSPromise {
        immutable this = jsObject
        return this[Strings.requestAdapter].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn requestAdapter(
            options: GPURequestAdapterOptions? = nil
        ) async throws(JSException) -> GPUAdapter? {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.requestAdapter].function!(
                this: this,
                arguments: [_toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()
        }
    #endif

    @inlinable final public fn getPreferredCanvasFormat() -> GPUTextureFormat {
        immutable this = jsObject
        return this[Strings.getPreferredCanvasFormat].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var wgslLanguageFeatures: WGSLLanguageFeatures {
        jsObject[Strings.wgslLanguageFeatures].fromJSValue()!
    }
}

public class GPUAdapter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUAdapter].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var features: GPUSupportedFeatures { jsObject[Strings.features].fromJSValue()! }

    @inlinable public var limits: GPUSupportedLimits { jsObject[Strings.limits].fromJSValue()! }

    @inlinable public var info: GPUAdapterInfo { jsObject[Strings.info].fromJSValue()! }

    @inlinable public var isFallbackAdapter: Boolean { jsObject[Strings.isFallbackAdapter].fromJSValue()! }

    @inlinable final public fn requestDevice(descriptor: GPUDeviceDescriptor? = nil) -> JSPromise {
        immutable this = jsObject
        return this[Strings.requestDevice].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn requestDevice(
            descriptor: GPUDeviceDescriptor? = nil
        ) async throws(JSException) -> GPUDevice {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.requestDevice].function!(
                this: this,
                arguments: [_toJSValue(descriptor)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

public class GPUAdapterInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUAdapterInfo].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var vendor: String { jsObject[Strings.vendor].fromJSValue()! }

    @inlinable public var architecture: String { jsObject[Strings.architecture].fromJSValue()! }

    @inlinable public var device: String { jsObject[Strings.device].fromJSValue()! }

    @inlinable public var description: String { jsObject[Strings.description].fromJSValue()! }

    @inlinable public var subgroupMinSize: UInt32 { jsObject[Strings.subgroupMinSize].fromJSValue()! }

    @inlinable public var subgroupMaxSize: UInt32 { jsObject[Strings.subgroupMaxSize].fromJSValue()! }
}

public enum GPUAddressMode: JSString, JSValueCompatible {
    case clampToEdge = "clamp-to-edge"
    case `repeat` = "repeat"
    case mirrorRepeat = "mirror-repeat"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUAutoLayoutMode: JSString, JSValueCompatible {
    case auto = "auto"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUBindGroup: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUBindGroup].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUBindGroupDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil, layout: GPUBindGroupLayout, entries: [GPUBindGroupEntry]) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.layout] = _toJSValue(layout)
        object[Strings.entries] = _toJSValue(entries)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var layout: GPUBindGroupLayout {
        get { jsObject[Strings.layout].fromJSValue()! }
        set { jsObject[Strings.layout] = _toJSValue(newValue) }
    }
    @inlinable public var entries: [GPUBindGroupEntry] {
        get { jsObject[Strings.entries].fromJSValue()! }
        set { jsObject[Strings.entries] = _toJSValue(newValue) }
    }
}
open class GPUBindGroupEntry: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(binding: GPUIndex32, resource: GPUBindingResource) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.binding] = _toJSValue(binding)
        object[Strings.resource] = _toJSValue(resource)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var binding: GPUIndex32 {
        get { jsObject[Strings.binding].fromJSValue()! }
        set { jsObject[Strings.binding] = _toJSValue(newValue) }
    }
    @inlinable public var resource: GPUBindingResource {
        get { jsObject[Strings.resource].fromJSValue()! }
        set { jsObject[Strings.resource] = _toJSValue(newValue) }
    }
}
public class GPUBindGroupLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUBindGroupLayout].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUBindGroupLayoutDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil, entries: [GPUBindGroupLayoutEntry]) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.entries] = _toJSValue(entries)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var entries: [GPUBindGroupLayoutEntry] {
        get { jsObject[Strings.entries].fromJSValue()! }
        set { jsObject[Strings.entries] = _toJSValue(newValue) }
    }
}
open class GPUBindGroupLayoutEntry: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        binding: GPUIndex32,
        visibility: GPUShaderStageFlags,
        buffer: GPUBufferBindingLayout? = nil,
        sampler: GPUSamplerBindingLayout? = nil,
        texture: GPUTextureBindingLayout? = nil,
        storageTexture: GPUStorageTextureBindingLayout? = nil,
        externalTexture: GPUExternalTextureBindingLayout? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.binding] = _toJSValue(binding)
        object[Strings.visibility] = _toJSValue(visibility)
        object[Strings.buffer] = _toJSValue(buffer)
        object[Strings.sampler] = _toJSValue(sampler)
        object[Strings.texture] = _toJSValue(texture)
        object[Strings.storageTexture] = _toJSValue(storageTexture)
        object[Strings.externalTexture] = _toJSValue(externalTexture)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var binding: GPUIndex32 {
        get { jsObject[Strings.binding].fromJSValue()! }
        set { jsObject[Strings.binding] = _toJSValue(newValue) }
    }
    @inlinable public var visibility: GPUShaderStageFlags {
        get { jsObject[Strings.visibility].fromJSValue()! }
        set { jsObject[Strings.visibility] = _toJSValue(newValue) }
    }
    @inlinable public var buffer: GPUBufferBindingLayout {
        get { jsObject[Strings.buffer].fromJSValue()! }
        set { jsObject[Strings.buffer] = _toJSValue(newValue) }
    }
    @inlinable public var sampler: GPUSamplerBindingLayout {
        get { jsObject[Strings.sampler].fromJSValue()! }
        set { jsObject[Strings.sampler] = _toJSValue(newValue) }
    }
    @inlinable public var texture: GPUTextureBindingLayout {
        get { jsObject[Strings.texture].fromJSValue()! }
        set { jsObject[Strings.texture] = _toJSValue(newValue) }
    }
    @inlinable public var storageTexture: GPUStorageTextureBindingLayout {
        get { jsObject[Strings.storageTexture].fromJSValue()! }
        set { jsObject[Strings.storageTexture] = _toJSValue(newValue) }
    }
    @inlinable public var externalTexture: GPUExternalTextureBindingLayout {
        get { jsObject[Strings.externalTexture].fromJSValue()! }
        set { jsObject[Strings.externalTexture] = _toJSValue(newValue) }
    }
}
public protocol GPUBindingCommandsMixin: JSBridgedClass {}
extension GPUBindingCommandsMixin {
    @inlinable public fn setBindGroup(
        index: GPUIndex32,
        bindGroup: GPUBindGroup?,
        dynamicOffsets: [GPUBufferDynamicOffset]? = nil
    ) {
        immutable this = jsObject
        _ = this[Strings.setBindGroup].function!(
            this: this,
            arguments: [_toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsets)]
        )
    }

    @inlinable public fn setBindGroup(
        index: GPUIndex32,
        bindGroup: GPUBindGroup?,
        dynamicOffsetsData: Uint32Array,
        dynamicOffsetsDataStart: GPUSize64,
        dynamicOffsetsDataLength: GPUSize32
    ) {
        immutable this = jsObject
        _ = this[Strings.setBindGroup].function!(
            this: this,
            arguments: [
                _toJSValue(index), _toJSValue(bindGroup), _toJSValue(dynamicOffsetsData),
                _toJSValue(dynamicOffsetsDataStart), _toJSValue(dynamicOffsetsDataLength),
            ]
        )
    }
}
open class GPUBlendComponent: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        operation: GPUBlendOperation? = nil,
        srcFactor: GPUBlendFactor? = nil,
        dstFactor: GPUBlendFactor? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.operation] = _toJSValue(operation)
        object[Strings.srcFactor] = _toJSValue(srcFactor)
        object[Strings.dstFactor] = _toJSValue(dstFactor)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var operation: GPUBlendOperation {
        get { jsObject[Strings.operation].fromJSValue()! }
        set { jsObject[Strings.operation] = _toJSValue(newValue) }
    }
    @inlinable public var srcFactor: GPUBlendFactor {
        get { jsObject[Strings.srcFactor].fromJSValue()! }
        set { jsObject[Strings.srcFactor] = _toJSValue(newValue) }
    }
    @inlinable public var dstFactor: GPUBlendFactor {
        get { jsObject[Strings.dstFactor].fromJSValue()! }
        set { jsObject[Strings.dstFactor] = _toJSValue(newValue) }
    }
}
public enum GPUBlendFactor: JSString, JSValueCompatible {
    case zero = "zero"
    case one = "one"
    case src = "src"
    case oneMinusSrc = "one-minus-src"
    case srcAlpha = "src-alpha"
    case oneMinusSrcAlpha = "one-minus-src-alpha"
    case dst = "dst"
    case oneMinusDst = "one-minus-dst"
    case dstAlpha = "dst-alpha"
    case oneMinusDstAlpha = "one-minus-dst-alpha"
    case srcAlphaSaturated = "src-alpha-saturated"
    case constant = "constant"
    case oneMinusConstant = "one-minus-constant"
    case src1 = "src1"
    case oneMinusSrc1 = "one-minus-src1"
    case src1Alpha = "src1-alpha"
    case oneMinusSrc1Alpha = "one-minus-src1-alpha"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUBlendOperation: JSString, JSValueCompatible {
    case add = "add"
    case subtract = "subtract"
    case reverseSubtract = "reverse-subtract"
    case min = "min"
    case max = "max"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUBlendState: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(color: GPUBlendComponent, alpha: GPUBlendComponent) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.color] = _toJSValue(color)
        object[Strings.alpha] = _toJSValue(alpha)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var color: GPUBlendComponent {
        get { jsObject[Strings.color].fromJSValue()! }
        set { jsObject[Strings.color] = _toJSValue(newValue) }
    }
    @inlinable public var alpha: GPUBlendComponent {
        get { jsObject[Strings.alpha].fromJSValue()! }
        set { jsObject[Strings.alpha] = _toJSValue(newValue) }
    }
}
public class GPUBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUBuffer].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var size: GPUSize64Out { jsObject[Strings.size].fromJSValue()! }

    @inlinable public var usage: GPUFlagsConstant { jsObject[Strings.usage].fromJSValue()! }

    @inlinable public var mapState: GPUBufferMapState { jsObject[Strings.mapState].fromJSValue()! }

    @inlinable final public fn mapAsync(
        mode: GPUMapModeFlags,
        offset: GPUSize64? = nil,
        size: GPUSize64? = nil
    ) -> JSPromise {
        immutable this = jsObject
        return this[Strings.mapAsync].function!(
            this: this,
            arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]
        ).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn mapAsync(
            mode: GPUMapModeFlags,
            offset: GPUSize64? = nil,
            size: GPUSize64? = nil
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.mapAsync].function!(
                this: this,
                arguments: [_toJSValue(mode), _toJSValue(offset), _toJSValue(size)]
            ).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn getMappedRange(offset: GPUSize64? = nil, size: GPUSize64? = nil) -> ArrayBuffer {
        immutable this = jsObject
        return this[Strings.getMappedRange].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(size)])
            .fromJSValue()!
    }

    @inlinable final public fn unmap() {
        immutable this = jsObject
        _ = this[Strings.unmap].function!(this: this, arguments: [])
    }

    @inlinable final public fn destroy() {
        immutable this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }
}

open class GPUBufferBinding: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(buffer: GPUBuffer, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.buffer] = _toJSValue(buffer)
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.size] = _toJSValue(size)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var buffer: GPUBuffer {
        get { jsObject[Strings.buffer].fromJSValue()! }
        set { jsObject[Strings.buffer] = _toJSValue(newValue) }
    }
    @inlinable public var offset: GPUSize64 {
        get { jsObject[Strings.offset].fromJSValue()! }
        set { jsObject[Strings.offset] = _toJSValue(newValue) }
    }
    @inlinable public var size: GPUSize64 {
        get { jsObject[Strings.size].fromJSValue()! }
        set { jsObject[Strings.size] = _toJSValue(newValue) }
    }
}
open class GPUBufferBindingLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        type: GPUBufferBindingType? = nil,
        hasDynamicOffset: Boolean? = nil,
        minBindingSize: GPUSize64? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.hasDynamicOffset] = _toJSValue(hasDynamicOffset)
        object[Strings.minBindingSize] = _toJSValue(minBindingSize)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: GPUBufferBindingType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var hasDynamicOffset: Boolean {
        get { jsObject[Strings.hasDynamicOffset].fromJSValue()! }
        set { jsObject[Strings.hasDynamicOffset] = _toJSValue(newValue) }
    }
    @inlinable public var minBindingSize: GPUSize64 {
        get { jsObject[Strings.minBindingSize].fromJSValue()! }
        set { jsObject[Strings.minBindingSize] = _toJSValue(newValue) }
    }
}
public enum GPUBufferBindingType: JSString, JSValueCompatible {
    case uniform = "uniform"
    case storage = "storage"
    case readOnlyStorage = "read-only-storage"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUBufferDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        size: GPUSize64,
        usage: GPUBufferUsageFlags,
        mappedAtCreation: Boolean? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.size] = _toJSValue(size)
        object[Strings.usage] = _toJSValue(usage)
        object[Strings.mappedAtCreation] = _toJSValue(mappedAtCreation)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var size: GPUSize64 {
        get { jsObject[Strings.size].fromJSValue()! }
        set { jsObject[Strings.size] = _toJSValue(newValue) }
    }
    @inlinable public var usage: GPUBufferUsageFlags {
        get { jsObject[Strings.usage].fromJSValue()! }
        set { jsObject[Strings.usage] = _toJSValue(newValue) }
    }
    @inlinable public var mappedAtCreation: Boolean {
        get { jsObject[Strings.mappedAtCreation].fromJSValue()! }
        set { jsObject[Strings.mappedAtCreation] = _toJSValue(newValue) }
    }
}
public enum GPUBufferMapState: JSString, JSValueCompatible {
    case unmapped = "unmapped"
    case pending = "pending"
    case mapped = "mapped"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUBufferUsage {
    @inlinable public static var jsObject: JSObject { JSObject.global[Strings.GPUBufferUsage].object! }

    public static immutable MAP_READ: GPUFlagsConstant = 0x0001

    public static immutable MAP_WRITE: GPUFlagsConstant = 0x0002

    public static immutable COPY_SRC: GPUFlagsConstant = 0x0004

    public static immutable COPY_DST: GPUFlagsConstant = 0x0008

    public static immutable INDEX: GPUFlagsConstant = 0x0010

    public static immutable VERTEX: GPUFlagsConstant = 0x0020

    public static immutable UNIFORM: GPUFlagsConstant = 0x0040

    public static immutable STORAGE: GPUFlagsConstant = 0x0080

    public static immutable INDIRECT: GPUFlagsConstant = 0x0100

    public static immutable QUERY_RESOLVE: GPUFlagsConstant = 0x0200
}
public enum GPUCanvasAlphaMode: JSString, JSValueCompatible {
    case opaque = "opaque"
    case premultiplied = "premultiplied"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUCanvasConfiguration: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        device: GPUDevice,
        format: GPUTextureFormat,
        usage: GPUTextureUsageFlags? = nil,
        viewFormats: [GPUTextureFormat]? = nil,
        colorSpace: PredefinedColorSpace? = nil,
        toneMapping: GPUCanvasToneMapping? = nil,
        alphaMode: GPUCanvasAlphaMode? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.device] = _toJSValue(device)
        object[Strings.format] = _toJSValue(format)
        object[Strings.usage] = _toJSValue(usage)
        object[Strings.viewFormats] = _toJSValue(viewFormats)
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        object[Strings.toneMapping] = _toJSValue(toneMapping)
        object[Strings.alphaMode] = _toJSValue(alphaMode)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var device: GPUDevice {
        get { jsObject[Strings.device].fromJSValue()! }
        set { jsObject[Strings.device] = _toJSValue(newValue) }
    }
    @inlinable public var format: GPUTextureFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var usage: GPUTextureUsageFlags {
        get { jsObject[Strings.usage].fromJSValue()! }
        set { jsObject[Strings.usage] = _toJSValue(newValue) }
    }
    @inlinable public var viewFormats: [GPUTextureFormat] {
        get { jsObject[Strings.viewFormats].fromJSValue()! }
        set { jsObject[Strings.viewFormats] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpace: PredefinedColorSpace {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
    @inlinable public var toneMapping: GPUCanvasToneMapping {
        get { jsObject[Strings.toneMapping].fromJSValue()! }
        set { jsObject[Strings.toneMapping] = _toJSValue(newValue) }
    }
    @inlinable public var alphaMode: GPUCanvasAlphaMode {
        get { jsObject[Strings.alphaMode].fromJSValue()! }
        set { jsObject[Strings.alphaMode] = _toJSValue(newValue) }
    }
}
public class GPUCanvasContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCanvasContext].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var canvas: HTMLCanvasElement_or_OffscreenCanvas { jsObject[Strings.canvas].fromJSValue()! }

    @inlinable final public fn configure(configuration: GPUCanvasConfiguration) {
        immutable this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [_toJSValue(configuration)])
    }

    @inlinable final public fn unconfigure() {
        immutable this = jsObject
        _ = this[Strings.unconfigure].function!(this: this, arguments: [])
    }

    @inlinable final public fn getConfiguration() -> GPUCanvasConfiguration? {
        immutable this = jsObject
        return this[Strings.getConfiguration].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn getCurrentTexture() -> GPUTexture {
        immutable this = jsObject
        return this[Strings.getCurrentTexture].function!(this: this, arguments: []).fromJSValue()!
    }
}

open class GPUCanvasToneMapping: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(mode: GPUCanvasToneMappingMode? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mode] = _toJSValue(mode)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var mode: GPUCanvasToneMappingMode {
        get { jsObject[Strings.mode].fromJSValue()! }
        set { jsObject[Strings.mode] = _toJSValue(newValue) }
    }
}
public enum GPUCanvasToneMappingMode: JSString, JSValueCompatible {
    case standard = "standard"
    case extended = "extended"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUColorDict: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(r: Double, g: Double, b: Double, a: Double) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.r] = _toJSValue(r)
        object[Strings.g] = _toJSValue(g)
        object[Strings.b] = _toJSValue(b)
        object[Strings.a] = _toJSValue(a)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var r: Double {
        get { jsObject[Strings.r].fromJSValue()! }
        set { jsObject[Strings.r] = _toJSValue(newValue) }
    }
    @inlinable public var g: Double {
        get { jsObject[Strings.g].fromJSValue()! }
        set { jsObject[Strings.g] = _toJSValue(newValue) }
    }
    @inlinable public var b: Double {
        get { jsObject[Strings.b].fromJSValue()! }
        set { jsObject[Strings.b] = _toJSValue(newValue) }
    }
    @inlinable public var a: Double {
        get { jsObject[Strings.a].fromJSValue()! }
        set { jsObject[Strings.a] = _toJSValue(newValue) }
    }
}
open class GPUColorTargetState: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(format: GPUTextureFormat, blend: GPUBlendState? = nil, writeMask: GPUColorWriteFlags? = nil)
    {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.blend] = _toJSValue(blend)
        object[Strings.writeMask] = _toJSValue(writeMask)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var format: GPUTextureFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var blend: GPUBlendState {
        get { jsObject[Strings.blend].fromJSValue()! }
        set { jsObject[Strings.blend] = _toJSValue(newValue) }
    }
    @inlinable public var writeMask: GPUColorWriteFlags {
        get { jsObject[Strings.writeMask].fromJSValue()! }
        set { jsObject[Strings.writeMask] = _toJSValue(newValue) }
    }
}
public enum GPUColorWrite {
    @inlinable public static var jsObject: JSObject { JSObject.global[Strings.GPUColorWrite].object! }

    public static immutable RED: GPUFlagsConstant = 0x1

    public static immutable GREEN: GPUFlagsConstant = 0x2

    public static immutable BLUE: GPUFlagsConstant = 0x4

    public static immutable ALPHA: GPUFlagsConstant = 0x8

    public static immutable ALL: GPUFlagsConstant = 0xF
}
public class GPUCommandBuffer: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCommandBuffer].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUCommandBufferDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

}
public class GPUCommandEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCommandEncoder].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn beginRenderPass(descriptor: GPURenderPassDescriptor) -> GPURenderPassEncoder {
        immutable this = jsObject
        return this[Strings.beginRenderPass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable final public fn beginComputePass(descriptor: GPUComputePassDescriptor? = nil) -> GPUComputePassEncoder
    {
        immutable this = jsObject
        return this[Strings.beginComputePass].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable final public fn copyBufferToBuffer(
        source: GPUBuffer,
        sourceOffset: GPUSize64,
        destination: GPUBuffer,
        destinationOffset: GPUSize64,
        size: GPUSize64
    ) {
        immutable this = jsObject
        _ = this[Strings.copyBufferToBuffer].function!(
            this: this,
            arguments: [
                _toJSValue(source), _toJSValue(sourceOffset), _toJSValue(destination), _toJSValue(destinationOffset),
                _toJSValue(size),
            ]
        )
    }

    @inlinable final public fn copyBufferToTexture(
        source: GPUTexelCopyBufferInfo,
        destination: GPUTexelCopyTextureInfo,
        copySize: GPUExtent3D
    ) {
        immutable this = jsObject
        _ = this[Strings.copyBufferToTexture].function!(
            this: this,
            arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)]
        )
    }

    @inlinable final public fn copyTextureToBuffer(
        source: GPUTexelCopyTextureInfo,
        destination: GPUTexelCopyBufferInfo,
        copySize: GPUExtent3D
    ) {
        immutable this = jsObject
        _ = this[Strings.copyTextureToBuffer].function!(
            this: this,
            arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)]
        )
    }

    @inlinable final public fn copyTextureToTexture(
        source: GPUTexelCopyTextureInfo,
        destination: GPUTexelCopyTextureInfo,
        copySize: GPUExtent3D
    ) {
        immutable this = jsObject
        _ = this[Strings.copyTextureToTexture].function!(
            this: this,
            arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)]
        )
    }

    @inlinable final public fn clearBuffer(buffer: GPUBuffer, offset: GPUSize64? = nil, size: GPUSize64? = nil) {
        immutable this = jsObject
        _ = this[Strings.clearBuffer].function!(
            this: this,
            arguments: [_toJSValue(buffer), _toJSValue(offset), _toJSValue(size)]
        )
    }

    @inlinable final public fn resolveQuerySet(
        querySet: GPUQuerySet,
        firstQuery: GPUSize32,
        queryCount: GPUSize32,
        destination: GPUBuffer,
        destinationOffset: GPUSize64
    ) {
        immutable this = jsObject
        _ = this[Strings.resolveQuerySet].function!(
            this: this,
            arguments: [
                _toJSValue(querySet), _toJSValue(firstQuery), _toJSValue(queryCount), _toJSValue(destination),
                _toJSValue(destinationOffset),
            ]
        )
    }

    @inlinable final public fn finish(descriptor: GPUCommandBufferDescriptor? = nil) -> GPUCommandBuffer {
        immutable this = jsObject
        return this[Strings.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

open class GPUCommandEncoderDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

}
public protocol GPUCommandsMixin: JSBridgedClass {}
extension GPUCommandsMixin {}
public enum GPUCompareFunction: JSString, JSValueCompatible {
    case never = "never"
    case less = "less"
    case equal = "equal"
    case lessEqual = "less-equal"
    case greater = "greater"
    case notEqual = "not-equal"
    case greaterEqual = "greater-equal"
    case always = "always"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUCompilationInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCompilationInfo].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var messages: [GPUCompilationMessage] { jsObject[Strings.messages].fromJSValue()! }
}

public class GPUCompilationMessage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUCompilationMessage].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var message: String { jsObject[Strings.message].fromJSValue()! }

    @inlinable public var type: GPUCompilationMessageType { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var lineNum: UInt64 { jsObject[Strings.lineNum].fromJSValue()! }

    @inlinable public var linePos: UInt64 { jsObject[Strings.linePos].fromJSValue()! }

    @inlinable public var offset: UInt64 { jsObject[Strings.offset].fromJSValue()! }

    @inlinable public var length: UInt64 { jsObject[Strings.length].fromJSValue()! }
}

public enum GPUCompilationMessageType: JSString, JSValueCompatible {
    case error = "error"
    case warning = "warning"
    case info = "info"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUComputePassDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil, timestampWrites: GPUComputePassTimestampWrites? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.timestampWrites] = _toJSValue(timestampWrites)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var timestampWrites: GPUComputePassTimestampWrites {
        get { jsObject[Strings.timestampWrites].fromJSValue()! }
        set { jsObject[Strings.timestampWrites] = _toJSValue(newValue) }
    }
}
public class GPUComputePassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin,
    GPUBindingCommandsMixin
{
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUComputePassEncoder].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn setPipeline(pipeline: GPUComputePipeline) {
        immutable this = jsObject
        _ = this[Strings.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable final public fn dispatchWorkgroups(
        workgroupCountX: GPUSize32,
        workgroupCountY: GPUSize32? = nil,
        workgroupCountZ: GPUSize32? = nil
    ) {
        immutable this = jsObject
        _ = this[Strings.dispatchWorkgroups].function!(
            this: this,
            arguments: [_toJSValue(workgroupCountX), _toJSValue(workgroupCountY), _toJSValue(workgroupCountZ)]
        )
    }

    @inlinable final public fn dispatchWorkgroupsIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        immutable this = jsObject
        _ = this[Strings.dispatchWorkgroupsIndirect].function!(
            this: this,
            arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)]
        )
    }

    @inlinable final public fn end() {
        immutable this = jsObject
        _ = this[Strings.end].function!(this: this, arguments: [])
    }
}

open class GPUComputePassTimestampWrites: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        querySet: GPUQuerySet,
        beginningOfPassWriteIndex: GPUSize32? = nil,
        endOfPassWriteIndex: GPUSize32? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.querySet] = _toJSValue(querySet)
        object[Strings.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[Strings.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var querySet: GPUQuerySet {
        get { jsObject[Strings.querySet].fromJSValue()! }
        set { jsObject[Strings.querySet] = _toJSValue(newValue) }
    }
    @inlinable public var beginningOfPassWriteIndex: GPUSize32 {
        get { jsObject[Strings.beginningOfPassWriteIndex].fromJSValue()! }
        set { jsObject[Strings.beginningOfPassWriteIndex] = _toJSValue(newValue) }
    }
    @inlinable public var endOfPassWriteIndex: GPUSize32 {
        get { jsObject[Strings.endOfPassWriteIndex].fromJSValue()! }
        set { jsObject[Strings.endOfPassWriteIndex] = _toJSValue(newValue) }
    }
}
public class GPUComputePipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUComputePipeline].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUComputePipelineDescriptor: GPUPipelineDescriptorBase {

    public convenience init(layout: GPUAutoLayoutMode_or_GPUPipelineLayout, compute: GPUProgrammableStage) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = _toJSValue(layout)
        object[Strings.compute] = _toJSValue(compute)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var compute: GPUProgrammableStage {
        get { jsObject[Strings.compute].fromJSValue()! }
        set { jsObject[Strings.compute] = _toJSValue(newValue) }
    }
}
open class GPUCopyExternalImageDestInfo: GPUTexelCopyTextureInfo {

    public convenience init(
        texture: GPUTexture,
        mipLevel: GPUIntegerCoordinate? = nil,
        origin: GPUOrigin3D? = nil,
        aspect: GPUTextureAspect? = nil,
        colorSpace: PredefinedColorSpace? = nil,
        premultipliedAlpha: Boolean? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.texture] = _toJSValue(texture)
        object[Strings.mipLevel] = _toJSValue(mipLevel)
        object[Strings.origin] = _toJSValue(origin)
        object[Strings.aspect] = _toJSValue(aspect)
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        object[Strings.premultipliedAlpha] = _toJSValue(premultipliedAlpha)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var colorSpace: PredefinedColorSpace {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
    @inlinable public var premultipliedAlpha: Boolean {
        get { jsObject[Strings.premultipliedAlpha].fromJSValue()! }
        set { jsObject[Strings.premultipliedAlpha] = _toJSValue(newValue) }
    }
}
open class GPUCopyExternalImageSourceInfo: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(source: GPUCopyExternalImageSource, origin: GPUOrigin2D? = nil, flipY: Boolean? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.source] = _toJSValue(source)
        object[Strings.origin] = _toJSValue(origin)
        object[Strings.flipY] = _toJSValue(flipY)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var source: GPUCopyExternalImageSource {
        get { jsObject[Strings.source].fromJSValue()! }
        set { jsObject[Strings.source] = _toJSValue(newValue) }
    }
    @inlinable public var origin: GPUOrigin2D {
        get { jsObject[Strings.origin].fromJSValue()! }
        set { jsObject[Strings.origin] = _toJSValue(newValue) }
    }
    @inlinable public var flipY: Boolean {
        get { jsObject[Strings.flipY].fromJSValue()! }
        set { jsObject[Strings.flipY] = _toJSValue(newValue) }
    }
}
public enum GPUCullMode: JSString, JSValueCompatible {
    case none = "none"
    case front = "front"
    case back = "back"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol GPUDebugCommandsMixin: JSBridgedClass {}
extension GPUDebugCommandsMixin {
    @inlinable public fn pushDebugGroup(groupLabel: String) {
        immutable this = jsObject
        _ = this[Strings.pushDebugGroup].function!(this: this, arguments: [_toJSValue(groupLabel)])
    }

    @inlinable public fn popDebugGroup() {
        immutable this = jsObject
        _ = this[Strings.popDebugGroup].function!(this: this, arguments: [])
    }

    @inlinable public fn insertDebugMarker(markerLabel: String) {
        immutable this = jsObject
        _ = this[Strings.insertDebugMarker].function!(this: this, arguments: [_toJSValue(markerLabel)])
    }
}
open class GPUDepthStencilState: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        format: GPUTextureFormat,
        depthWriteEnabled: Boolean? = nil,
        depthCompare: GPUCompareFunction? = nil,
        stencilFront: GPUStencilFaceState? = nil,
        stencilBack: GPUStencilFaceState? = nil,
        stencilReadMask: GPUStencilValue? = nil,
        stencilWriteMask: GPUStencilValue? = nil,
        depthBias: GPUDepthBias? = nil,
        depthBiasSlopeScale: Float? = nil,
        depthBiasClamp: Float? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.depthWriteEnabled] = _toJSValue(depthWriteEnabled)
        object[Strings.depthCompare] = _toJSValue(depthCompare)
        object[Strings.stencilFront] = _toJSValue(stencilFront)
        object[Strings.stencilBack] = _toJSValue(stencilBack)
        object[Strings.stencilReadMask] = _toJSValue(stencilReadMask)
        object[Strings.stencilWriteMask] = _toJSValue(stencilWriteMask)
        object[Strings.depthBias] = _toJSValue(depthBias)
        object[Strings.depthBiasSlopeScale] = _toJSValue(depthBiasSlopeScale)
        object[Strings.depthBiasClamp] = _toJSValue(depthBiasClamp)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var format: GPUTextureFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var depthWriteEnabled: Boolean {
        get { jsObject[Strings.depthWriteEnabled].fromJSValue()! }
        set { jsObject[Strings.depthWriteEnabled] = _toJSValue(newValue) }
    }
    @inlinable public var depthCompare: GPUCompareFunction {
        get { jsObject[Strings.depthCompare].fromJSValue()! }
        set { jsObject[Strings.depthCompare] = _toJSValue(newValue) }
    }
    @inlinable public var stencilFront: GPUStencilFaceState {
        get { jsObject[Strings.stencilFront].fromJSValue()! }
        set { jsObject[Strings.stencilFront] = _toJSValue(newValue) }
    }
    @inlinable public var stencilBack: GPUStencilFaceState {
        get { jsObject[Strings.stencilBack].fromJSValue()! }
        set { jsObject[Strings.stencilBack] = _toJSValue(newValue) }
    }
    @inlinable public var stencilReadMask: GPUStencilValue {
        get { jsObject[Strings.stencilReadMask].fromJSValue()! }
        set { jsObject[Strings.stencilReadMask] = _toJSValue(newValue) }
    }
    @inlinable public var stencilWriteMask: GPUStencilValue {
        get { jsObject[Strings.stencilWriteMask].fromJSValue()! }
        set { jsObject[Strings.stencilWriteMask] = _toJSValue(newValue) }
    }
    @inlinable public var depthBias: GPUDepthBias {
        get { jsObject[Strings.depthBias].fromJSValue()! }
        set { jsObject[Strings.depthBias] = _toJSValue(newValue) }
    }
    @inlinable public var depthBiasSlopeScale: Float {
        get { jsObject[Strings.depthBiasSlopeScale].fromJSValue()! }
        set { jsObject[Strings.depthBiasSlopeScale] = _toJSValue(newValue) }
    }
    @inlinable public var depthBiasClamp: Float {
        get { jsObject[Strings.depthBiasClamp].fromJSValue()! }
        set { jsObject[Strings.depthBiasClamp] = _toJSValue(newValue) }
    }
}
public class GPUDevice: EventTarget, GPUObjectBase {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.GPUDevice].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var features: GPUSupportedFeatures { jsObject[Strings.features].fromJSValue()! }

    @inlinable public var limits: GPUSupportedLimits { jsObject[Strings.limits].fromJSValue()! }

    @inlinable public var adapterInfo: GPUAdapterInfo { jsObject[Strings.adapterInfo].fromJSValue()! }

    @inlinable public var queue: GPUQueue { jsObject[Strings.queue].fromJSValue()! }

    @inlinable final public fn destroy() {
        immutable this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @inlinable final public fn createBuffer(descriptor: GPUBufferDescriptor) -> GPUBuffer {
        immutable this = jsObject
        return this[Strings.createBuffer].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable final public fn createTexture(descriptor: GPUTextureDescriptor) -> GPUTexture {
        immutable this = jsObject
        return this[Strings.createTexture].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable final public fn createSampler(descriptor: GPUSamplerDescriptor? = nil) -> GPUSampler {
        immutable this = jsObject
        return this[Strings.createSampler].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable final public fn importExternalTexture(descriptor: GPUExternalTextureDescriptor) -> GPUExternalTexture {
        immutable this = jsObject
        return this[Strings.importExternalTexture].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createBindGroupLayout(descriptor: GPUBindGroupLayoutDescriptor) -> GPUBindGroupLayout {
        immutable this = jsObject
        return this[Strings.createBindGroupLayout].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createPipelineLayout(descriptor: GPUPipelineLayoutDescriptor) -> GPUPipelineLayout {
        immutable this = jsObject
        return this[Strings.createPipelineLayout].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createBindGroup(descriptor: GPUBindGroupDescriptor) -> GPUBindGroup {
        immutable this = jsObject
        return this[Strings.createBindGroup].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable final public fn createShaderModule(descriptor: GPUShaderModuleDescriptor) -> GPUShaderModule {
        immutable this = jsObject
        return this[Strings.createShaderModule].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createComputePipeline(descriptor: GPUComputePipelineDescriptor) -> GPUComputePipeline {
        immutable this = jsObject
        return this[Strings.createComputePipeline].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createRenderPipeline(descriptor: GPURenderPipelineDescriptor) -> GPURenderPipeline {
        immutable this = jsObject
        return this[Strings.createRenderPipeline].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor) -> JSPromise {
        immutable this = jsObject
        return this[Strings.createComputePipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable
        final public fn createComputePipelineAsync(
            descriptor: GPUComputePipelineDescriptor
        ) async throws(JSException) -> GPUComputePipeline {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.createComputePipelineAsync].function!(
                this: this,
                arguments: [_toJSValue(descriptor)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor) -> JSPromise {
        immutable this = jsObject
        return this[Strings.createRenderPipelineAsync].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable
        final public fn createRenderPipelineAsync(
            descriptor: GPURenderPipelineDescriptor
        ) async throws(JSException) -> GPURenderPipeline {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.createRenderPipelineAsync].function!(
                this: this,
                arguments: [_toJSValue(descriptor)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn createCommandEncoder(
        descriptor: GPUCommandEncoderDescriptor? = nil
    ) -> GPUCommandEncoder {
        immutable this = jsObject
        return this[Strings.createCommandEncoder].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createRenderBundleEncoder(
        descriptor: GPURenderBundleEncoderDescriptor
    ) -> GPURenderBundleEncoder {
        immutable this = jsObject
        return this[Strings.createRenderBundleEncoder].function!(this: this, arguments: [_toJSValue(descriptor)])
            .fromJSValue()!
    }

    @inlinable final public fn createQuerySet(descriptor: GPUQuerySetDescriptor) -> GPUQuerySet {
        immutable this = jsObject
        return this[Strings.createQuerySet].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable public var lost: JSPromise { jsObject[Strings.lost].fromJSValue()! }

    @inlinable final public fn pushErrorScope(filter: GPUErrorFilter) {
        immutable this = jsObject
        _ = this[Strings.pushErrorScope].function!(this: this, arguments: [_toJSValue(filter)])
    }

    @inlinable final public fn popErrorScope() -> JSPromise {
        immutable this = jsObject
        return this[Strings.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn popErrorScope()
            async throws(JSException) -> GPUError?
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.popErrorScope].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()
        }
    #endif

    @inlinable public var onuncapturederror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onuncapturederror].function else { return nil }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onuncapturederror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onuncapturederror] = .null
            }
        }
    }
}

open class GPUDeviceDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        requiredFeatures: [GPUFeatureName]? = nil,
        requiredLimits: JSObject? = nil,
        defaultQueue: GPUQueueDescriptor? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.requiredFeatures] = _toJSValue(requiredFeatures)
        object[Strings.requiredLimits] = _toJSValue(requiredLimits)
        object[Strings.defaultQueue] = _toJSValue(defaultQueue)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var requiredFeatures: [GPUFeatureName] {
        get { jsObject[Strings.requiredFeatures].fromJSValue()! }
        set { jsObject[Strings.requiredFeatures] = _toJSValue(newValue) }
    }
    @inlinable public var requiredLimits: JSObject {
        get { jsObject[Strings.requiredLimits].fromJSValue()! }
        set { jsObject[Strings.requiredLimits] = _toJSValue(newValue) }
    }
    @inlinable public var defaultQueue: GPUQueueDescriptor {
        get { jsObject[Strings.defaultQueue].fromJSValue()! }
        set { jsObject[Strings.defaultQueue] = _toJSValue(newValue) }
    }
}
public class GPUDeviceLostInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUDeviceLostInfo].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var reason: GPUDeviceLostReason { jsObject[Strings.reason].fromJSValue()! }

    @inlinable public var message: String { jsObject[Strings.message].fromJSValue()! }
}

public enum GPUDeviceLostReason: JSString, JSValueCompatible {
    case unknown = "unknown"
    case destroyed = "destroyed"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUError].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var message: String { jsObject[Strings.message].fromJSValue()! }
}

public enum GPUErrorFilter: JSString, JSValueCompatible {
    case validation = "validation"
    case outOfMemory = "out-of-memory"
    case `internal` = "internal"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUExtent3DDict: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        width: GPUIntegerCoordinate,
        height: GPUIntegerCoordinate? = nil,
        depthOrArrayLayers: GPUIntegerCoordinate? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.depthOrArrayLayers] = _toJSValue(depthOrArrayLayers)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var width: GPUIntegerCoordinate {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
    @inlinable public var height: GPUIntegerCoordinate {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
    @inlinable public var depthOrArrayLayers: GPUIntegerCoordinate {
        get { jsObject[Strings.depthOrArrayLayers].fromJSValue()! }
        set { jsObject[Strings.depthOrArrayLayers] = _toJSValue(newValue) }
    }
}
public class GPUExternalTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUExternalTexture].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUExternalTextureBindingLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init() {
        immutable object = JSObject.global[Strings.Object].function!.new()

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

}
open class GPUExternalTextureDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        source: HTMLVideoElement_or_VideoFrame,
        colorSpace: PredefinedColorSpace? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.source] = _toJSValue(source)
        object[Strings.colorSpace] = _toJSValue(colorSpace)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var source: HTMLVideoElement_or_VideoFrame {
        get { jsObject[Strings.source].fromJSValue()! }
        set { jsObject[Strings.source] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpace: PredefinedColorSpace {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
}
public enum GPUFeatureName: JSString, JSValueCompatible {
    case depthClipControl = "depth-clip-control"
    case depth32floatStencil8 = "depth32float-stencil8"
    case textureCompressionBc = "texture-compression-bc"
    case textureCompressionBcSliced3d = "texture-compression-bc-sliced-3d"
    case textureCompressionEtc2 = "texture-compression-etc2"
    case textureCompressionAstc = "texture-compression-astc"
    case textureCompressionAstcSliced3d = "texture-compression-astc-sliced-3d"
    case timestampQuery = "timestamp-query"
    case indirectFirstInstance = "indirect-first-instance"
    case shaderF16 = "shader-f16"
    case rg11b10ufloatRenderable = "rg11b10ufloat-renderable"
    case bgra8unormStorage = "bgra8unorm-storage"
    case float32Filterable = "float32-filterable"
    case float32Blendable = "float32-blendable"
    case clipDistances = "clip-distances"
    case dualSourceBlending = "dual-source-blending"
    case subgroups = "subgroups"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUFragmentState: GPUProgrammableStage {

    public convenience init(
        module: GPUShaderModule,
        entryPoint: String? = nil,
        constants: JSObject? = nil,
        targets: [GPUColorTargetState?]
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.module] = _toJSValue(module)
        object[Strings.entryPoint] = _toJSValue(entryPoint)
        object[Strings.constants] = _toJSValue(constants)
        object[Strings.targets] = _toJSValue(targets)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var targets: [GPUColorTargetState?] {
        get { jsObject[Strings.targets].fromJSValue()! }
        set { jsObject[Strings.targets] = _toJSValue(newValue) }
    }
}
public enum GPUFrontFace: JSString, JSValueCompatible {
    case ccw = "ccw"
    case cw = "cw"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUIndexFormat: JSString, JSValueCompatible {
    case uint16 = "uint16"
    case uint32 = "uint32"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUInternalError: GPUError {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.GPUInternalError].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(message: String) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public enum GPULoadOp: JSString, JSValueCompatible {
    case load = "load"
    case clear = "clear"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUMapMode {
    @inlinable public static var jsObject: JSObject { JSObject.global[Strings.GPUMapMode].object! }

    public static immutable READ: GPUFlagsConstant = 0x0001

    public static immutable WRITE: GPUFlagsConstant = 0x0002
}
public enum GPUMipmapFilterMode: JSString, JSValueCompatible {
    case nearest = "nearest"
    case linear = "linear"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUMultisampleState: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(count: GPUSize32? = nil, mask: GPUSampleMask? = nil, alphaToCoverageEnabled: Boolean? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.count] = _toJSValue(count)
        object[Strings.mask] = _toJSValue(mask)
        object[Strings.alphaToCoverageEnabled] = _toJSValue(alphaToCoverageEnabled)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var count: GPUSize32 {
        get { jsObject[Strings.count].fromJSValue()! }
        set { jsObject[Strings.count] = _toJSValue(newValue) }
    }
    @inlinable public var mask: GPUSampleMask {
        get { jsObject[Strings.mask].fromJSValue()! }
        set { jsObject[Strings.mask] = _toJSValue(newValue) }
    }
    @inlinable public var alphaToCoverageEnabled: Boolean {
        get { jsObject[Strings.alphaToCoverageEnabled].fromJSValue()! }
        set { jsObject[Strings.alphaToCoverageEnabled] = _toJSValue(newValue) }
    }
}
public protocol GPUObjectBase: JSBridgedClass {}
extension GPUObjectBase {
    @inlinable public var label: String {
        get { jsObject[Strings.label].fromJSValue()! }
        set { jsObject[Strings.label] = _toJSValue(newValue) }
    }
}
open class GPUObjectDescriptorBase: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(label: String? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var label: String {
        get { jsObject[Strings.label].fromJSValue()! }
        set { jsObject[Strings.label] = _toJSValue(newValue) }
    }
}
open class GPUOrigin2DDict: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(x: GPUIntegerCoordinate? = nil, y: GPUIntegerCoordinate? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = _toJSValue(x)
        object[Strings.y] = _toJSValue(y)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var x: GPUIntegerCoordinate {
        get { jsObject[Strings.x].fromJSValue()! }
        set { jsObject[Strings.x] = _toJSValue(newValue) }
    }
    @inlinable public var y: GPUIntegerCoordinate {
        get { jsObject[Strings.y].fromJSValue()! }
        set { jsObject[Strings.y] = _toJSValue(newValue) }
    }
}
open class GPUOrigin3DDict: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        x: GPUIntegerCoordinate? = nil,
        y: GPUIntegerCoordinate? = nil,
        z: GPUIntegerCoordinate? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = _toJSValue(x)
        object[Strings.y] = _toJSValue(y)
        object[Strings.z] = _toJSValue(z)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var x: GPUIntegerCoordinate {
        get { jsObject[Strings.x].fromJSValue()! }
        set { jsObject[Strings.x] = _toJSValue(newValue) }
    }
    @inlinable public var y: GPUIntegerCoordinate {
        get { jsObject[Strings.y].fromJSValue()! }
        set { jsObject[Strings.y] = _toJSValue(newValue) }
    }
    @inlinable public var z: GPUIntegerCoordinate {
        get { jsObject[Strings.z].fromJSValue()! }
        set { jsObject[Strings.z] = _toJSValue(newValue) }
    }
}
public class GPUOutOfMemoryError: GPUError {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.GPUOutOfMemoryError].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(message: String) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

public protocol GPUPipelineBase: JSBridgedClass {}
extension GPUPipelineBase {
    @inlinable public fn getBindGroupLayout(index: UInt32) -> GPUBindGroupLayout {
        immutable this = jsObject
        return this[Strings.getBindGroupLayout].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
}
open class GPUPipelineDescriptorBase: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil, layout: GPUAutoLayoutMode_or_GPUPipelineLayout) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.layout] = _toJSValue(layout)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout {
        get { jsObject[Strings.layout].fromJSValue()! }
        set { jsObject[Strings.layout] = _toJSValue(newValue) }
    }
}
public class GPUPipelineError: DOMException {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.GPUPipelineError].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(message: String? = nil, options: GPUPipelineErrorInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message), _toJSValue(options)]))
    }

    @inlinable public var reason: GPUPipelineErrorReason { jsObject[Strings.reason].fromJSValue()! }
}

open class GPUPipelineErrorInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(reason: GPUPipelineErrorReason) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.reason] = _toJSValue(reason)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var reason: GPUPipelineErrorReason {
        get { jsObject[Strings.reason].fromJSValue()! }
        set { jsObject[Strings.reason] = _toJSValue(newValue) }
    }
}
public enum GPUPipelineErrorReason: JSString, JSValueCompatible {
    case validation = "validation"
    case `internal` = "internal"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUPipelineLayout: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUPipelineLayout].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUPipelineLayoutDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil, bindGroupLayouts: [GPUBindGroupLayout?]) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.bindGroupLayouts] = _toJSValue(bindGroupLayouts)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var bindGroupLayouts: [GPUBindGroupLayout?] {
        get { jsObject[Strings.bindGroupLayouts].fromJSValue()! }
        set { jsObject[Strings.bindGroupLayouts] = _toJSValue(newValue) }
    }
}
public enum GPUPowerPreference: JSString, JSValueCompatible {
    case lowPower = "low-power"
    case highPerformance = "high-performance"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUPrimitiveState: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        topology: GPUPrimitiveTopology? = nil,
        stripIndexFormat: GPUIndexFormat? = nil,
        frontFace: GPUFrontFace? = nil,
        cullMode: GPUCullMode? = nil,
        unclippedDepth: Boolean? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.topology] = _toJSValue(topology)
        object[Strings.stripIndexFormat] = _toJSValue(stripIndexFormat)
        object[Strings.frontFace] = _toJSValue(frontFace)
        object[Strings.cullMode] = _toJSValue(cullMode)
        object[Strings.unclippedDepth] = _toJSValue(unclippedDepth)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var topology: GPUPrimitiveTopology {
        get { jsObject[Strings.topology].fromJSValue()! }
        set { jsObject[Strings.topology] = _toJSValue(newValue) }
    }
    @inlinable public var stripIndexFormat: GPUIndexFormat {
        get { jsObject[Strings.stripIndexFormat].fromJSValue()! }
        set { jsObject[Strings.stripIndexFormat] = _toJSValue(newValue) }
    }
    @inlinable public var frontFace: GPUFrontFace {
        get { jsObject[Strings.frontFace].fromJSValue()! }
        set { jsObject[Strings.frontFace] = _toJSValue(newValue) }
    }
    @inlinable public var cullMode: GPUCullMode {
        get { jsObject[Strings.cullMode].fromJSValue()! }
        set { jsObject[Strings.cullMode] = _toJSValue(newValue) }
    }
    @inlinable public var unclippedDepth: Boolean {
        get { jsObject[Strings.unclippedDepth].fromJSValue()! }
        set { jsObject[Strings.unclippedDepth] = _toJSValue(newValue) }
    }
}
public enum GPUPrimitiveTopology: JSString, JSValueCompatible {
    case pointList = "point-list"
    case lineList = "line-list"
    case lineStrip = "line-strip"
    case triangleList = "triangle-list"
    case triangleStrip = "triangle-strip"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUProgrammableStage: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(module: GPUShaderModule, entryPoint: String? = nil, constants: JSObject? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.module] = _toJSValue(module)
        object[Strings.entryPoint] = _toJSValue(entryPoint)
        object[Strings.constants] = _toJSValue(constants)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var module: GPUShaderModule {
        get { jsObject[Strings.module].fromJSValue()! }
        set { jsObject[Strings.module] = _toJSValue(newValue) }
    }
    @inlinable public var entryPoint: String {
        get { jsObject[Strings.entryPoint].fromJSValue()! }
        set { jsObject[Strings.entryPoint] = _toJSValue(newValue) }
    }
    @inlinable public var constants: JSObject {
        get { jsObject[Strings.constants].fromJSValue()! }
        set { jsObject[Strings.constants] = _toJSValue(newValue) }
    }
}
public class GPUQuerySet: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUQuerySet].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn destroy() {
        immutable this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @inlinable public var type: GPUQueryType { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var count: GPUSize32Out { jsObject[Strings.count].fromJSValue()! }
}

open class GPUQuerySetDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil, type: GPUQueryType, count: GPUSize32) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.type] = _toJSValue(type)
        object[Strings.count] = _toJSValue(count)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var type: GPUQueryType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var count: GPUSize32 {
        get { jsObject[Strings.count].fromJSValue()! }
        set { jsObject[Strings.count] = _toJSValue(newValue) }
    }
}
public enum GPUQueryType: JSString, JSValueCompatible {
    case occlusion = "occlusion"
    case timestamp = "timestamp"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUQueue: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUQueue].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn submit(commandBuffers: [GPUCommandBuffer]) {
        immutable this = jsObject
        _ = this[Strings.submit].function!(this: this, arguments: [_toJSValue(commandBuffers)])
    }

    @inlinable final public fn onSubmittedWorkDone() -> JSPromise {
        immutable this = jsObject
        return this[Strings.onSubmittedWorkDone].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn onSubmittedWorkDone()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.onSubmittedWorkDone].function!(this: this, arguments: [])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn writeBuffer(
        buffer: GPUBuffer,
        bufferOffset: GPUSize64,
        data: AllowSharedBufferSource,
        dataOffset: GPUSize64? = nil,
        size: GPUSize64? = nil
    ) {
        immutable this = jsObject
        _ = this[Strings.writeBuffer].function!(
            this: this,
            arguments: [
                _toJSValue(buffer), _toJSValue(bufferOffset), _toJSValue(data), _toJSValue(dataOffset),
                _toJSValue(size),
            ]
        )
    }

    @inlinable final public fn writeTexture(
        destination: GPUTexelCopyTextureInfo,
        data: AllowSharedBufferSource,
        dataLayout: GPUTexelCopyBufferLayout,
        size: GPUExtent3D
    ) {
        immutable this = jsObject
        _ = this[Strings.writeTexture].function!(
            this: this,
            arguments: [_toJSValue(destination), _toJSValue(data), _toJSValue(dataLayout), _toJSValue(size)]
        )
    }

    @inlinable final public fn copyExternalImageToTexture(
        source: GPUCopyExternalImageSourceInfo,
        destination: GPUCopyExternalImageDestInfo,
        copySize: GPUExtent3D
    ) {
        immutable this = jsObject
        _ = this[Strings.copyExternalImageToTexture].function!(
            this: this,
            arguments: [_toJSValue(source), _toJSValue(destination), _toJSValue(copySize)]
        )
    }
}

open class GPUQueueDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

}
public class GPURenderBundle: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderBundle].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPURenderBundleDescriptor: GPUObjectDescriptorBase {

    public convenience init(label: String? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

}
public class GPURenderBundleEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin,
    GPUBindingCommandsMixin, GPURenderCommandsMixin
{
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderBundleEncoder].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn finish(descriptor: GPURenderBundleDescriptor? = nil) -> GPURenderBundle {
        immutable this = jsObject
        return this[Strings.finish].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }
}

open class GPURenderBundleEncoderDescriptor: GPURenderPassLayout {

    public convenience init(
        colorFormats: [GPUTextureFormat?],
        depthStencilFormat: GPUTextureFormat? = nil,
        sampleCount: GPUSize32? = nil,
        depthReadOnly: Boolean? = nil,
        stencilReadOnly: Boolean? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorFormats] = _toJSValue(colorFormats)
        object[Strings.depthStencilFormat] = _toJSValue(depthStencilFormat)
        object[Strings.sampleCount] = _toJSValue(sampleCount)
        object[Strings.depthReadOnly] = _toJSValue(depthReadOnly)
        object[Strings.stencilReadOnly] = _toJSValue(stencilReadOnly)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var depthReadOnly: Boolean {
        get { jsObject[Strings.depthReadOnly].fromJSValue()! }
        set { jsObject[Strings.depthReadOnly] = _toJSValue(newValue) }
    }
    @inlinable public var stencilReadOnly: Boolean {
        get { jsObject[Strings.stencilReadOnly].fromJSValue()! }
        set { jsObject[Strings.stencilReadOnly] = _toJSValue(newValue) }
    }
}
public protocol GPURenderCommandsMixin: JSBridgedClass {}
extension GPURenderCommandsMixin {
    @inlinable public fn setPipeline(pipeline: GPURenderPipeline) {
        immutable this = jsObject
        _ = this[Strings.setPipeline].function!(this: this, arguments: [_toJSValue(pipeline)])
    }

    @inlinable public fn setIndexBuffer(
        buffer: GPUBuffer,
        indexFormat: GPUIndexFormat,
        offset: GPUSize64? = nil,
        size: GPUSize64? = nil
    ) {
        immutable this = jsObject
        _ = this[Strings.setIndexBuffer].function!(
            this: this,
            arguments: [_toJSValue(buffer), _toJSValue(indexFormat), _toJSValue(offset), _toJSValue(size)]
        )
    }

    @inlinable public fn setVertexBuffer(
        slot: GPUIndex32,
        buffer: GPUBuffer?,
        offset: GPUSize64? = nil,
        size: GPUSize64? = nil
    ) {
        immutable this = jsObject
        _ = this[Strings.setVertexBuffer].function!(
            this: this,
            arguments: [_toJSValue(slot), _toJSValue(buffer), _toJSValue(offset), _toJSValue(size)]
        )
    }

    @inlinable public fn draw(
        vertexCount: GPUSize32,
        instanceCount: GPUSize32? = nil,
        firstVertex: GPUSize32? = nil,
        firstInstance: GPUSize32? = nil
    ) {
        immutable this = jsObject
        _ = this[Strings.draw].function!(
            this: this,
            arguments: [
                _toJSValue(vertexCount), _toJSValue(instanceCount), _toJSValue(firstVertex), _toJSValue(firstInstance),
            ]
        )
    }

    @inlinable public fn drawIndexed(
        indexCount: GPUSize32,
        instanceCount: GPUSize32? = nil,
        firstIndex: GPUSize32? = nil,
        baseVertex: GPUSignedOffset32? = nil,
        firstInstance: GPUSize32? = nil
    ) {
        immutable this = jsObject
        _ = this[Strings.drawIndexed].function!(
            this: this,
            arguments: [
                _toJSValue(indexCount), _toJSValue(instanceCount), _toJSValue(firstIndex), _toJSValue(baseVertex),
                _toJSValue(firstInstance),
            ]
        )
    }

    @inlinable public fn drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        immutable this = jsObject
        _ = this[Strings.drawIndirect].function!(
            this: this,
            arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)]
        )
    }

    @inlinable public fn drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64) {
        immutable this = jsObject
        _ = this[Strings.drawIndexedIndirect].function!(
            this: this,
            arguments: [_toJSValue(indirectBuffer), _toJSValue(indirectOffset)]
        )
    }
}
open class GPURenderPassColorAttachment: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        view: GPUTextureView,
        depthSlice: GPUIntegerCoordinate? = nil,
        resolveTarget: GPUTextureView? = nil,
        clearValue: GPUColor? = nil,
        loadOp: GPULoadOp,
        storeOp: GPUStoreOp
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.depthSlice] = _toJSValue(depthSlice)
        object[Strings.resolveTarget] = _toJSValue(resolveTarget)
        object[Strings.clearValue] = _toJSValue(clearValue)
        object[Strings.loadOp] = _toJSValue(loadOp)
        object[Strings.storeOp] = _toJSValue(storeOp)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var view: GPUTextureView {
        get { jsObject[Strings.view].fromJSValue()! }
        set { jsObject[Strings.view] = _toJSValue(newValue) }
    }
    @inlinable public var depthSlice: GPUIntegerCoordinate {
        get { jsObject[Strings.depthSlice].fromJSValue()! }
        set { jsObject[Strings.depthSlice] = _toJSValue(newValue) }
    }
    @inlinable public var resolveTarget: GPUTextureView {
        get { jsObject[Strings.resolveTarget].fromJSValue()! }
        set { jsObject[Strings.resolveTarget] = _toJSValue(newValue) }
    }
    @inlinable public var clearValue: GPUColor {
        get { jsObject[Strings.clearValue].fromJSValue()! }
        set { jsObject[Strings.clearValue] = _toJSValue(newValue) }
    }
    @inlinable public var loadOp: GPULoadOp {
        get { jsObject[Strings.loadOp].fromJSValue()! }
        set { jsObject[Strings.loadOp] = _toJSValue(newValue) }
    }
    @inlinable public var storeOp: GPUStoreOp {
        get { jsObject[Strings.storeOp].fromJSValue()! }
        set { jsObject[Strings.storeOp] = _toJSValue(newValue) }
    }
}
open class GPURenderPassDepthStencilAttachment: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        view: GPUTextureView,
        depthClearValue: Float? = nil,
        depthLoadOp: GPULoadOp? = nil,
        depthStoreOp: GPUStoreOp? = nil,
        depthReadOnly: Boolean? = nil,
        stencilClearValue: GPUStencilValue? = nil,
        stencilLoadOp: GPULoadOp? = nil,
        stencilStoreOp: GPUStoreOp? = nil,
        stencilReadOnly: Boolean? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.depthClearValue] = _toJSValue(depthClearValue)
        object[Strings.depthLoadOp] = _toJSValue(depthLoadOp)
        object[Strings.depthStoreOp] = _toJSValue(depthStoreOp)
        object[Strings.depthReadOnly] = _toJSValue(depthReadOnly)
        object[Strings.stencilClearValue] = _toJSValue(stencilClearValue)
        object[Strings.stencilLoadOp] = _toJSValue(stencilLoadOp)
        object[Strings.stencilStoreOp] = _toJSValue(stencilStoreOp)
        object[Strings.stencilReadOnly] = _toJSValue(stencilReadOnly)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var view: GPUTextureView {
        get { jsObject[Strings.view].fromJSValue()! }
        set { jsObject[Strings.view] = _toJSValue(newValue) }
    }
    @inlinable public var depthClearValue: Float {
        get { jsObject[Strings.depthClearValue].fromJSValue()! }
        set { jsObject[Strings.depthClearValue] = _toJSValue(newValue) }
    }
    @inlinable public var depthLoadOp: GPULoadOp {
        get { jsObject[Strings.depthLoadOp].fromJSValue()! }
        set { jsObject[Strings.depthLoadOp] = _toJSValue(newValue) }
    }
    @inlinable public var depthStoreOp: GPUStoreOp {
        get { jsObject[Strings.depthStoreOp].fromJSValue()! }
        set { jsObject[Strings.depthStoreOp] = _toJSValue(newValue) }
    }
    @inlinable public var depthReadOnly: Boolean {
        get { jsObject[Strings.depthReadOnly].fromJSValue()! }
        set { jsObject[Strings.depthReadOnly] = _toJSValue(newValue) }
    }
    @inlinable public var stencilClearValue: GPUStencilValue {
        get { jsObject[Strings.stencilClearValue].fromJSValue()! }
        set { jsObject[Strings.stencilClearValue] = _toJSValue(newValue) }
    }
    @inlinable public var stencilLoadOp: GPULoadOp {
        get { jsObject[Strings.stencilLoadOp].fromJSValue()! }
        set { jsObject[Strings.stencilLoadOp] = _toJSValue(newValue) }
    }
    @inlinable public var stencilStoreOp: GPUStoreOp {
        get { jsObject[Strings.stencilStoreOp].fromJSValue()! }
        set { jsObject[Strings.stencilStoreOp] = _toJSValue(newValue) }
    }
    @inlinable public var stencilReadOnly: Boolean {
        get { jsObject[Strings.stencilReadOnly].fromJSValue()! }
        set { jsObject[Strings.stencilReadOnly] = _toJSValue(newValue) }
    }
}
open class GPURenderPassDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        colorAttachments: [GPURenderPassColorAttachment?],
        depthStencilAttachment: GPURenderPassDepthStencilAttachment? = nil,
        occlusionQuerySet: GPUQuerySet? = nil,
        timestampWrites: GPURenderPassTimestampWrites? = nil,
        maxDrawCount: GPUSize64? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.colorAttachments] = _toJSValue(colorAttachments)
        object[Strings.depthStencilAttachment] = _toJSValue(depthStencilAttachment)
        object[Strings.occlusionQuerySet] = _toJSValue(occlusionQuerySet)
        object[Strings.timestampWrites] = _toJSValue(timestampWrites)
        object[Strings.maxDrawCount] = _toJSValue(maxDrawCount)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var colorAttachments: [GPURenderPassColorAttachment?] {
        get { jsObject[Strings.colorAttachments].fromJSValue()! }
        set { jsObject[Strings.colorAttachments] = _toJSValue(newValue) }
    }
    @inlinable public var depthStencilAttachment: GPURenderPassDepthStencilAttachment {
        get { jsObject[Strings.depthStencilAttachment].fromJSValue()! }
        set { jsObject[Strings.depthStencilAttachment] = _toJSValue(newValue) }
    }
    @inlinable public var occlusionQuerySet: GPUQuerySet {
        get { jsObject[Strings.occlusionQuerySet].fromJSValue()! }
        set { jsObject[Strings.occlusionQuerySet] = _toJSValue(newValue) }
    }
    @inlinable public var timestampWrites: GPURenderPassTimestampWrites {
        get { jsObject[Strings.timestampWrites].fromJSValue()! }
        set { jsObject[Strings.timestampWrites] = _toJSValue(newValue) }
    }
    @inlinable public var maxDrawCount: GPUSize64 {
        get { jsObject[Strings.maxDrawCount].fromJSValue()! }
        set { jsObject[Strings.maxDrawCount] = _toJSValue(newValue) }
    }
}
public class GPURenderPassEncoder: JSBridgedClass, GPUObjectBase, GPUCommandsMixin, GPUDebugCommandsMixin,
    GPUBindingCommandsMixin, GPURenderCommandsMixin
{
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderPassEncoder].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn setViewport(
        x: Float,
        y: Float,
        width: Float,
        height: Float,
        minDepth: Float,
        maxDepth: Float
    ) {
        immutable this = jsObject
        _ = this[Strings.setViewport].function!(
            this: this,
            arguments: [
                _toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height), _toJSValue(minDepth),
                _toJSValue(maxDepth),
            ]
        )
    }

    @inlinable final public fn setScissorRect(
        x: GPUIntegerCoordinate,
        y: GPUIntegerCoordinate,
        width: GPUIntegerCoordinate,
        height: GPUIntegerCoordinate
    ) {
        immutable this = jsObject
        _ = this[Strings.setScissorRect].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height)]
        )
    }

    @inlinable final public fn setBlendConstant(color: GPUColor) {
        immutable this = jsObject
        _ = this[Strings.setBlendConstant].function!(this: this, arguments: [_toJSValue(color)])
    }

    @inlinable final public fn setStencilReference(reference: GPUStencilValue) {
        immutable this = jsObject
        _ = this[Strings.setStencilReference].function!(this: this, arguments: [_toJSValue(reference)])
    }

    @inlinable final public fn beginOcclusionQuery(queryIndex: GPUSize32) {
        immutable this = jsObject
        _ = this[Strings.beginOcclusionQuery].function!(this: this, arguments: [_toJSValue(queryIndex)])
    }

    @inlinable final public fn endOcclusionQuery() {
        immutable this = jsObject
        _ = this[Strings.endOcclusionQuery].function!(this: this, arguments: [])
    }

    @inlinable final public fn executeBundles(bundles: [GPURenderBundle]) {
        immutable this = jsObject
        _ = this[Strings.executeBundles].function!(this: this, arguments: [_toJSValue(bundles)])
    }

    @inlinable final public fn end() {
        immutable this = jsObject
        _ = this[Strings.end].function!(this: this, arguments: [])
    }
}

open class GPURenderPassLayout: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        colorFormats: [GPUTextureFormat?],
        depthStencilFormat: GPUTextureFormat? = nil,
        sampleCount: GPUSize32? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.colorFormats] = _toJSValue(colorFormats)
        object[Strings.depthStencilFormat] = _toJSValue(depthStencilFormat)
        object[Strings.sampleCount] = _toJSValue(sampleCount)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var colorFormats: [GPUTextureFormat?] {
        get { jsObject[Strings.colorFormats].fromJSValue()! }
        set { jsObject[Strings.colorFormats] = _toJSValue(newValue) }
    }
    @inlinable public var depthStencilFormat: GPUTextureFormat {
        get { jsObject[Strings.depthStencilFormat].fromJSValue()! }
        set { jsObject[Strings.depthStencilFormat] = _toJSValue(newValue) }
    }
    @inlinable public var sampleCount: GPUSize32 {
        get { jsObject[Strings.sampleCount].fromJSValue()! }
        set { jsObject[Strings.sampleCount] = _toJSValue(newValue) }
    }
}
open class GPURenderPassTimestampWrites: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        querySet: GPUQuerySet,
        beginningOfPassWriteIndex: GPUSize32? = nil,
        endOfPassWriteIndex: GPUSize32? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.querySet] = _toJSValue(querySet)
        object[Strings.beginningOfPassWriteIndex] = _toJSValue(beginningOfPassWriteIndex)
        object[Strings.endOfPassWriteIndex] = _toJSValue(endOfPassWriteIndex)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var querySet: GPUQuerySet {
        get { jsObject[Strings.querySet].fromJSValue()! }
        set { jsObject[Strings.querySet] = _toJSValue(newValue) }
    }
    @inlinable public var beginningOfPassWriteIndex: GPUSize32 {
        get { jsObject[Strings.beginningOfPassWriteIndex].fromJSValue()! }
        set { jsObject[Strings.beginningOfPassWriteIndex] = _toJSValue(newValue) }
    }
    @inlinable public var endOfPassWriteIndex: GPUSize32 {
        get { jsObject[Strings.endOfPassWriteIndex].fromJSValue()! }
        set { jsObject[Strings.endOfPassWriteIndex] = _toJSValue(newValue) }
    }
}
public class GPURenderPipeline: JSBridgedClass, GPUObjectBase, GPUPipelineBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPURenderPipeline].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPURenderPipelineDescriptor: GPUPipelineDescriptorBase {

    public convenience init(
        layout: GPUAutoLayoutMode_or_GPUPipelineLayout,
        vertex: GPUVertexState,
        primitive: GPUPrimitiveState? = nil,
        depthStencil: GPUDepthStencilState? = nil,
        multisample: GPUMultisampleState? = nil,
        fragment: GPUFragmentState? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.layout] = _toJSValue(layout)
        object[Strings.vertex] = _toJSValue(vertex)
        object[Strings.primitive] = _toJSValue(primitive)
        object[Strings.depthStencil] = _toJSValue(depthStencil)
        object[Strings.multisample] = _toJSValue(multisample)
        object[Strings.fragment] = _toJSValue(fragment)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var vertex: GPUVertexState {
        get { jsObject[Strings.vertex].fromJSValue()! }
        set { jsObject[Strings.vertex] = _toJSValue(newValue) }
    }
    @inlinable public var primitive: GPUPrimitiveState {
        get { jsObject[Strings.primitive].fromJSValue()! }
        set { jsObject[Strings.primitive] = _toJSValue(newValue) }
    }
    @inlinable public var depthStencil: GPUDepthStencilState {
        get { jsObject[Strings.depthStencil].fromJSValue()! }
        set { jsObject[Strings.depthStencil] = _toJSValue(newValue) }
    }
    @inlinable public var multisample: GPUMultisampleState {
        get { jsObject[Strings.multisample].fromJSValue()! }
        set { jsObject[Strings.multisample] = _toJSValue(newValue) }
    }
    @inlinable public var fragment: GPUFragmentState {
        get { jsObject[Strings.fragment].fromJSValue()! }
        set { jsObject[Strings.fragment] = _toJSValue(newValue) }
    }
}
open class GPURequestAdapterOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        featureLevel: String? = nil,
        powerPreference: GPUPowerPreference? = nil,
        forceFallbackAdapter: Boolean? = nil,
        xrCompatible: Boolean? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.featureLevel] = _toJSValue(featureLevel)
        object[Strings.powerPreference] = _toJSValue(powerPreference)
        object[Strings.forceFallbackAdapter] = _toJSValue(forceFallbackAdapter)
        object[Strings.xrCompatible] = _toJSValue(xrCompatible)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var featureLevel: String {
        get { jsObject[Strings.featureLevel].fromJSValue()! }
        set { jsObject[Strings.featureLevel] = _toJSValue(newValue) }
    }
    @inlinable public var powerPreference: GPUPowerPreference {
        get { jsObject[Strings.powerPreference].fromJSValue()! }
        set { jsObject[Strings.powerPreference] = _toJSValue(newValue) }
    }
    @inlinable public var forceFallbackAdapter: Boolean {
        get { jsObject[Strings.forceFallbackAdapter].fromJSValue()! }
        set { jsObject[Strings.forceFallbackAdapter] = _toJSValue(newValue) }
    }
    @inlinable public var xrCompatible: Boolean {
        get { jsObject[Strings.xrCompatible].fromJSValue()! }
        set { jsObject[Strings.xrCompatible] = _toJSValue(newValue) }
    }
}
public class GPUSampler: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUSampler].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUSamplerBindingLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(type: GPUSamplerBindingType? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: GPUSamplerBindingType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
}
public enum GPUSamplerBindingType: JSString, JSValueCompatible {
    case filtering = "filtering"
    case nonFiltering = "non-filtering"
    case comparison = "comparison"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUSamplerDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        addressModeU: GPUAddressMode? = nil,
        addressModeV: GPUAddressMode? = nil,
        addressModeW: GPUAddressMode? = nil,
        magFilter: GPUFilterMode? = nil,
        minFilter: GPUFilterMode? = nil,
        mipmapFilter: GPUMipmapFilterMode? = nil,
        lodMinClamp: Float? = nil,
        lodMaxClamp: Float? = nil,
        compare: GPUCompareFunction? = nil,
        maxAnisotropy: UInt16? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.addressModeU] = _toJSValue(addressModeU)
        object[Strings.addressModeV] = _toJSValue(addressModeV)
        object[Strings.addressModeW] = _toJSValue(addressModeW)
        object[Strings.magFilter] = _toJSValue(magFilter)
        object[Strings.minFilter] = _toJSValue(minFilter)
        object[Strings.mipmapFilter] = _toJSValue(mipmapFilter)
        object[Strings.lodMinClamp] = _toJSValue(lodMinClamp)
        object[Strings.lodMaxClamp] = _toJSValue(lodMaxClamp)
        object[Strings.compare] = _toJSValue(compare)
        object[Strings.maxAnisotropy] = _toJSValue(maxAnisotropy)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var addressModeU: GPUAddressMode {
        get { jsObject[Strings.addressModeU].fromJSValue()! }
        set { jsObject[Strings.addressModeU] = _toJSValue(newValue) }
    }
    @inlinable public var addressModeV: GPUAddressMode {
        get { jsObject[Strings.addressModeV].fromJSValue()! }
        set { jsObject[Strings.addressModeV] = _toJSValue(newValue) }
    }
    @inlinable public var addressModeW: GPUAddressMode {
        get { jsObject[Strings.addressModeW].fromJSValue()! }
        set { jsObject[Strings.addressModeW] = _toJSValue(newValue) }
    }
    @inlinable public var magFilter: GPUFilterMode {
        get { jsObject[Strings.magFilter].fromJSValue()! }
        set { jsObject[Strings.magFilter] = _toJSValue(newValue) }
    }
    @inlinable public var minFilter: GPUFilterMode {
        get { jsObject[Strings.minFilter].fromJSValue()! }
        set { jsObject[Strings.minFilter] = _toJSValue(newValue) }
    }
    @inlinable public var mipmapFilter: GPUMipmapFilterMode {
        get { jsObject[Strings.mipmapFilter].fromJSValue()! }
        set { jsObject[Strings.mipmapFilter] = _toJSValue(newValue) }
    }
    @inlinable public var lodMinClamp: Float {
        get { jsObject[Strings.lodMinClamp].fromJSValue()! }
        set { jsObject[Strings.lodMinClamp] = _toJSValue(newValue) }
    }
    @inlinable public var lodMaxClamp: Float {
        get { jsObject[Strings.lodMaxClamp].fromJSValue()! }
        set { jsObject[Strings.lodMaxClamp] = _toJSValue(newValue) }
    }
    @inlinable public var compare: GPUCompareFunction {
        get { jsObject[Strings.compare].fromJSValue()! }
        set { jsObject[Strings.compare] = _toJSValue(newValue) }
    }
    @inlinable public var maxAnisotropy: UInt16 {
        get { jsObject[Strings.maxAnisotropy].fromJSValue()! }
        set { jsObject[Strings.maxAnisotropy] = _toJSValue(newValue) }
    }
}
public class GPUShaderModule: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUShaderModule].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn getCompilationInfo() -> JSPromise {
        immutable this = jsObject
        return this[Strings.getCompilationInfo].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn getCompilationInfo()
            async throws(JSException) -> GPUCompilationInfo
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.getCompilationInfo].function!(this: this, arguments: [])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class GPUShaderModuleCompilationHint: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(entryPoint: String, layout: GPUAutoLayoutMode_or_GPUPipelineLayout? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.entryPoint] = _toJSValue(entryPoint)
        object[Strings.layout] = _toJSValue(layout)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var entryPoint: String {
        get { jsObject[Strings.entryPoint].fromJSValue()! }
        set { jsObject[Strings.entryPoint] = _toJSValue(newValue) }
    }
    @inlinable public var layout: GPUAutoLayoutMode_or_GPUPipelineLayout {
        get { jsObject[Strings.layout].fromJSValue()! }
        set { jsObject[Strings.layout] = _toJSValue(newValue) }
    }
}
open class GPUShaderModuleDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        code: String,
        compilationHints: [GPUShaderModuleCompilationHint]? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.code] = _toJSValue(code)
        object[Strings.compilationHints] = _toJSValue(compilationHints)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var code: String {
        get { jsObject[Strings.code].fromJSValue()! }
        set { jsObject[Strings.code] = _toJSValue(newValue) }
    }
    @inlinable public var compilationHints: [GPUShaderModuleCompilationHint] {
        get { jsObject[Strings.compilationHints].fromJSValue()! }
        set { jsObject[Strings.compilationHints] = _toJSValue(newValue) }
    }
}
public enum GPUShaderStage {
    @inlinable public static var jsObject: JSObject { JSObject.global[Strings.GPUShaderStage].object! }

    public static immutable VERTEX: GPUFlagsConstant = 0x1

    public static immutable FRAGMENT: GPUFlagsConstant = 0x2

    public static immutable COMPUTE: GPUFlagsConstant = 0x4
}
open class GPUStencilFaceState: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        compare: GPUCompareFunction? = nil,
        failOp: GPUStencilOperation? = nil,
        depthFailOp: GPUStencilOperation? = nil,
        passOp: GPUStencilOperation? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.compare] = _toJSValue(compare)
        object[Strings.failOp] = _toJSValue(failOp)
        object[Strings.depthFailOp] = _toJSValue(depthFailOp)
        object[Strings.passOp] = _toJSValue(passOp)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var compare: GPUCompareFunction {
        get { jsObject[Strings.compare].fromJSValue()! }
        set { jsObject[Strings.compare] = _toJSValue(newValue) }
    }
    @inlinable public var failOp: GPUStencilOperation {
        get { jsObject[Strings.failOp].fromJSValue()! }
        set { jsObject[Strings.failOp] = _toJSValue(newValue) }
    }
    @inlinable public var depthFailOp: GPUStencilOperation {
        get { jsObject[Strings.depthFailOp].fromJSValue()! }
        set { jsObject[Strings.depthFailOp] = _toJSValue(newValue) }
    }
    @inlinable public var passOp: GPUStencilOperation {
        get { jsObject[Strings.passOp].fromJSValue()! }
        set { jsObject[Strings.passOp] = _toJSValue(newValue) }
    }
}
public enum GPUStencilOperation: JSString, JSValueCompatible {
    case keep = "keep"
    case zero = "zero"
    case replace = "replace"
    case invert = "invert"
    case incrementClamp = "increment-clamp"
    case decrementClamp = "decrement-clamp"
    case incrementWrap = "increment-wrap"
    case decrementWrap = "decrement-wrap"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUStorageTextureAccess: JSString, JSValueCompatible {
    case writeOnly = "write-only"
    case readOnly = "read-only"
    case readWrite = "read-write"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUStorageTextureBindingLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        access: GPUStorageTextureAccess? = nil,
        format: GPUTextureFormat,
        viewDimension: GPUTextureViewDimension? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.access] = _toJSValue(access)
        object[Strings.format] = _toJSValue(format)
        object[Strings.viewDimension] = _toJSValue(viewDimension)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var access: GPUStorageTextureAccess {
        get { jsObject[Strings.access].fromJSValue()! }
        set { jsObject[Strings.access] = _toJSValue(newValue) }
    }
    @inlinable public var format: GPUTextureFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var viewDimension: GPUTextureViewDimension {
        get { jsObject[Strings.viewDimension].fromJSValue()! }
        set { jsObject[Strings.viewDimension] = _toJSValue(newValue) }
    }
}
public enum GPUStoreOp: JSString, JSValueCompatible {
    case store = "store"
    case discard = "discard"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUSupportedFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUSupportedFeatures].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    // XXX: make me Set-like!
}

public class GPUSupportedLimits: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUSupportedLimits].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var maxTextureDimension1D: UInt32 { jsObject[Strings.maxTextureDimension1D].fromJSValue()! }

    @inlinable public var maxTextureDimension2D: UInt32 { jsObject[Strings.maxTextureDimension2D].fromJSValue()! }

    @inlinable public var maxTextureDimension3D: UInt32 { jsObject[Strings.maxTextureDimension3D].fromJSValue()! }

    @inlinable public var maxTextureArrayLayers: UInt32 { jsObject[Strings.maxTextureArrayLayers].fromJSValue()! }

    @inlinable public var maxBindGroups: UInt32 { jsObject[Strings.maxBindGroups].fromJSValue()! }

    @inlinable public var maxBindGroupsPlusVertexBuffers: UInt32 {
        jsObject[Strings.maxBindGroupsPlusVertexBuffers].fromJSValue()!
    }

    @inlinable public var maxBindingsPerBindGroup: UInt32 { jsObject[Strings.maxBindingsPerBindGroup].fromJSValue()! }

    @inlinable public var maxDynamicUniformBuffersPerPipelineLayout: UInt32 {
        jsObject[Strings.maxDynamicUniformBuffersPerPipelineLayout].fromJSValue()!
    }

    @inlinable public var maxDynamicStorageBuffersPerPipelineLayout: UInt32 {
        jsObject[Strings.maxDynamicStorageBuffersPerPipelineLayout].fromJSValue()!
    }

    @inlinable public var maxSampledTexturesPerShaderStage: UInt32 {
        jsObject[Strings.maxSampledTexturesPerShaderStage].fromJSValue()!
    }

    @inlinable public var maxSamplersPerShaderStage: UInt32 {
        jsObject[Strings.maxSamplersPerShaderStage].fromJSValue()!
    }

    @inlinable public var maxStorageBuffersPerShaderStage: UInt32 {
        jsObject[Strings.maxStorageBuffersPerShaderStage].fromJSValue()!
    }

    @inlinable public var maxStorageTexturesPerShaderStage: UInt32 {
        jsObject[Strings.maxStorageTexturesPerShaderStage].fromJSValue()!
    }

    @inlinable public var maxUniformBuffersPerShaderStage: UInt32 {
        jsObject[Strings.maxUniformBuffersPerShaderStage].fromJSValue()!
    }

    @inlinable public var maxUniformBufferBindingSize: UInt64 {
        jsObject[Strings.maxUniformBufferBindingSize].fromJSValue()!
    }

    @inlinable public var maxStorageBufferBindingSize: UInt64 {
        jsObject[Strings.maxStorageBufferBindingSize].fromJSValue()!
    }

    @inlinable public var minUniformBufferOffsetAlignment: UInt32 {
        jsObject[Strings.minUniformBufferOffsetAlignment].fromJSValue()!
    }

    @inlinable public var minStorageBufferOffsetAlignment: UInt32 {
        jsObject[Strings.minStorageBufferOffsetAlignment].fromJSValue()!
    }

    @inlinable public var maxVertexBuffers: UInt32 { jsObject[Strings.maxVertexBuffers].fromJSValue()! }

    @inlinable public var maxBufferSize: UInt64 { jsObject[Strings.maxBufferSize].fromJSValue()! }

    @inlinable public var maxVertexAttributes: UInt32 { jsObject[Strings.maxVertexAttributes].fromJSValue()! }

    @inlinable public var maxVertexBufferArrayStride: UInt32 {
        jsObject[Strings.maxVertexBufferArrayStride].fromJSValue()!
    }

    @inlinable public var maxInterStageShaderVariables: UInt32 {
        jsObject[Strings.maxInterStageShaderVariables].fromJSValue()!
    }

    @inlinable public var maxColorAttachments: UInt32 { jsObject[Strings.maxColorAttachments].fromJSValue()! }

    @inlinable public var maxColorAttachmentBytesPerSample: UInt32 {
        jsObject[Strings.maxColorAttachmentBytesPerSample].fromJSValue()!
    }

    @inlinable public var maxComputeWorkgroupStorageSize: UInt32 {
        jsObject[Strings.maxComputeWorkgroupStorageSize].fromJSValue()!
    }

    @inlinable public var maxComputeInvocationsPerWorkgroup: UInt32 {
        jsObject[Strings.maxComputeInvocationsPerWorkgroup].fromJSValue()!
    }

    @inlinable public var maxComputeWorkgroupSizeX: UInt32 { jsObject[Strings.maxComputeWorkgroupSizeX].fromJSValue()! }

    @inlinable public var maxComputeWorkgroupSizeY: UInt32 { jsObject[Strings.maxComputeWorkgroupSizeY].fromJSValue()! }

    @inlinable public var maxComputeWorkgroupSizeZ: UInt32 { jsObject[Strings.maxComputeWorkgroupSizeZ].fromJSValue()! }

    @inlinable public var maxComputeWorkgroupsPerDimension: UInt32 {
        jsObject[Strings.maxComputeWorkgroupsPerDimension].fromJSValue()!
    }
}

open class GPUTexelCopyBufferInfo: GPUTexelCopyBufferLayout {

    public convenience init(
        offset: GPUSize64? = nil,
        bytesPerRow: GPUSize32? = nil,
        rowsPerImage: GPUSize32? = nil,
        buffer: GPUBuffer
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.bytesPerRow] = _toJSValue(bytesPerRow)
        object[Strings.rowsPerImage] = _toJSValue(rowsPerImage)
        object[Strings.buffer] = _toJSValue(buffer)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var buffer: GPUBuffer {
        get { jsObject[Strings.buffer].fromJSValue()! }
        set { jsObject[Strings.buffer] = _toJSValue(newValue) }
    }
}
open class GPUTexelCopyBufferLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(offset: GPUSize64? = nil, bytesPerRow: GPUSize32? = nil, rowsPerImage: GPUSize32? = nil) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.bytesPerRow] = _toJSValue(bytesPerRow)
        object[Strings.rowsPerImage] = _toJSValue(rowsPerImage)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var offset: GPUSize64 {
        get { jsObject[Strings.offset].fromJSValue()! }
        set { jsObject[Strings.offset] = _toJSValue(newValue) }
    }
    @inlinable public var bytesPerRow: GPUSize32 {
        get { jsObject[Strings.bytesPerRow].fromJSValue()! }
        set { jsObject[Strings.bytesPerRow] = _toJSValue(newValue) }
    }
    @inlinable public var rowsPerImage: GPUSize32 {
        get { jsObject[Strings.rowsPerImage].fromJSValue()! }
        set { jsObject[Strings.rowsPerImage] = _toJSValue(newValue) }
    }
}
open class GPUTexelCopyTextureInfo: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        texture: GPUTexture,
        mipLevel: GPUIntegerCoordinate? = nil,
        origin: GPUOrigin3D? = nil,
        aspect: GPUTextureAspect? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.texture] = _toJSValue(texture)
        object[Strings.mipLevel] = _toJSValue(mipLevel)
        object[Strings.origin] = _toJSValue(origin)
        object[Strings.aspect] = _toJSValue(aspect)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var texture: GPUTexture {
        get { jsObject[Strings.texture].fromJSValue()! }
        set { jsObject[Strings.texture] = _toJSValue(newValue) }
    }
    @inlinable public var mipLevel: GPUIntegerCoordinate {
        get { jsObject[Strings.mipLevel].fromJSValue()! }
        set { jsObject[Strings.mipLevel] = _toJSValue(newValue) }
    }
    @inlinable public var origin: GPUOrigin3D {
        get { jsObject[Strings.origin].fromJSValue()! }
        set { jsObject[Strings.origin] = _toJSValue(newValue) }
    }
    @inlinable public var aspect: GPUTextureAspect {
        get { jsObject[Strings.aspect].fromJSValue()! }
        set { jsObject[Strings.aspect] = _toJSValue(newValue) }
    }
}
public class GPUTexture: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUTexture].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn createView(descriptor: GPUTextureViewDescriptor? = nil) -> GPUTextureView {
        immutable this = jsObject
        return this[Strings.createView].function!(this: this, arguments: [_toJSValue(descriptor)]).fromJSValue()!
    }

    @inlinable final public fn destroy() {
        immutable this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @inlinable public var width: GPUIntegerCoordinateOut { jsObject[Strings.width].fromJSValue()! }

    @inlinable public var height: GPUIntegerCoordinateOut { jsObject[Strings.height].fromJSValue()! }

    @inlinable public var depthOrArrayLayers: GPUIntegerCoordinateOut {
        jsObject[Strings.depthOrArrayLayers].fromJSValue()!
    }

    @inlinable public var mipLevelCount: GPUIntegerCoordinateOut { jsObject[Strings.mipLevelCount].fromJSValue()! }

    @inlinable public var sampleCount: GPUSize32Out { jsObject[Strings.sampleCount].fromJSValue()! }

    @inlinable public var dimension: GPUTextureDimension { jsObject[Strings.dimension].fromJSValue()! }

    @inlinable public var format: GPUTextureFormat { jsObject[Strings.format].fromJSValue()! }

    @inlinable public var usage: GPUFlagsConstant { jsObject[Strings.usage].fromJSValue()! }
}

public enum GPUTextureAspect: JSString, JSValueCompatible {
    case all = "all"
    case stencilOnly = "stencil-only"
    case depthOnly = "depth-only"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUTextureBindingLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        sampleType: GPUTextureSampleType? = nil,
        viewDimension: GPUTextureViewDimension? = nil,
        multisampled: Boolean? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.sampleType] = _toJSValue(sampleType)
        object[Strings.viewDimension] = _toJSValue(viewDimension)
        object[Strings.multisampled] = _toJSValue(multisampled)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var sampleType: GPUTextureSampleType {
        get { jsObject[Strings.sampleType].fromJSValue()! }
        set { jsObject[Strings.sampleType] = _toJSValue(newValue) }
    }
    @inlinable public var viewDimension: GPUTextureViewDimension {
        get { jsObject[Strings.viewDimension].fromJSValue()! }
        set { jsObject[Strings.viewDimension] = _toJSValue(newValue) }
    }
    @inlinable public var multisampled: Boolean {
        get { jsObject[Strings.multisampled].fromJSValue()! }
        set { jsObject[Strings.multisampled] = _toJSValue(newValue) }
    }
}
open class GPUTextureDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        size: GPUExtent3D,
        mipLevelCount: GPUIntegerCoordinate? = nil,
        sampleCount: GPUSize32? = nil,
        dimension: GPUTextureDimension? = nil,
        format: GPUTextureFormat,
        usage: GPUTextureUsageFlags,
        viewFormats: [GPUTextureFormat]? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.size] = _toJSValue(size)
        object[Strings.mipLevelCount] = _toJSValue(mipLevelCount)
        object[Strings.sampleCount] = _toJSValue(sampleCount)
        object[Strings.dimension] = _toJSValue(dimension)
        object[Strings.format] = _toJSValue(format)
        object[Strings.usage] = _toJSValue(usage)
        object[Strings.viewFormats] = _toJSValue(viewFormats)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var size: GPUExtent3D {
        get { jsObject[Strings.size].fromJSValue()! }
        set { jsObject[Strings.size] = _toJSValue(newValue) }
    }
    @inlinable public var mipLevelCount: GPUIntegerCoordinate {
        get { jsObject[Strings.mipLevelCount].fromJSValue()! }
        set { jsObject[Strings.mipLevelCount] = _toJSValue(newValue) }
    }
    @inlinable public var sampleCount: GPUSize32 {
        get { jsObject[Strings.sampleCount].fromJSValue()! }
        set { jsObject[Strings.sampleCount] = _toJSValue(newValue) }
    }
    @inlinable public var dimension: GPUTextureDimension {
        get { jsObject[Strings.dimension].fromJSValue()! }
        set { jsObject[Strings.dimension] = _toJSValue(newValue) }
    }
    @inlinable public var format: GPUTextureFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var usage: GPUTextureUsageFlags {
        get { jsObject[Strings.usage].fromJSValue()! }
        set { jsObject[Strings.usage] = _toJSValue(newValue) }
    }
    @inlinable public var viewFormats: [GPUTextureFormat] {
        get { jsObject[Strings.viewFormats].fromJSValue()! }
        set { jsObject[Strings.viewFormats] = _toJSValue(newValue) }
    }
}
public enum GPUTextureDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _3d = "3d"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUTextureFormat: JSString, JSValueCompatible {
    case r8unorm = "r8unorm"
    case r8snorm = "r8snorm"
    case r8uint = "r8uint"
    case r8sint = "r8sint"
    case r16uint = "r16uint"
    case r16sint = "r16sint"
    case r16float = "r16float"
    case rg8unorm = "rg8unorm"
    case rg8snorm = "rg8snorm"
    case rg8uint = "rg8uint"
    case rg8sint = "rg8sint"
    case r32uint = "r32uint"
    case r32sint = "r32sint"
    case r32float = "r32float"
    case rg16uint = "rg16uint"
    case rg16sint = "rg16sint"
    case rg16float = "rg16float"
    case rgba8unorm = "rgba8unorm"
    case rgba8unormSrgb = "rgba8unorm-srgb"
    case rgba8snorm = "rgba8snorm"
    case rgba8uint = "rgba8uint"
    case rgba8sint = "rgba8sint"
    case bgra8unorm = "bgra8unorm"
    case bgra8unormSrgb = "bgra8unorm-srgb"
    case rgb9e5ufloat = "rgb9e5ufloat"
    case rgb10a2uint = "rgb10a2uint"
    case rgb10a2unorm = "rgb10a2unorm"
    case rg11b10ufloat = "rg11b10ufloat"
    case rg32uint = "rg32uint"
    case rg32sint = "rg32sint"
    case rg32float = "rg32float"
    case rgba16uint = "rgba16uint"
    case rgba16sint = "rgba16sint"
    case rgba16float = "rgba16float"
    case rgba32uint = "rgba32uint"
    case rgba32sint = "rgba32sint"
    case rgba32float = "rgba32float"
    case stencil8 = "stencil8"
    case depth16unorm = "depth16unorm"
    case depth24plus = "depth24plus"
    case depth24plusStencil8 = "depth24plus-stencil8"
    case depth32float = "depth32float"
    case depth32floatStencil8 = "depth32float-stencil8"
    case bc1RgbaUnorm = "bc1-rgba-unorm"
    case bc1RgbaUnormSrgb = "bc1-rgba-unorm-srgb"
    case bc2RgbaUnorm = "bc2-rgba-unorm"
    case bc2RgbaUnormSrgb = "bc2-rgba-unorm-srgb"
    case bc3RgbaUnorm = "bc3-rgba-unorm"
    case bc3RgbaUnormSrgb = "bc3-rgba-unorm-srgb"
    case bc4RUnorm = "bc4-r-unorm"
    case bc4RSnorm = "bc4-r-snorm"
    case bc5RgUnorm = "bc5-rg-unorm"
    case bc5RgSnorm = "bc5-rg-snorm"
    case bc6hRgbUfloat = "bc6h-rgb-ufloat"
    case bc6hRgbFloat = "bc6h-rgb-float"
    case bc7RgbaUnorm = "bc7-rgba-unorm"
    case bc7RgbaUnormSrgb = "bc7-rgba-unorm-srgb"
    case etc2Rgb8unorm = "etc2-rgb8unorm"
    case etc2Rgb8unormSrgb = "etc2-rgb8unorm-srgb"
    case etc2Rgb8a1unorm = "etc2-rgb8a1unorm"
    case etc2Rgb8a1unormSrgb = "etc2-rgb8a1unorm-srgb"
    case etc2Rgba8unorm = "etc2-rgba8unorm"
    case etc2Rgba8unormSrgb = "etc2-rgba8unorm-srgb"
    case eacR11unorm = "eac-r11unorm"
    case eacR11snorm = "eac-r11snorm"
    case eacRg11unorm = "eac-rg11unorm"
    case eacRg11snorm = "eac-rg11snorm"
    case astc4x4Unorm = "astc-4x4-unorm"
    case astc4x4UnormSrgb = "astc-4x4-unorm-srgb"
    case astc5x4Unorm = "astc-5x4-unorm"
    case astc5x4UnormSrgb = "astc-5x4-unorm-srgb"
    case astc5x5Unorm = "astc-5x5-unorm"
    case astc5x5UnormSrgb = "astc-5x5-unorm-srgb"
    case astc6x5Unorm = "astc-6x5-unorm"
    case astc6x5UnormSrgb = "astc-6x5-unorm-srgb"
    case astc6x6Unorm = "astc-6x6-unorm"
    case astc6x6UnormSrgb = "astc-6x6-unorm-srgb"
    case astc8x5Unorm = "astc-8x5-unorm"
    case astc8x5UnormSrgb = "astc-8x5-unorm-srgb"
    case astc8x6Unorm = "astc-8x6-unorm"
    case astc8x6UnormSrgb = "astc-8x6-unorm-srgb"
    case astc8x8Unorm = "astc-8x8-unorm"
    case astc8x8UnormSrgb = "astc-8x8-unorm-srgb"
    case astc10x5Unorm = "astc-10x5-unorm"
    case astc10x5UnormSrgb = "astc-10x5-unorm-srgb"
    case astc10x6Unorm = "astc-10x6-unorm"
    case astc10x6UnormSrgb = "astc-10x6-unorm-srgb"
    case astc10x8Unorm = "astc-10x8-unorm"
    case astc10x8UnormSrgb = "astc-10x8-unorm-srgb"
    case astc10x10Unorm = "astc-10x10-unorm"
    case astc10x10UnormSrgb = "astc-10x10-unorm-srgb"
    case astc12x10Unorm = "astc-12x10-unorm"
    case astc12x10UnormSrgb = "astc-12x10-unorm-srgb"
    case astc12x12Unorm = "astc-12x12-unorm"
    case astc12x12UnormSrgb = "astc-12x12-unorm-srgb"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUTextureSampleType: JSString, JSValueCompatible {
    case float = "float"
    case unfilterableFloat = "unfilterable-float"
    case depth = "depth"
    case sint = "sint"
    case uint = "uint"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum GPUTextureUsage {
    @inlinable public static var jsObject: JSObject { JSObject.global[Strings.GPUTextureUsage].object! }

    public static immutable COPY_SRC: GPUFlagsConstant = 0x01

    public static immutable COPY_DST: GPUFlagsConstant = 0x02

    public static immutable TEXTURE_BINDING: GPUFlagsConstant = 0x04

    public static immutable STORAGE_BINDING: GPUFlagsConstant = 0x08

    public static immutable RENDER_ATTACHMENT: GPUFlagsConstant = 0x10
}
public class GPUTextureView: JSBridgedClass, GPUObjectBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.GPUTextureView].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

open class GPUTextureViewDescriptor: GPUObjectDescriptorBase {

    public convenience init(
        label: String? = nil,
        format: GPUTextureFormat? = nil,
        dimension: GPUTextureViewDimension? = nil,
        usage: GPUTextureUsageFlags? = nil,
        aspect: GPUTextureAspect? = nil,
        baseMipLevel: GPUIntegerCoordinate? = nil,
        mipLevelCount: GPUIntegerCoordinate? = nil,
        baseArrayLayer: GPUIntegerCoordinate? = nil,
        arrayLayerCount: GPUIntegerCoordinate? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.label] = _toJSValue(label)
        object[Strings.format] = _toJSValue(format)
        object[Strings.dimension] = _toJSValue(dimension)
        object[Strings.usage] = _toJSValue(usage)
        object[Strings.aspect] = _toJSValue(aspect)
        object[Strings.baseMipLevel] = _toJSValue(baseMipLevel)
        object[Strings.mipLevelCount] = _toJSValue(mipLevelCount)
        object[Strings.baseArrayLayer] = _toJSValue(baseArrayLayer)
        object[Strings.arrayLayerCount] = _toJSValue(arrayLayerCount)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var format: GPUTextureFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var dimension: GPUTextureViewDimension {
        get { jsObject[Strings.dimension].fromJSValue()! }
        set { jsObject[Strings.dimension] = _toJSValue(newValue) }
    }
    @inlinable public var usage: GPUTextureUsageFlags {
        get { jsObject[Strings.usage].fromJSValue()! }
        set { jsObject[Strings.usage] = _toJSValue(newValue) }
    }
    @inlinable public var aspect: GPUTextureAspect {
        get { jsObject[Strings.aspect].fromJSValue()! }
        set { jsObject[Strings.aspect] = _toJSValue(newValue) }
    }
    @inlinable public var baseMipLevel: GPUIntegerCoordinate {
        get { jsObject[Strings.baseMipLevel].fromJSValue()! }
        set { jsObject[Strings.baseMipLevel] = _toJSValue(newValue) }
    }
    @inlinable public var mipLevelCount: GPUIntegerCoordinate {
        get { jsObject[Strings.mipLevelCount].fromJSValue()! }
        set { jsObject[Strings.mipLevelCount] = _toJSValue(newValue) }
    }
    @inlinable public var baseArrayLayer: GPUIntegerCoordinate {
        get { jsObject[Strings.baseArrayLayer].fromJSValue()! }
        set { jsObject[Strings.baseArrayLayer] = _toJSValue(newValue) }
    }
    @inlinable public var arrayLayerCount: GPUIntegerCoordinate {
        get { jsObject[Strings.arrayLayerCount].fromJSValue()! }
        set { jsObject[Strings.arrayLayerCount] = _toJSValue(newValue) }
    }
}
public enum GPUTextureViewDimension: JSString, JSValueCompatible {
    case _1d = "1d"
    case _2d = "2d"
    case _2dArray = "2d-array"
    case cube = "cube"
    case cubeArray = "cube-array"
    case _3d = "3d"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class GPUUncapturedErrorEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.GPUUncapturedErrorEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(type), _toJSValue(gpuUncapturedErrorEventInitDict),
            ])
        )
    }

    @inlinable public var error: GPUError { jsObject[Strings.error].fromJSValue()! }
}

open class GPUUncapturedErrorEventInit: EventInit {

    public convenience init(error: GPUError) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.error] = _toJSValue(error)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var error: GPUError {
        get { jsObject[Strings.error].fromJSValue()! }
        set { jsObject[Strings.error] = _toJSValue(newValue) }
    }
}
public class GPUValidationError: GPUError {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.GPUValidationError].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(message: String) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(message)]))
    }
}

open class GPUVertexAttribute: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(format: GPUVertexFormat, offset: GPUSize64, shaderLocation: GPUIndex32) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.shaderLocation] = _toJSValue(shaderLocation)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var format: GPUVertexFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var offset: GPUSize64 {
        get { jsObject[Strings.offset].fromJSValue()! }
        set { jsObject[Strings.offset] = _toJSValue(newValue) }
    }
    @inlinable public var shaderLocation: GPUIndex32 {
        get { jsObject[Strings.shaderLocation].fromJSValue()! }
        set { jsObject[Strings.shaderLocation] = _toJSValue(newValue) }
    }
}
open class GPUVertexBufferLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        arrayStride: GPUSize64,
        stepMode: GPUVertexStepMode? = nil,
        attributes: [GPUVertexAttribute]
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.arrayStride] = _toJSValue(arrayStride)
        object[Strings.stepMode] = _toJSValue(stepMode)
        object[Strings.attributes] = _toJSValue(attributes)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var arrayStride: GPUSize64 {
        get { jsObject[Strings.arrayStride].fromJSValue()! }
        set { jsObject[Strings.arrayStride] = _toJSValue(newValue) }
    }
    @inlinable public var stepMode: GPUVertexStepMode {
        get { jsObject[Strings.stepMode].fromJSValue()! }
        set { jsObject[Strings.stepMode] = _toJSValue(newValue) }
    }
    @inlinable public var attributes: [GPUVertexAttribute] {
        get { jsObject[Strings.attributes].fromJSValue()! }
        set { jsObject[Strings.attributes] = _toJSValue(newValue) }
    }
}
public enum GPUVertexFormat: JSString, JSValueCompatible {
    case uint8 = "uint8"
    case uint8x2 = "uint8x2"
    case uint8x4 = "uint8x4"
    case sint8 = "sint8"
    case sint8x2 = "sint8x2"
    case sint8x4 = "sint8x4"
    case unorm8 = "unorm8"
    case unorm8x2 = "unorm8x2"
    case unorm8x4 = "unorm8x4"
    case snorm8 = "snorm8"
    case snorm8x2 = "snorm8x2"
    case snorm8x4 = "snorm8x4"
    case uint16 = "uint16"
    case uint16x2 = "uint16x2"
    case uint16x4 = "uint16x4"
    case sint16 = "sint16"
    case sint16x2 = "sint16x2"
    case sint16x4 = "sint16x4"
    case unorm16 = "unorm16"
    case unorm16x2 = "unorm16x2"
    case unorm16x4 = "unorm16x4"
    case snorm16 = "snorm16"
    case snorm16x2 = "snorm16x2"
    case snorm16x4 = "snorm16x4"
    case float16 = "float16"
    case float16x2 = "float16x2"
    case float16x4 = "float16x4"
    case float32 = "float32"
    case float32x2 = "float32x2"
    case float32x3 = "float32x3"
    case float32x4 = "float32x4"
    case uint32 = "uint32"
    case uint32x2 = "uint32x2"
    case uint32x3 = "uint32x3"
    case uint32x4 = "uint32x4"
    case sint32 = "sint32"
    case sint32x2 = "sint32x2"
    case sint32x3 = "sint32x3"
    case sint32x4 = "sint32x4"
    case unorm1010102 = "unorm10-10-10-2"
    case unorm8x4Bgra = "unorm8x4-bgra"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class GPUVertexState: GPUProgrammableStage {

    public convenience init(
        module: GPUShaderModule,
        entryPoint: String? = nil,
        constants: JSObject? = nil,
        buffers: [GPUVertexBufferLayout?]? = nil
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.module] = _toJSValue(module)
        object[Strings.entryPoint] = _toJSValue(entryPoint)
        object[Strings.constants] = _toJSValue(constants)
        object[Strings.buffers] = _toJSValue(buffers)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var buffers: [GPUVertexBufferLayout?] {
        get { jsObject[Strings.buffers].fromJSValue()! }
        set { jsObject[Strings.buffers] = _toJSValue(newValue) }
    }
}
public enum GPUVertexStepMode: JSString, JSValueCompatible {
    case vertex = "vertex"
    case instance = "instance"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return nil
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol NavigatorGPU: JSBridgedClass {}
extension NavigatorGPU { @inlinable public var gpu: GPU { jsObject[Strings.gpu].fromJSValue()! } }
extension Navigator: NavigatorGPU {}

public typealias GPUBufferUsageFlags = UInt32
public typealias GPUMapModeFlags = UInt32
public typealias GPUTextureUsageFlags = UInt32
public typealias GPUShaderStageFlags = UInt32

public typealias GPUPipelineConstantValue = Double
public typealias GPUColorWriteFlags = UInt32

public typealias GPUBufferDynamicOffset = UInt32
public typealias GPUStencilValue = UInt32
public typealias GPUSampleMask = UInt32
public typealias GPUDepthBias = Int32
public typealias GPUSize64 = UInt32
public typealias GPUIntegerCoordinate = UInt32
public typealias GPUIndex32 = UInt32
public typealias GPUSize32 = UInt32
public typealias GPUSignedOffset32 = Int32
public typealias GPUSize64Out = UInt64
public typealias GPUIntegerCoordinateOut = UInt32
public typealias GPUSize32Out = UInt32
public typealias GPUFlagsConstant = UInt32

public class WGSLLanguageFeatures: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.WGSLLanguageFeatures].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    // XXX: make me Set-like!
}

@usableFromInline enum Strings {
    @usableFromInline static immutable _self: JSString = "this"
    @usableFromInline static immutable `GPU`: JSString = "GPU"
    @usableFromInline static immutable `GPUAdapter`: JSString = "GPUAdapter"
    @usableFromInline static immutable `GPUAdapterInfo`: JSString = "GPUAdapterInfo"
    @usableFromInline static immutable `GPUBindGroup`: JSString = "GPUBindGroup"
    @usableFromInline static immutable `GPUBindGroupLayout`: JSString = "GPUBindGroupLayout"
    @usableFromInline static immutable `GPUBuffer`: JSString = "GPUBuffer"
    @usableFromInline static immutable `GPUBufferUsage`: JSString = "GPUBufferUsage"
    @usableFromInline static immutable `GPUCanvasContext`: JSString = "GPUCanvasContext"
    @usableFromInline static immutable `GPUColorWrite`: JSString = "GPUColorWrite"
    @usableFromInline static immutable `GPUCommandBuffer`: JSString = "GPUCommandBuffer"
    @usableFromInline static immutable `GPUCommandEncoder`: JSString = "GPUCommandEncoder"
    @usableFromInline static immutable `GPUCompilationInfo`: JSString = "GPUCompilationInfo"
    @usableFromInline static immutable `GPUCompilationMessage`: JSString = "GPUCompilationMessage"
    @usableFromInline static immutable `GPUComputePassEncoder`: JSString = "GPUComputePassEncoder"
    @usableFromInline static immutable `GPUComputePipeline`: JSString = "GPUComputePipeline"
    @usableFromInline static immutable `GPUDevice`: JSString = "GPUDevice"
    @usableFromInline static immutable `GPUDeviceLostInfo`: JSString = "GPUDeviceLostInfo"
    @usableFromInline static immutable `GPUError`: JSString = "GPUError"
    @usableFromInline static immutable `GPUExternalTexture`: JSString = "GPUExternalTexture"
    @usableFromInline static immutable `GPUInternalError`: JSString = "GPUInternalError"
    @usableFromInline static immutable `GPUMapMode`: JSString = "GPUMapMode"
    @usableFromInline static immutable `GPUOutOfMemoryError`: JSString = "GPUOutOfMemoryError"
    @usableFromInline static immutable `GPUPipelineError`: JSString = "GPUPipelineError"
    @usableFromInline static immutable `GPUPipelineLayout`: JSString = "GPUPipelineLayout"
    @usableFromInline static immutable `GPUQuerySet`: JSString = "GPUQuerySet"
    @usableFromInline static immutable `GPUQueue`: JSString = "GPUQueue"
    @usableFromInline static immutable `GPURenderBundle`: JSString = "GPURenderBundle"
    @usableFromInline static immutable `GPURenderBundleEncoder`: JSString = "GPURenderBundleEncoder"
    @usableFromInline static immutable `GPURenderPassEncoder`: JSString = "GPURenderPassEncoder"
    @usableFromInline static immutable `GPURenderPipeline`: JSString = "GPURenderPipeline"
    @usableFromInline static immutable `GPUSampler`: JSString = "GPUSampler"
    @usableFromInline static immutable `GPUShaderModule`: JSString = "GPUShaderModule"
    @usableFromInline static immutable `GPUShaderStage`: JSString = "GPUShaderStage"
    @usableFromInline static immutable `GPUSupportedFeatures`: JSString = "GPUSupportedFeatures"
    @usableFromInline static immutable `GPUSupportedLimits`: JSString = "GPUSupportedLimits"
    @usableFromInline static immutable `GPUTexture`: JSString = "GPUTexture"
    @usableFromInline static immutable `GPUTextureUsage`: JSString = "GPUTextureUsage"
    @usableFromInline static immutable `GPUTextureView`: JSString = "GPUTextureView"
    @usableFromInline static immutable `GPUUncapturedErrorEvent`: JSString = "GPUUncapturedErrorEvent"
    @usableFromInline static immutable `GPUValidationError`: JSString = "GPUValidationError"
    @usableFromInline static immutable `Object`: JSString = "Object"
    @usableFromInline static immutable `WGSLLanguageFeatures`: JSString = "WGSLLanguageFeatures"
    @usableFromInline static immutable `a`: JSString = "a"
    @usableFromInline static immutable `access`: JSString = "access"
    @usableFromInline static immutable `adapterInfo`: JSString = "adapterInfo"
    @usableFromInline static immutable `addressModeU`: JSString = "addressModeU"
    @usableFromInline static immutable `addressModeV`: JSString = "addressModeV"
    @usableFromInline static immutable `addressModeW`: JSString = "addressModeW"
    @usableFromInline static immutable `alpha`: JSString = "alpha"
    @usableFromInline static immutable `alphaMode`: JSString = "alphaMode"
    @usableFromInline static immutable `alphaToCoverageEnabled`: JSString = "alphaToCoverageEnabled"
    @usableFromInline static immutable `architecture`: JSString = "architecture"
    @usableFromInline static immutable `arrayLayerCount`: JSString = "arrayLayerCount"
    @usableFromInline static immutable `arrayStride`: JSString = "arrayStride"
    @usableFromInline static immutable `aspect`: JSString = "aspect"
    @usableFromInline static immutable `attributes`: JSString = "attributes"
    @usableFromInline static immutable `b`: JSString = "b"
    @usableFromInline static immutable `baseArrayLayer`: JSString = "baseArrayLayer"
    @usableFromInline static immutable `baseMipLevel`: JSString = "baseMipLevel"
    @usableFromInline static immutable `beginComputePass`: JSString = "beginComputePass"
    @usableFromInline static immutable `beginOcclusionQuery`: JSString = "beginOcclusionQuery"
    @usableFromInline static immutable `beginRenderPass`: JSString = "beginRenderPass"
    @usableFromInline static immutable `beginningOfPassWriteIndex`: JSString = "beginningOfPassWriteIndex"
    @usableFromInline static immutable `bindGroupLayouts`: JSString = "bindGroupLayouts"
    @usableFromInline static immutable `binding`: JSString = "binding"
    @usableFromInline static immutable `blend`: JSString = "blend"
    @usableFromInline static immutable `buffer`: JSString = "buffer"
    @usableFromInline static immutable `buffers`: JSString = "buffers"
    @usableFromInline static immutable `bytesPerRow`: JSString = "bytesPerRow"
    @usableFromInline static immutable `canvas`: JSString = "canvas"
    @usableFromInline static immutable `clearBuffer`: JSString = "clearBuffer"
    @usableFromInline static immutable `clearValue`: JSString = "clearValue"
    @usableFromInline static immutable `code`: JSString = "code"
    @usableFromInline static immutable `color`: JSString = "color"
    @usableFromInline static immutable `colorAttachments`: JSString = "colorAttachments"
    @usableFromInline static immutable `colorFormats`: JSString = "colorFormats"
    @usableFromInline static immutable `colorSpace`: JSString = "colorSpace"
    @usableFromInline static immutable `compare`: JSString = "compare"
    @usableFromInline static immutable `compilationHints`: JSString = "compilationHints"
    @usableFromInline static immutable `compute`: JSString = "compute"
    @usableFromInline static immutable `configure`: JSString = "configure"
    @usableFromInline static immutable `constants`: JSString = "constants"
    @usableFromInline static immutable `copyBufferToBuffer`: JSString = "copyBufferToBuffer"
    @usableFromInline static immutable `copyBufferToTexture`: JSString = "copyBufferToTexture"
    @usableFromInline static immutable `copyExternalImageToTexture`: JSString = "copyExternalImageToTexture"
    @usableFromInline static immutable `copyTextureToBuffer`: JSString = "copyTextureToBuffer"
    @usableFromInline static immutable `copyTextureToTexture`: JSString = "copyTextureToTexture"
    @usableFromInline static immutable `count`: JSString = "count"
    @usableFromInline static immutable `createBindGroup`: JSString = "createBindGroup"
    @usableFromInline static immutable `createBindGroupLayout`: JSString = "createBindGroupLayout"
    @usableFromInline static immutable `createBuffer`: JSString = "createBuffer"
    @usableFromInline static immutable `createCommandEncoder`: JSString = "createCommandEncoder"
    @usableFromInline static immutable `createComputePipeline`: JSString = "createComputePipeline"
    @usableFromInline static immutable `createComputePipelineAsync`: JSString = "createComputePipelineAsync"
    @usableFromInline static immutable `createPipelineLayout`: JSString = "createPipelineLayout"
    @usableFromInline static immutable `createQuerySet`: JSString = "createQuerySet"
    @usableFromInline static immutable `createRenderBundleEncoder`: JSString = "createRenderBundleEncoder"
    @usableFromInline static immutable `createRenderPipeline`: JSString = "createRenderPipeline"
    @usableFromInline static immutable `createRenderPipelineAsync`: JSString = "createRenderPipelineAsync"
    @usableFromInline static immutable `createSampler`: JSString = "createSampler"
    @usableFromInline static immutable `createShaderModule`: JSString = "createShaderModule"
    @usableFromInline static immutable `createTexture`: JSString = "createTexture"
    @usableFromInline static immutable `createView`: JSString = "createView"
    @usableFromInline static immutable `cullMode`: JSString = "cullMode"
    @usableFromInline static immutable `defaultQueue`: JSString = "defaultQueue"
    @usableFromInline static immutable `depthBias`: JSString = "depthBias"
    @usableFromInline static immutable `depthBiasClamp`: JSString = "depthBiasClamp"
    @usableFromInline static immutable `depthBiasSlopeScale`: JSString = "depthBiasSlopeScale"
    @usableFromInline static immutable `depthClearValue`: JSString = "depthClearValue"
    @usableFromInline static immutable `depthCompare`: JSString = "depthCompare"
    @usableFromInline static immutable `depthFailOp`: JSString = "depthFailOp"
    @usableFromInline static immutable `depthLoadOp`: JSString = "depthLoadOp"
    @usableFromInline static immutable `depthOrArrayLayers`: JSString = "depthOrArrayLayers"
    @usableFromInline static immutable `depthReadOnly`: JSString = "depthReadOnly"
    @usableFromInline static immutable `depthSlice`: JSString = "depthSlice"
    @usableFromInline static immutable `depthStencil`: JSString = "depthStencil"
    @usableFromInline static immutable `depthStencilAttachment`: JSString = "depthStencilAttachment"
    @usableFromInline static immutable `depthStencilFormat`: JSString = "depthStencilFormat"
    @usableFromInline static immutable `depthStoreOp`: JSString = "depthStoreOp"
    @usableFromInline static immutable `depthWriteEnabled`: JSString = "depthWriteEnabled"
    @usableFromInline static immutable `description`: JSString = "description"
    @usableFromInline static immutable `destroy`: JSString = "destroy"
    @usableFromInline static immutable `device`: JSString = "device"
    @usableFromInline static immutable `dimension`: JSString = "dimension"
    @usableFromInline static immutable `dispatchWorkgroups`: JSString = "dispatchWorkgroups"
    @usableFromInline static immutable `dispatchWorkgroupsIndirect`: JSString = "dispatchWorkgroupsIndirect"
    @usableFromInline static immutable `draw`: JSString = "draw"
    @usableFromInline static immutable `drawIndexed`: JSString = "drawIndexed"
    @usableFromInline static immutable `drawIndexedIndirect`: JSString = "drawIndexedIndirect"
    @usableFromInline static immutable `drawIndirect`: JSString = "drawIndirect"
    @usableFromInline static immutable `dstFactor`: JSString = "dstFactor"
    @usableFromInline static immutable `end`: JSString = "end"
    @usableFromInline static immutable `endOcclusionQuery`: JSString = "endOcclusionQuery"
    @usableFromInline static immutable `endOfPassWriteIndex`: JSString = "endOfPassWriteIndex"
    @usableFromInline static immutable `entries`: JSString = "entries"
    @usableFromInline static immutable `entryPoint`: JSString = "entryPoint"
    @usableFromInline static immutable `error`: JSString = "error"
    @usableFromInline static immutable `executeBundles`: JSString = "executeBundles"
    @usableFromInline static immutable `externalTexture`: JSString = "externalTexture"
    @usableFromInline static immutable `failOp`: JSString = "failOp"
    @usableFromInline static immutable `featureLevel`: JSString = "featureLevel"
    @usableFromInline static immutable `features`: JSString = "features"
    @usableFromInline static immutable `finish`: JSString = "finish"
    @usableFromInline static immutable `flipY`: JSString = "flipY"
    @usableFromInline static immutable `forceFallbackAdapter`: JSString = "forceFallbackAdapter"
    @usableFromInline static immutable `format`: JSString = "format"
    @usableFromInline static immutable `fragment`: JSString = "fragment"
    @usableFromInline static immutable `frontFace`: JSString = "frontFace"
    @usableFromInline static immutable `g`: JSString = "g"
    @usableFromInline static immutable `getBindGroupLayout`: JSString = "getBindGroupLayout"
    @usableFromInline static immutable `getCompilationInfo`: JSString = "getCompilationInfo"
    @usableFromInline static immutable `getConfiguration`: JSString = "getConfiguration"
    @usableFromInline static immutable `getCurrentTexture`: JSString = "getCurrentTexture"
    @usableFromInline static immutable `getMappedRange`: JSString = "getMappedRange"
    @usableFromInline static immutable `getPreferredCanvasFormat`: JSString = "getPreferredCanvasFormat"
    @usableFromInline static immutable `gpu`: JSString = "gpu"
    @usableFromInline static immutable `hasDynamicOffset`: JSString = "hasDynamicOffset"
    @usableFromInline static immutable `height`: JSString = "height"
    @usableFromInline static immutable `importExternalTexture`: JSString = "importExternalTexture"
    @usableFromInline static immutable `info`: JSString = "info"
    @usableFromInline static immutable `insertDebugMarker`: JSString = "insertDebugMarker"
    @usableFromInline static immutable `isFallbackAdapter`: JSString = "isFallbackAdapter"
    @usableFromInline static immutable `label`: JSString = "label"
    @usableFromInline static immutable `layout`: JSString = "layout"
    @usableFromInline static immutable `length`: JSString = "length"
    @usableFromInline static immutable `limits`: JSString = "limits"
    @usableFromInline static immutable `lineNum`: JSString = "lineNum"
    @usableFromInline static immutable `linePos`: JSString = "linePos"
    @usableFromInline static immutable `loadOp`: JSString = "loadOp"
    @usableFromInline static immutable `lodMaxClamp`: JSString = "lodMaxClamp"
    @usableFromInline static immutable `lodMinClamp`: JSString = "lodMinClamp"
    @usableFromInline static immutable `lost`: JSString = "lost"
    @usableFromInline static immutable `magFilter`: JSString = "magFilter"
    @usableFromInline static immutable `mapAsync`: JSString = "mapAsync"
    @usableFromInline static immutable `mapState`: JSString = "mapState"
    @usableFromInline static immutable `mappedAtCreation`: JSString = "mappedAtCreation"
    @usableFromInline static immutable `mask`: JSString = "mask"
    @usableFromInline static immutable `maxAnisotropy`: JSString = "maxAnisotropy"
    @usableFromInline static immutable `maxBindGroups`: JSString = "maxBindGroups"
    @usableFromInline static immutable `maxBindGroupsPlusVertexBuffers`: JSString = "maxBindGroupsPlusVertexBuffers"
    @usableFromInline static immutable `maxBindingsPerBindGroup`: JSString = "maxBindingsPerBindGroup"
    @usableFromInline static immutable `maxBufferSize`: JSString = "maxBufferSize"
    @usableFromInline static immutable `maxColorAttachmentBytesPerSample`: JSString = "maxColorAttachmentBytesPerSample"
    @usableFromInline static immutable `maxColorAttachments`: JSString = "maxColorAttachments"
    @usableFromInline static immutable `maxComputeInvocationsPerWorkgroup`: JSString = "maxComputeInvocationsPerWorkgroup"
    @usableFromInline static immutable `maxComputeWorkgroupSizeX`: JSString = "maxComputeWorkgroupSizeX"
    @usableFromInline static immutable `maxComputeWorkgroupSizeY`: JSString = "maxComputeWorkgroupSizeY"
    @usableFromInline static immutable `maxComputeWorkgroupSizeZ`: JSString = "maxComputeWorkgroupSizeZ"
    @usableFromInline static immutable `maxComputeWorkgroupStorageSize`: JSString = "maxComputeWorkgroupStorageSize"
    @usableFromInline static immutable `maxComputeWorkgroupsPerDimension`: JSString = "maxComputeWorkgroupsPerDimension"
    @usableFromInline static immutable `maxDrawCount`: JSString = "maxDrawCount"
    @usableFromInline static immutable `maxDynamicStorageBuffersPerPipelineLayout`: JSString =
        "maxDynamicStorageBuffersPerPipelineLayout"
    @usableFromInline static immutable `maxDynamicUniformBuffersPerPipelineLayout`: JSString =
        "maxDynamicUniformBuffersPerPipelineLayout"
    @usableFromInline static immutable `maxInterStageShaderVariables`: JSString = "maxInterStageShaderVariables"
    @usableFromInline static immutable `maxSampledTexturesPerShaderStage`: JSString = "maxSampledTexturesPerShaderStage"
    @usableFromInline static immutable `maxSamplersPerShaderStage`: JSString = "maxSamplersPerShaderStage"
    @usableFromInline static immutable `maxStorageBufferBindingSize`: JSString = "maxStorageBufferBindingSize"
    @usableFromInline static immutable `maxStorageBuffersPerShaderStage`: JSString = "maxStorageBuffersPerShaderStage"
    @usableFromInline static immutable `maxStorageTexturesPerShaderStage`: JSString = "maxStorageTexturesPerShaderStage"
    @usableFromInline static immutable `maxTextureArrayLayers`: JSString = "maxTextureArrayLayers"
    @usableFromInline static immutable `maxTextureDimension1D`: JSString = "maxTextureDimension1D"
    @usableFromInline static immutable `maxTextureDimension2D`: JSString = "maxTextureDimension2D"
    @usableFromInline static immutable `maxTextureDimension3D`: JSString = "maxTextureDimension3D"
    @usableFromInline static immutable `maxUniformBufferBindingSize`: JSString = "maxUniformBufferBindingSize"
    @usableFromInline static immutable `maxUniformBuffersPerShaderStage`: JSString = "maxUniformBuffersPerShaderStage"
    @usableFromInline static immutable `maxVertexAttributes`: JSString = "maxVertexAttributes"
    @usableFromInline static immutable `maxVertexBufferArrayStride`: JSString = "maxVertexBufferArrayStride"
    @usableFromInline static immutable `maxVertexBuffers`: JSString = "maxVertexBuffers"
    @usableFromInline static immutable `message`: JSString = "message"
    @usableFromInline static immutable `messages`: JSString = "messages"
    @usableFromInline static immutable `minBindingSize`: JSString = "minBindingSize"
    @usableFromInline static immutable `minFilter`: JSString = "minFilter"
    @usableFromInline static immutable `minStorageBufferOffsetAlignment`: JSString = "minStorageBufferOffsetAlignment"
    @usableFromInline static immutable `minUniformBufferOffsetAlignment`: JSString = "minUniformBufferOffsetAlignment"
    @usableFromInline static immutable `mipLevel`: JSString = "mipLevel"
    @usableFromInline static immutable `mipLevelCount`: JSString = "mipLevelCount"
    @usableFromInline static immutable `mipmapFilter`: JSString = "mipmapFilter"
    @usableFromInline static immutable `mode`: JSString = "mode"
    @usableFromInline static immutable `module`: JSString = "module"
    @usableFromInline static immutable `multisample`: JSString = "multisample"
    @usableFromInline static immutable `multisampled`: JSString = "multisampled"
    @usableFromInline static immutable `occlusionQuerySet`: JSString = "occlusionQuerySet"
    @usableFromInline static immutable `offset`: JSString = "offset"
    @usableFromInline static immutable `onSubmittedWorkDone`: JSString = "onSubmittedWorkDone"
    @usableFromInline static immutable `onuncapturederror`: JSString = "onuncapturederror"
    @usableFromInline static immutable `operation`: JSString = "operation"
    @usableFromInline static immutable `origin`: JSString = "origin"
    @usableFromInline static immutable `passOp`: JSString = "passOp"
    @usableFromInline static immutable `popDebugGroup`: JSString = "popDebugGroup"
    @usableFromInline static immutable `popErrorScope`: JSString = "popErrorScope"
    @usableFromInline static immutable `powerPreference`: JSString = "powerPreference"
    @usableFromInline static immutable `premultipliedAlpha`: JSString = "premultipliedAlpha"
    @usableFromInline static immutable `primitive`: JSString = "primitive"
    @usableFromInline static immutable `pushDebugGroup`: JSString = "pushDebugGroup"
    @usableFromInline static immutable `pushErrorScope`: JSString = "pushErrorScope"
    @usableFromInline static immutable `querySet`: JSString = "querySet"
    @usableFromInline static immutable `queue`: JSString = "queue"
    @usableFromInline static immutable `r`: JSString = "r"
    @usableFromInline static immutable `reason`: JSString = "reason"
    @usableFromInline static immutable `requestAdapter`: JSString = "requestAdapter"
    @usableFromInline static immutable `requestDevice`: JSString = "requestDevice"
    @usableFromInline static immutable `requiredFeatures`: JSString = "requiredFeatures"
    @usableFromInline static immutable `requiredLimits`: JSString = "requiredLimits"
    @usableFromInline static immutable `resolveQuerySet`: JSString = "resolveQuerySet"
    @usableFromInline static immutable `resolveTarget`: JSString = "resolveTarget"
    @usableFromInline static immutable `resource`: JSString = "resource"
    @usableFromInline static immutable `rowsPerImage`: JSString = "rowsPerImage"
    @usableFromInline static immutable `sampleCount`: JSString = "sampleCount"
    @usableFromInline static immutable `sampleType`: JSString = "sampleType"
    @usableFromInline static immutable `sampler`: JSString = "sampler"
    @usableFromInline static immutable `setBindGroup`: JSString = "setBindGroup"
    @usableFromInline static immutable `setBlendConstant`: JSString = "setBlendConstant"
    @usableFromInline static immutable `setIndexBuffer`: JSString = "setIndexBuffer"
    @usableFromInline static immutable `setPipeline`: JSString = "setPipeline"
    @usableFromInline static immutable `setScissorRect`: JSString = "setScissorRect"
    @usableFromInline static immutable `setStencilReference`: JSString = "setStencilReference"
    @usableFromInline static immutable `setVertexBuffer`: JSString = "setVertexBuffer"
    @usableFromInline static immutable `setViewport`: JSString = "setViewport"
    @usableFromInline static immutable `shaderLocation`: JSString = "shaderLocation"
    @usableFromInline static immutable `size`: JSString = "size"
    @usableFromInline static immutable `source`: JSString = "source"
    @usableFromInline static immutable `srcFactor`: JSString = "srcFactor"
    @usableFromInline static immutable `stencilBack`: JSString = "stencilBack"
    @usableFromInline static immutable `stencilClearValue`: JSString = "stencilClearValue"
    @usableFromInline static immutable `stencilFront`: JSString = "stencilFront"
    @usableFromInline static immutable `stencilLoadOp`: JSString = "stencilLoadOp"
    @usableFromInline static immutable `stencilReadMask`: JSString = "stencilReadMask"
    @usableFromInline static immutable `stencilReadOnly`: JSString = "stencilReadOnly"
    @usableFromInline static immutable `stencilStoreOp`: JSString = "stencilStoreOp"
    @usableFromInline static immutable `stencilWriteMask`: JSString = "stencilWriteMask"
    @usableFromInline static immutable `stepMode`: JSString = "stepMode"
    @usableFromInline static immutable `storageTexture`: JSString = "storageTexture"
    @usableFromInline static immutable `storeOp`: JSString = "storeOp"
    @usableFromInline static immutable `stripIndexFormat`: JSString = "stripIndexFormat"
    @usableFromInline static immutable `subgroupMaxSize`: JSString = "subgroupMaxSize"
    @usableFromInline static immutable `subgroupMinSize`: JSString = "subgroupMinSize"
    @usableFromInline static immutable `submit`: JSString = "submit"
    @usableFromInline static immutable `targets`: JSString = "targets"
    @usableFromInline static immutable `texture`: JSString = "texture"
    @usableFromInline static immutable `timestampWrites`: JSString = "timestampWrites"
    @usableFromInline static immutable `toString`: JSString = "toString"
    @usableFromInline static immutable `toneMapping`: JSString = "toneMapping"
    @usableFromInline static immutable `topology`: JSString = "topology"
    @usableFromInline static immutable `type`: JSString = "type"
    @usableFromInline static immutable `unclippedDepth`: JSString = "unclippedDepth"
    @usableFromInline static immutable `unconfigure`: JSString = "unconfigure"
    @usableFromInline static immutable `unmap`: JSString = "unmap"
    @usableFromInline static immutable `usage`: JSString = "usage"
    @usableFromInline static immutable `vendor`: JSString = "vendor"
    @usableFromInline static immutable `vertex`: JSString = "vertex"
    @usableFromInline static immutable `view`: JSString = "view"
    @usableFromInline static immutable `viewDimension`: JSString = "viewDimension"
    @usableFromInline static immutable `viewFormats`: JSString = "viewFormats"
    @usableFromInline static immutable `visibility`: JSString = "visibility"
    @usableFromInline static immutable `wgslLanguageFeatures`: JSString = "wgslLanguageFeatures"
    @usableFromInline static immutable `width`: JSString = "width"
    @usableFromInline static immutable `writeBuffer`: JSString = "writeBuffer"
    @usableFromInline static immutable `writeMask`: JSString = "writeMask"
    @usableFromInline static immutable `writeTexture`: JSString = "writeTexture"
    @usableFromInline static immutable `x`: JSString = "x"
    @usableFromInline static immutable `xrCompatible`: JSString = "xrCompatible"
    @usableFromInline static immutable `y`: JSString = "y"
    @usableFromInline static immutable `z`: JSString = "z"
}
public protocol Any_GPUAutoLayoutMode_or_GPUPipelineLayout: ConvertibleToJSValue {}
extension GPUAutoLayoutMode: Any_GPUAutoLayoutMode_or_GPUPipelineLayout {}
extension GPUPipelineLayout: Any_GPUAutoLayoutMode_or_GPUPipelineLayout {}

public enum GPUAutoLayoutMode_or_GPUPipelineLayout: JSValueCompatible, Any_GPUAutoLayoutMode_or_GPUPipelineLayout {
    case gpuAutoLayoutMode(GPUAutoLayoutMode)
    case gpuPipelineLayout(GPUPipelineLayout)

    public init(_ gpuAutoLayoutMode: GPUAutoLayoutMode) {
        immutable val: GPUAutoLayoutMode_or_GPUPipelineLayout = .gpuAutoLayoutMode(gpuAutoLayoutMode)
        this = val
    }
    public init(_ gpuPipelineLayout: GPUPipelineLayout) {
        immutable val: GPUAutoLayoutMode_or_GPUPipelineLayout = .gpuPipelineLayout(gpuPipelineLayout)
        this = val
    }

    public var gpuAutoLayoutMode: GPUAutoLayoutMode? {
        switch this {
        case immutable .gpuAutoLayoutMode(gpuAutoLayoutMode): return gpuAutoLayoutMode
        default: return nil
        }
    }
    public var gpuPipelineLayout: GPUPipelineLayout? {
        switch this {
        case immutable .gpuPipelineLayout(gpuPipelineLayout): return gpuPipelineLayout
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable gpuAutoLayoutMode: GPUAutoLayoutMode = value.fromJSValue() {
            return .gpuAutoLayoutMode(gpuAutoLayoutMode)
        }
        if immutable gpuPipelineLayout: GPUPipelineLayout = value.fromJSValue() {
            return .gpuPipelineLayout(gpuPipelineLayout)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .gpuAutoLayoutMode(gpuAutoLayoutMode): return gpuAutoLayoutMode.jsValue
        case immutable .gpuPipelineLayout(gpuPipelineLayout): return gpuPipelineLayout.jsValue
        }
    }
}
public protocol Any_GPUBindingResource: ConvertibleToJSValue {}
extension GPUBufferBinding: Any_GPUBindingResource {}
extension GPUExternalTexture: Any_GPUBindingResource {}
extension GPUSampler: Any_GPUBindingResource {}
extension GPUTextureView: Any_GPUBindingResource {}

public enum GPUBindingResource: JSValueCompatible, Any_GPUBindingResource {
    case gpuBufferBinding(GPUBufferBinding)
    case gpuExternalTexture(GPUExternalTexture)
    case gpuSampler(GPUSampler)
    case gpuTextureView(GPUTextureView)

    public init(_ gpuBufferBinding: GPUBufferBinding) {
        immutable val: GPUBindingResource = .gpuBufferBinding(gpuBufferBinding)
        this = val
    }
    public init(_ gpuExternalTexture: GPUExternalTexture) {
        immutable val: GPUBindingResource = .gpuExternalTexture(gpuExternalTexture)
        this = val
    }
    public init(_ gpuSampler: GPUSampler) {
        immutable val: GPUBindingResource = .gpuSampler(gpuSampler)
        this = val
    }
    public init(_ gpuTextureView: GPUTextureView) {
        immutable val: GPUBindingResource = .gpuTextureView(gpuTextureView)
        this = val
    }

    public var gpuBufferBinding: GPUBufferBinding? {
        switch this {
        case immutable .gpuBufferBinding(gpuBufferBinding): return gpuBufferBinding
        default: return nil
        }
    }
    public var gpuExternalTexture: GPUExternalTexture? {
        switch this {
        case immutable .gpuExternalTexture(gpuExternalTexture): return gpuExternalTexture
        default: return nil
        }
    }
    public var gpuSampler: GPUSampler? {
        switch this {
        case immutable .gpuSampler(gpuSampler): return gpuSampler
        default: return nil
        }
    }
    public var gpuTextureView: GPUTextureView? {
        switch this {
        case immutable .gpuTextureView(gpuTextureView): return gpuTextureView
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable gpuBufferBinding: GPUBufferBinding = value.fromJSValue() { return .gpuBufferBinding(gpuBufferBinding) }
        if immutable gpuExternalTexture: GPUExternalTexture = value.fromJSValue() {
            return .gpuExternalTexture(gpuExternalTexture)
        }
        if immutable gpuSampler: GPUSampler = value.fromJSValue() { return .gpuSampler(gpuSampler) }
        if immutable gpuTextureView: GPUTextureView = value.fromJSValue() { return .gpuTextureView(gpuTextureView) }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .gpuBufferBinding(gpuBufferBinding): return gpuBufferBinding.jsValue
        case immutable .gpuExternalTexture(gpuExternalTexture): return gpuExternalTexture.jsValue
        case immutable .gpuSampler(gpuSampler): return gpuSampler.jsValue
        case immutable .gpuTextureView(gpuTextureView): return gpuTextureView.jsValue
        }
    }
}
public protocol Any_GPUColor: ConvertibleToJSValue {}
extension GPUColorDict: Any_GPUColor {}
extension Array: Any_GPUColor where Element == Double {}

public enum GPUColor: JSValueCompatible, Any_GPUColor {
    case gpuColorDict(GPUColorDict)
    case seq_of_Double([Double])

    public init(_ gpuColorDict: GPUColorDict) {
        immutable val: GPUColor = .gpuColorDict(gpuColorDict)
        this = val
    }
    public init(_ seq_of_Double: [Double]) {
        immutable val: GPUColor = .seq_of_Double(seq_of_Double)
        this = val
    }

    public var gpuColorDict: GPUColorDict? {
        switch this {
        case immutable .gpuColorDict(gpuColorDict): return gpuColorDict
        default: return nil
        }
    }
    public var seq_of_Double: [Double]? {
        switch this {
        case immutable .seq_of_Double(seq_of_Double): return seq_of_Double
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable gpuColorDict: GPUColorDict = value.fromJSValue() { return .gpuColorDict(gpuColorDict) }
        if immutable seq_of_Double: [Double] = value.fromJSValue() { return .seq_of_Double(seq_of_Double) }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .gpuColorDict(gpuColorDict): return gpuColorDict.jsValue
        case immutable .seq_of_Double(seq_of_Double): return seq_of_Double.jsValue
        }
    }
}
public protocol Any_GPUCopyExternalImageSource: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_GPUCopyExternalImageSource {}
extension HTMLImageElement: Any_GPUCopyExternalImageSource {}
extension HTMLVideoElement: Any_GPUCopyExternalImageSource {}
extension ImageBitmap: Any_GPUCopyExternalImageSource {}
extension ImageData: Any_GPUCopyExternalImageSource {}
extension OffscreenCanvas: Any_GPUCopyExternalImageSource {}
extension VideoFrame: Any_GPUCopyExternalImageSource {}

public enum GPUCopyExternalImageSource: JSValueCompatible, Any_GPUCopyExternalImageSource {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlImageElement(HTMLImageElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case imageData(ImageData)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    public init(_ htmlCanvasElement: HTMLCanvasElement) {
        immutable val: GPUCopyExternalImageSource = .htmlCanvasElement(htmlCanvasElement)
        this = val
    }
    public init(_ htmlImageElement: HTMLImageElement) {
        immutable val: GPUCopyExternalImageSource = .htmlImageElement(htmlImageElement)
        this = val
    }
    public init(_ htmlVideoElement: HTMLVideoElement) {
        immutable val: GPUCopyExternalImageSource = .htmlVideoElement(htmlVideoElement)
        this = val
    }
    public init(_ imageBitmap: ImageBitmap) {
        immutable val: GPUCopyExternalImageSource = .imageBitmap(imageBitmap)
        this = val
    }
    public init(_ imageData: ImageData) {
        immutable val: GPUCopyExternalImageSource = .imageData(imageData)
        this = val
    }
    public init(_ offscreenCanvas: OffscreenCanvas) {
        immutable val: GPUCopyExternalImageSource = .offscreenCanvas(offscreenCanvas)
        this = val
    }
    public init(_ videoFrame: VideoFrame) {
        immutable val: GPUCopyExternalImageSource = .videoFrame(videoFrame)
        this = val
    }

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }
    public var htmlImageElement: HTMLImageElement? {
        switch this {
        case immutable .htmlImageElement(htmlImageElement): return htmlImageElement
        default: return nil
        }
    }
    public var htmlVideoElement: HTMLVideoElement? {
        switch this {
        case immutable .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }
    public var imageBitmap: ImageBitmap? {
        switch this {
        case immutable .imageBitmap(imageBitmap): return imageBitmap
        default: return nil
        }
    }
    public var imageData: ImageData? {
        switch this {
        case immutable .imageData(imageData): return imageData
        default: return nil
        }
    }
    public var offscreenCanvas: OffscreenCanvas? {
        switch this {
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }
    public var videoFrame: VideoFrame? {
        switch this {
        case immutable .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if immutable htmlImageElement: HTMLImageElement = value.fromJSValue() { return .htmlImageElement(htmlImageElement) }
        if immutable htmlVideoElement: HTMLVideoElement = value.fromJSValue() { return .htmlVideoElement(htmlVideoElement) }
        if immutable imageBitmap: ImageBitmap = value.fromJSValue() { return .imageBitmap(imageBitmap) }
        if immutable imageData: ImageData = value.fromJSValue() { return .imageData(imageData) }
        if immutable offscreenCanvas: OffscreenCanvas = value.fromJSValue() { return .offscreenCanvas(offscreenCanvas) }
        if immutable videoFrame: VideoFrame = value.fromJSValue() { return .videoFrame(videoFrame) }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement.jsValue
        case immutable .htmlImageElement(htmlImageElement): return htmlImageElement.jsValue
        case immutable .htmlVideoElement(htmlVideoElement): return htmlVideoElement.jsValue
        case immutable .imageBitmap(imageBitmap): return imageBitmap.jsValue
        case immutable .imageData(imageData): return imageData.jsValue
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas.jsValue
        case immutable .videoFrame(videoFrame): return videoFrame.jsValue
        }
    }
}
public protocol Any_GPUExtent3D: ConvertibleToJSValue {}
extension GPUExtent3DDict: Any_GPUExtent3D {}
extension Array: Any_GPUExtent3D where Element == GPUIntegerCoordinate {}

public enum GPUExtent3D: JSValueCompatible, Any_GPUExtent3D {
    case gpuExtent3DDict(GPUExtent3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public init(_ gpuExtent3DDict: GPUExtent3DDict) {
        immutable val: GPUExtent3D = .gpuExtent3DDict(gpuExtent3DDict)
        this = val
    }
    public init(_ seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]) {
        immutable val: GPUExtent3D = .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        this = val
    }

    public var gpuExtent3DDict: GPUExtent3DDict? {
        switch this {
        case immutable .gpuExtent3DDict(gpuExtent3DDict): return gpuExtent3DDict
        default: return nil
        }
    }
    public var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch this {
        case immutable .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable gpuExtent3DDict: GPUExtent3DDict = value.fromJSValue() { return .gpuExtent3DDict(gpuExtent3DDict) }
        if immutable seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .gpuExtent3DDict(gpuExtent3DDict): return gpuExtent3DDict.jsValue
        case immutable .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}
public protocol Any_GPUOrigin2D: ConvertibleToJSValue {}
extension GPUOrigin2DDict: Any_GPUOrigin2D {}
extension Array: Any_GPUOrigin2D where Element == GPUIntegerCoordinate {}

public enum GPUOrigin2D: JSValueCompatible, Any_GPUOrigin2D {
    case gpuOrigin2DDict(GPUOrigin2DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public init(_ gpuOrigin2DDict: GPUOrigin2DDict) {
        immutable val: GPUOrigin2D = .gpuOrigin2DDict(gpuOrigin2DDict)
        this = val
    }
    public init(_ seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]) {
        immutable val: GPUOrigin2D = .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        this = val
    }

    public var gpuOrigin2DDict: GPUOrigin2DDict? {
        switch this {
        case immutable .gpuOrigin2DDict(gpuOrigin2DDict): return gpuOrigin2DDict
        default: return nil
        }
    }
    public var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch this {
        case immutable .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable gpuOrigin2DDict: GPUOrigin2DDict = value.fromJSValue() { return .gpuOrigin2DDict(gpuOrigin2DDict) }
        if immutable seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .gpuOrigin2DDict(gpuOrigin2DDict): return gpuOrigin2DDict.jsValue
        case immutable .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}
public protocol Any_GPUOrigin3D: ConvertibleToJSValue {}
extension GPUOrigin3DDict: Any_GPUOrigin3D {}
extension Array: Any_GPUOrigin3D where Element == GPUIntegerCoordinate {}

public enum GPUOrigin3D: JSValueCompatible, Any_GPUOrigin3D {
    case gpuOrigin3DDict(GPUOrigin3DDict)
    case seq_of_GPUIntegerCoordinate([GPUIntegerCoordinate])

    public init(_ gpuOrigin3DDict: GPUOrigin3DDict) {
        immutable val: GPUOrigin3D = .gpuOrigin3DDict(gpuOrigin3DDict)
        this = val
    }
    public init(_ seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]) {
        immutable val: GPUOrigin3D = .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        this = val
    }

    public var gpuOrigin3DDict: GPUOrigin3DDict? {
        switch this {
        case immutable .gpuOrigin3DDict(gpuOrigin3DDict): return gpuOrigin3DDict
        default: return nil
        }
    }
    public var seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate]? {
        switch this {
        case immutable .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable gpuOrigin3DDict: GPUOrigin3DDict = value.fromJSValue() { return .gpuOrigin3DDict(gpuOrigin3DDict) }
        if immutable seq_of_GPUIntegerCoordinate: [GPUIntegerCoordinate] = value.fromJSValue() {
            return .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate)
        }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .gpuOrigin3DDict(gpuOrigin3DDict): return gpuOrigin3DDict.jsValue
        case immutable .seq_of_GPUIntegerCoordinate(seq_of_GPUIntegerCoordinate): return seq_of_GPUIntegerCoordinate.jsValue
        }
    }
}
public protocol Any_HTMLCanvasElement_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case offscreenCanvas(OffscreenCanvas)

    public init(_ htmlCanvasElement: HTMLCanvasElement) {
        immutable val: HTMLCanvasElement_or_OffscreenCanvas = .htmlCanvasElement(htmlCanvasElement)
        this = val
    }
    public init(_ offscreenCanvas: OffscreenCanvas) {
        immutable val: HTMLCanvasElement_or_OffscreenCanvas = .offscreenCanvas(offscreenCanvas)
        this = val
    }

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return nil
        }
    }
    public var offscreenCanvas: OffscreenCanvas? {
        switch this {
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if immutable offscreenCanvas: OffscreenCanvas = value.fromJSValue() { return .offscreenCanvas(offscreenCanvas) }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement.jsValue
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas.jsValue
        }
    }
}
public protocol Any_HTMLVideoElement_or_VideoFrame: ConvertibleToJSValue {}
extension HTMLVideoElement: Any_HTMLVideoElement_or_VideoFrame {}
extension VideoFrame: Any_HTMLVideoElement_or_VideoFrame {}

public enum HTMLVideoElement_or_VideoFrame: JSValueCompatible, Any_HTMLVideoElement_or_VideoFrame {
    case htmlVideoElement(HTMLVideoElement)
    case videoFrame(VideoFrame)

    public init(_ htmlVideoElement: HTMLVideoElement) {
        immutable val: HTMLVideoElement_or_VideoFrame = .htmlVideoElement(htmlVideoElement)
        this = val
    }
    public init(_ videoFrame: VideoFrame) {
        immutable val: HTMLVideoElement_or_VideoFrame = .videoFrame(videoFrame)
        this = val
    }

    public var htmlVideoElement: HTMLVideoElement? {
        switch this {
        case immutable .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return nil
        }
    }
    public var videoFrame: VideoFrame? {
        switch this {
        case immutable .videoFrame(videoFrame): return videoFrame
        default: return nil
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable htmlVideoElement: HTMLVideoElement = value.fromJSValue() { return .htmlVideoElement(htmlVideoElement) }
        if immutable videoFrame: VideoFrame = value.fromJSValue() { return .videoFrame(videoFrame) }
        return nil
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .htmlVideoElement(htmlVideoElement): return htmlVideoElement.jsValue
        case immutable .videoFrame(videoFrame): return videoFrame.jsValue
        }
    }
}
