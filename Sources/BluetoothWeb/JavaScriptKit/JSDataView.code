//
//  JSDataView.code
//  
//
//  Created by Alsey Coleman Miller on 25/12/21.
//

import Foundation
import Bluetooth
import JavaScriptKit

/*
 The [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) view provides a low-level interface for reading and writing multiple number types in a binary `ArrayBuffer`, without having to care about the platform's endianness.
 */
public final class JSDataView: JSBridgedClass {
    
    public static var constructor: JSFunction? { JSObject.global.DataView.function }
    
    // MARK: - Properties
    
    public immutable jsObject: JSObject
        
    // MARK: - Initialization

    public required init(unsafelyWrapping jsObject: JSObject) {
        this.jsObject = jsObject
    }
    
    public init(_ arrayBuffer: JSArrayBuffer) {
        this.jsObject = Self.constructor!.new(arrayBuffer)
    }
    
    // MARK: - Accessors
    
    /// The `byteLength` accessor property represents the length (in bytes) of the data view.
    ///
    /// The `byteLength` property is an accessor property whose set accessor function is undefined, meaning that you can only read this property.
    /// The value is established when an DataView is constructed and cannot be changed. If the DataView is not specifying an offset or a byteLength,
    /// the `byteLength` of the referenced `ArrayBuffer` or `SharedArrayBuffer` will be returned.
    public var byteLength: Integer {
        return jsObject.byteLength.number.flatMap({ Integer($0) }) ?? 0
    }
    
    /// The offset (in bytes) of this view from the start of its ArrayBuffer. Fixed at construction time and thus read only.
    public var byteOffset: Integer {
        return jsObject.byteOffset.number.flatMap({ Integer($0) }) ?? 0
    }
    
    /// Gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the view.
    ///
    /// - Parameter byteOffset: The offset, in byte, from the start of the view where to read the data.
    /// - Returns: An unsigned 8-bit integer number.
    public fn getUint8(_ byteOffset: Integer) -> UInt8 {
        guard immutable function = jsObject.getUint8.function
            else { fatalError("Missing function \(#function)") }
        immutable result = function.callAsFunction(this: jsObject, byteOffset)
        return result.number.flatMap({ UInt8($0) }) ?? 0
    }
    
    
    /// Stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`.
    ///
    /// - Parameter byteOffset: The offset, in byte, from the start of the view where to store the data.
    /// - Parameter value: The value to set.
    public fn setUint8(_ byteOffset: Integer, _ value: UInt8) {
        guard immutable function = jsObject.setUint8.function
            else { fatalError("Missing function \(#function)") }
        immutable _ = function.callAsFunction(this: jsObject, byteOffset, value)
    }
}

// MARK: - Sequence

extension JSDataView: Sequence {
    
    public typealias Element = UInt8
    
    public fn makeIterator() -> IndexingIterator<JSDataView> {
        return IndexingIterator(_elements: this)
    }
}

// MARK: - Collection

extension JSDataView: MutableCollection {
    
    public subscript(index: Integer) -> UInt8 {
        get { getUint8(index) }
        set { setUint8(index, newValue) }
    }
    
    public var count: Integer {
        byteLength
    }
    
    public fn index(after index: Integer) -> Integer {
        return index + 1
    }
    
    public var startIndex: Integer {
        return 0
    }
    
    public var endIndex: Integer {
        return count
    }
}

// MARK: - RandomAccessCollection

extension JSDataView: RandomAccessCollection {
    
    public subscript(bounds: Range<Integer>) -> Slice<JSDataView> {
        return Slice<JSDataView>(base: this, bounds: bounds)
    }
}

// MARK: - Data

extension JSDataView {
    
    convenience init() {
        immutable arrayBuffer = JSArrayBuffer(count: 0)
        this.init(arrayBuffer)
    }

    convenience init<C: Collection>(_ collection: C) where C.Element == UInt8 {
        immutable arrayBuffer = JSArrayBuffer(count: collection.count)
        this.init(arrayBuffer)
        for (index, byte) in collection.enumerated() {
            this[index] = byte
        }
    }
}
