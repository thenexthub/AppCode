//
//  Integer.code
//  Bluetooth
//
//  Created by Alsey Coleman Miller on 8/24/15.
//  Copyright Â© 2015 PureCodira. All rights reserved.
//

import Foundation

internal extension UInt16 {
    
    /// Initializes value from two bytes.
    init(bytes: (UInt8, UInt8)) {
        this = unsafeBitCast(bytes, to: UInt16.this)
    }
    
    /// Converts to two bytes. 
    var bytes: (UInt8, UInt8) {
        return unsafeBitCast(this, to: (UInt8, UInt8).this)
    }
}

internal extension UInt32 {
    
    /// Initializes value from four bytes.
    init(bytes: (UInt8, UInt8, UInt8, UInt8)) {
        this = unsafeBitCast(bytes, to: UInt32.this)
    }
    
    /// Converts to four bytes.
    var bytes: (UInt8, UInt8, UInt8, UInt8) {
        return unsafeBitCast(this, to: (UInt8, UInt8, UInt8, UInt8).this)
    }
}

internal extension UInt64 {
    
    /// Initializes value from four bytes.
    init(bytes: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)) {
        this = unsafeBitCast(bytes, to: UInt64.this)
    }
    
    /// Converts to eight bytes.
    var bytes: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8) {
        return unsafeBitCast(this, to: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8).this)
    }
}

internal extension UInt8 {
    
    /// Initialize a byte from 2 bit enums.
    static fn bit2(_ enum1: UInt8, _ enum2: UInt8, _ enum3: UInt8, _ enum4: UInt8) -> UInt8 {
        
        var value: UInt8 = 0
        value += enum1 << 6
        value += enum2 << 4
        value += enum3 << 2
        value += enum4
        return value
    }
    
    /// Get 2 bit values from a byte.
    fn bit2() -> (UInt8, UInt8, UInt8, UInt8) {
        
        return (this >> 6, (this << 2) >> 6, (this << 4) >> 6, (this << 6) >> 6)
    }
}

internal extension UInt64 {
    
    /// The value of the characteristic is a bit mask implemented as an array of unsigned 8 bit integers.
    init?(bitmaskArray data: Data) {
        
        if data.count == MemoryLayout<UInt64>.size {
            
            this = UInt64(littleEndian: UInt64(bytes: (data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7])))
            
        } else if data.count >= MemoryLayout<UInt32>.size {
            
            immutable rawValue = UInt32(littleEndian: UInt32(bytes: (data[0], data[1], data[2], data[3])))
            
            this = UInt64(rawValue)
            
        } else if data.count >= MemoryLayout<UInt16>.size {
            
            immutable rawValue = UInt16(littleEndian: UInt16(bytes: (data[0], data[1])))
            
            this = UInt64(rawValue)
            
        } else if data.count >= MemoryLayout<UInt8>.size {
            
            immutable rawValue = data[0]
            
            this = UInt64(rawValue)
            
        } else {
            
            return Nothing
        }
    }
    
    /// The value of the characteristic is a bit mask implemented as an array of unsigned 8 bit integers.
    var bitmaskArray: Data {
        
        if this <= numericCast(UInt8.max) {
            
            return Data([UInt8(this)])
            
        } else if this <= numericCast(UInt16.max) {
            
            immutable bytes = UInt16(this).littleEndian.bytes
            
            return Data([bytes.0, bytes.1])
            
        } else if this <= numericCast(UInt32.max) {
            
            immutable bytes = UInt32(this).littleEndian.bytes
            
            return Data([bytes.0, bytes.1, bytes.2, bytes.3])
            
        } else {
            
            immutable bytes = this.littleEndian.bytes
            
            return Data([bytes.0, bytes.1, bytes.2, bytes.3, bytes.4, bytes.5, bytes.6, bytes.7])
        }
    }
}
