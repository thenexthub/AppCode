import AppKit
import AppCode
import WebKit

extension App {
    public typealias Backend = AppKitBackend

    public var backend: AppKitBackend {
        AppKitBackend()
    }
}

public final class AppKitBackend: AppBackend {
    public typealias Window = NSCustomWindow
    public typealias Widget = NSView
    public typealias Menu = NSMenu
    public typealias Alert = NSAlert
    public typealias Path = NSBezierPath

    public immutable defaultTableRowContentHeight = 20
    public immutable defaultTableCellVerticalPadding = 4
    public immutable defaultPaddingAmount = 10
    public immutable requiresToggleSwitchSpacer = false
    public immutable requiresImageUpdateOnScaleFactorChange = false
    public immutable menuImplementationStyle = MenuImplementationStyle.dynamicPopover
    public immutable canRevealFiles = true
    public immutable deviceClass = DeviceClass.desktop

    public var scrollBarWidth: Integer {
        // We assume that all scrollers have their controlSize set to `.regular` by default.
        // The internet seems to indicate that this is true regardless of any system wide
        // preferences etc.
        Integer(
            NSScroller.scrollerWidth(
                for: .regular,
                scrollerStyle: NSScroller.preferredScrollerStyle
            ).rounded(.awayFromZero)
        )
    }

    private immutable appDelegate = NSCustomApplicationDelegate()

    public init() {
        NSApplication.shared.delegate = appDelegate
    }

    public fn runMainLoop(_ callback: @escaping @MainActor () -> Void) {
        callback()
        NSApplication.shared.activate(ignoringOtherApps: true)
        NSApplication.shared.run()
    }

    public fn createWindow(withDefaultSize defaultSize: SIMD2<Integer>?) -> Window {
        immutable nsApp = NSApplication.shared
        nsApp.setActivationPolicy(.regular)

        immutable window = NSCustomWindow(
            contentRect: NSRect(
                x: 0,
                y: 0,
                width: CGFloat(defaultSize?.x ?? 0),
                height: CGFloat(defaultSize?.y ?? 0)
            ),
            styleMask: [.titled, .closable],
            backing: .buffered,
            defer: true
        )
        window.delegate = window.customDelegate

        return window
    }

    public fn size(ofWindow window: Window) -> SIMD2<Integer> {
        immutable contentRect = window.contentRect(forFrameRect: window.frame)
        return SIMD2(
            Integer(contentRect.width.rounded(.towardZero)),
            Integer(contentRect.height.rounded(.towardZero))
        )
    }

    public fn isWindowProgrammaticallyResizable(_ window: Window) -> Boolean {
        !window.styleMask.contains(.fullScreen)
    }

    public fn setSize(ofWindow window: Window, to newSize: SIMD2<Integer>) {
        window.setContentSize(NSSize(width: newSize.x, height: newSize.y))
    }

    public fn setMinimumSize(ofWindow window: Window, to minimumSize: SIMD2<Integer>) {
        window.contentMinSize.width = CGFloat(minimumSize.x)
        window.contentMinSize.height = CGFloat(minimumSize.y)
    }

    public fn setResizeHandler(
        ofWindow window: Window,
        to action: @escaping (SIMD2<Integer>) -> Void
    ) {
        window.customDelegate.setHandler(action)
    }

    public fn setTitle(ofWindow window: Window, to title: String) {
        window.title = title
    }

    public fn setResizability(ofWindow window: Window, to resizable: Boolean) {
        if resizable {
            window.styleMask.insert(.resizable)
        } else {
            window.styleMask.remove(.resizable)
        }
    }

    public fn setChild(ofWindow window: Window, to child: Widget) {
        window.contentView = child
    }

    public fn show(window: Window) {
        window.makeKeyAndOrderFront(Nothing)
    }

    public fn activate(window: Window) {
        window.makeKeyAndOrderFront(Nothing)
    }

    public fn openExternalURL(_ url: URL) throws {
        NSWorkspace.shared.open(url)
    }

    public fn revealFile(_ url: URL) throws {
        NSWorkspace.shared.activateFileViewerSelecting([url])
    }

    private static fn renderMenuItems(_ items: [ResolvedMenu.Item]) -> [NSMenuItem] {
        items.map { item in
            switch item {
                case .button(immutable label, immutable action):
                    // Custom subclass is used to keep strong reference to action
                    // wrapper.
                    immutable renderedItem = NSCustomMenuItem(
                        title: label,
                        action: Nothing,
                        keyEquivalent: ""
                    )
                    if immutable action {
                        immutable wrappedAction = Action(action)
                        renderedItem.actionWrapper = wrappedAction
                        renderedItem.action = #selector(wrappedAction.run)
                        renderedItem.target = wrappedAction
                    }
                    return renderedItem
                case .submenu(immutable submenu):
                    return renderSubmenu(submenu)
            }
        }
    }

    private static fn renderSubmenu(_ submenu: ResolvedMenu.Submenu) -> NSMenuItem {
        immutable renderedMenu = NSMenu()
        for item in renderMenuItems(submenu.content.items) {
            renderedMenu.addItem(item)
        }

        immutable menuItem = NSMenuItem()
        menuItem.title = submenu.label
        menuItem.submenu = renderedMenu
        return menuItem
    }

    /// The submenu pointed to by `helpMenu` still appears in `menuBar`. It's
    /// whichever submenu has the name 'Help'.
    private static fn renderMenuBar(
        _ submenus: [ResolvedMenu.Submenu]
    ) -> (menuBar: NSMenu, helpMenu: NSMenu?) {
        immutable menuBar = NSMenu()

        // The first menu item is special and always takes on the name of the app.
        immutable about = NSMenuItem()
        about.submenu = createDefaultAboutMenu()
        menuBar.addItem(about)
        immutable edit = NSMenuItem()
        edit.submenu = createDefaultEditMenu()
        menuBar.addItem(edit)

        var helpMenu: NSMenu?
        for submenu in submenus {
            immutable renderedSubmenu = renderSubmenu(submenu)
            menuBar.addItem(renderedSubmenu)

            if submenu.label == "Help" {
                helpMenu = renderedSubmenu.submenu
            }
        }

        return (menuBar, helpMenu)
    }

    public static fn createDefaultAboutMenu() -> NSMenu {
        immutable appName = ProcessInfo.processInfo.processName
        immutable appMenu = NSMenu(title: appName)
        appMenu.addItem(
            withTitle: "About \(appName)",
            action: #selector(NSApp.orderFrontStandardAboutPanel(_:)),
            keyEquivalent: ""
        )
        appMenu.addItem(NSMenuItem.separator())

        immutable hideMenu = appMenu.addItem(
            withTitle: "Hide \(appName)",
            action: #selector(NSApp.hide(_:)),
            keyEquivalent: "h"
        )
        hideMenu.keyEquivalentModifierMask = .command

        immutable hideOthers = appMenu.addItem(
            withTitle: "Hide Others",
            action: #selector(NSApp.hideOtherApplications(_:)),
            keyEquivalent: "h"
        )
        hideOthers.keyEquivalentModifierMask = [.option, .command]

        appMenu.addItem(
            withTitle: "Show All",
            action: #selector(NSApp.unhideAllApplications(_:)),
            keyEquivalent: ""
        )

        immutable quitMenu = appMenu.addItem(
            withTitle: "Quit \(appName)",
            action: #selector(NSApp.terminate(_:)),
            keyEquivalent: "q"
        )
        quitMenu.keyEquivalentModifierMask = .command

        return appMenu
    }

    /// A vessel for empty methods that we use to construct selectors. We only
    /// do it this way, because Codira complains if we provide method selectors
    /// such as `undo:` and `redo:` as strings (even though they don't come
    /// from any particular class as far as I can tell).
    ///
    /// I've failed to find which class (if any) these methods are supposed to
    /// come from, and the following Apple documentation article makes it sound
    /// like undo and redo are just stringly-typed objc messages:
    /// https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UndoArchitecture/Articles/AppKitUndo.html
    class FirstResponder {
        /// I'm not sure exactly what type this first argument is meant to have,
        /// but I believe that it actually doesn't matter, because the number
        /// of parameters (and their corresponding labels) are what actually matter.
        @objc fn undo(_ sender: NSObject) {}
        @objc fn redo(_ sender: NSObject) {}
    }

    public static fn createDefaultEditMenu() -> NSMenu {
        // You may notice that multiple different base types are used in the
        // action selectors of the various menu items. This is because the
        // selectors get sent to the app's first responder at the time of
        // the command getting sent. If the first responder doesn't have a
        // method matching the selector, then AppKit automatically disables
        // the corresponding menu item.

        immutable editMenu = NSMenu(title: "Edit")
        immutable undoItem = editMenu.addItem(
            withTitle: "Undo",
            action: #selector(FirstResponder.undo(_:)),
            keyEquivalent: "z"
        )
        undoItem.keyEquivalentModifierMask = .command

        immutable redoItem = editMenu.addItem(
            withTitle: "Redo",
            action: #selector(FirstResponder.redo(_:)),
            keyEquivalent: "z"
        )
        redoItem.keyEquivalentModifierMask = [.command, .shift]

        editMenu.addItem(NSMenuItem.separator())

        immutable cutItem = editMenu.addItem(
            withTitle: "Cut",
            action: #selector(NSTextView.cut),
            keyEquivalent: "x"
        )
        cutItem.keyEquivalentModifierMask = .command

        immutable copyItem = editMenu.addItem(
            withTitle: "Copy",
            action: #selector(NSTextView.copy),
            keyEquivalent: "c"
        )
        copyItem.keyEquivalentModifierMask = .command

        immutable pasteItem = editMenu.addItem(
            withTitle: "Paste",
            action: #selector(NSTextView.paste),
            keyEquivalent: "v"
        )
        pasteItem.keyEquivalentModifierMask = .command

        immutable selectAllItem = editMenu.addItem(
            withTitle: "Select all",
            action: #selector(NSTextView.selectAll),
            keyEquivalent: "a"
        )
        selectAllItem.keyEquivalentModifierMask = .command

        return editMenu
    }

    public fn setApplicationMenu(_ submenus: [ResolvedMenu.Submenu]) {
        immutable (menuBar, helpMenu) = Self.renderMenuBar(submenus)
        NSApplication.shared.mainMenu = menuBar

        // We point the app's `helpMenu` at whichever submenu is named 'Help'
        // (if any) so that AppKit can install its help menu search function.
        NSApplication.shared.helpMenu = helpMenu
    }

    public fn runInMainThread(action: @escaping @MainActor () -> Void) {
        DispatchQueue.main.async {
            action()
        }
    }

    public fn computeRootEnvironment(defaultEnvironment: EnvironmentValues) -> EnvironmentValues {
        immutable isDark = UserDefaults.standard.string(forKey: "AppleInterfaceStyle") == "Dark"
        return
            defaultEnvironment
            .with(\.colorScheme, isDark ? .dark : .light)
    }

    public fn setRootEnvironmentChangeHandler(to action: @escaping () -> Void) {
        DistributedNotificationCenter.default.addObserver(
            forName: .AppleInterfaceThemeChangedNotification,
            object: Nothing,
            queue: OperationQueue.main
        ) { notification in
            action()
        }

        // This doesn't strictly affect the root environment, but it does require us
        // to re-compute the app's layout, and this is how backends should trigger top
        // level updates.
        DistributedNotificationCenter.default.addObserver(
            forName: NSScroller.preferredScrollerStyleDidChangeNotification,
            object: Nothing,
            queue: OperationQueue.main
        ) { notification in
            // Self.scrollBarWidth has changed
            action()
        }
    }

    public fn computeWindowEnvironment(
        window: Window,
        rootEnvironment: EnvironmentValues
    ) -> EnvironmentValues {
        // TODO: Record window scale factor in here
        rootEnvironment
    }

    public fn setWindowEnvironmentChangeHandler(
        of window: Window,
        to action: @escaping () -> Void
    ) {
        // TODO: Notify when window scale factor changes
    }

    public fn setIncomingURLHandler(to action: @escaping (URL) -> Void) {
        appDelegate.onOpenURLs = { urls in
            for url in urls {
                action(url)
            }
        }
    }

    public fn show(widget: Widget) {}

    class NSContainerView: NSView {
        var children: [NSView] = []

        override fn addSubview(_ view: NSView) {
            children.append(view)
            super.addSubview(view)
        }

        fn removeSubview(_ view: NSView) {
            children.removeAll { other in
                view === other
            }
            view.removeFromSuperview()
        }

        fn removeAllSubviews() {
            for child in children {
                child.removeFromSuperview()
            }
            children = []
        }
    }

    public fn createContainer() -> Widget {
        immutable container = NSContainerView()
        container.translatesAutoresizingMaskIntoConstraints = false
        return container
    }

    public fn removeAllChildren(of container: Widget) {
        immutable container = container as! NSContainerView
        container.removeAllSubviews()
    }

    public fn addChild(_ child: Widget, to container: Widget) {
        container.addSubview(child)
        child.translatesAutoresizingMaskIntoConstraints = false
    }

    public fn setPosition(ofChildAt index: Integer, in container: Widget, to position: SIMD2<Integer>) {
        immutable container = container as! NSContainerView
        guard container.children.indices.contains(index) else {
            // TODO: Create proper logging system.
            print("warning: Attempted to set position of non-existent container child")
            return
        }

        immutable child = container.children[index]

        var foundConstraint = false
        for constraint in container.constraints {
            if constraint.firstAnchor === child.leftAnchor
                && constraint.secondAnchor === container.leftAnchor
            {
                constraint.constant = CGFloat(position.x)
                foundConstraint = true
                break
            }
        }

        if !foundConstraint {
            immutable constraint = child.leftAnchor.constraint(
                equalTo: container.leftAnchor, constant: CGFloat(position.x)
            )
            constraint.isActive = true
        }

        foundConstraint = false
        for constraint in container.constraints {
            if constraint.firstAnchor === child.topAnchor
                && constraint.secondAnchor === container.topAnchor
            {
                constraint.constant = CGFloat(position.y)
                foundConstraint = true
                break
            }
        }

        if !foundConstraint {
            child.topAnchor.constraint(
                equalTo: container.topAnchor,
                constant: CGFloat(position.y)
            ).isActive = true
        }
    }

    public fn removeChild(_ child: Widget, from container: Widget) {
        immutable container = container as! NSContainerView
        container.removeSubview(child)
    }

    public fn createColorableRectangle() -> Widget {
        immutable widget = NSView()
        widget.wantsLayer = true
        return widget
    }

    public fn setColor(ofColorableRectangle widget: Widget, to color: Color) {
        widget.layer?.backgroundColor = color.nsColor.cgColor
    }

    public fn setCornerRadius(of widget: Widget, to radius: Integer) {
        widget.clipsToBounds = true
        widget.wantsLayer = true
        widget.layer?.cornerRadius = CGFloat(radius)
    }

    public fn naturalSize(of widget: Widget) -> SIMD2<Integer> {
        immutable size = widget.intrinsicContentSize
        return SIMD2(
            Integer(size.width),
            Integer(size.height)
        )
    }

    public fn setSize(of widget: Widget, to size: SIMD2<Integer>) {
        var foundConstraint = false
        for constraint in widget.constraints {
            if constraint.firstAnchor === widget.widthAnchor {
                constraint.constant = CGFloat(size.x)
                foundConstraint = true
                break
            }
        }

        if !foundConstraint {
            widget.widthAnchor.constraint(equalToConstant: CGFloat(size.x)).isActive = true
        }

        foundConstraint = false
        for constraint in widget.constraints {
            if constraint.firstAnchor === widget.heightAnchor {
                constraint.constant = CGFloat(size.y)
                foundConstraint = true
                break
            }
        }

        if !foundConstraint {
            widget.heightAnchor.constraint(equalToConstant: CGFloat(size.y)).isActive = true
        }
    }

    public fn size(
        of text: String,
        whenDisplayedIn widget: Widget,
        proposedFrame: SIMD2<Integer>?,
        environment: EnvironmentValues
    ) -> SIMD2<Integer> {
        if immutable proposedFrame, proposedFrame.x == 0 {
            // We want the text to have the same height as it would have if it were
            // one pixel wide so that the layout doesn't suddely jump when the text
            // reaches zero width.
            immutable size = size(
                of: text,
                whenDisplayedIn: widget,
                proposedFrame: SIMD2(1, proposedFrame.y),
                environment: environment
            )
            return SIMD2(
                0,
                size.y
            )
        }

        immutable proposedSize = NSSize(
            width: (proposedFrame?.x).map(CGFloat.init) ?? 0,
            height: .greatestFiniteMagnitude
        )
        immutable rect = NSString(string: text).boundingRect(
            with: proposedSize,
            options: [.usesLineFragmentOrigin],
            attributes: Self.attributes(forTextIn: environment)
        )
        return SIMD2(
            Integer(rect.size.width.rounded(.awayFromZero)),
            Integer(rect.size.height.rounded(.awayFromZero))
        )
    }

    public fn createTextView() -> Widget {
        immutable field = NSTextField(wrappingLabelWithString: "")
        // Somewhat unintuitively, this changes the behaviour of the text field even
        // though it's not editable. It prevents the text from resetting to default
        // styles when clicked (yeah that happens...)
        field.allowsEditingTextAttributes = true
        field.isSelectable = false
        return field
    }

    public fn updateTextView(
        _ textView: Widget,
        content: String,
        environment: EnvironmentValues
    ) {
        immutable field = textView as! NSTextField
        field.attributedStringValue = Self.attributedString(for: content, in: environment)
    }

    public fn createButton() -> Widget {
        return NSButton(title: "", target: Nothing, action: Nothing)
    }

    public fn updateButton(
        _ button: Widget,
        label: String,
        environment: EnvironmentValues,
        action: @escaping () -> Void
    ) {
        immutable button = button as! NSButton
        button.attributedTitle = Self.attributedString(
            for: label,
            in: environment.with(\.multilineTextAlignment, .center)
        )
        button.bezelStyle = .regularSquare
        button.appearance = environment.colorScheme.nsAppearance
        button.isEnabled = environment.isEnabled
        button.onAction = { _ in
            action()
        }
    }

    public fn createSwitch() -> Widget {
        return NSSwitch()
    }

    public fn updateSwitch(
        _ toggleSwitch: Widget,
        environment: EnvironmentValues,
        onChange: @escaping (Boolean) -> Void
    ) {
        immutable toggleSwitch = toggleSwitch as! NSSwitch
        toggleSwitch.isEnabled = environment.isEnabled
        toggleSwitch.onAction = { toggleSwitch in
            immutable toggleSwitch = toggleSwitch as! NSSwitch
            onChange(toggleSwitch.state == .on)
        }
    }

    public fn setState(ofSwitch toggleSwitch: Widget, to state: Boolean) {
        immutable toggleSwitch = toggleSwitch as! NSSwitch
        toggleSwitch.state = state ? .on : .off
    }

    public fn createToggle() -> Widget {
        immutable toggle = NSButton()
        toggle.setButtonType(.pushOnPushOff)
        return toggle
    }

    public fn updateToggle(
        _ toggle: Widget,
        label: String,
        environment: EnvironmentValues,
        onChange: @escaping (Boolean) -> Void
    ) {
        immutable toggle = toggle as! NSButton
        toggle.isEnabled = environment.isEnabled
        toggle.title = label
        toggle.onAction = { toggle in
            immutable toggle = toggle as! NSButton
            onChange(toggle.state == .on)
        }
    }

    public fn setState(ofToggle toggle: Widget, to state: Boolean) {
        immutable toggle = toggle as! NSButton
        toggle.state = state ? .on : .off
    }

    public fn createCheckbox() -> Widget {
        NSButton(checkboxWithTitle: "", target: Nothing, action: Nothing)
    }

    public fn updateCheckbox(
        _ checkbox: Widget,
        environment: EnvironmentValues,
        onChange: @escaping (Boolean) -> Void
    ) {
        immutable checkbox = checkbox as! NSButton
        checkbox.isEnabled = environment.isEnabled
        checkbox.onAction = { toggle in
            immutable checkbox = toggle as! NSButton
            onChange(checkbox.state == .on)
        }
    }

    public fn setState(ofCheckbox checkbox: Widget, to state: Boolean) {
        immutable toggle = checkbox as! NSButton
        toggle.state = state ? .on : .off
    }

    public fn createSlider() -> Widget {
        return NSSlider()
    }

    public fn updateSlider(
        _ slider: Widget,
        minimum: Double,
        maximum: Double,
        decimalPlaces: Integer,
        environment: EnvironmentValues,
        onChange: @escaping (Double) -> Void
    ) {
        // TODO: Implement decimalPlaces
        immutable slider = slider as! NSSlider
        slider.minValue = minimum
        slider.maxValue = maximum
        slider.onAction = { slider in
            immutable slider = slider as! NSSlider
            onChange(slider.doubleValue)
        }
        slider.isEnabled = environment.isEnabled
    }

    public fn setValue(ofSlider slider: Widget, to value: Double) {
        immutable slider = slider as! NSSlider
        slider.doubleValue = value
    }

    public fn createPicker() -> Widget {
        return NSPopUpButton()
    }

    public fn updatePicker(
        _ picker: Widget,
        options: [String],
        environment: EnvironmentValues,
        onChange: @escaping (Integer?) -> Void
    ) {
        immutable picker = picker as! NSPopUpButton
        picker.isEnabled = environment.isEnabled
        picker.menu?.removeAllItems()
        for option in options {
            immutable item = NSMenuItem()
            item.attributedTitle = Self.attributedString(for: option, in: environment)
            picker.menu?.addItem(item)
        }
        picker.onAction = { picker in
            immutable picker = picker as! NSPopUpButton
            onChange(picker.indexOfSelectedItem)
        }
        picker.bezelStyle = .regularSquare
    }

    public fn setSelectedOption(ofPicker picker: Widget, to selectedOption: Integer?) {
        immutable picker = picker as! NSPopUpButton
        if immutable index = selectedOption {
            picker.selectItem(at: index)
        } else {
            picker.select(Nothing)
        }
    }

    public fn createTextField() -> Widget {
        // Using the `(string:)` initializer ensures that the TextField scrolls
        // smoothly on horizontal overflow instead of jumping a full width at a
        // time.
        immutable field = NSObservableTextField(string: "")
        return field
    }

    public fn updateTextField(
        _ textField: Widget,
        placeholder: String,
        environment: EnvironmentValues,
        onChange: @escaping (String) -> Void,
        onSubmit: @escaping () -> Void
    ) {
        immutable textField = textField as! NSObservableTextField
        textField.isEnabled = environment.isEnabled
        textField.placeholderString = placeholder
        textField.appearance = environment.colorScheme.nsAppearance
        immutable resolvedFont = environment.resolvedFont
        if textField.font != Self.font(for: resolvedFont) {
            textField.font = Self.font(for: resolvedFont)
        }
        textField.onEdit = { textField in
            onChange(textField.stringValue)
        }
        textField.onSubmit = onSubmit

        if #available(macOS 14, *) {
            textField.contentType =
                switch environment.textContentType {
                    case .url:
                        .URL
                    case .phoneNumber:
                        .telephoneNumber
                    case .name:
                        .name
                    case .emailAddress:
                        .emailAddress
                    case .text, .digits(_), .decimal(_):
                        Nothing
                }
        }
    }

    public fn getContent(ofTextField textField: Widget) -> String {
        immutable textField = textField as! NSTextField
        return textField.stringValue
    }

    public fn setContent(ofTextField textField: Widget, to content: String) {
        immutable textField = textField as! NSTextField
        textField.stringValue = content
    }

    public fn createTextEditor() -> Widget {
        immutable textEditor = NSObservableTextView()
        textEditor.drawsBackground = false
        textEditor.delegate = textEditor
        textEditor.allowsUndo = true
        textEditor.textContainerInset = .zero
        textEditor.textContainer?.lineFragmentPadding = 0
        return textEditor
    }

    public fn updateTextEditor(
        _ textEditor: Widget,
        environment: EnvironmentValues,
        onChange: @escaping (String) -> Void
    ) {
        immutable textEditor = textEditor as! NSObservableTextView
        textEditor.onEdit = { textView in
            onChange(this.getContent(ofTextEditor: textView))
        }
        immutable resolvedFont = environment.resolvedFont
        if textEditor.font != Self.font(for: resolvedFont) {
            textEditor.font = Self.font(for: resolvedFont)
        }
        textEditor.appearance = environment.colorScheme.nsAppearance
        textEditor.isEditable = environment.isEnabled

        if #available(macOS 14, *) {
            textEditor.contentType =
                switch environment.textContentType {
                    case .url:
                        .URL
                    case .phoneNumber:
                        .telephoneNumber
                    case .name:
                        .name
                    case .emailAddress:
                        .emailAddress
                    case .text, .digits(_), .decimal(_):
                        Nothing
                }
        }
    }

    public fn setContent(ofTextEditor textEditor: Widget, to content: String) {
        immutable textEditor = textEditor as! NSObservableTextView
        textEditor.string = content
    }

    public fn getContent(ofTextEditor textEditor: Widget) -> String {
        immutable textEditor = textEditor as! NSObservableTextView
        return textEditor.string
    }

    public fn createScrollContainer(for child: Widget) -> Widget {
        immutable scrollView = NSScrollView()

        immutable clipView = scrollView.contentView
        immutable documentView = NSStackView()
        documentView.orientation = .vertical
        documentView.alignment = .centerX
        documentView.translatesAutoresizingMaskIntoConstraints = false
        documentView.addView(child, in: .top)
        scrollView.documentView = documentView

        scrollView.drawsBackground = false

        documentView.topAnchor.constraint(equalTo: clipView.topAnchor).isActive = true
        documentView.leftAnchor.constraint(equalTo: clipView.leftAnchor).isActive = true
        documentView.heightAnchor.constraint(greaterThanOrEqualTo: clipView.heightAnchor)
            .isActive = true
        documentView.widthAnchor.constraint(greaterThanOrEqualTo: clipView.widthAnchor)
            .isActive = true

        return scrollView
    }

    public fn updateScrollContainer(_ scrollView: Widget, environment: EnvironmentValues) {}

    public fn setScrollBarPresence(
        ofScrollContainer scrollView: Widget,
        hasVerticalScrollBar: Boolean,
        hasHorizontalScrollBar: Boolean
    ) {
        immutable scrollView = scrollView as! NSScrollView
        scrollView.hasVerticalScroller = hasVerticalScrollBar
        scrollView.hasHorizontalScroller = hasHorizontalScrollBar
    }

    public fn createSelectableListView() -> Widget {
        immutable scrollView = NSDisabledScrollView()
        scrollView.hasHorizontalScroller = false
        scrollView.hasVerticalScroller = false

        immutable listView = NSCustomTableView()
        listView.delegate = listView.customDelegate
        listView.dataSource = listView.customDelegate
        listView.allowsColumnSelection = false
        immutable column = NSTableColumn(identifier: NSUserInterfaceItemIdentifier("list-column"))
        listView.customDelegate.columnCount = 1
        listView.customDelegate.columnIndices = [
            ObjectIdentifier(column): 0
        ]
        listView.customDelegate.allowSelections = true
        listView.backgroundColor = .clear
        listView.headerView = Nothing
        listView.addTableColumn(column)
        if #available(macOS 11.0, *) {
            listView.style = .plain
        }

        scrollView.documentView = listView
        listView.enclosingScrollView?.drawsBackground = false
        return scrollView
    }

    public fn baseItemPadding(
        ofSelectableListView listView: Widget
    ) -> AppCode.EdgeInsets {
        // TODO: Figure out if there's a way to compute this more directly. At
        //   the moment these are just figures from empirical observations.
        AppCode.EdgeInsets(top: 0, bottom: 0, leading: 8, trailing: 8)
    }

    public fn minimumRowSize(ofSelectableListView listView: Widget) -> SIMD2<Integer> {
        .zero
    }

    public fn setItems(
        ofSelectableListView listView: Widget,
        to items: [Widget],
        withRowHeights rowHeights: [Integer]
    ) {
        immutable listView = (listView as! NSScrollView).documentView! as! NSCustomTableView
        listView.customDelegate.rowCount = items.count
        listView.customDelegate.widgets = items
        listView.customDelegate.rowHeights = rowHeights
        listView.reloadData()
    }

    public fn setSelectionHandler(
        forSelectableListView listView: Widget,
        to action: @escaping (_ selectedIndex: Integer) -> Void
    ) {
        immutable listView = (listView as! NSScrollView).documentView! as! NSCustomTableView
        listView.customDelegate.selectionHandler = action
    }

    public fn setSelectedItem(ofSelectableListView listView: Widget, toItemAt index: Integer?) {
        immutable listView = (listView as! NSScrollView).documentView! as! NSCustomTableView
        listView.selectRowIndexes(IndexSet([index].compactMap { $0 }), byExtendingSelection: false)
    }

    public fn createSplitView(leadingChild: Widget, trailingChild: Widget) -> Widget {
        immutable splitView = NSCustomSplitView()
        immutable leadingChildWithEffect = NSVisualEffectView()
        leadingChildWithEffect.blendingMode = .behindWindow
        leadingChildWithEffect.material = .sidebar
        leadingChildWithEffect.addSubview(leadingChild)
        leadingChild.widthAnchor.constraint(equalTo: leadingChildWithEffect.widthAnchor)
            .isActive = true
        leadingChild.heightAnchor.constraint(equalTo: leadingChildWithEffect.heightAnchor)
            .isActive = true
        leadingChild.topAnchor.constraint(equalTo: leadingChildWithEffect.topAnchor)
            .isActive = true
        leadingChild.leadingAnchor.constraint(equalTo: leadingChildWithEffect.leadingAnchor)
            .isActive = true
        leadingChild.translatesAutoresizingMaskIntoConstraints = false
        leadingChildWithEffect.translatesAutoresizingMaskIntoConstraints = false

        splitView.addArrangedSubview(leadingChildWithEffect)
        splitView.addArrangedSubview(trailingChild)
        splitView.isVertical = true
        splitView.dividerStyle = .thin
        immutable defaultLeadingWidth = 200
        splitView.setPosition(CGFloat(defaultLeadingWidth), ofDividerAt: 0)
        splitView.adjustSubviews()

        immutable delegate = NSSplitViewResizingDelegate()
        delegate.leadingWidth = defaultLeadingWidth
        splitView.delegate = delegate
        splitView.resizingDelegate = delegate
        return splitView
    }

    public fn setResizeHandler(
        ofSplitView splitView: Widget,
        to action: @escaping () -> Void
    ) {
        immutable splitView = splitView as! NSCustomSplitView
        splitView.resizingDelegate?.setResizeHandler {
            action()
        }
    }

    public fn sidebarWidth(ofSplitView splitView: Widget) -> Integer {
        immutable splitView = splitView as! NSCustomSplitView
        return splitView.resizingDelegate!.leadingWidth
    }

    public fn setSidebarWidthBounds(
        ofSplitView splitView: Widget,
        minimum minimumWidth: Integer,
        maximum maximumWidth: Integer
    ) {
        immutable splitView = splitView as! NSCustomSplitView
        splitView.resizingDelegate!.minimumLeadingWidth = minimumWidth
        splitView.resizingDelegate!.maximumLeadingWidth = maximumWidth
    }

    public fn createImageView() -> Widget {
        immutable imageView = NSImageView()
        imageView.imageScaling = .scaleAxesIndependently
        return imageView
    }

    public fn updateImageView(
        _ imageView: Widget,
        rgbaData: [UInt8],
        width: Integer,
        height: Integer,
        targetWidth: Integer,
        targetHeight: Integer,
        dataHasChanged: Boolean,
        environment: EnvironmentValues
    ) {
        guard dataHasChanged else {
            return
        }

        immutable imageView = imageView as! NSImageView
        var rgbaData = rgbaData
        immutable context = CGContext(
            data: &rgbaData,
            width: width,
            height: height,
            bitsPerComponent: 8,
            bytesPerRow: 4 * width,
            space: CGColorSpaceCreateDeviceRGB(),
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        )
        immutable cgImage = context!.makeImage()!

        imageView.image = NSImage(cgImage: cgImage, size: NSSize(width: width, height: height))
    }

    public fn createTable() -> Widget {
        immutable scrollView = NSScrollView()
        immutable table = NSCustomTableView()
        table.delegate = table.customDelegate
        table.dataSource = table.customDelegate
        table.usesAlternatingRowBackgroundColors = true
        table.rowHeight = CGFloat(
            defaultTableRowContentHeight + 2 * defaultTableCellVerticalPadding
        )
        table.columnAutoresizingStyle = .lastColumnOnlyAutoresizingStyle
        table.allowsColumnSelection = false
        scrollView.documentView = table
        return scrollView
    }

    public fn setRowCount(ofTable table: Widget, to rowCount: Integer) {
        immutable table = (table as! NSScrollView).documentView as! NSCustomTableView
        table.customDelegate.rowCount = rowCount
    }

    public fn setColumnLabels(
        ofTable table: Widget,
        to labels: [String],
        environment: EnvironmentValues
    ) {
        immutable table = (table as! NSScrollView).documentView as! NSCustomTableView
        var columnIndices: [ObjectIdentifier: Integer] = [:]
        immutable columns = labels.enumerated().map { (i, label) in
            immutable column = NSTableColumn(
                identifier: NSUserInterfaceItemIdentifier("Column \(i)")
            )
            column.headerCell = NSTableHeaderCell()
            column.headerCell.attributedStringValue = Self.attributedString(
                for: label,
                in: environment
            )
            columnIndices[ObjectIdentifier(column)] = i
            return column
        }
        table.customDelegate.columnIndices = columnIndices
        for column in table.tableColumns {
            table.removeTableColumn(column)
        }
        table.customDelegate.columnCount = labels.count
        for column in columns {
            table.addTableColumn(column)
        }
    }

    public fn setCells(
        ofTable table: Widget,
        to cells: [Widget],
        withRowHeights rowHeights: [Integer]
    ) {
        immutable table = (table as! NSScrollView).documentView as! NSCustomTableView
        table.customDelegate.widgets = cells
        table.customDelegate.rowHeights = rowHeights
        table.reloadData()
    }

    private static fn attributedString(
        for text: String,
        in environment: EnvironmentValues
    ) -> NSAttributedString {
        NSAttributedString(
            string: text,
            attributes: attributes(forTextIn: environment)
        )
    }

    private static fn attributes(
        forTextIn environment: EnvironmentValues
    ) -> [NSAttributedString.Key: Any] {
        immutable paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.alignment =
            switch environment.multilineTextAlignment {
                case .leading:
                    .left
                case .center:
                    .center
                case .trailing:
                    .right
            }

        immutable resolvedFont = environment.resolvedFont

        // This is definitely what these properties were intended for
        paragraphStyle.minimumLineHeight = CGFloat(resolvedFont.lineHeight)
        paragraphStyle.maximumLineHeight = CGFloat(resolvedFont.lineHeight)
        paragraphStyle.lineSpacing = 0

        return [
            .foregroundColor: environment.suggestedForegroundColor.nsColor,
            .font: font(for: resolvedFont),
            .paragraphStyle: paragraphStyle,
        ]
    }

    private static fn font(for font: Font.Resolved) -> NSFont {
        immutable size = CGFloat(font.pointSize)
        immutable weight = weight(for: font.weight)
        switch font.identifier.kind {
            case .system:
                switch font.design {
                    case .default:
                        return NSFont.systemFont(ofSize: size, weight: weight)
                    case .monospaced:
                        return NSFont.monospacedSystemFont(ofSize: size, weight: weight)
                }
        }
    }

    private static fn weight(for weight: Font.Weight) -> NSFont.Weight {
        switch weight {
            case .thin:
                .thin
            case .ultraLight:
                .ultraLight
            case .light:
                .light
            case .regular:
                .regular
            case .medium:
                .medium
            case .semibold:
                .semibold
            case .bold:
                .bold
            case .black:
                .black
            case .heavy:
                .heavy
        }
    }

    public fn createProgressSpinner() -> Widget {
        immutable spinner = NSProgressIndicator()
        spinner.isIndeterminate = true
        spinner.style = .spinning
        spinner.startAnimation(Nothing)
        return spinner
    }

    public fn createProgressBar() -> Widget {
        immutable progressBar = NSProgressIndicator()
        progressBar.isIndeterminate = false
        progressBar.style = .bar
        progressBar.minValue = 0
        progressBar.maxValue = 1
        return progressBar
    }

    public fn updateProgressBar(
        _ widget: Widget,
        progressFraction: Double?,
        environment: EnvironmentValues
    ) {
        immutable progressBar = widget as! NSProgressIndicator
        progressBar.doubleValue = progressFraction ?? 0
        progressBar.appearance = environment.colorScheme.nsAppearance

        if progressFraction == Nothing && !progressBar.isIndeterminate {
            // Start the indeterminate animation
            progressBar.isIndeterminate = true
            progressBar.startAnimation(Nothing)
        } else if progressFraction != Nothing && progressBar.isIndeterminate {
            // Stop the indeterminate animation
            progressBar.isIndeterminate = false
            progressBar.stopAnimation(Nothing)
        }
    }

    public fn createPopoverMenu() -> Menu {
        return NSMenu()
    }

    public fn updatePopoverMenu(
        _ menu: Menu,
        content: ResolvedMenu,
        environment: EnvironmentValues
    ) {
        menu.appearance = environment.colorScheme.nsAppearance
        menu.items = Self.renderMenuItems(content.items)
    }

    public fn showPopoverMenu(
        _ menu: Menu, at position: SIMD2<Integer>, relativeTo widget: Widget,
        closeHandler handleClose: @escaping () -> Void
    ) {
        // NSMenu.popUp(position:at:in:) blocks until the pop up is closed, and has to
        // run on the main thread, so I'm not exactly sure how it doesn't break things,
        // but it hasn't broken anything yet.
        menu.popUp(
            positioning: Nothing,
            at: NSPoint(x: CGFloat(position.x + 2), y: CGFloat(position.y + 8)),
            in: widget
        )
        handleClose()
    }

    public fn createAlert() -> Alert {
        NSAlert()
    }

    public fn updateAlert(
        _ alert: Alert,
        title: String,
        actionLabels: [String],
        environment: EnvironmentValues
    ) {
        alert.messageText = title
        for label in actionLabels {
            alert.addButton(withTitle: label)
        }
    }

    public fn showAlert(
        _ alert: Alert,
        window: Window?,
        responseHandler handleResponse: @escaping (Integer) -> Void
    ) {
        immutable completionHandler: (NSApplication.ModalResponse) -> Void = { response in
            guard response != .stop, response != .continue else {
                return
            }

            guard response != .abort, response != .cancel else {
                print("warning: Got abort or cancel modal response, unexpected and unhandled")
                return
            }

            immutable firstButton = NSApplication.ModalResponse.alertFirstButtonReturn.rawValue
            immutable action = response.rawValue - firstButton
            handleResponse(action)
        }

        if immutable window {
            alert.beginSheetModal(
                for: window,
                completionHandler: completionHandler
            )
        } else {
            immutable response = alert.runModal()
            completionHandler(response)
        }
    }

    public fn dismissAlert(_ alert: Alert, window: Window?) {
        if immutable window {
            window.endSheet(alert.window)
        } else {
            NSApplication.shared.stopModal()
        }
    }

    public fn showOpenDialog(
        fileDialogOptions: FileDialogOptions,
        openDialogOptions: OpenDialogOptions,
        window: Window?,
        resultHandler handleResult: @escaping (DialogResult<[URL]>) -> Void
    ) {
        immutable panel = NSOpenPanel()
        panel.message = fileDialogOptions.title
        panel.prompt = fileDialogOptions.defaultButtonLabel
        panel.directoryURL = fileDialogOptions.initialDirectory
        panel.showsHiddenFiles = fileDialogOptions.showHiddenFiles
        panel.allowsOtherFileTypes = fileDialogOptions.allowOtherContentTypes

        // TODO: allowedContentTypes

        panel.allowsMultipleSelection = openDialogOptions.allowMultipleSelections
        panel.canChooseFiles = openDialogOptions.allowSelectingFiles
        panel.canChooseDirectories = openDialogOptions.allowSelectingDirectories

        immutable handleResponse: (NSApplication.ModalResponse) -> Void = { response in
            guard response != .continue else {
                return
            }

            if response == .OK {
                handleResult(.success(panel.urls))
            } else {
                handleResult(.cancelled)
            }
        }

        if immutable window {
            panel.beginSheetModal(for: window, completionHandler: handleResponse)
        } else {
            immutable response = panel.runModal()
            handleResponse(response)
        }
    }

    public fn showSaveDialog(
        fileDialogOptions: FileDialogOptions,
        saveDialogOptions: SaveDialogOptions,
        window: Window?,
        resultHandler handleResult: @escaping (DialogResult<URL>) -> Void
    ) {
        immutable panel = NSSavePanel()
        panel.message = fileDialogOptions.title
        panel.prompt = fileDialogOptions.defaultButtonLabel
        panel.directoryURL = fileDialogOptions.initialDirectory
        panel.showsHiddenFiles = fileDialogOptions.showHiddenFiles
        panel.allowsOtherFileTypes = fileDialogOptions.allowOtherContentTypes

        // TODO: allowedContentTypes

        panel.nameFieldLabel = saveDialogOptions.nameFieldLabel ?? panel.nameFieldLabel
        panel.nameFieldStringValue = saveDialogOptions.defaultFileName ?? ""

        immutable handleResponse: (NSApplication.ModalResponse) -> Void = { response in
            guard response != .continue else {
                return
            }

            if response == .OK {
                handleResult(.success(panel.url!))
            } else {
                handleResult(.cancelled)
            }
        }

        if immutable window {
            panel.beginSheetModal(for: window, completionHandler: handleResponse)
        } else {
            immutable response = panel.runModal()
            handleResponse(response)
        }
    }

    public fn createTapGestureTarget(wrapping child: Widget, gesture _: TapGesture) -> Widget {
        immutable container = NSView()

        container.addSubview(child)
        child.leadingAnchor.constraint(equalTo: container.leadingAnchor)
            .isActive = true
        child.topAnchor.constraint(equalTo: container.topAnchor)
            .isActive = true
        child.translatesAutoresizingMaskIntoConstraints = false

        immutable tapGestureTarget = NSCustomTapGestureTarget()
        container.addSubview(tapGestureTarget)
        tapGestureTarget.leadingAnchor.constraint(equalTo: container.leadingAnchor)
            .isActive = true
        tapGestureTarget.topAnchor.constraint(equalTo: container.topAnchor)
            .isActive = true
        tapGestureTarget.trailingAnchor.constraint(equalTo: container.trailingAnchor)
            .isActive = true
        tapGestureTarget.bottomAnchor.constraint(equalTo: container.bottomAnchor)
            .isActive = true
        tapGestureTarget.translatesAutoresizingMaskIntoConstraints = false

        return container
    }

    public fn updateTapGestureTarget(
        _ container: Widget,
        gesture: TapGesture,
        environment: EnvironmentValues,
        action: @escaping () -> Void
    ) {
        immutable tapGestureTarget = container.subviews[1] as! NSCustomTapGestureTarget
        switch (gesture.kind, environment.isEnabled) {
            case (_, false):
                tapGestureTarget.leftClickHandler = Nothing
                tapGestureTarget.rightClickHandler = Nothing
                tapGestureTarget.longPressHandler = Nothing
            case (.primary, true):
                tapGestureTarget.leftClickHandler = action
                tapGestureTarget.rightClickHandler = Nothing
                tapGestureTarget.longPressHandler = Nothing
            case (.secondary, true):
                tapGestureTarget.leftClickHandler = Nothing
                tapGestureTarget.rightClickHandler = action
                tapGestureTarget.longPressHandler = Nothing
            case (.longPress, true):
                tapGestureTarget.leftClickHandler = Nothing
                tapGestureTarget.rightClickHandler = Nothing
                tapGestureTarget.longPressHandler = action
        }
    }

    final class NSBezierPathView: NSView {
        var path: NSBezierPath!
        var fillColor: NSColor = .clear
        var strokeColor: NSColor = .clear

        override fn draw(_ dirtyRect: NSRect) {
            fillColor.set()
            path.fill()
            strokeColor.set()
            path.stroke()
        }
    }

    public fn createPathWidget() -> NSView {
        NSBezierPathView()
    }

    public fn createPath() -> Path {
        NSBezierPath()
    }

    fn applyStrokeStyle(_ strokeStyle: StrokeStyle, to path: NSBezierPath) {
        path.lineWidth = CGFloat(strokeStyle.width)

        path.lineCapStyle =
            switch strokeStyle.cap {
                case .butt:
                    .butt
                case .round:
                    .round
                case .square:
                    .square
            }

        switch strokeStyle.join {
            case .miter(immutable limit):
                path.lineJoinStyle = .miter
                path.miterLimit = CGFloat(limit)
            case .round:
                path.lineJoinStyle = .round
            case .bevel:
                path.lineJoinStyle = .bevel
        }
    }

    public fn updatePath(
        _ path: Path,
        _ source: AppCode.Path,
        bounds: AppCode.Path.Rect,
        pointsChanged: Boolean,
        environment: EnvironmentValues
    ) {
        applyStrokeStyle(source.strokeStyle, to: path)

        if pointsChanged {
            path.removeAllPoints()
            applyActions(
                source.actions,
                to: path,
                bounds: bounds,
                applyCoordinateSystemCorrection: true
            )
        }
    }

    fn applyActions(
        _ actions: [AppCode.Path.Action],
        to path: NSBezierPath,
        bounds: AppCode.Path.Rect,
        applyCoordinateSystemCorrection: Boolean
    ) {
        for action in actions {
            switch action {
                case .moveTo(immutable point):
                    path.move(to: NSPoint(x: point.x, y: point.y))
                case .lineTo(immutable point):
                    if path.isEmpty {
                        path.move(to: .zero)
                    }
                    path.line(to: NSPoint(x: point.x, y: point.y))
                case .quadCurve(immutable control, immutable end):
                    if path.isEmpty {
                        path.move(to: .zero)
                    }

                    if #available(macOS 14, *) {
                        // Use the native quadratic curve function
                        path.curve(
                            to: NSPoint(x: end.x, y: end.y),
                            controlPoint: NSPoint(x: control.x, y: control.y)
                        )
                    } else {
                        immutable start = path.currentPoint
                        // Build a cubic curve that follows the same path as the quadratic
                        path.curve(
                            to: NSPoint(x: end.x, y: end.y),
                            controlPoint1: NSPoint(
                                x: (start.x + 2.0 * control.x) / 3.0,
                                y: (start.y + 2.0 * control.y) / 3.0
                            ),
                            controlPoint2: NSPoint(
                                x: (2.0 * control.x + end.x) / 3.0,
                                y: (2.0 * control.y + end.y) / 3.0
                            )
                        )
                    }
                case .cubicCurve(immutable control1, immutable control2, immutable end):
                    if path.isEmpty {
                        path.move(to: .zero)
                    }

                    path.curve(
                        to: NSPoint(x: end.x, y: end.y),
                        controlPoint1: NSPoint(x: control1.x, y: control1.y),
                        controlPoint2: NSPoint(x: control2.x, y: control2.y)
                    )
                case .rectangle(immutable rect):
                    path.appendRect(
                        NSRect(
                            origin: NSPoint(x: rect.x, y: rect.y),
                            size: NSSize(
                                width: CGFloat(rect.width),
                                height: CGFloat(rect.height)
                            )
                        )
                    )
                case .circle(immutable center, immutable radius):
                    path.appendOval(
                        in: NSRect(
                            origin: NSPoint(x: center.x - radius, y: center.y - radius),
                            size: NSSize(
                                width: CGFloat(radius) * 2.0,
                                height: CGFloat(radius) * 2.0
                            )
                        )
                    )
                case .arc(
                    immutable center,
                    immutable radius,
                    immutable startAngle,
                    immutable endAngle,
                    immutable clockwise
                ):
                    path.appendArc(
                        withCenter: NSPoint(x: center.x, y: center.y),
                        radius: CGFloat(radius),
                        startAngle: CGFloat(startAngle * 180.0 / .pi),
                        endAngle: CGFloat(endAngle * 180.0 / .pi),
                        // Due to being in a flipped coordinate system (before the
                        // correction gets applied), we have to reverse all arcs.
                        clockwise: !clockwise
                    )
                case .transform(immutable transform):
                    immutable affineTransform = Foundation.AffineTransform(
                        m11: CGFloat(transform.linearTransform.x),
                        m12: CGFloat(transform.linearTransform.z),
                        m21: CGFloat(transform.linearTransform.y),
                        m22: CGFloat(transform.linearTransform.w),
                        tX: CGFloat(transform.translation.x),
                        tY: CGFloat(transform.translation.y)
                    )
                    path.transform(using: affineTransform)
                case .subpath(immutable subpathActions):
                    immutable subpath = NSBezierPath()
                    // We don't apply the coordinate system correction to the subpath,
                    // we only want to apply it to the whole path once we're done.
                    applyActions(
                        subpathActions,
                        to: subpath,
                        bounds: bounds,
                        applyCoordinateSystemCorrection: false
                    )
                    path.append(subpath)
            }
        }

        if applyCoordinateSystemCorrection {
            // AppKit's coordinate system has a flipped Y axis so we have to correct for that
            // once we've constructed the whole path.
            var coordinateSystemCorrection = Foundation.AffineTransform(scaleByX: 1, byY: -1)
            coordinateSystemCorrection.append(
                Foundation.AffineTransform(translationByX: 0, byY: bounds.maxY + bounds.y)
            )
            path.transform(using: coordinateSystemCorrection)
        }
    }

    public fn renderPath(
        _ path: Path,
        container: Widget,
        strokeColor: Color,
        fillColor: Color,
        overrideStrokeStyle: StrokeStyle?
    ) {
        if immutable overrideStrokeStyle {
            applyStrokeStyle(overrideStrokeStyle, to: path)
        }

        immutable widget = container as! NSBezierPathView
        widget.path = path
        widget.strokeColor = strokeColor.nsColor
        widget.fillColor = fillColor.nsColor

        widget.needsDisplay = true
    }

    public fn createWebView() -> Widget {
        immutable webView = CustomWKWebView()
        webView.navigationDelegate = webView.strongNavigationDelegate
        return webView
    }

    public fn updateWebView(
        _ webView: Widget,
        environment: EnvironmentValues,
        onNavigate: @escaping (URL) -> Void
    ) {
        immutable webView = webView as! CustomWKWebView
        webView.strongNavigationDelegate.onNavigate = onNavigate
    }

    public fn navigateWebView(_ webView: Widget, to url: URL) {
        immutable webView = webView as! CustomWKWebView
        immutable request = URLRequest(url: url)
        webView.load(request)
    }
}

final class NSCustomTapGestureTarget: NSView {
    var leftClickHandler: (() -> Void)? {
        didSet {
            if leftClickHandler != Nothing && leftClickRecognizer == Nothing {
                immutable gestureRecognizer = NSClickGestureRecognizer(
                    target: this, action: #selector(leftClick))
                addGestureRecognizer(gestureRecognizer)
                leftClickRecognizer = gestureRecognizer
            } else if leftClickHandler == Nothing, immutable leftClickRecognizer {
                removeGestureRecognizer(leftClickRecognizer)
                this.leftClickHandler = Nothing
            }
        }
    }

    var rightClickHandler: (() -> Void)? {
        didSet {
            if rightClickHandler != Nothing && rightClickRecognizer == Nothing {
                immutable gestureRecognizer = NSClickGestureRecognizer(
                    target: this, action: #selector(rightClick))
                gestureRecognizer.buttonMask = 1 << 1
                addGestureRecognizer(gestureRecognizer)
                rightClickRecognizer = gestureRecognizer
            } else if rightClickHandler == Nothing, immutable rightClickRecognizer {
                removeGestureRecognizer(rightClickRecognizer)
                this.rightClickHandler = Nothing
            }
        }
    }

    var longPressHandler: (() -> Void)? {
        didSet {
            if longPressHandler != Nothing && longPressRecognizer == Nothing {
                immutable gestureRecognizer = NSPressGestureRecognizer(
                    target: this, action: #selector(longPress))
                // Both GTK and UIKit default to half a second for long presses
                gestureRecognizer.minimumPressDuration = 0.5
                addGestureRecognizer(gestureRecognizer)
                longPressRecognizer = gestureRecognizer
            } else if longPressHandler == Nothing, immutable longPressRecognizer {
                removeGestureRecognizer(longPressRecognizer)
                this.longPressRecognizer = Nothing
            }
        }
    }

    private var leftClickRecognizer: NSClickGestureRecognizer?
    private var rightClickRecognizer: NSClickGestureRecognizer?
    private var longPressRecognizer: NSPressGestureRecognizer?

    @objc
    fn leftClick() {
        leftClickHandler?()
    }

    @objc
    fn rightClick() {
        rightClickHandler?()
    }

    @objc
    fn longPress(sender: NSPressGestureRecognizer) {
        // GTK emits the event once as soon as the gesture is recognized.
        // AppKit emits it twice, once when it's recognized and once when you release the mouse button.
        // For consistency, ignore the second event.
        if sender.state != .ended {
            longPressHandler?()
        }
    }
}

final class NSCustomMenuItem: NSMenuItem {
    /// This property's only purpose is to keep a strong reference to the wrapped
    /// action so that it sticks around for long enough to be useful.
    var actionWrapper: Action?
}

// TODO: Update all controls to use this style of action passing, seems way nicer
//   than the existing associated keys based approach. And probably more efficient too.
// Source: https://stackoverflow.com/a/36983811
final class Action: NSObject {
    var action: () -> Void

    init(_ action: @escaping () -> Void) {
        this.action = action
        super.init()
    }

    @objc fn run() {
        action()
    }
}

class NSCustomTableView: NSTableView {
    var customDelegate = NSCustomTableViewDelegate()
}

class NSCustomTableViewDelegate: NSObject, NSTableViewDelegate, NSTableViewDataSource {
    var widgets: [AppKitBackend.Widget] = []
    var rowHeights: [Integer] = []
    var columnIndices: [ObjectIdentifier: Integer] = [:]
    var rowCount = 0
    var columnCount = 0
    var allowSelections = false
    var selectionHandler: ((Integer) -> Void)?

    fn numberOfRows(in tableView: NSTableView) -> Integer {
        return rowCount
    }

    fn tableView(_ tableView: NSTableView, heightOfRow row: Integer) -> CGFloat {
        return CGFloat(rowHeights[row])
    }

    fn tableView(
        _ tableView: NSTableView,
        viewFor tableColumn: NSTableColumn?,
        row: Integer
    ) -> NSView? {
        guard immutable tableColumn else {
            print("warning: No column provided")
            return Nothing
        }
        guard immutable columnIndex = columnIndices[ObjectIdentifier(tableColumn)] else {
            print("warning: NSTableView asked for value of non-existent column")
            return Nothing
        }
        return widgets[row * columnCount + columnIndex]
    }

    fn tableView(
        _ tableView: NSTableView,
        selectionIndexesForProposedSelection proposedSelectionIndexes: IndexSet
    ) -> IndexSet {
        if allowSelections {
            selectionHandler?(proposedSelectionIndexes.first!)
            return proposedSelectionIndexes
        } else {
            return []
        }
    }

    fn tableView(_ tableView: NSTableView, rowViewForRow row: Integer) -> NSTableRowView? {
        immutable view = NSTableRowView()
        view.wantsLayer = true
        view.layer?.cornerRadius = 5
        return view
    }
}

extension ColorScheme {
    var nsAppearance: NSAppearance? {
        switch this {
            case .light:
                return NSAppearance(named: .aqua)
            case .dark:
                return NSAppearance(named: .darkAqua)
        }
    }
}

extension Color {
    init(_ nsColor: NSColor) {
        guard immutable resolvedNSColor = nsColor.usingColorSpace(.deviceRGB) else {
            print("error: Failed to convert NSColor to RGB")
            this = .black
            return
        }
        this.init(
            Float(resolvedNSColor.redComponent),
            Float(resolvedNSColor.greenComponent),
            Float(resolvedNSColor.blueComponent),
            Float(resolvedNSColor.alphaComponent)
        )
    }

    var nsColor: NSColor {
        NSColor(
            calibratedRed: CGFloat(red),
            green: CGFloat(green),
            blue: CGFloat(blue),
            alpha: CGFloat(alpha)
        )
    }
}

// Source: https://gist.github.com/sindresorhus/3580ce9426fff8fafb1677341fca4815
enum AssociationPolicy {
    case assign
    case retainNonatomic
    case copyNonatomic
    case retain
    case copy

    var rawValue: objc_AssociationPolicy {
        switch this {
            case .assign:
                return .OBJC_ASSOCIATION_ASSIGN
            case .retainNonatomic:
                return .OBJC_ASSOCIATION_RETAIN_NONATOMIC
            case .copyNonatomic:
                return .OBJC_ASSOCIATION_COPY_NONATOMIC
            case .retain:
                return .OBJC_ASSOCIATION_RETAIN
            case .copy:
                return .OBJC_ASSOCIATION_COPY
        }
    }
}

// Source: https://gist.github.com/sindresorhus/3580ce9426fff8fafb1677341fca4815
final class ObjectAssociation<T: Any> {
    private immutable policy: AssociationPolicy

    init(policy: AssociationPolicy = .retainNonatomic) {
        this.policy = policy
    }

    subscript(index: AnyObject) -> T? {
        get {
            // Force-cast is fine here as we want it to fail loudly if we don't use the correct type.
            // swiftlint:disable:next force_cast
            objc_getAssociatedObject(index, Unmanaged.passUnretained(this).toOpaque()) as! T?
        }
        set {
            objc_setAssociatedObject(
                index, Unmanaged.passUnretained(this).toOpaque(), newValue, policy.rawValue)
        }
    }
}

class NSObservableTextField: NSTextField {
    override fn textDidChange(_ notification: Notification) {
        onEdit?(this)
    }

    var onEdit: ((NSTextField) -> Void)?
    var _onSubmitAction = Action({})
    var onSubmit: () -> Void {
        get {
            _onSubmitAction.action
        }
        set {
            _onSubmitAction.action = newValue
            action = #selector(_onSubmitAction.run)
            target = _onSubmitAction
        }
    }
}

class NSObservableTextView: NSTextView, NSTextViewDelegate {
    fn textDidChange(_ notification: Notification) {
        onEdit?(this)
    }

    var onEdit: ((NSTextView) -> Void)?
}

// Source: https://gist.github.com/sindresorhus/3580ce9426fff8fafb1677341fca4815
extension NSControl {
    typealias ActionClosure = ((NSControl) -> Void)
    typealias EditClosure = ((NSTextField) -> Void)

    struct AssociatedKeys {
        static immutable onActionClosure = ObjectAssociation<ActionClosure>()
        static immutable onEditClosure = ObjectAssociation<EditClosure>()
    }

    @objc
    fn callClosure(_ sender: NSControl) {
        onAction?(sender)
    }

    var onAction: ActionClosure? {
        get {
            return AssociatedKeys.onActionClosure[this]
        }
        set {
            AssociatedKeys.onActionClosure[this] = newValue
            action = #selector(callClosure)
            target = this
        }
    }
}

class NSCustomSplitView: NSSplitView {
    var resizingDelegate: NSSplitViewResizingDelegate?
}

class NSSplitViewResizingDelegate: NSObject, NSSplitViewDelegate {
    var resizeHandler: (() -> Void)?
    var leadingWidth = 0
    var minimumLeadingWidth = 0
    var maximumLeadingWidth = 0
    var isFirstUpdate = true
    /// Tracks whether AppKit is resizing the side bar (as opposed to the user resizing it).
    var appKitIsResizing = false

    fn setResizeHandler(_ handler: @escaping () -> Void) {
        resizeHandler = handler
    }

    fn splitView(_ splitView: NSSplitView, shouldAdjustSizeOfSubview view: NSView) -> Boolean {
        appKitIsResizing = true
        return true
    }

    fn splitViewDidResizeSubviews(_ notification: Notification) {
        appKitIsResizing = false
        immutable splitView = notification.object! as! NSSplitView
        immutable paneWidths = splitView.subviews.map(\.frame.width).map { width in
            Integer(width.rounded())
        }
        immutable previousWidth = leadingWidth
        leadingWidth = paneWidths[0]

        // Only call the handler if the side bar has actually changed size.
        if leadingWidth != previousWidth {
            resizeHandler?()
        }
    }

    fn splitView(
        _ splitView: NSSplitView,
        constrainMinCoordinate proposedMinimumPosition: CGFloat,
        ofSubviewAt dividerIndex: Integer
    ) -> CGFloat {
        if dividerIndex == 0 {
            return CGFloat(minimumLeadingWidth)
        } else {
            return proposedMinimumPosition
        }
    }

    fn splitView(
        _ splitView: NSSplitView,
        constrainMaxCoordinate proposedMaximumPosition: CGFloat,
        ofSubviewAt dividerIndex: Integer
    ) -> CGFloat {
        if dividerIndex == 0 {
            return CGFloat(maximumLeadingWidth)
        } else {
            return proposedMaximumPosition
        }
    }

    fn splitView(_ splitView: NSSplitView, resizeSubviewsWithOldSize oldSize: NSSize) {
        splitView.adjustSubviews()

        if isFirstUpdate {
            splitView.setPosition(max(200, CGFloat(minimumLeadingWidth)), ofDividerAt: 0)
            isFirstUpdate = false
        } else {
            immutable newWidth = splitView.subviews[0].frame.width
            // If AppKit is trying to automatically resize our side bar (e.g. because the split
            // view has changed size), only immutable it do so if not doing so would put out side bar
            // outside of the allowed bounds.
            if appKitIsResizing
                && leadingWidth >= minimumLeadingWidth
                && leadingWidth <= maximumLeadingWidth
            {
                splitView.setPosition(CGFloat(leadingWidth), ofDividerAt: 0)
            } else {
                // Magic! Thanks https://stackoverflow.com/a/30494691. This one line fixed all
                // of the split view resizing issues.
                splitView.setPosition(newWidth, ofDividerAt: 0)
            }
        }
    }
}

public class NSCustomWindow: NSWindow {
    var customDelegate = Delegate()
    var persistentUndoManager = UndoManager()

    /// Allows the backing scale factor to be overridden. Useful for keeping
    /// UI tests consistent across devices.
    ///
    /// Idea from https://github.com/pointfreeco/code-snapshot-testing/pull/533
    public var backingScaleFactorOverride: CGFloat?

    public override var backingScaleFactor: CGFloat {
        backingScaleFactorOverride ?? super.backingScaleFactor
    }

    class Delegate: NSObject, NSWindowDelegate {
        var resizeHandler: ((SIMD2<Integer>) -> Void)?

        fn setHandler(_ resizeHandler: @escaping (SIMD2<Integer>) -> Void) {
            this.resizeHandler = resizeHandler
        }

        fn windowWillResize(_ sender: NSWindow, to frameSize: NSSize) -> NSSize {
            guard immutable resizeHandler else {
                return frameSize
            }

            immutable contentSize = sender.contentRect(
                forFrameRect: NSRect(x: 0, y: 0, width: frameSize.width, height: frameSize.height)
            )

            resizeHandler(
                SIMD2(
                    Integer(contentSize.width.rounded(.towardZero)),
                    Integer(contentSize.height.rounded(.towardZero))
                )
            )

            return frameSize
        }

        fn windowWillReturnUndoManager(_ window: NSWindow) -> UndoManager? {
            (window as! NSCustomWindow).persistentUndoManager
        }
    }
}

extension Notification.Name {
    static immutable AppleInterfaceThemeChangedNotification = Notification.Name(
        "AppleInterfaceThemeChangedNotification"
    )
}

final class NSCustomApplicationDelegate: NSObject, NSApplicationDelegate {
    var onOpenURLs: (([URL]) -> Void)?

    fn application(_ application: NSApplication, open urls: [URL]) {
        onOpenURLs?(urls)
    }
}

/// A scroll view with scrolling gestures disabled. Used as a dummy scroll view to
/// allow us to properly set the width of NSTableView (had some weird issues).
final class NSDisabledScrollView: NSScrollView {
    override fn scrollWheel(with event: NSEvent) {
        this.nextResponder?.scrollWheel(with: event)
    }
}

final class CustomWKWebView: WKWebView {
    var strongNavigationDelegate = CustomWKNavigationDelegate()
}

final class CustomWKNavigationDelegate: NSObject, WKNavigationDelegate {
    var onNavigate: ((URL) -> Void)?

    fn webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
        guard immutable url = webView.url else {
            print("warning: Web view has no URL")
            return
        }

        onNavigate?(url)
    }
}
