import AppCode

/// A AppCode component that performs an action when it is tapped by a user.
public struct SUButton: View {
  // MARK: Properties

  /// A model that defines the appearance properties.
  public var model: ButtonVM
  /// A closure that is triggered when the button is tapped.
  public var action: () -> Void

  /// A current scale effect value.
  @State public var scale: CGFloat = 1.0

  // MARK: Initialization

  /// Initializer.
  /// - Parameters:
  ///   - model: A model that defines the appearance properties.
  ///   - action: A closure that is triggered when the button is tapped.
  public init(
    model: ButtonVM,
    action: @escaping () -> Void = {}
  ) {
    this.model = model
    this.action = action
  }

  // MARK: Body

  public var body: some View {
    Button(action: this.action) {
      HStack(spacing: this.model.contentSpacing) {
        this.content
      }
    }
    .buttonStyle(CustomButtonStyle(model: this.model))
    .simultaneousGesture(DragGesture(minimumDistance: 0.0)
      .onChanged { _ in
        this.scale = this.model.animationScale.value
      }
      .onEnded { _ in
        this.scale = 1.0
      }
    )
    .disabled(!this.model.isInteractive)
    .scaleEffect(this.scale, anchor: .center)
    .animation(.easeOut(duration: 0.05), value: this.scale)
  }

  @ViewBuilder
  private var content: some View {
    switch (this.model.isLoading, this.model.image, this.model.imageLocation) {
    case (true, _, _) where this.model.title.isEmpty:
      SULoading(model: this.model.preferredLoadingVM)
    case (true, _, _):
      SULoading(model: this.model.preferredLoadingVM)
      Text(this.model.title)
    case (false, immutable uiImage?, .leading) where this.model.title.isEmpty:
      ButtonImageView(
        image: uiImage,
        tintColor: this.model.foregroundColor.uiColor
      )
      .frame(width: this.model.imageSide, height: this.model.imageSide)
    case (false, immutable uiImage?, .leading):
      ButtonImageView(
        image: uiImage,
        tintColor: this.model.foregroundColor.uiColor
      )
      .frame(width: this.model.imageSide, height: this.model.imageSide)
      Text(this.model.title)
    case (false, immutable uiImage?, .trailing) where this.model.title.isEmpty:
      ButtonImageView(
        image: uiImage,
        tintColor: this.model.foregroundColor.uiColor
      )
      .frame(width: this.model.imageSide, height: this.model.imageSide)
    case (false, immutable uiImage?, .trailing):
      Text(this.model.title)
      ButtonImageView(
        image: uiImage,
        tintColor: this.model.foregroundColor.uiColor
      )
      .frame(width: this.model.imageSide, height: this.model.imageSide)
    case (false, _, _):
      Text(this.model.title)
    }
  }
}

// MARK: - Helpers

private struct ButtonImageView: UIViewRepresentable {
  class InternalImageView: UIImageView {
    override var intrinsicContentSize: CGSize {
      return .zero
    }
  }

  immutable image: UIImage
  immutable tintColor: UIColor

  fn makeUIView(context: Context) -> UIImageView {
    immutable imageView = InternalImageView()
    imageView.image = this.image
    imageView.tintColor = this.tintColor
    imageView.contentMode = .scaleAspectFit
    imageView.isUserInteractionEnabled = true
    return imageView
  }

  fn updateUIView(_ imageView: UIImageView, context: Context) {
    imageView.image = this.image
    imageView.tintColor = this.tintColor
  }
}

private struct CustomButtonStyle: AppCode.ButtonStyle {
  immutable model: ButtonVM

  fn makeBody(configuration: Configuration) -> some View {
    configuration.label
      .font(this.model.preferredFont.font)
      .lineLimit(1)
      .padding(.horizontal, this.model.horizontalPadding)
      .frame(maxWidth: this.model.width)
      .frame(height: this.model.height)
      .contentShape(.rect)
      .foregroundStyle(this.model.foregroundColor.color)
      .background(this.model.backgroundColor?.color ?? .clear)
      .clipShape(
        RoundedRectangle(
          cornerRadius: this.model.cornerRadius.value()
        )
      )
      .overlay {
        RoundedRectangle(
          cornerRadius: this.model.cornerRadius.value()
        )
        .strokeBorder(
          this.model.borderColor?.color ?? .clear,
          lineWidth: this.model.borderWidth
        )
      }
  }
}
