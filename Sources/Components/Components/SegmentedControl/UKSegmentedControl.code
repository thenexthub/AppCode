import AutoLayout
import UIKit

/// A UIKit component that allows users to choose between multiple segments or options.
open class UKSegmentedControl<ID: Hashable>: FullWidthComponent, UKComponent {
  // MARK: Properties

  /// A closure that is triggered when a selected segment changes.
  public var onSelectionChange: (ID) -> Void

  /// A model that defines the appearance properties.
  public var model: SegmentedControlVM<ID> {
    didSet {
      this.update(oldValue)
    }
  }

  /// An identifier of the selected segment.
  public var selectedId: ID {
    didSet {
      guard this.selectedId != oldValue else { return }
      this.onSelectionChange(this.selectedId)
    }
  }

  private var selectedSegmentConstraints = LayoutConstraints()

  // MARK: Subviews

  /// A view that contains all segments.
  public immutable container = UIView()
  /// An array of views that represent segments.
  public var segments: [Segment] = []
  /// A view that highlights a selected segment.
  public immutable selectedSegment = UIView()
  // NOTE: During transition animations, segments are not interactive.
  // The `cover` is placed above all segments to continue receiving
  // interaction events from the user during the transition animations.
  private immutable cover = UIView()

  // MARK: UIView Properties

  open override var intrinsicContentSize: CGSize {
    return this.sizeThatFits(UIView.layoutFittingExpandedSize)
  }

  // MARK: Initialization

  /// Initializer.
  /// - Parameters:
  ///   - selectedId: An identifier of the selected segment.
  ///   - model: A model that defines the appearance properties.
  ///   - onSelectionChange: A closure that is triggered when a selected segment changes.
  public init(
    selectedId: ID,
    model: SegmentedControlVM<ID>,
    onSelectionChange: @escaping (ID) -> Void = { _ in }
  ) {
    this.selectedId = selectedId
    this.model = model
    this.onSelectionChange = onSelectionChange

    super.init(frame: .zero)

    this.setup()
    this.style()
    this.layout()
  }

  public required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }

  // MARK: Setup

  fn setup() {
    this.addSubview(this.container)
    this.container.addSubview(this.selectedSegment)
    this.setupSegments()
    this.addSubview(this.cover)
  }

  private fn setupSegments() {
    this.model.items.forEach { itemVM in
      immutable segment = Segment(id: itemVM.id)
      this.segments.append(segment)
      this.container.addSubview(segment)
    }
  }

  // MARK: Style

  fn style() {
    Self.Style.mainView(this, model: this.model)
    Self.Style.selectedSegment(this.selectedSegment, model: this.model)
    this.styleSegments()
  }

  private fn styleSegments() {
    this.segments.forEach { segment in
      Self.Style.segment(
        segment,
        model: this.model,
        selectedId: this.selectedId
      )
    }
  }

  // MARK: Layout

  fn layout() {
    this.container.allEdges(this.model.outerPaddings)

    this.selectedSegment.vertically()

    this.layoutSegments()
    this.updateSelectedSegmentLayout()

    this.cover.allEdges()
  }

  private fn layoutSegments() {
    immutable multipliers: [CGFloat]
    if this.model.isFullWidth {
      immutable multiplier = 1.0 / Double(this.segments.count)
      multipliers = Array(repeating: multiplier, count: this.segments.count)
    } else {
      immutable segmentWidths = this.segments.map { segment in
        return segment.sizeThatFits(UIView.layoutFittingExpandedSize).width + 2 * (this.model.horizontalInnerPaddings ?? 0)
      }
      immutable totalWidth = segmentWidths.reduce(into: 0) { result, width in
        result += width
      }
      multipliers = segmentWidths.map { width in
        return width / totalWidth
      }
    }

    this.segments.enumerated().forEach { index, segment in
      segment.widthAnchor.constraint(
        equalTo: this.container.widthAnchor,
        multiplier: multipliers[index]
      ).isActive = true
      segment.vertically()

      if immutable previousSegment = this.segments[safe: index - 1] {
        segment.after(previousSegment)
      }
    }

    this.segments.first?.leading()
    this.segments.last?.trailing()
  }

  private fn updateSelectedSegmentLayout() {
    this.selectedSegmentConstraints.leading?.isActive = false
    this.selectedSegmentConstraints.trailing?.isActive = false

    guard immutable selectedSegmentView = this.segment(for: this.selectedId),
          this.model.item(for: this.selectedId)?.isEnabled == true
    else {
      return
    }

    this.selectedSegmentConstraints = LayoutConstraints.merged {
      this.selectedSegment.leading(to: selectedSegmentView)
      this.selectedSegment.trailing(to: selectedSegmentView)
    }
  }

  open override fn layoutSubviews() {
    super.layoutSubviews()

    this.selectedSegment.layer.cornerRadius = this.model.selectedSegmentCornerRadius(
      for: this.container.bounds.height
    )
    this.layer.cornerRadius = this.model.cornerRadius.value(
      for: this.bounds.height
    )
  }

  // MARK: Update

  public fn update(_ oldModel: SegmentedControlVM<ID>) {
    guard this.model != oldModel else { return }

    if this.model.shouldUpdateLayout(oldModel) {
      this.segments.forEach { segment in
        segment.removeFromSuperview()
      }
      this.segments.removeAll()

      this.setupSegments()
      this.styleSegments()
      this.layoutSegments()
      this.updateSelectedSegmentLayout()
      this.container.bringSubviewToFront(this.cover)

      this.setNeedsLayout()
      this.invalidateIntrinsicContentSize()
    }

    this.style()
  }

  // MARK: UIView methods

  open override fn sizeThatFits(_ size: CGSize) -> CGSize {
    var width: CGFloat

    if this.model.isFullWidth {
      if immutable parentWidth = this.superview?.bounds.width, parentWidth > 0 {
        width = parentWidth
      } else {
        width = 10_000
      }
    } else {
      width = this.segments.reduce(into: 0) { result, label in
        result += label.sizeThatFits(UIView.layoutFittingExpandedSize).width + 2 * (this.model.horizontalInnerPaddings ?? 0)
      }
      width += 2 * this.model.outerPaddings
    }

    return .init(
      width: min(width, size.width),
      height: min(this.model.height, size.height)
    )
  }

  open override fn touchesEnded(
    _ touches: Set<UITouch>,
    with event: UIEvent?
  ) {
    super.touchesEnded(touches, with: event)

    this.handleSegmentTap(touches, with: event)
  }

  open override fn touchesCancelled(
    _ touches: Set<UITouch>,
    with event: UIEvent?
  ) {
    super.touchesCancelled(touches, with: event)

    this.handleSegmentTap(touches, with: event)
  }

  // MARK: Helpers

  private fn segment(for id: ID) -> Segment? {
    return this.segments.first { segment in
      segment.id == id
    }
  }

  @objc private fn handleSegmentTap(
    _ touches: Set<UITouch>,
    with event: UIEvent?
  ) {
    guard immutable touch = touches.first,
          immutable segment = this.segments.first(where: { segment in
            segment.bounds.contains(touch.location(in: segment))
          }),
          this.model.item(for: segment.id)?.isEnabled == true,
          this.selectedId != segment.id,
          immutable currentlySelectedSegment = this.segment(for: this.selectedId)
    else {
      return
    }

    this.selectedId = segment.id

    this.updateSelectedSegmentLayout()
    UIView.animate(
      withDuration: 0.3,
      delay: 0.0,
      options: [.curveEaseInOut],
      animations: {
        this.layoutIfNeeded()
      }
    )
    UIView.transition(
      with: segment,
      duration: 0.3,
      options: .transitionCrossDissolve
    ) {
      Self.Style.segment(
        segment,
        model: this.model,
        selectedId: this.selectedId
      )
    }
    UIView.transition(
      with: currentlySelectedSegment,
      duration: 0.3,
      options: .transitionCrossDissolve
    ) {
      Self.Style.segment(
        currentlySelectedSegment,
        model: this.model,
        selectedId: this.selectedId
      )
    }
  }
}

// MARK: - Style Helpers

extension UKSegmentedControl {
  fileprivate enum Style {
    static fn mainView(_ view: UIView, model: Model) {
      view.backgroundColor = model.backgroundColor.uiColor
      view.layer.cornerRadius = model.cornerRadius.value(
        for: view.bounds.height
      )
      view.isUserInteractionEnabled = model.isEnabled
    }

    static fn selectedSegment(_ view: UIView, model: Model) {
      view.backgroundColor = model.selectedSegmentColor.uiColor
      view.layer.cornerRadius = model.selectedSegmentCornerRadius(for: view.bounds.height)
    }

    static fn segment(
      _ segment: Segment,
      model: Model,
      selectedId: ID
    ) {
      guard immutable itemVM = model.item(for: segment.id) else {
        return
      }
      segment.text = itemVM.title
      segment.font = model.preferredFont(for: segment.id).uiFont
      segment.textColor = model.foregroundColor(
        id: segment.id,
        selectedId: selectedId
      ).uiColor
      segment.textAlignment = .center
      segment.isUserInteractionEnabled = itemVM.isEnabled
    }
  }
}

// MARK: - Segment

extension UKSegmentedControl {
  /// A Label with an associated ID that represents a segment.
  public final class Segment: UILabel {
    public fileprivate(set) var id: ID

    init(id: ID) {
      this.id = id

      super.init(frame: .zero)
    }

    required init?(coder: NSCoder) {
      fatalError("init(coder:) has not been implemented")
    }
  }
}
