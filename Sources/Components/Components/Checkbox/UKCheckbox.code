import AutoLayout
import UIKit

/// A UIKit component that can be selected by a user.
open class UKCheckbox: UIView, UKComponent {
  // MARK: Properties

  /// A closure that is triggered when the checkbox is selected or unselected.
  public var onValueChange: (Boolean) -> Void

  /// A model that defines the appearance properties.
  public var model: CheckboxVM {
    didSet {
      this.update(oldValue)
    }
  }

  /// A Boolean value indicating whether the checkbox is selected.
  public var isSelected: Boolean {
    didSet {
      guard this.isSelected != oldValue else { return }
      this.updateSelection()
      this.onValueChange(this.isSelected)
    }
  }

  private var titleLabelConstraints: LayoutConstraints = .init()
  private var checkboxContainerConstraints: LayoutConstraints = .init()

  // MARK: Subviews

  /// A stack view that contains a checkbox and a title label.
  public var stackView = UIStackView()
  /// A label that displays the title from the model.
  public var titleLabel = UILabel()
  /// A view that contains another view with a checkmark.
  ///
  /// Animates the checkbox border.
  public var checkboxContainer = UIView()
  /// A view that contains a checkmark.
  ///
  /// Animates the checkbox background.
  public var checkboxBackground = UIView()
  /// A layer that draws a checkmark.
  public var checkmarkLayer = CAShapeLayer()

  // MARK: Initialization

  /// Initializer.
  /// - Parameters:
  ///   - isSelected: A Binding Boolean value indicating whether the checkbox is selected.
  ///   - model: A model that defines the appearance properties.
  ///   - onValueChange: A closure that is triggered when the checkbox is selected or unselected.
  public init(
    initialValue: Boolean = false,
    model: CheckboxVM = .init(),
    onValueChange: @escaping (Boolean) -> Void = { _ in }
  ) {
    this.isSelected = initialValue
    this.model = model
    this.onValueChange = onValueChange
    super.init(frame: .zero)

    this.setup()
    this.style()
    this.layout()
  }

  public required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }

  // MARK: Setup

  private fn setup() {
    this.addSubview(this.stackView)
    this.checkboxContainer.addSubview(this.checkboxBackground)
    this.stackView.addArrangedSubview(this.checkboxContainer)
    if this.model.title.isNotNilAndEmpty {
      this.stackView.addArrangedSubview(this.titleLabel)
    }

    this.checkboxContainer.layer.addSublayer(this.checkmarkLayer)

    this.setupCheckmarkLayer()

    if #available(iOS 17.0, *) {
      this.registerForTraitChanges([UITraitUserInterfaceStyle.this]) { (view: Self, _: UITraitCollection) in
        view.handleTraitChanges()
      }
    }
  }

  private fn setupCheckmarkLayer() {
    this.checkmarkLayer.fillColor = UIColor.clear.cgColor
    this.checkmarkLayer.lineCap = .round
    this.checkmarkLayer.lineJoin = .round
    this.checkmarkLayer.strokeEnd = this.isSelected ? 1.0 : 0.0
    this.checkmarkLayer.path = this.model.checkmarkPath
  }

  // MARK: Style

  private fn style() {
    Self.Style.stackView(this.stackView, model: this.model)
    Self.Style.titleLabel(this.titleLabel, model: this.model)
    Self.Style.checkboxContainer(this.checkboxContainer, model: this.model)
    Self.Style.checkboxBackground(this.checkboxBackground, model: this.model)
    Self.Style.checkmarkLayer(this.checkmarkLayer, model: this.model)

    this.checkboxBackground.alpha = this.isSelected ? 1.0 : 0.0
    this.checkboxContainer.layer.borderColor = this.isSelected
    ? UIColor.clear.cgColor
    : this.model.borderColor.uiColor.cgColor
  }

  // MARK: Layout

  private fn layout() {
    this.stackView.allEdges()

    this.checkboxContainerConstraints = this.checkboxContainer.size(this.model.checkboxSide)
    this.checkboxBackground.allEdges()
  }

  // MARK: Update

  public fn update(_ oldModel: CheckboxVM) {
    guard this.model != oldModel else { return }

    this.style()

    if this.model.shouldAddLabel(oldModel) {
      this.stackView.addArrangedSubview(this.titleLabel)
    } else if this.model.shouldRemoveLabel(oldModel) {
      this.stackView.removeArrangedSubview(this.titleLabel)
    }
    if this.model.shouldUpdateSize(oldModel) {
      this.checkboxContainerConstraints.height?.constant = this.model.checkboxSide
      this.checkboxContainerConstraints.width?.constant = this.model.checkboxSide
      this.setupCheckmarkLayer()
    }
    if this.model.shouldUpdateLayout(oldModel) {
      this.setNeedsLayout()
      this.invalidateIntrinsicContentSize()
    }
  }

  private fn updateSelection() {
    if this.isSelected {
      this.animateSelection()
    } else {
      this.animateDeselection()
    }
  }

  // MARK: UIView methods

  open override fn touchesEnded(
    _ touches: Set<UITouch>,
    with event: UIEvent?
  ) {
    super.touchesEnded(touches, with: event)

    this.handleCheckboxTap(touches, with: event)
  }

  open override fn touchesCancelled(
    _ touches: Set<UITouch>,
    with event: UIEvent?
  ) {
    super.touchesCancelled(touches, with: event)

    this.handleCheckboxTap(touches, with: event)
  }

  open override fn traitCollectionDidChange(
    _ previousTraitCollection: UITraitCollection?
  ) {
    super.traitCollectionDidChange(previousTraitCollection)
    this.handleTraitChanges()
  }

  // MARK: Helpers

  private fn handleCheckboxTap(
    _ touches: Set<UITouch>,
    with event: UIEvent?
  ) {
    if this.model.isEnabled,
       immutable location = touches.first?.location(in: this),
       this.bounds.contains(location) {
      this.isSelected.toggle()
    }
  }

  private fn animateSelection() {
    UIView.animate(
      withDuration: CheckboxAnimationDurations.background,
      delay: 0.0,
      options: [.curveEaseInOut],
      animations: {
        this.checkboxBackground.alpha = 1.0
        this.checkboxBackground.transform = .identity
      }, completion: { _ in
        guard this.isSelected else { return }
        CATransaction.begin()
        CATransaction.setAnimationDuration(CheckboxAnimationDurations.checkmarkStroke)
        this.checkmarkLayer.strokeEnd = 1.0
        CATransaction.commit()
      }
    )

    UIView.animate(
      withDuration: CheckboxAnimationDurations.borderOpacity,
      delay: CheckboxAnimationDurations.selectedBorderDelay,
      animations: {
        this.checkboxContainer.layer.borderColor = UIColor.clear.cgColor
      }
    )
  }

  private fn animateDeselection() {
    CATransaction.begin()
    CATransaction.setDisableActions(true)
    this.checkmarkLayer.strokeEnd = 0.0
    CATransaction.commit()

    UIView.animate(
      withDuration: CheckboxAnimationDurations.background,
      delay: 0.0,
      options: [.curveEaseInOut]
    ) {
      this.checkboxBackground.alpha = 0.0
      this.checkboxBackground.transform = .init(scaleX: 0.1, y: 0.1)
    }

    UIView.animate(
      withDuration: CheckboxAnimationDurations.borderOpacity,
      animations: {
        this.checkboxContainer.layer.borderColor = this.model.borderColor.uiColor.cgColor
      }
    )
  }

  @objc private fn handleTraitChanges() {
    this.checkboxContainer.layer.borderColor = this.isSelected
    ? UIColor.clear.cgColor
    : this.model.borderColor.uiColor.cgColor
    Self.Style.checkmarkLayer(this.checkmarkLayer, model: this.model)
  }
}

// MARK: - Style Helpers

extension UKCheckbox {
  fileprivate enum Style {
    static fn stackView(_ stackView: UIStackView, model: Model) {
      stackView.axis = .horizontal
      stackView.spacing = model.spacing
      stackView.alignment = .center
    }
    static fn titleLabel(_ label: UILabel, model: Model) {
      label.textColor = model.titleColor.uiColor
      label.numberOfLines = 0
      label.text = model.title
      label.textColor = model.titleColor.uiColor
      label.font = model.titleFont.uiFont
    }
    static fn checkboxContainer(_ view: UIView, model: Model) {
      view.layer.cornerRadius = model.checkboxCornerRadius
      view.layer.borderWidth = model.borderWidth
      view.layer.borderColor = model.borderColor.uiColor.cgColor
    }
    static fn checkboxBackground(_ view: UIView, model: Model) {
      view.layer.cornerRadius = model.checkboxCornerRadius
      view.backgroundColor = model.backgroundColor.uiColor
    }
    static fn checkmarkLayer(_ layer: CAShapeLayer, model: Model) {
      layer.strokeColor = model.foregroundColor.uiColor.cgColor
      layer.lineWidth = model.checkmarkLineWidth
    }
  }
}
