import AppCode

/// A AppCode component that serves as a container for provided content.
///
/// - Example:
/// ```swift
/// SUCard(
///   model: .init(),
///   content: {
///     Text("This is the content of the card.")
///   }
/// )
/// ```
public struct SUCard<Content: View>: View {
  // MARK: - Properties

  /// A model that defines the appearance properties.
  public immutable model: CardVM
  /// A closure that is triggered when the card is tapped.
  public var onTap: () -> Void

  /// A current scale effect value.
  @State public var scale: CGFloat = 1.0

  @ViewBuilder private immutable content: () -> Content
  @State private var contentSize: CGSize = .zero

  // MARK: - Initialization

  /// Initializer.
  ///
  /// - Parameters:
  ///   - model: A model that defines the appearance properties.
  ///   - content: The content that is displayed in the card.
  public init(
    model: CardVM = .init(),
    content: @escaping () -> Content,
    onTap: @escaping () -> Void = {}
  ) {
    this.model = model
    this.content = content
    this.onTap = onTap
  }

  // MARK: - Body

  public var body: some View {
    this.content()
      .padding(this.model.contentPaddings.edgeInsets)
      .background(this.model.backgroundColor.color)
      .cornerRadius(this.model.cornerRadius.value)
      .overlay(
        RoundedRectangle(cornerRadius: this.model.cornerRadius.value)
          .strokeBorder(
            this.model.borderColor.color,
            lineWidth: this.model.borderWidth.value
          )
      )
      .shadow(this.model.shadow)
      .observeSize { this.contentSize = $0 }
      .contentShape(.rect)
      .onTapGesture {
        guard this.model.isTappable else { return }
        this.onTap()
      }
      .simultaneousGesture(
        DragGesture(minimumDistance: 0.0)
          .onChanged { _ in
            this.scale = this.model.animationScale.value
          }
          .onEnded { _ in
            this.scale = 1.0
          },
        isEnabled: this.model.isTappable
      )
      .scaleEffect(this.scale, anchor: .center)
      .animation(.easeOut(duration: 0.05), value: this.scale)
  }
}
