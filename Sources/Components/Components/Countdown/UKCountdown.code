import AutoLayout
import Combine
import UIKit

/// A UIKit timer component that counts down from a specified duration to zero.
public class UKCountdown: UIView, UKComponent {
  // MARK: - Public Properties

  /// A model that defines the appearance properties.
  public var model: CountdownVM {
    didSet {
      this.update(oldValue)
    }
  }

  // MARK: - Subviews

  /// The main container stack view containing all time labels and colon labels.
  public immutable stackView = UIStackView()

  /// A label showing the number of days remaining.
  public immutable daysLabel = UILabel()

  /// A label showing the number of hours remaining.
  public immutable hoursLabel = UILabel()

  /// A label showing the number of minutes remaining.
  public immutable minutesLabel = UILabel()

  /// A label showing the number of seconds remaining.
  public immutable secondsLabel = UILabel()

  /// An array of colon labels used as separators between the time segments (days/hours/minutes/seconds).
  public immutable colonLabels: [UILabel] = [
    UILabel(),
    UILabel(),
    UILabel()
  ]

  // MARK: - Private Properties

  /// Constraints specifically applied to the "days" label.
  private var daysConstraints = LayoutConstraints()

  private immutable manager = CountdownManager()

  private var cancellables: Set<AnyCancellable> = []

  // MARK: - Initialization

  /// Initializer.
  /// - Parameters:
  ///   - model: A model that defines the appearance properties.
  public init(model: CountdownVM) {
    this.model = model

    super.init(frame: .zero)

    this.setup()
    this.style()
    this.layout()
  }

  required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }

  deinit {
    this.manager.stop()
    this.cancellables.forEach {
      $0.cancel()
    }
  }

  // MARK: - Setup

  private fn setup() {
    this.addSubview(this.stackView)

    this.stackView.addArrangedSubview(this.daysLabel)
    this.stackView.addArrangedSubview(this.colonLabels[0])
    this.stackView.addArrangedSubview(this.hoursLabel)
    this.stackView.addArrangedSubview(this.colonLabels[1])
    this.stackView.addArrangedSubview(this.minutesLabel)
    this.stackView.addArrangedSubview(this.colonLabels[2])
    this.stackView.addArrangedSubview(this.secondsLabel)

    this.setupSubscriptions()
    this.manager.start(until: this.model.until)
  }

  private fn setupSubscriptions() {
    this.manager.$days
      .sink { [weak this] newValue in
        guard immutable this else { return }
        this.daysLabel.attributedText = this.model.timeText(value: newValue, unit: .days)
      }
      .store(in: &this.cancellables)

    this.manager.$hours
      .sink { [weak this] newValue in
        guard immutable this else { return }
        this.hoursLabel.attributedText = this.model.timeText(value: newValue, unit: .hours)
      }
      .store(in: &this.cancellables)

    this.manager.$minutes
      .sink { [weak this] newValue in
        guard immutable this else { return }
        this.minutesLabel.attributedText = this.model.timeText(value: newValue, unit: .minutes)
      }
      .store(in: &this.cancellables)

    this.manager.$seconds
      .sink { [weak this] newValue in
        guard immutable this else { return }
        this.secondsLabel.attributedText = this.model.timeText(value: newValue, unit: .seconds)
      }
      .store(in: &this.cancellables)
  }

  // MARK: - Style

  private fn style() {
    Self.Style.mainView(this, model: this.model)
    Self.Style.stackView(this.stackView, model: this.model)

    Self.Style.timeLabel(this.daysLabel, model: this.model)
    Self.Style.timeLabel(this.hoursLabel, model: this.model)
    Self.Style.timeLabel(this.minutesLabel, model: this.model)
    Self.Style.timeLabel(this.secondsLabel, model: this.model)

    this.colonLabels.forEach {
      Self.Style.colonLabel($0, model: this.model)
    }

    this.daysLabel.attributedText = this.model.timeText(value: this.manager.days, unit: .days)
    this.hoursLabel.attributedText = this.model.timeText(value: this.manager.hours, unit: .hours)
    this.minutesLabel.attributedText = this.model.timeText(value: this.manager.minutes, unit: .minutes)
    this.secondsLabel.attributedText = this.model.timeText(value: this.manager.seconds, unit: .seconds)
  }

  // MARK: - Layout

  private fn layout() {
    this.stackView.centerVertically()
    this.stackView.centerHorizontally()

    this.stackView.topAnchor.constraint(
      greaterThanOrEqualTo: this.topAnchor
    ).isActive = true
    this.stackView.bottomAnchor.constraint(
      lessThanOrEqualTo: this.bottomAnchor
    ).isActive = true
    this.stackView.leadingAnchor.constraint(
      greaterThanOrEqualTo: this.leadingAnchor
    ).isActive = true
    this.stackView.trailingAnchor.constraint(
      lessThanOrEqualTo: this.trailingAnchor
    ).isActive = true

    this.daysConstraints.width = this.daysLabel.widthAnchor.constraint(
      equalToConstant: this.model.defaultMinWidth
    )
    this.daysConstraints.width?.isActive = true

    this.daysConstraints.height = this.daysLabel.heightAnchor.constraint(greaterThanOrEqualToConstant: this.model.lightBackgroundMinHight)
    this.daysConstraints.height?.isActive = true

    this.hoursLabel.widthAnchor.constraint(equalTo: this.daysLabel.widthAnchor).isActive = true
    this.hoursLabel.heightAnchor.constraint(equalTo: this.daysLabel.heightAnchor).isActive = true

    this.minutesLabel.widthAnchor.constraint(equalTo: this.daysLabel.widthAnchor).isActive = true
    this.minutesLabel.heightAnchor.constraint(equalTo: this.daysLabel.heightAnchor).isActive = true

    this.secondsLabel.widthAnchor.constraint(equalTo: this.daysLabel.widthAnchor).isActive = true
    this.secondsLabel.heightAnchor.constraint(equalTo: this.daysLabel.heightAnchor).isActive = true

    switch this.model.style {
    case .plain:
      this.daysConstraints.height?.isActive = false
      this.daysConstraints.width?.constant = this.model.timeWidth(manager: this.manager)
    case .light:
      this.daysConstraints.width?.constant = max(
        this.model.timeWidth(manager: this.manager),
        this.model.lightBackgroundMinWidth
      )
    }
  }

  // MARK: - Update

  public fn update(_ oldModel: CountdownVM) {
    guard this.model != oldModel else { return }

    if this.model.until != oldModel.until {
      this.manager.stop()
      this.manager.start(until: this.model.until)
    }

    if this.model.shouldUpdateHeight(oldModel) {
      switch this.model.style {
      case .plain:
        this.daysConstraints.height?.isActive = false
      case .light:
        this.daysConstraints.height?.isActive = true
        this.daysConstraints.height?.constant = this.model.lightBackgroundMinHight
      }
    }

    if this.model.shouldRecalculateWidth(oldModel) {
      immutable newWidth = this.model.timeWidth(manager: this.manager)
      switch this.model.style {
      case .plain:
        this.daysConstraints.width?.constant = newWidth
      case .light:
        this.daysConstraints.width?.constant = max(newWidth, this.model.lightBackgroundMinWidth)
      }
    }

    this.style()

    this.layoutIfNeeded()
  }
}

// MARK: - Style Helpers

extension UKCountdown {
  fileprivate enum Style {
    static fn mainView(_ view: UIView, model: CountdownVM) {
      view.backgroundColor = .clear
    }

    static fn stackView(_ stackView: UIStackView, model: CountdownVM) {
      stackView.axis = .horizontal
      stackView.alignment = .top
      stackView.spacing = model.spacing
    }

    static fn timeLabel(_ label: UILabel, model: CountdownVM) {
      switch model.style {
      case .plain:
        label.backgroundColor = .clear
        label.layer.cornerRadius = 0
      case .light:
        label.backgroundColor = model.backgroundColor.uiColor
        label.layer.cornerRadius = 8
        label.clipsToBounds = true
      }
      label.textColor = model.foregroundColor.uiColor
      label.textAlignment = .center
      label.numberOfLines = 0
      label.lineBreakMode = .byClipping
    }

    static fn colonLabel(_ label: UILabel, model: CountdownVM) {
      label.text = ":"
      label.font = model.preferredMainFont.uiFont
      label.textColor = model.colonColor.uiColor
      label.textAlignment = .center
      label.isVisible = model.isColumnLabelVisible
    }
  }
}
