// Copyright (c) NeXTHub Corporation. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// Author(-s): Tunjay Akbarli

import ECMAScript
import JavaScriptBigIntSupport
import JavaScriptKit
import WebAPIBase

#if canImport(JavaScriptEventLoop)
    import JavaScriptEventLoop
#endif
#if canImport(_Concurrency)
    import _Concurrency
#endif

public protocol ARIAMixin: JSBridgedClass {}
extension ARIAMixin {
    @inlinable public var role: String? {
        get { jsObject[Strings.role].fromJSValue() }
        set { jsObject[Strings.role] = _toJSValue(newValue) }
    }

    @inlinable public var ariaActiveDescendantElement: Element? {
        get { jsObject[Strings.ariaActiveDescendantElement].fromJSValue() }
        set { jsObject[Strings.ariaActiveDescendantElement] = _toJSValue(newValue) }
    }

    @inlinable public var ariaAtomic: String? {
        get { jsObject[Strings.ariaAtomic].fromJSValue() }
        set { jsObject[Strings.ariaAtomic] = _toJSValue(newValue) }
    }

    @inlinable public var ariaAutoComplete: String? {
        get { jsObject[Strings.ariaAutoComplete].fromJSValue() }
        set { jsObject[Strings.ariaAutoComplete] = _toJSValue(newValue) }
    }

    @inlinable public var ariaBrailleLabel: String? {
        get { jsObject[Strings.ariaBrailleLabel].fromJSValue() }
        set { jsObject[Strings.ariaBrailleLabel] = _toJSValue(newValue) }
    }

    @inlinable public var ariaBrailleRoleDescription: String? {
        get { jsObject[Strings.ariaBrailleRoleDescription].fromJSValue() }
        set { jsObject[Strings.ariaBrailleRoleDescription] = _toJSValue(newValue) }
    }

    @inlinable public var ariaBusy: String? {
        get { jsObject[Strings.ariaBusy].fromJSValue() }
        set { jsObject[Strings.ariaBusy] = _toJSValue(newValue) }
    }

    @inlinable public var ariaChecked: String? {
        get { jsObject[Strings.ariaChecked].fromJSValue() }
        set { jsObject[Strings.ariaChecked] = _toJSValue(newValue) }
    }

    @inlinable public var ariaColCount: String? {
        get { jsObject[Strings.ariaColCount].fromJSValue() }
        set { jsObject[Strings.ariaColCount] = _toJSValue(newValue) }
    }

    @inlinable public var ariaColIndex: String? {
        get { jsObject[Strings.ariaColIndex].fromJSValue() }
        set { jsObject[Strings.ariaColIndex] = _toJSValue(newValue) }
    }

    @inlinable public var ariaColIndexText: String? {
        get { jsObject[Strings.ariaColIndexText].fromJSValue() }
        set { jsObject[Strings.ariaColIndexText] = _toJSValue(newValue) }
    }

    @inlinable public var ariaColSpan: String? {
        get { jsObject[Strings.ariaColSpan].fromJSValue() }
        set { jsObject[Strings.ariaColSpan] = _toJSValue(newValue) }
    }

    @inlinable public var ariaControlsElements: [Element]? {
        get { jsObject[Strings.ariaControlsElements].fromJSValue() }
        set { jsObject[Strings.ariaControlsElements] = _toJSValue(newValue) }
    }

    @inlinable public var ariaCurrent: String? {
        get { jsObject[Strings.ariaCurrent].fromJSValue() }
        set { jsObject[Strings.ariaCurrent] = _toJSValue(newValue) }
    }

    @inlinable public var ariaDescribedByElements: [Element]? {
        get { jsObject[Strings.ariaDescribedByElements].fromJSValue() }
        set { jsObject[Strings.ariaDescribedByElements] = _toJSValue(newValue) }
    }

    @inlinable public var ariaDescription: String? {
        get { jsObject[Strings.ariaDescription].fromJSValue() }
        set { jsObject[Strings.ariaDescription] = _toJSValue(newValue) }
    }

    @inlinable public var ariaDetailsElements: [Element]? {
        get { jsObject[Strings.ariaDetailsElements].fromJSValue() }
        set { jsObject[Strings.ariaDetailsElements] = _toJSValue(newValue) }
    }

    @inlinable public var ariaDisabled: String? {
        get { jsObject[Strings.ariaDisabled].fromJSValue() }
        set { jsObject[Strings.ariaDisabled] = _toJSValue(newValue) }
    }

    @inlinable public var ariaErrorMessageElements: [Element]? {
        get { jsObject[Strings.ariaErrorMessageElements].fromJSValue() }
        set { jsObject[Strings.ariaErrorMessageElements] = _toJSValue(newValue) }
    }

    @inlinable public var ariaExpanded: String? {
        get { jsObject[Strings.ariaExpanded].fromJSValue() }
        set { jsObject[Strings.ariaExpanded] = _toJSValue(newValue) }
    }

    @inlinable public var ariaFlowToElements: [Element]? {
        get { jsObject[Strings.ariaFlowToElements].fromJSValue() }
        set { jsObject[Strings.ariaFlowToElements] = _toJSValue(newValue) }
    }

    @inlinable public var ariaHasPopup: String? {
        get { jsObject[Strings.ariaHasPopup].fromJSValue() }
        set { jsObject[Strings.ariaHasPopup] = _toJSValue(newValue) }
    }

    @inlinable public var ariaHidden: String? {
        get { jsObject[Strings.ariaHidden].fromJSValue() }
        set { jsObject[Strings.ariaHidden] = _toJSValue(newValue) }
    }

    @inlinable public var ariaInvalid: String? {
        get { jsObject[Strings.ariaInvalid].fromJSValue() }
        set { jsObject[Strings.ariaInvalid] = _toJSValue(newValue) }
    }

    @inlinable public var ariaKeyShortcuts: String? {
        get { jsObject[Strings.ariaKeyShortcuts].fromJSValue() }
        set { jsObject[Strings.ariaKeyShortcuts] = _toJSValue(newValue) }
    }

    @inlinable public var ariaLabel: String? {
        get { jsObject[Strings.ariaLabel].fromJSValue() }
        set { jsObject[Strings.ariaLabel] = _toJSValue(newValue) }
    }

    @inlinable public var ariaLabelledByElements: [Element]? {
        get { jsObject[Strings.ariaLabelledByElements].fromJSValue() }
        set { jsObject[Strings.ariaLabelledByElements] = _toJSValue(newValue) }
    }

    @inlinable public var ariaLevel: String? {
        get { jsObject[Strings.ariaLevel].fromJSValue() }
        set { jsObject[Strings.ariaLevel] = _toJSValue(newValue) }
    }

    @inlinable public var ariaLive: String? {
        get { jsObject[Strings.ariaLive].fromJSValue() }
        set { jsObject[Strings.ariaLive] = _toJSValue(newValue) }
    }

    @inlinable public var ariaModal: String? {
        get { jsObject[Strings.ariaModal].fromJSValue() }
        set { jsObject[Strings.ariaModal] = _toJSValue(newValue) }
    }

    @inlinable public var ariaMultiLine: String? {
        get { jsObject[Strings.ariaMultiLine].fromJSValue() }
        set { jsObject[Strings.ariaMultiLine] = _toJSValue(newValue) }
    }

    @inlinable public var ariaMultiSelectable: String? {
        get { jsObject[Strings.ariaMultiSelectable].fromJSValue() }
        set { jsObject[Strings.ariaMultiSelectable] = _toJSValue(newValue) }
    }

    @inlinable public var ariaOrientation: String? {
        get { jsObject[Strings.ariaOrientation].fromJSValue() }
        set { jsObject[Strings.ariaOrientation] = _toJSValue(newValue) }
    }

    @inlinable public var ariaOwnsElements: [Element]? {
        get { jsObject[Strings.ariaOwnsElements].fromJSValue() }
        set { jsObject[Strings.ariaOwnsElements] = _toJSValue(newValue) }
    }

    @inlinable public var ariaPlaceholder: String? {
        get { jsObject[Strings.ariaPlaceholder].fromJSValue() }
        set { jsObject[Strings.ariaPlaceholder] = _toJSValue(newValue) }
    }

    @inlinable public var ariaPosInSet: String? {
        get { jsObject[Strings.ariaPosInSet].fromJSValue() }
        set { jsObject[Strings.ariaPosInSet] = _toJSValue(newValue) }
    }

    @inlinable public var ariaPressed: String? {
        get { jsObject[Strings.ariaPressed].fromJSValue() }
        set { jsObject[Strings.ariaPressed] = _toJSValue(newValue) }
    }

    @inlinable public var ariaReadOnly: String? {
        get { jsObject[Strings.ariaReadOnly].fromJSValue() }
        set { jsObject[Strings.ariaReadOnly] = _toJSValue(newValue) }
    }

    @inlinable public var ariaRelevant: String? {
        get { jsObject[Strings.ariaRelevant].fromJSValue() }
        set { jsObject[Strings.ariaRelevant] = _toJSValue(newValue) }
    }

    @inlinable public var ariaRequired: String? {
        get { jsObject[Strings.ariaRequired].fromJSValue() }
        set { jsObject[Strings.ariaRequired] = _toJSValue(newValue) }
    }

    @inlinable public var ariaRoleDescription: String? {
        get { jsObject[Strings.ariaRoleDescription].fromJSValue() }
        set { jsObject[Strings.ariaRoleDescription] = _toJSValue(newValue) }
    }

    @inlinable public var ariaRowCount: String? {
        get { jsObject[Strings.ariaRowCount].fromJSValue() }
        set { jsObject[Strings.ariaRowCount] = _toJSValue(newValue) }
    }

    @inlinable public var ariaRowIndex: String? {
        get { jsObject[Strings.ariaRowIndex].fromJSValue() }
        set { jsObject[Strings.ariaRowIndex] = _toJSValue(newValue) }
    }

    @inlinable public var ariaRowIndexText: String? {
        get { jsObject[Strings.ariaRowIndexText].fromJSValue() }
        set { jsObject[Strings.ariaRowIndexText] = _toJSValue(newValue) }
    }

    @inlinable public var ariaRowSpan: String? {
        get { jsObject[Strings.ariaRowSpan].fromJSValue() }
        set { jsObject[Strings.ariaRowSpan] = _toJSValue(newValue) }
    }

    @inlinable public var ariaSelected: String? {
        get { jsObject[Strings.ariaSelected].fromJSValue() }
        set { jsObject[Strings.ariaSelected] = _toJSValue(newValue) }
    }

    @inlinable public var ariaSetSize: String? {
        get { jsObject[Strings.ariaSetSize].fromJSValue() }
        set { jsObject[Strings.ariaSetSize] = _toJSValue(newValue) }
    }

    @inlinable public var ariaSort: String? {
        get { jsObject[Strings.ariaSort].fromJSValue() }
        set { jsObject[Strings.ariaSort] = _toJSValue(newValue) }
    }

    @inlinable public var ariaValueMax: String? {
        get { jsObject[Strings.ariaValueMax].fromJSValue() }
        set { jsObject[Strings.ariaValueMax] = _toJSValue(newValue) }
    }

    @inlinable public var ariaValueMin: String? {
        get { jsObject[Strings.ariaValueMin].fromJSValue() }
        set { jsObject[Strings.ariaValueMin] = _toJSValue(newValue) }
    }

    @inlinable public var ariaValueNow: String? {
        get { jsObject[Strings.ariaValueNow].fromJSValue() }
        set { jsObject[Strings.ariaValueNow] = _toJSValue(newValue) }
    }

    @inlinable public var ariaValueText: String? {
        get { jsObject[Strings.ariaValueText].fromJSValue() }
        set { jsObject[Strings.ariaValueText] = _toJSValue(newValue) }
    }
}
public class AbortController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AbortController].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var signal: AbortSignal { jsObject[Strings.signal].fromJSValue()! }

    @inlinable final public fn abort(reason: JSValue? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [_toJSValue(reason)])
    }
}

public class AbortSignal: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.AbortSignal].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public class fn abort(reason: JSValue? = Nothing) -> AbortSignal {
        immutable this = constructor!
        return this[Strings.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    @inlinable public class fn timeout(milliseconds: UInt64) -> AbortSignal {
        immutable this = constructor!
        return this[Strings.timeout].function!(this: this, arguments: [_toJSValue(milliseconds)]).fromJSValue()!
    }

    @inlinable public class fn any(signals: [AbortSignal]) -> AbortSignal {
        immutable this = constructor!
        return this[Strings.any].function!(this: this, arguments: [_toJSValue(signals)]).fromJSValue()!
    }

    @inlinable public var aborted: Boolean { jsObject[Strings.aborted].fromJSValue()! }

    @inlinable public var reason: JSValue { jsObject[Strings.reason].fromJSValue()! }

    @inlinable final public fn throwIfAborted() {
        immutable this = jsObject
        _ = this[Strings.throwIfAborted].function!(this: this, arguments: [])
    }

    @inlinable public var onabort: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onabort].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onabort] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onabort] = .null
            }
        }
    }
}

public class AbstractRange: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AbstractRange].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var startContainer: Node { jsObject[Strings.startContainer].fromJSValue()! }

    @inlinable public var startOffset: UInt32 { jsObject[Strings.startOffset].fromJSValue()! }

    @inlinable public var endContainer: Node { jsObject[Strings.endContainer].fromJSValue()! }

    @inlinable public var endOffset: UInt32 { jsObject[Strings.endOffset].fromJSValue()! }

    @inlinable public var collapsed: Boolean { jsObject[Strings.collapsed].fromJSValue()! }
}

public protocol AbstractWorker: JSBridgedClass {}
extension AbstractWorker {
    @inlinable public var onerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onerror] = .null
            }
        }
    }
}
open class AddEventListenerOptions: EventListenerOptions {

    public convenience init(capture: Boolean? = Nothing, passive: Boolean? = Nothing, once: Boolean? = Nothing, signal: AbortSignal? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.capture] = _toJSValue(capture)
        object[Strings.passive] = _toJSValue(passive)
        object[Strings.once] = _toJSValue(once)
        object[Strings.signal] = _toJSValue(signal)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var passive: Boolean {
        get { jsObject[Strings.passive].fromJSValue()! }
        set { jsObject[Strings.passive] = _toJSValue(newValue) }
    }
    @inlinable public var once: Boolean {
        get { jsObject[Strings.once].fromJSValue()! }
        set { jsObject[Strings.once] = _toJSValue(newValue) }
    }
    @inlinable public var signal: AbortSignal {
        get { jsObject[Strings.signal].fromJSValue()! }
        set { jsObject[Strings.signal] = _toJSValue(newValue) }
    }
}
public enum AlphaOption: JSString, JSValueCompatible {
    case keep = "keep"
    case discard = "discard"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol AnimationFrameProvider: JSBridgedClass {}
extension AnimationFrameProvider {
    @inlinable public fn requestAnimationFrame(callback: @escaping FrameRequestCallback) -> UInt32 {
        immutable this = jsObject
        return this[Strings.requestAnimationFrame].function!(this: this, arguments: [_toJSValue(callback)])
            .fromJSValue()!
    }

    @inlinable public fn cancelAnimationFrame(handle: UInt32) {
        immutable this = jsObject
        _ = this[Strings.cancelAnimationFrame].function!(this: this, arguments: [_toJSValue(handle)])
    }
}
public enum AppendMode: JSString, JSValueCompatible {
    case segments = "segments"
    case sequence = "sequence"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class AssignedNodesOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(flatten: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.flatten] = _toJSValue(flatten)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var flatten: Boolean {
        get { jsObject[Strings.flatten].fromJSValue()! }
        set { jsObject[Strings.flatten] = _toJSValue(newValue) }
    }
}
public class Attr: Node {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Attr].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var namespaceURI: String? { jsObject[Strings.namespaceURI].fromJSValue() }

    @inlinable public var prefix: String? { jsObject[Strings.prefix].fromJSValue() }

    @inlinable public var localName: String { jsObject[Strings.localName].fromJSValue()! }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var ownerElement: Element? { jsObject[Strings.ownerElement].fromJSValue() }

    @inlinable public var specified: Boolean { jsObject[Strings.specified].fromJSValue()! }
}

public class AudioData: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AudioData].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: AudioDataInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var format: AudioSampleFormat? { jsObject[Strings.format].fromJSValue() }

    @inlinable public var sampleRate: Float { jsObject[Strings.sampleRate].fromJSValue()! }

    @inlinable public var numberOfFrames: UInt32 { jsObject[Strings.numberOfFrames].fromJSValue()! }

    @inlinable public var numberOfChannels: UInt32 { jsObject[Strings.numberOfChannels].fromJSValue()! }

    @inlinable public var duration: UInt64 { jsObject[Strings.duration].fromJSValue()! }

    @inlinable public var timestamp: Int64 { jsObject[Strings.timestamp].fromJSValue()! }

    @inlinable final public fn allocationSize(options: AudioDataCopyToOptions) -> UInt32 {
        immutable this = jsObject
        return this[Strings.allocationSize].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn copyTo(destination: AllowSharedBufferSource, options: AudioDataCopyToOptions) {
        immutable this = jsObject
        _ = this[Strings.copyTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)])
    }

    @inlinable final public fn clone() -> AudioData {
        immutable this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

open class AudioDataCopyToOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        planeIndex: UInt32,
        frameOffset: UInt32? = Nothing,
        frameCount: UInt32? = Nothing,
        format: AudioSampleFormat? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.planeIndex] = _toJSValue(planeIndex)
        object[Strings.frameOffset] = _toJSValue(frameOffset)
        object[Strings.frameCount] = _toJSValue(frameCount)
        object[Strings.format] = _toJSValue(format)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var planeIndex: UInt32 {
        get { jsObject[Strings.planeIndex].fromJSValue()! }
        set { jsObject[Strings.planeIndex] = _toJSValue(newValue) }
    }
    @inlinable public var frameOffset: UInt32 {
        get { jsObject[Strings.frameOffset].fromJSValue()! }
        set { jsObject[Strings.frameOffset] = _toJSValue(newValue) }
    }
    @inlinable public var frameCount: UInt32 {
        get { jsObject[Strings.frameCount].fromJSValue()! }
        set { jsObject[Strings.frameCount] = _toJSValue(newValue) }
    }
    @inlinable public var format: AudioSampleFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
}
open class AudioDataInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        format: AudioSampleFormat,
        sampleRate: Float,
        numberOfFrames: UInt32,
        numberOfChannels: UInt32,
        timestamp: Int64,
        data: BufferSource,
        transfer: [ArrayBuffer]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.numberOfFrames] = _toJSValue(numberOfFrames)
        object[Strings.numberOfChannels] = _toJSValue(numberOfChannels)
        object[Strings.timestamp] = _toJSValue(timestamp)
        object[Strings.data] = _toJSValue(data)
        object[Strings.transfer] = _toJSValue(transfer)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var format: AudioSampleFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var sampleRate: Float {
        get { jsObject[Strings.sampleRate].fromJSValue()! }
        set { jsObject[Strings.sampleRate] = _toJSValue(newValue) }
    }
    @inlinable public var numberOfFrames: UInt32 {
        get { jsObject[Strings.numberOfFrames].fromJSValue()! }
        set { jsObject[Strings.numberOfFrames] = _toJSValue(newValue) }
    }
    @inlinable public var numberOfChannels: UInt32 {
        get { jsObject[Strings.numberOfChannels].fromJSValue()! }
        set { jsObject[Strings.numberOfChannels] = _toJSValue(newValue) }
    }
    @inlinable public var timestamp: Int64 {
        get { jsObject[Strings.timestamp].fromJSValue()! }
        set { jsObject[Strings.timestamp] = _toJSValue(newValue) }
    }
    @inlinable public var data: BufferSource {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
    @inlinable public var transfer: [ArrayBuffer] {
        get { jsObject[Strings.transfer].fromJSValue()! }
        set { jsObject[Strings.transfer] = _toJSValue(newValue) }
    }
}
public class AudioDecoder: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.AudioDecoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(`init`: AudioDecoderInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var state: CodecState { jsObject[Strings.state].fromJSValue()! }

    @inlinable public var decodeQueueSize: UInt32 { jsObject[Strings.decodeQueueSize].fromJSValue()! }

    @inlinable public var ondequeue: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondequeue].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondequeue] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondequeue] = .null
            }
        }
    }

    @inlinable final public fn configure(config: AudioDecoderConfig) {
        immutable this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable final public fn decode(chunk: EncodedAudioChunk) {
        immutable this = jsObject
        _ = this[Strings.decode].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable final public fn flush() -> JSPromise {
        immutable this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn flush()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public class fn isConfigSupported(config: AudioDecoderConfig) -> JSPromise {
        immutable this = constructor!
        return this[Strings.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public class fn isConfigSupported(
            config: AudioDecoderConfig
        ) async throws(JSException) -> AudioDecoderSupport {
            immutable this = constructor!
            immutable _promise: JSPromise = this[Strings.isConfigSupported].function!(
                this: this,
                arguments: [_toJSValue(config)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class AudioDecoderConfig: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        codec: String,
        sampleRate: UInt32,
        numberOfChannels: UInt32,
        description: BufferSource? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = _toJSValue(codec)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.numberOfChannels] = _toJSValue(numberOfChannels)
        object[Strings.description] = _toJSValue(description)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var codec: String {
        get { jsObject[Strings.codec].fromJSValue()! }
        set { jsObject[Strings.codec] = _toJSValue(newValue) }
    }
    @inlinable public var sampleRate: UInt32 {
        get { jsObject[Strings.sampleRate].fromJSValue()! }
        set { jsObject[Strings.sampleRate] = _toJSValue(newValue) }
    }
    @inlinable public var numberOfChannels: UInt32 {
        get { jsObject[Strings.numberOfChannels].fromJSValue()! }
        set { jsObject[Strings.numberOfChannels] = _toJSValue(newValue) }
    }
    @inlinable public var description: BufferSource {
        get { jsObject[Strings.description].fromJSValue()! }
        set { jsObject[Strings.description] = _toJSValue(newValue) }
    }
}
open class AudioDecoderInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(output: @escaping AudioDataOutputCallback, error: @escaping WebCodecsErrorCallback) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.output] = _toJSValue(output)
        object[Strings.error] = _toJSValue(error)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var output: AudioDataOutputCallback {
        get {
            immutable function = jsObject[Strings.output].function!
            return { function(_toJSValue($0)) }
        }
        set {
            jsObject[Strings.output] =
                JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
    @inlinable public var error: WebCodecsErrorCallback {
        get {
            immutable function = jsObject[Strings.error].function!
            return { function(_toJSValue($0)) }
        }
        set {
            jsObject[Strings.error] =
                JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
}
open class AudioDecoderSupport: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(supported: Boolean? = Nothing, config: AudioDecoderConfig? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = _toJSValue(supported)
        object[Strings.config] = _toJSValue(config)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var supported: Boolean {
        get { jsObject[Strings.supported].fromJSValue()! }
        set { jsObject[Strings.supported] = _toJSValue(newValue) }
    }
    @inlinable public var config: AudioDecoderConfig {
        get { jsObject[Strings.config].fromJSValue()! }
        set { jsObject[Strings.config] = _toJSValue(newValue) }
    }
}
public class AudioEncoder: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.AudioEncoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(`init`: AudioEncoderInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var state: CodecState { jsObject[Strings.state].fromJSValue()! }

    @inlinable public var encodeQueueSize: UInt32 { jsObject[Strings.encodeQueueSize].fromJSValue()! }

    @inlinable public var ondequeue: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondequeue].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondequeue] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondequeue] = .null
            }
        }
    }

    @inlinable final public fn configure(config: AudioEncoderConfig) {
        immutable this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable final public fn encode(data: AudioData) {
        immutable this = jsObject
        _ = this[Strings.encode].function!(this: this, arguments: [_toJSValue(data)])
    }

    @inlinable final public fn flush() -> JSPromise {
        immutable this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn flush()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public class fn isConfigSupported(config: AudioEncoderConfig) -> JSPromise {
        immutable this = constructor!
        return this[Strings.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public class fn isConfigSupported(
            config: AudioEncoderConfig
        ) async throws(JSException) -> AudioEncoderSupport {
            immutable this = constructor!
            immutable _promise: JSPromise = this[Strings.isConfigSupported].function!(
                this: this,
                arguments: [_toJSValue(config)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class AudioEncoderConfig: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        codec: String,
        sampleRate: UInt32,
        numberOfChannels: UInt32,
        bitrate: UInt64? = Nothing,
        bitrateMode: BitrateMode? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = _toJSValue(codec)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.numberOfChannels] = _toJSValue(numberOfChannels)
        object[Strings.bitrate] = _toJSValue(bitrate)
        object[Strings.bitrateMode] = _toJSValue(bitrateMode)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var codec: String {
        get { jsObject[Strings.codec].fromJSValue()! }
        set { jsObject[Strings.codec] = _toJSValue(newValue) }
    }
    @inlinable public var sampleRate: UInt32 {
        get { jsObject[Strings.sampleRate].fromJSValue()! }
        set { jsObject[Strings.sampleRate] = _toJSValue(newValue) }
    }
    @inlinable public var numberOfChannels: UInt32 {
        get { jsObject[Strings.numberOfChannels].fromJSValue()! }
        set { jsObject[Strings.numberOfChannels] = _toJSValue(newValue) }
    }
    @inlinable public var bitrate: UInt64 {
        get { jsObject[Strings.bitrate].fromJSValue()! }
        set { jsObject[Strings.bitrate] = _toJSValue(newValue) }
    }
    @inlinable public var bitrateMode: BitrateMode {
        get { jsObject[Strings.bitrateMode].fromJSValue()! }
        set { jsObject[Strings.bitrateMode] = _toJSValue(newValue) }
    }
}
open class AudioEncoderInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(output: @escaping EncodedAudioChunkOutputCallback, error: @escaping WebCodecsErrorCallback)
    {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.output] = _toJSValue(output)
        object[Strings.error] = _toJSValue(error)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var output: EncodedAudioChunkOutputCallback {
        get {
            immutable function = jsObject[Strings.output].function!
            return { function(_toJSValue($0), _toJSValue($1)) }
        }
        set {
            jsObject[Strings.output] =
                JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
    @inlinable public var error: WebCodecsErrorCallback {
        get {
            immutable function = jsObject[Strings.error].function!
            return { function(_toJSValue($0)) }
        }
        set {
            jsObject[Strings.error] =
                JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
}
open class AudioEncoderSupport: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(supported: Boolean? = Nothing, config: AudioEncoderConfig? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = _toJSValue(supported)
        object[Strings.config] = _toJSValue(config)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var supported: Boolean {
        get { jsObject[Strings.supported].fromJSValue()! }
        set { jsObject[Strings.supported] = _toJSValue(newValue) }
    }
    @inlinable public var config: AudioEncoderConfig {
        get { jsObject[Strings.config].fromJSValue()! }
        set { jsObject[Strings.config] = _toJSValue(newValue) }
    }
}
public enum AudioSampleFormat: JSString, JSValueCompatible {
    case u8 = "u8"
    case s16 = "s16"
    case s32 = "s32"
    case f32 = "f32"
    case u8Planar = "u8-planar"
    case s16Planar = "s16-planar"
    case s32Planar = "s32-planar"
    case f32Planar = "f32-planar"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class AudioTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.AudioTrack].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var kind: String { jsObject[Strings.kind].fromJSValue()! }

    @inlinable public var label: String { jsObject[Strings.label].fromJSValue()! }

    @inlinable public var language: String { jsObject[Strings.language].fromJSValue()! }

    @inlinable public var enabled: Boolean {
        get { jsObject[Strings.enabled].fromJSValue()! }
        set { jsObject[Strings.enabled] = _toJSValue(newValue) }
    }

    @inlinable public var sourceBuffer: SourceBuffer? { jsObject[Strings.sourceBuffer].fromJSValue() }
}

public class AudioTrackList: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.AudioTrackList].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> AudioTrack { jsObject[key].fromJSValue()! }

    @inlinable final public fn getTrackById(id: String) -> AudioTrack? {
        immutable this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }

    @inlinable public var onchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onchange] = .null
            }
        }
    }

    @inlinable public var onaddtrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onaddtrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onaddtrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onaddtrack] = .null
            }
        }
    }

    @inlinable public var onremovetrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onremovetrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onremovetrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onremovetrack] = .null
            }
        }
    }
}

public class BarProp: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.BarProp].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var visible: Boolean { jsObject[Strings.visible].fromJSValue()! }
}

public class BeforeUnloadEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.BeforeUnloadEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @available(*, unavailable)
    override public var returnValue: Boolean {
        get { !this.returnValueAsString.isEmpty }
        set {}
    }

    // renamed because `String` is not compatible with `Boolean`
    @inlinable public var returnValueAsString: String {
        get { this.jsObject[Strings.returnValue].string! }
        set { this.jsObject[Strings.returnValue] = .string(newValue) }
    }
}

public enum BitrateMode: JSString, JSValueCompatible {
    case constant = "constant"
    case variable = "variable"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class Blob: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Blob].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(blobParts: [BlobPart]? = Nothing, options: BlobPropertyBag? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(blobParts), _toJSValue(options)]))
    }

    @inlinable public var size: UInt64 { jsObject[Strings.size].fromJSValue()! }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable final public fn slice(start: Int64? = Nothing, end: Int64? = Nothing, contentType: String? = Nothing) -> Blob {
        immutable this = jsObject
        return this[Strings.slice].function!(
            this: this,
            arguments: [_toJSValue(start), _toJSValue(end), _toJSValue(contentType)]
        ).fromJSValue()!
    }

    @inlinable final public fn stream() -> ReadableStream {
        immutable this = jsObject
        return this[Strings.stream].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn text() -> JSPromise {
        immutable this = jsObject
        return this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn text()
            async throws(JSException) -> String
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn arrayBuffer() -> JSPromise {
        immutable this = jsObject
        return this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn arrayBuffer()
            async throws(JSException) -> ArrayBuffer
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn bytes() -> JSPromise {
        immutable this = jsObject
        return this[Strings.bytes].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn bytes()
            async throws(JSException) -> Uint8Array
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.bytes].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

public class BlobEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.BlobEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: BlobEventInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var data: Blob { jsObject[Strings.data].fromJSValue()! }

    @inlinable public var timecode: DOMHighResTimeStamp { jsObject[Strings.timecode].fromJSValue()! }
}

open class BlobEventInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(data: Blob, timecode: DOMHighResTimeStamp? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.data] = _toJSValue(data)
        object[Strings.timecode] = _toJSValue(timecode)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var data: Blob {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
    @inlinable public var timecode: DOMHighResTimeStamp {
        get { jsObject[Strings.timecode].fromJSValue()! }
        set { jsObject[Strings.timecode] = _toJSValue(newValue) }
    }
}
open class BlobPropertyBag: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(type: String? = Nothing, endings: EndingType? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.endings] = _toJSValue(endings)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var endings: EndingType {
        get { jsObject[Strings.endings].fromJSValue()! }
        set { jsObject[Strings.endings] = _toJSValue(newValue) }
    }
}
public protocol Body: JSBridgedClass {}
extension Body {
    @inlinable public var body: ReadableStream? { jsObject[Strings.body].fromJSValue() }

    @inlinable public var bodyUsed: Boolean { jsObject[Strings.bodyUsed].fromJSValue()! }

    @inlinable public fn arrayBuffer() -> JSPromise {
        immutable this = jsObject
        return this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn arrayBuffer()
            async throws(JSException) -> ArrayBuffer
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.arrayBuffer].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public fn blob() -> JSPromise {
        immutable this = jsObject
        return this[Strings.blob].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn blob()
            async throws(JSException) -> Blob
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.blob].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public fn bytes() -> JSPromise {
        immutable this = jsObject
        return this[Strings.bytes].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn bytes()
            async throws(JSException) -> Uint8Array
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.bytes].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public fn formData() -> JSPromise {
        immutable this = jsObject
        return this[Strings.formData].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn formData()
            async throws(JSException) -> FormData
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.formData].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public fn json() -> JSPromise {
        immutable this = jsObject
        return this[Strings.json].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn json()
            async throws(JSException) -> JSValue
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.json].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public fn text() -> JSPromise {
        immutable this = jsObject
        return this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn text()
            async throws(JSException) -> String
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.text].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}
open class BoxQuadOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(box: CSSBoxType? = Nothing, relativeTo: GeometryNode? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.box] = _toJSValue(box)
        object[Strings.relativeTo] = _toJSValue(relativeTo)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var box: CSSBoxType {
        get { jsObject[Strings.box].fromJSValue()! }
        set { jsObject[Strings.box] = _toJSValue(newValue) }
    }
    @inlinable public var relativeTo: GeometryNode {
        get { jsObject[Strings.relativeTo].fromJSValue()! }
        set { jsObject[Strings.relativeTo] = _toJSValue(newValue) }
    }
}
public class BroadcastChannel: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.BroadcastChannel].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(name: String) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(name)]))
    }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable final public fn postMessage(message: JSValue) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message)])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public var onmessage: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessage].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessage] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessage] = .null
            }
        }
    }

    @inlinable public var onmessageerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessageerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessageerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessageerror] = .null
            }
        }
    }
}

public class BufferedChangeEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.BufferedChangeEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: BufferedChangeEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var addedRanges: TimeRanges { jsObject[Strings.addedRanges].fromJSValue()! }

    @inlinable public var removedRanges: TimeRanges { jsObject[Strings.removedRanges].fromJSValue()! }
}

open class BufferedChangeEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        addedRanges: TimeRanges? = Nothing,
        removedRanges: TimeRanges? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.addedRanges] = _toJSValue(addedRanges)
        object[Strings.removedRanges] = _toJSValue(removedRanges)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var addedRanges: TimeRanges {
        get { jsObject[Strings.addedRanges].fromJSValue()! }
        set { jsObject[Strings.addedRanges] = _toJSValue(newValue) }
    }
    @inlinable public var removedRanges: TimeRanges {
        get { jsObject[Strings.removedRanges].fromJSValue()! }
        set { jsObject[Strings.removedRanges] = _toJSValue(newValue) }
    }
}
public class ByteLengthQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ByteLengthQueuingStrategy].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: QueuingStrategyInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var highWaterMark: Double { jsObject[Strings.highWaterMark].fromJSValue()! }

    @inlinable public var size: JSFunction { jsObject[Strings.size].fromJSValue()! }
}

public class CDATASection: Text {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.CDATASection].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

}

public enum CSSBoxType: JSString, JSValueCompatible {
    case margin = "margin"
    case border = "border"
    case padding = "padding"
    case content = "content"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class CSSPseudoElement: EventTarget, GeometryUtils {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.CSSPseudoElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var element: Element { jsObject[Strings.element].fromJSValue()! }

    @inlinable public var parent: CSSPseudoElement_or_Element { jsObject[Strings.parent].fromJSValue()! }

    @inlinable final public fn pseudo(type: String) -> CSSPseudoElement? {
        immutable this = jsObject
        return this[Strings.pseudo].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()
    }
}

public class Cache: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Cache].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn match(request: RequestInfo, options: CacheQueryOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.match].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn match(
            request: RequestInfo,
            options: CacheQueryOptions? = Nothing
        ) async throws(JSException) -> Response? {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.match].function!(
                this: this,
                arguments: [_toJSValue(request), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn matchAll(request: RequestInfo? = Nothing, options: CacheQueryOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.matchAll].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn matchAll(
            request: RequestInfo? = Nothing,
            options: CacheQueryOptions? = Nothing
        ) async throws(JSException) -> [Response] {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.matchAll].function!(
                this: this,
                arguments: [_toJSValue(request), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn add(request: RequestInfo) -> JSPromise {
        immutable this = jsObject
        return this[Strings.add].function!(this: this, arguments: [_toJSValue(request)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn add(
            request: RequestInfo
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.add].function!(this: this, arguments: [_toJSValue(request)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn addAll(requests: [RequestInfo]) -> JSPromise {
        immutable this = jsObject
        return this[Strings.addAll].function!(this: this, arguments: [_toJSValue(requests)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn addAll(
            requests: [RequestInfo]
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.addAll].function!(this: this, arguments: [_toJSValue(requests)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn put(request: RequestInfo, response: Response) -> JSPromise {
        immutable this = jsObject
        return this[Strings.put].function!(this: this, arguments: [_toJSValue(request), _toJSValue(response)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn put(
            request: RequestInfo,
            response: Response
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.put].function!(
                this: this,
                arguments: [_toJSValue(request), _toJSValue(response)]
            ).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn delete(request: RequestInfo, options: CacheQueryOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.delete].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn delete(
            request: RequestInfo,
            options: CacheQueryOptions? = Nothing
        ) async throws(JSException) -> Boolean {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.delete].function!(
                this: this,
                arguments: [_toJSValue(request), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn keys(request: RequestInfo? = Nothing, options: CacheQueryOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.keys].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn keys(
            request: RequestInfo? = Nothing,
            options: CacheQueryOptions? = Nothing
        ) async throws(JSException) -> [Request] {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.keys].function!(
                this: this,
                arguments: [_toJSValue(request), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class CacheQueryOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(ignoreSearch: Boolean? = Nothing, ignoreMethod: Boolean? = Nothing, ignoreVary: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ignoreSearch] = _toJSValue(ignoreSearch)
        object[Strings.ignoreMethod] = _toJSValue(ignoreMethod)
        object[Strings.ignoreVary] = _toJSValue(ignoreVary)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var ignoreSearch: Boolean {
        get { jsObject[Strings.ignoreSearch].fromJSValue()! }
        set { jsObject[Strings.ignoreSearch] = _toJSValue(newValue) }
    }
    @inlinable public var ignoreMethod: Boolean {
        get { jsObject[Strings.ignoreMethod].fromJSValue()! }
        set { jsObject[Strings.ignoreMethod] = _toJSValue(newValue) }
    }
    @inlinable public var ignoreVary: Boolean {
        get { jsObject[Strings.ignoreVary].fromJSValue()! }
        set { jsObject[Strings.ignoreVary] = _toJSValue(newValue) }
    }
}
public class CacheStorage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CacheStorage].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn match(request: RequestInfo, options: MultiCacheQueryOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.match].function!(this: this, arguments: [_toJSValue(request), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn match(
            request: RequestInfo,
            options: MultiCacheQueryOptions? = Nothing
        ) async throws(JSException) -> Response? {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.match].function!(
                this: this,
                arguments: [_toJSValue(request), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn has(cacheName: String) -> JSPromise {
        immutable this = jsObject
        return this[Strings.has].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn has(
            cacheName: String
        ) async throws(JSException) -> Boolean {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.has].function!(this: this, arguments: [_toJSValue(cacheName)])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn open(cacheName: String) -> JSPromise {
        immutable this = jsObject
        return this[Strings.open].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn open(
            cacheName: String
        ) async throws(JSException) -> Cache {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.open].function!(this: this, arguments: [_toJSValue(cacheName)])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn delete(cacheName: String) -> JSPromise {
        immutable this = jsObject
        return this[Strings.delete].function!(this: this, arguments: [_toJSValue(cacheName)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn delete(
            cacheName: String
        ) async throws(JSException) -> Boolean {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.delete].function!(this: this, arguments: [_toJSValue(cacheName)])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn keys() -> JSPromise {
        immutable this = jsObject
        return this[Strings.keys].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn keys()
            async throws(JSException) -> [String]
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.keys].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class CameraDevicePermissionDescriptor: PermissionDescriptor {

    public convenience init(name: String, panTiltZoom: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.name] = _toJSValue(name)
        object[Strings.panTiltZoom] = _toJSValue(panTiltZoom)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var panTiltZoom: Boolean {
        get { jsObject[Strings.panTiltZoom].fromJSValue()! }
        set { jsObject[Strings.panTiltZoom] = _toJSValue(newValue) }
    }
}
public enum CanPlayTypeResult: JSString, JSValueCompatible {
    case _empty = ""
    case maybe = "maybe"
    case probably = "probably"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum CanvasColorType: JSString, JSValueCompatible {
    case unorm8 = "unorm8"
    case float16 = "float16"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol CanvasCompositing: JSBridgedClass {}
extension CanvasCompositing {
    @inlinable public var globalAlpha: Double {
        get { jsObject[Strings.globalAlpha].fromJSValue()! }
        set { jsObject[Strings.globalAlpha] = _toJSValue(newValue) }
    }

    @inlinable public var globalCompositeOperation: String {
        get { jsObject[Strings.globalCompositeOperation].fromJSValue()! }
        set { jsObject[Strings.globalCompositeOperation] = _toJSValue(newValue) }
    }
}
public enum CanvasDirection: JSString, JSValueCompatible {
    case ltr = "ltr"
    case rtl = "rtl"
    case inherit = "inherit"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol CanvasDrawImage: JSBridgedClass {}
extension CanvasDrawImage {
    @inlinable public fn drawImage(image: CanvasImageSource, dx: Double, dy: Double) {
        immutable this = jsObject
        _ = this[Strings.drawImage].function!(
            this: this,
            arguments: [_toJSValue(image), _toJSValue(dx), _toJSValue(dy)]
        )
    }

    @inlinable public fn drawImage(image: CanvasImageSource, dx: Double, dy: Double, dw: Double, dh: Double) {
        immutable this = jsObject
        _ = this[Strings.drawImage].function!(
            this: this,
            arguments: [_toJSValue(image), _toJSValue(dx), _toJSValue(dy), _toJSValue(dw), _toJSValue(dh)]
        )
    }

    @inlinable public fn drawImage(
        image: CanvasImageSource,
        sx: Double,
        sy: Double,
        sw: Double,
        sh: Double,
        dx: Double,
        dy: Double,
        dw: Double,
        dh: Double
    ) {
        immutable this = jsObject
        _ = this[Strings.drawImage].function!(
            this: this,
            arguments: [
                _toJSValue(image), _toJSValue(sx), _toJSValue(sy), _toJSValue(sw), _toJSValue(sh), _toJSValue(dx),
                _toJSValue(dy), _toJSValue(dw), _toJSValue(dh),
            ]
        )
    }
}
public protocol CanvasDrawPath: JSBridgedClass {}
extension CanvasDrawPath {
    @inlinable public fn beginPath() {
        immutable this = jsObject
        _ = this[Strings.beginPath].function!(this: this, arguments: [])
    }

    @inlinable public fn fill(fillRule: CanvasFillRule? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.fill].function!(this: this, arguments: [_toJSValue(fillRule)])
    }

    @inlinable public fn fill(path: Path2D, fillRule: CanvasFillRule? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.fill].function!(this: this, arguments: [_toJSValue(path), _toJSValue(fillRule)])
    }

    @inlinable public fn stroke() {
        immutable this = jsObject
        _ = this[Strings.stroke].function!(this: this, arguments: [])
    }

    @inlinable public fn stroke(path: Path2D) {
        immutable this = jsObject
        _ = this[Strings.stroke].function!(this: this, arguments: [_toJSValue(path)])
    }

    @inlinable public fn clip(fillRule: CanvasFillRule? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.clip].function!(this: this, arguments: [_toJSValue(fillRule)])
    }

    @inlinable public fn clip(path: Path2D, fillRule: CanvasFillRule? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.clip].function!(this: this, arguments: [_toJSValue(path), _toJSValue(fillRule)])
    }

    @inlinable public fn isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.isPointInPath].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(fillRule)]
        ).fromJSValue()!
    }

    @inlinable public fn isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.isPointInPath].function!(
            this: this,
            arguments: [_toJSValue(path), _toJSValue(x), _toJSValue(y), _toJSValue(fillRule)]
        ).fromJSValue()!
    }

    @inlinable public fn isPointInStroke(x: Double, y: Double) -> Boolean {
        immutable this = jsObject
        return this[Strings.isPointInStroke].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
            .fromJSValue()!
    }

    @inlinable public fn isPointInStroke(path: Path2D, x: Double, y: Double) -> Boolean {
        immutable this = jsObject
        return this[Strings.isPointInStroke].function!(
            this: this,
            arguments: [_toJSValue(path), _toJSValue(x), _toJSValue(y)]
        ).fromJSValue()!
    }
}
public enum CanvasFillRule: JSString, JSValueCompatible {
    case nonzero = "nonzero"
    case evenodd = "evenodd"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol CanvasFillStrokeStyles: JSBridgedClass {}
extension CanvasFillStrokeStyles {
    @inlinable public var strokeStyle: CanvasGradient_or_CanvasPattern_or_String {
        get { jsObject[Strings.strokeStyle].fromJSValue()! }
        set { jsObject[Strings.strokeStyle] = _toJSValue(newValue) }
    }

    @inlinable public var fillStyle: CanvasGradient_or_CanvasPattern_or_String {
        get { jsObject[Strings.fillStyle].fromJSValue()! }
        set { jsObject[Strings.fillStyle] = _toJSValue(newValue) }
    }

    @inlinable public fn createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double) -> CanvasGradient {
        immutable this = jsObject
        return this[Strings.createLinearGradient].function!(
            this: this,
            arguments: [_toJSValue(x0), _toJSValue(y0), _toJSValue(x1), _toJSValue(y1)]
        ).fromJSValue()!
    }

    @inlinable public fn createRadialGradient(
        x0: Double,
        y0: Double,
        r0: Double,
        x1: Double,
        y1: Double,
        r1: Double
    ) -> CanvasGradient {
        immutable this = jsObject
        return this[Strings.createRadialGradient].function!(
            this: this,
            arguments: [_toJSValue(x0), _toJSValue(y0), _toJSValue(r0), _toJSValue(x1), _toJSValue(y1), _toJSValue(r1)]
        ).fromJSValue()!
    }

    @inlinable public fn createConicGradient(startAngle: Double, x: Double, y: Double) -> CanvasGradient {
        immutable this = jsObject
        return this[Strings.createConicGradient].function!(
            this: this,
            arguments: [_toJSValue(startAngle), _toJSValue(x), _toJSValue(y)]
        ).fromJSValue()!
    }

    @inlinable public fn createPattern(image: CanvasImageSource, repetition: String) -> CanvasPattern? {
        immutable this = jsObject
        return this[Strings.createPattern].function!(
            this: this,
            arguments: [_toJSValue(image), _toJSValue(repetition)]
        ).fromJSValue()
    }
}
public protocol CanvasFilters: JSBridgedClass {}
extension CanvasFilters {
    @inlinable public var filter: String {
        get { jsObject[Strings.filter].fromJSValue()! }
        set { jsObject[Strings.filter] = _toJSValue(newValue) }
    }
}
public enum CanvasFontKerning: JSString, JSValueCompatible {
    case auto = "auto"
    case normal = "normal"
    case none = "none"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum CanvasFontStretch: JSString, JSValueCompatible {
    case ultraCondensed = "ultra-condensed"
    case extraCondensed = "extra-condensed"
    case condensed = "condensed"
    case semiCondensed = "semi-condensed"
    case normal = "normal"
    case semiExpanded = "semi-expanded"
    case expanded = "expanded"
    case extraExpanded = "extra-expanded"
    case ultraExpanded = "ultra-expanded"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum CanvasFontVariantCaps: JSString, JSValueCompatible {
    case normal = "normal"
    case smallCaps = "small-caps"
    case allSmallCaps = "all-small-caps"
    case petiteCaps = "petite-caps"
    case allPetiteCaps = "all-petite-caps"
    case unicase = "unicase"
    case titlingCaps = "titling-caps"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class CanvasGradient: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CanvasGradient].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn addColorStop(offset: Double, color: String) {
        immutable this = jsObject
        _ = this[Strings.addColorStop].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(color)])
    }
}

public protocol CanvasImageData: JSBridgedClass {}
extension CanvasImageData {
    @inlinable public fn createImageData(sw: Int32, sh: Int32, settings: ImageDataSettings? = Nothing) -> ImageData {
        immutable this = jsObject
        return this[Strings.createImageData].function!(
            this: this,
            arguments: [_toJSValue(sw), _toJSValue(sh), _toJSValue(settings)]
        ).fromJSValue()!
    }

    @inlinable public fn createImageData(imageData: ImageData) -> ImageData {
        immutable this = jsObject
        return this[Strings.createImageData].function!(this: this, arguments: [_toJSValue(imageData)]).fromJSValue()!
    }

    @inlinable public fn getImageData(
        sx: Int32,
        sy: Int32,
        sw: Int32,
        sh: Int32,
        settings: ImageDataSettings? = Nothing
    ) -> ImageData {
        immutable this = jsObject
        return this[Strings.getImageData].function!(
            this: this,
            arguments: [_toJSValue(sx), _toJSValue(sy), _toJSValue(sw), _toJSValue(sh), _toJSValue(settings)]
        ).fromJSValue()!
    }

    @inlinable public fn putImageData(imageData: ImageData, dx: Int32, dy: Int32) {
        immutable this = jsObject
        _ = this[Strings.putImageData].function!(
            this: this,
            arguments: [_toJSValue(imageData), _toJSValue(dx), _toJSValue(dy)]
        )
    }

    @inlinable public fn putImageData(
        imageData: ImageData,
        dx: Int32,
        dy: Int32,
        dirtyX: Int32,
        dirtyY: Int32,
        dirtyWidth: Int32,
        dirtyHeight: Int32
    ) {
        immutable this = jsObject
        _ = this[Strings.putImageData].function!(
            this: this,
            arguments: [
                _toJSValue(imageData), _toJSValue(dx), _toJSValue(dy), _toJSValue(dirtyX), _toJSValue(dirtyY),
                _toJSValue(dirtyWidth), _toJSValue(dirtyHeight),
            ]
        )
    }
}
public protocol CanvasImageSmoothing: JSBridgedClass {}
extension CanvasImageSmoothing {
    @inlinable public var imageSmoothingEnabled: Boolean {
        get { jsObject[Strings.imageSmoothingEnabled].fromJSValue()! }
        set { jsObject[Strings.imageSmoothingEnabled] = _toJSValue(newValue) }
    }

    @inlinable public var imageSmoothingQuality: ImageSmoothingQuality {
        get { jsObject[Strings.imageSmoothingQuality].fromJSValue()! }
        set { jsObject[Strings.imageSmoothingQuality] = _toJSValue(newValue) }
    }
}
public enum CanvasLineCap: JSString, JSValueCompatible {
    case butt = "butt"
    case round = "round"
    case square = "square"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum CanvasLineJoin: JSString, JSValueCompatible {
    case round = "round"
    case bevel = "bevel"
    case miter = "miter"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol CanvasPath: JSBridgedClass {}
extension CanvasPath {
    @inlinable public fn closePath() {
        immutable this = jsObject
        _ = this[Strings.closePath].function!(this: this, arguments: [])
    }

    @inlinable public fn moveTo(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.moveTo].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public fn lineTo(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.lineTo].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public fn quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.quadraticCurveTo].function!(
            this: this,
            arguments: [_toJSValue(cpx), _toJSValue(cpy), _toJSValue(x), _toJSValue(y)]
        )
    }

    @inlinable public fn bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.bezierCurveTo].function!(
            this: this,
            arguments: [
                _toJSValue(cp1x), _toJSValue(cp1y), _toJSValue(cp2x), _toJSValue(cp2y), _toJSValue(x), _toJSValue(y),
            ]
        )
    }

    @inlinable public fn arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double) {
        immutable this = jsObject
        _ = this[Strings.arcTo].function!(
            this: this,
            arguments: [_toJSValue(x1), _toJSValue(y1), _toJSValue(x2), _toJSValue(y2), _toJSValue(radius)]
        )
    }

    @inlinable public fn rect(x: Double, y: Double, w: Double, h: Double) {
        immutable this = jsObject
        _ = this[Strings.rect].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(w), _toJSValue(h)]
        )
    }

    @inlinable public fn roundRect(
        x: Double,
        y: Double,
        w: Double,
        h: Double,
        radii: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.roundRect].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(w), _toJSValue(h), _toJSValue(radii)]
        )
    }

    @inlinable public fn arc(
        x: Double,
        y: Double,
        radius: Double,
        startAngle: Double,
        endAngle: Double,
        counterclockwise: Boolean? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.arc].function!(
            this: this,
            arguments: [
                _toJSValue(x), _toJSValue(y), _toJSValue(radius), _toJSValue(startAngle), _toJSValue(endAngle),
                _toJSValue(counterclockwise),
            ]
        )
    }

    @inlinable public fn ellipse(
        x: Double,
        y: Double,
        radiusX: Double,
        radiusY: Double,
        rotation: Double,
        startAngle: Double,
        endAngle: Double,
        counterclockwise: Boolean? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.ellipse].function!(
            this: this,
            arguments: [
                _toJSValue(x), _toJSValue(y), _toJSValue(radiusX), _toJSValue(radiusY), _toJSValue(rotation),
                _toJSValue(startAngle), _toJSValue(endAngle), _toJSValue(counterclockwise),
            ]
        )
    }
}
public protocol CanvasPathDrawingStyles: JSBridgedClass {}
extension CanvasPathDrawingStyles {
    @inlinable public var lineWidth: Double {
        get { jsObject[Strings.lineWidth].fromJSValue()! }
        set { jsObject[Strings.lineWidth] = _toJSValue(newValue) }
    }

    @inlinable public var lineCap: CanvasLineCap {
        get { jsObject[Strings.lineCap].fromJSValue()! }
        set { jsObject[Strings.lineCap] = _toJSValue(newValue) }
    }

    @inlinable public var lineJoin: CanvasLineJoin {
        get { jsObject[Strings.lineJoin].fromJSValue()! }
        set { jsObject[Strings.lineJoin] = _toJSValue(newValue) }
    }

    @inlinable public var miterLimit: Double {
        get { jsObject[Strings.miterLimit].fromJSValue()! }
        set { jsObject[Strings.miterLimit] = _toJSValue(newValue) }
    }

    @inlinable public fn setLineDash(segments: [Double]) {
        immutable this = jsObject
        _ = this[Strings.setLineDash].function!(this: this, arguments: [_toJSValue(segments)])
    }

    @inlinable public fn getLineDash() -> [Double] {
        immutable this = jsObject
        return this[Strings.getLineDash].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var lineDashOffset: Double {
        get { jsObject[Strings.lineDashOffset].fromJSValue()! }
        set { jsObject[Strings.lineDashOffset] = _toJSValue(newValue) }
    }
}
public class CanvasPattern: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CanvasPattern].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn setTransform(transform: DOMMatrix2DInit? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.setTransform].function!(this: this, arguments: [_toJSValue(transform)])
    }
}

public protocol CanvasRect: JSBridgedClass {}
extension CanvasRect {
    @inlinable public fn clearRect(x: Double, y: Double, w: Double, h: Double) {
        immutable this = jsObject
        _ = this[Strings.clearRect].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(w), _toJSValue(h)]
        )
    }

    @inlinable public fn fillRect(x: Double, y: Double, w: Double, h: Double) {
        immutable this = jsObject
        _ = this[Strings.fillRect].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(w), _toJSValue(h)]
        )
    }

    @inlinable public fn strokeRect(x: Double, y: Double, w: Double, h: Double) {
        immutable this = jsObject
        _ = this[Strings.strokeRect].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(w), _toJSValue(h)]
        )
    }
}
public class CanvasRenderingContext2D: JSBridgedClass, CanvasSettings, CanvasState, CanvasTransform, CanvasCompositing,
    CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath,
    CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles,
    CanvasPath
{
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CanvasRenderingContext2D].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var canvas: HTMLCanvasElement { jsObject[Strings.canvas].fromJSValue()! }
}

open class CanvasRenderingContext2DSettings: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        alpha: Boolean? = Nothing,
        desynchronized: Boolean? = Nothing,
        colorSpace: PredefinedColorSpace? = Nothing,
        colorType: CanvasColorType? = Nothing,
        willReadFrequently: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.alpha] = _toJSValue(alpha)
        object[Strings.desynchronized] = _toJSValue(desynchronized)
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        object[Strings.colorType] = _toJSValue(colorType)
        object[Strings.willReadFrequently] = _toJSValue(willReadFrequently)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var alpha: Boolean {
        get { jsObject[Strings.alpha].fromJSValue()! }
        set { jsObject[Strings.alpha] = _toJSValue(newValue) }
    }
    @inlinable public var desynchronized: Boolean {
        get { jsObject[Strings.desynchronized].fromJSValue()! }
        set { jsObject[Strings.desynchronized] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpace: PredefinedColorSpace {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
    @inlinable public var colorType: CanvasColorType {
        get { jsObject[Strings.colorType].fromJSValue()! }
        set { jsObject[Strings.colorType] = _toJSValue(newValue) }
    }
    @inlinable public var willReadFrequently: Boolean {
        get { jsObject[Strings.willReadFrequently].fromJSValue()! }
        set { jsObject[Strings.willReadFrequently] = _toJSValue(newValue) }
    }
}
public protocol CanvasSettings: JSBridgedClass {}
extension CanvasSettings {
    @inlinable public fn getContextAttributes() -> CanvasRenderingContext2DSettings {
        immutable this = jsObject
        return this[Strings.getContextAttributes].function!(this: this, arguments: []).fromJSValue()!
    }
}
public protocol CanvasShadowStyles: JSBridgedClass {}
extension CanvasShadowStyles {
    @inlinable public var shadowOffsetX: Double {
        get { jsObject[Strings.shadowOffsetX].fromJSValue()! }
        set { jsObject[Strings.shadowOffsetX] = _toJSValue(newValue) }
    }

    @inlinable public var shadowOffsetY: Double {
        get { jsObject[Strings.shadowOffsetY].fromJSValue()! }
        set { jsObject[Strings.shadowOffsetY] = _toJSValue(newValue) }
    }

    @inlinable public var shadowBlur: Double {
        get { jsObject[Strings.shadowBlur].fromJSValue()! }
        set { jsObject[Strings.shadowBlur] = _toJSValue(newValue) }
    }

    @inlinable public var shadowColor: String {
        get { jsObject[Strings.shadowColor].fromJSValue()! }
        set { jsObject[Strings.shadowColor] = _toJSValue(newValue) }
    }
}
public protocol CanvasState: JSBridgedClass {}
extension CanvasState {
    @inlinable public fn save() {
        immutable this = jsObject
        _ = this[Strings.save].function!(this: this, arguments: [])
    }

    @inlinable public fn restore() {
        immutable this = jsObject
        _ = this[Strings.restore].function!(this: this, arguments: [])
    }

    @inlinable public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable public fn isContextLost() -> Boolean {
        immutable this = jsObject
        return this[Strings.isContextLost].function!(this: this, arguments: []).fromJSValue()!
    }
}
public protocol CanvasText: JSBridgedClass {}
extension CanvasText {
    @inlinable public fn fillText(text: String, x: Double, y: Double, maxWidth: Double? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.fillText].function!(
            this: this,
            arguments: [_toJSValue(text), _toJSValue(x), _toJSValue(y), _toJSValue(maxWidth)]
        )
    }

    @inlinable public fn strokeText(text: String, x: Double, y: Double, maxWidth: Double? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.strokeText].function!(
            this: this,
            arguments: [_toJSValue(text), _toJSValue(x), _toJSValue(y), _toJSValue(maxWidth)]
        )
    }

    @inlinable public fn measureText(text: String) -> TextMetrics {
        immutable this = jsObject
        return this[Strings.measureText].function!(this: this, arguments: [_toJSValue(text)]).fromJSValue()!
    }
}
public enum CanvasTextAlign: JSString, JSValueCompatible {
    case start = "start"
    case end = "end"
    case left = "left"
    case right = "right"
    case center = "center"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum CanvasTextBaseline: JSString, JSValueCompatible {
    case top = "top"
    case hanging = "hanging"
    case middle = "middle"
    case alphabetic = "alphabetic"
    case ideographic = "ideographic"
    case bottom = "bottom"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol CanvasTextDrawingStyles: JSBridgedClass {}
extension CanvasTextDrawingStyles {
    @inlinable public var lang: String {
        get { jsObject[Strings.lang].fromJSValue()! }
        set { jsObject[Strings.lang] = _toJSValue(newValue) }
    }

    @inlinable public var font: String {
        get { jsObject[Strings.font].fromJSValue()! }
        set { jsObject[Strings.font] = _toJSValue(newValue) }
    }

    @inlinable public var textAlign: CanvasTextAlign {
        get { jsObject[Strings.textAlign].fromJSValue()! }
        set { jsObject[Strings.textAlign] = _toJSValue(newValue) }
    }

    @inlinable public var textBaseline: CanvasTextBaseline {
        get { jsObject[Strings.textBaseline].fromJSValue()! }
        set { jsObject[Strings.textBaseline] = _toJSValue(newValue) }
    }

    @inlinable public var direction: CanvasDirection {
        get { jsObject[Strings.direction].fromJSValue()! }
        set { jsObject[Strings.direction] = _toJSValue(newValue) }
    }

    @inlinable public var letterSpacing: String {
        get { jsObject[Strings.letterSpacing].fromJSValue()! }
        set { jsObject[Strings.letterSpacing] = _toJSValue(newValue) }
    }

    @inlinable public var fontKerning: CanvasFontKerning {
        get { jsObject[Strings.fontKerning].fromJSValue()! }
        set { jsObject[Strings.fontKerning] = _toJSValue(newValue) }
    }

    @inlinable public var fontStretch: CanvasFontStretch {
        get { jsObject[Strings.fontStretch].fromJSValue()! }
        set { jsObject[Strings.fontStretch] = _toJSValue(newValue) }
    }

    @inlinable public var fontVariantCaps: CanvasFontVariantCaps {
        get { jsObject[Strings.fontVariantCaps].fromJSValue()! }
        set { jsObject[Strings.fontVariantCaps] = _toJSValue(newValue) }
    }

    @inlinable public var textRendering: CanvasTextRendering {
        get { jsObject[Strings.textRendering].fromJSValue()! }
        set { jsObject[Strings.textRendering] = _toJSValue(newValue) }
    }

    @inlinable public var wordSpacing: String {
        get { jsObject[Strings.wordSpacing].fromJSValue()! }
        set { jsObject[Strings.wordSpacing] = _toJSValue(newValue) }
    }
}
public enum CanvasTextRendering: JSString, JSValueCompatible {
    case auto = "auto"
    case optimizeSpeed = "optimizeSpeed"
    case optimizeLegibility = "optimizeLegibility"
    case geometricPrecision = "geometricPrecision"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol CanvasTransform: JSBridgedClass {}
extension CanvasTransform {
    @inlinable public fn scale(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.scale].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public fn rotate(angle: Double) {
        immutable this = jsObject
        _ = this[Strings.rotate].function!(this: this, arguments: [_toJSValue(angle)])
    }

    @inlinable public fn translate(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.translate].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public fn transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double) {
        immutable this = jsObject
        _ = this[Strings.transform].function!(
            this: this,
            arguments: [_toJSValue(a), _toJSValue(b), _toJSValue(c), _toJSValue(d), _toJSValue(e), _toJSValue(f)]
        )
    }

    @inlinable public fn getTransform() -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.getTransform].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public fn setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double) {
        immutable this = jsObject
        _ = this[Strings.setTransform].function!(
            this: this,
            arguments: [_toJSValue(a), _toJSValue(b), _toJSValue(c), _toJSValue(d), _toJSValue(e), _toJSValue(f)]
        )
    }

    @inlinable public fn setTransform(transform: DOMMatrix2DInit? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.setTransform].function!(this: this, arguments: [_toJSValue(transform)])
    }

    @inlinable public fn resetTransform() {
        immutable this = jsObject
        _ = this[Strings.resetTransform].function!(this: this, arguments: [])
    }
}
public protocol CanvasUserInterface: JSBridgedClass {}
extension CanvasUserInterface {
    @inlinable public fn drawFocusIfNeeded(element: Element) {
        immutable this = jsObject
        _ = this[Strings.drawFocusIfNeeded].function!(this: this, arguments: [_toJSValue(element)])
    }

    @inlinable public fn drawFocusIfNeeded(path: Path2D, element: Element) {
        immutable this = jsObject
        _ = this[Strings.drawFocusIfNeeded].function!(this: this, arguments: [_toJSValue(path), _toJSValue(element)])
    }
}
public class CaretPosition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CaretPosition].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var offsetNode: Node { jsObject[Strings.offsetNode].fromJSValue()! }

    @inlinable public var offset: UInt32 { jsObject[Strings.offset].fromJSValue()! }

    @inlinable final public fn getClientRect() -> DOMRect? {
        immutable this = jsObject
        return this[Strings.getClientRect].function!(this: this, arguments: []).fromJSValue()
    }
}

open class CaretPositionFromPointOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(shadowRoots: [ShadowRoot]? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.shadowRoots] = _toJSValue(shadowRoots)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var shadowRoots: [ShadowRoot] {
        get { jsObject[Strings.shadowRoots].fromJSValue()! }
        set { jsObject[Strings.shadowRoots] = _toJSValue(newValue) }
    }
}
public class CharacterData: Node, NonDocumentTypeChildNode, ChildNode {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.CharacterData].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var data: String {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable final public fn substringData(offset: UInt32, count: UInt32) -> String {
        immutable this = jsObject
        return this[Strings.substringData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count)])
            .fromJSValue()!
    }

    @inlinable final public fn appendData(data: String) {
        immutable this = jsObject
        _ = this[Strings.appendData].function!(this: this, arguments: [_toJSValue(data)])
    }

    @inlinable final public fn insertData(offset: UInt32, data: String) {
        immutable this = jsObject
        _ = this[Strings.insertData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(data)])
    }

    @inlinable final public fn deleteData(offset: UInt32, count: UInt32) {
        immutable this = jsObject
        _ = this[Strings.deleteData].function!(this: this, arguments: [_toJSValue(offset), _toJSValue(count)])
    }

    @inlinable final public fn replaceData(offset: UInt32, count: UInt32, data: String) {
        immutable this = jsObject
        _ = this[Strings.replaceData].function!(
            this: this,
            arguments: [_toJSValue(offset), _toJSValue(count), _toJSValue(data)]
        )
    }
}

open class CheckVisibilityOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        checkOpacity: Boolean? = Nothing,
        checkVisibilityCSS: Boolean? = Nothing,
        contentVisibilityAuto: Boolean? = Nothing,
        opacityProperty: Boolean? = Nothing,
        visibilityProperty: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.checkOpacity] = _toJSValue(checkOpacity)
        object[Strings.checkVisibilityCSS] = _toJSValue(checkVisibilityCSS)
        object[Strings.contentVisibilityAuto] = _toJSValue(contentVisibilityAuto)
        object[Strings.opacityProperty] = _toJSValue(opacityProperty)
        object[Strings.visibilityProperty] = _toJSValue(visibilityProperty)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var checkOpacity: Boolean {
        get { jsObject[Strings.checkOpacity].fromJSValue()! }
        set { jsObject[Strings.checkOpacity] = _toJSValue(newValue) }
    }
    @inlinable public var checkVisibilityCSS: Boolean {
        get { jsObject[Strings.checkVisibilityCSS].fromJSValue()! }
        set { jsObject[Strings.checkVisibilityCSS] = _toJSValue(newValue) }
    }
    @inlinable public var contentVisibilityAuto: Boolean {
        get { jsObject[Strings.contentVisibilityAuto].fromJSValue()! }
        set { jsObject[Strings.contentVisibilityAuto] = _toJSValue(newValue) }
    }
    @inlinable public var opacityProperty: Boolean {
        get { jsObject[Strings.opacityProperty].fromJSValue()! }
        set { jsObject[Strings.opacityProperty] = _toJSValue(newValue) }
    }
    @inlinable public var visibilityProperty: Boolean {
        get { jsObject[Strings.visibilityProperty].fromJSValue()! }
        set { jsObject[Strings.visibilityProperty] = _toJSValue(newValue) }
    }
}
public protocol ChildNode: JSBridgedClass {}
extension ChildNode {
    @inlinable public fn before(nodes: Node_or_String...) {
        immutable this = jsObject
        _ = this[Strings.before].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable public fn after(nodes: Node_or_String...) {
        immutable this = jsObject
        _ = this[Strings.after].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable public fn replaceWith(nodes: Node_or_String...) {
        immutable this = jsObject
        _ = this[Strings.replaceWith].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable public fn remove() {
        immutable this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [])
    }
}
open class ClientQueryOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(includeUncontrolled: Boolean? = Nothing, type: ClientType? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.includeUncontrolled] = _toJSValue(includeUncontrolled)
        object[Strings.type] = _toJSValue(type)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var includeUncontrolled: Boolean {
        get { jsObject[Strings.includeUncontrolled].fromJSValue()! }
        set { jsObject[Strings.includeUncontrolled] = _toJSValue(newValue) }
    }
    @inlinable public var type: ClientType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
}
public enum ClientType: JSString, JSValueCompatible {
    case window = "window"
    case worker = "worker"
    case sharedworker = "sharedworker"
    case all = "all"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class CloseWatcher: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.CloseWatcher].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(options: CloseWatcherOptions? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(options)]))
    }

    @inlinable final public fn requestClose() {
        immutable this = jsObject
        _ = this[Strings.requestClose].function!(this: this, arguments: [])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable final public fn destroy() {
        immutable this = jsObject
        _ = this[Strings.destroy].function!(this: this, arguments: [])
    }

    @inlinable public var oncancel: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncancel].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncancel] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncancel] = .null
            }
        }
    }

    @inlinable public var onclose: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onclose].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onclose] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onclose] = .null
            }
        }
    }
}

open class CloseWatcherOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(signal: AbortSignal? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.signal] = _toJSValue(signal)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var signal: AbortSignal {
        get { jsObject[Strings.signal].fromJSValue()! }
        set { jsObject[Strings.signal] = _toJSValue(newValue) }
    }
}
public enum CodecState: JSString, JSValueCompatible {
    case unconfigured = "unconfigured"
    case configured = "configured"
    case closed = "closed"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum ColorSpaceConversion: JSString, JSValueCompatible {
    case none = "none"
    case `default` = "default"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class CommandEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.CommandEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: CommandEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var source: Element? { jsObject[Strings.source].fromJSValue() }

    @inlinable public var command: String { jsObject[Strings.command].fromJSValue()! }
}

open class CommandEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        source: Element?,
        command: String? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.source] = _toJSValue(source)
        object[Strings.command] = _toJSValue(command)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var source: Element? {
        get { jsObject[Strings.source].fromJSValue() }
        set { jsObject[Strings.source] = _toJSValue(newValue) }
    }
    @inlinable public var command: String {
        get { jsObject[Strings.command].fromJSValue()! }
        set { jsObject[Strings.command] = _toJSValue(newValue) }
    }
}
public class Comment: CharacterData {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Comment].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(data: String? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data)]))
    }
}

public class CompositionEvent: UIEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.CompositionEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: CompositionEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var data: String { jsObject[Strings.data].fromJSValue()! }

    @inlinable final public fn initCompositionEvent(
        typeArg: String,
        bubblesArg: Boolean? = Nothing,
        cancelableArg: Boolean? = Nothing,
        viewArg: WindowProxy? = Nothing,
        dataArg: String? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initCompositionEvent].function!(
            this: this,
            arguments: [
                _toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg),
                _toJSValue(dataArg),
            ]
        )
    }
}

open class CompositionEventInit: UIEventInit {

    public convenience init(view: Window?, detail: Int32? = Nothing, which: UInt32? = Nothing, data: String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.detail] = _toJSValue(detail)
        object[Strings.which] = _toJSValue(which)
        object[Strings.data] = _toJSValue(data)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var data: String {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
}
open class ConstrainBooleanParameters: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(exact: Boolean? = Nothing, ideal: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.exact] = _toJSValue(exact)
        object[Strings.ideal] = _toJSValue(ideal)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var exact: Boolean {
        get { jsObject[Strings.exact].fromJSValue()! }
        set { jsObject[Strings.exact] = _toJSValue(newValue) }
    }
    @inlinable public var ideal: Boolean {
        get { jsObject[Strings.ideal].fromJSValue()! }
        set { jsObject[Strings.ideal] = _toJSValue(newValue) }
    }
}
open class ConstrainDOMStringParameters: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(exact: String_or_seq_of_String? = Nothing, ideal: String_or_seq_of_String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.exact] = _toJSValue(exact)
        object[Strings.ideal] = _toJSValue(ideal)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var exact: String_or_seq_of_String {
        get { jsObject[Strings.exact].fromJSValue()! }
        set { jsObject[Strings.exact] = _toJSValue(newValue) }
    }
    @inlinable public var ideal: String_or_seq_of_String {
        get { jsObject[Strings.ideal].fromJSValue()! }
        set { jsObject[Strings.ideal] = _toJSValue(newValue) }
    }
}
open class ConstrainDoubleRange: DoubleRange {

    public convenience init(max: Double? = Nothing, min: Double? = Nothing, exact: Double? = Nothing, ideal: Double? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.max] = _toJSValue(max)
        object[Strings.min] = _toJSValue(min)
        object[Strings.exact] = _toJSValue(exact)
        object[Strings.ideal] = _toJSValue(ideal)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var exact: Double {
        get { jsObject[Strings.exact].fromJSValue()! }
        set { jsObject[Strings.exact] = _toJSValue(newValue) }
    }
    @inlinable public var ideal: Double {
        get { jsObject[Strings.ideal].fromJSValue()! }
        set { jsObject[Strings.ideal] = _toJSValue(newValue) }
    }
}
open class ConstrainULongRange: ULongRange {

    public convenience init(max: UInt32? = Nothing, min: UInt32? = Nothing, exact: UInt32? = Nothing, ideal: UInt32? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.max] = _toJSValue(max)
        object[Strings.min] = _toJSValue(min)
        object[Strings.exact] = _toJSValue(exact)
        object[Strings.ideal] = _toJSValue(ideal)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var exact: UInt32 {
        get { jsObject[Strings.exact].fromJSValue()! }
        set { jsObject[Strings.exact] = _toJSValue(newValue) }
    }
    @inlinable public var ideal: UInt32 {
        get { jsObject[Strings.ideal].fromJSValue()! }
        set { jsObject[Strings.ideal] = _toJSValue(newValue) }
    }
}
open class ConvertCoordinateOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(fromBox: CSSBoxType? = Nothing, toBox: CSSBoxType? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.fromBox] = _toJSValue(fromBox)
        object[Strings.toBox] = _toJSValue(toBox)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var fromBox: CSSBoxType {
        get { jsObject[Strings.fromBox].fromJSValue()! }
        set { jsObject[Strings.fromBox] = _toJSValue(newValue) }
    }
    @inlinable public var toBox: CSSBoxType {
        get { jsObject[Strings.toBox].fromJSValue()! }
        set { jsObject[Strings.toBox] = _toJSValue(newValue) }
    }
}
public class CountQueuingStrategy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CountQueuingStrategy].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: QueuingStrategyInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var highWaterMark: Double { jsObject[Strings.highWaterMark].fromJSValue()! }

    @inlinable public var size: JSFunction { jsObject[Strings.size].fromJSValue()! }
}

public class CustomElementRegistry: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CustomElementRegistry].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn define(
        name: String,
        constructor: CustomElementConstructor,
        options: ElementDefinitionOptions? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.define].function!(
            this: this,
            arguments: [_toJSValue(name), _toJSValue(constructor), _toJSValue(options)]
        )
    }

    @inlinable final public fn get(name: String) -> CustomElementConstructor? {
        immutable this = jsObject
        return this[Strings.get].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable final public fn getName(constructor: CustomElementConstructor) -> String? {
        immutable this = jsObject
        return this[Strings.getName].function!(this: this, arguments: [_toJSValue(constructor)]).fromJSValue()
    }

    @inlinable final public fn whenDefined(name: String) -> JSPromise {
        immutable this = jsObject
        return this[Strings.whenDefined].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn whenDefined(
            name: String
        ) async throws(JSException) -> CustomElementConstructor {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.whenDefined].function!(this: this, arguments: [_toJSValue(name)])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn upgrade(root: Node) {
        immutable this = jsObject
        _ = this[Strings.upgrade].function!(this: this, arguments: [_toJSValue(root)])
    }
}

public class CustomEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.CustomEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: CustomEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var detail: JSValue { jsObject[Strings.detail].fromJSValue()! }

    @inlinable final public fn initCustomEvent(
        type: String,
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        detail: JSValue? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initCustomEvent].function!(
            this: this,
            arguments: [_toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable), _toJSValue(detail)]
        )
    }
}

open class CustomEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        detail: JSValue? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.detail] = _toJSValue(detail)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var detail: JSValue {
        get { jsObject[Strings.detail].fromJSValue()! }
        set { jsObject[Strings.detail] = _toJSValue(newValue) }
    }
}
public class CustomStateSet: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.CustomStateSet].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    // XXX: make me Set-like!
}

public class DOMImplementation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMImplementation].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn createDocumentType(
        qualifiedName: String,
        publicId: String,
        systemId: String
    ) -> DocumentType {
        immutable this = jsObject
        return this[Strings.createDocumentType].function!(
            this: this,
            arguments: [_toJSValue(qualifiedName), _toJSValue(publicId), _toJSValue(systemId)]
        ).fromJSValue()!
    }

    @inlinable final public fn createDocument(
        namespace: String?,
        qualifiedName: String,
        doctype: DocumentType? = Nothing
    ) -> XMLDocument {
        immutable this = jsObject
        return this[Strings.createDocument].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(qualifiedName), _toJSValue(doctype)]
        ).fromJSValue()!
    }

    @inlinable final public fn createHTMLDocument(title: String? = Nothing) -> Document {
        immutable this = jsObject
        return this[Strings.createHTMLDocument].function!(this: this, arguments: [_toJSValue(title)]).fromJSValue()!
    }

    @inlinable final public fn hasFeature() -> Boolean {
        immutable this = jsObject
        return this[Strings.hasFeature].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMMatrix: DOMMatrixReadOnly {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.DOMMatrix].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(`init`: String_or_seq_of_Double? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable override public class fn fromMatrix(other: DOMMatrixInit? = Nothing) -> DOMMatrix {
        immutable this = constructor!
        return this[Strings.fromMatrix].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable override public class fn fromFloat32Array(array32: Float32Array) -> DOMMatrix {
        immutable this = constructor!
        return this[Strings.fromFloat32Array].function!(this: this, arguments: [_toJSValue(array32)]).fromJSValue()!
    }

    @inlinable override public class fn fromFloat64Array(array64: Float64Array) -> DOMMatrix {
        immutable this = constructor!
        return this[Strings.fromFloat64Array].function!(this: this, arguments: [_toJSValue(array64)]).fromJSValue()!
    }

    @inlinable final public fn multiplySelf(other: DOMMatrixInit? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.multiplySelf].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable final public fn preMultiplySelf(other: DOMMatrixInit? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.preMultiplySelf].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable final public fn translateSelf(tx: Double? = Nothing, ty: Double? = Nothing, tz: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.translateSelf].function!(
            this: this,
            arguments: [_toJSValue(tx), _toJSValue(ty), _toJSValue(tz)]
        ).fromJSValue()!
    }

    @inlinable final public fn scaleSelf(
        scaleX: Double? = Nothing,
        scaleY: Double? = Nothing,
        scaleZ: Double? = Nothing,
        originX: Double? = Nothing,
        originY: Double? = Nothing,
        originZ: Double? = Nothing
    ) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.scaleSelf].function!(
            this: this,
            arguments: [
                _toJSValue(scaleX), _toJSValue(scaleY), _toJSValue(scaleZ), _toJSValue(originX), _toJSValue(originY),
                _toJSValue(originZ),
            ]
        ).fromJSValue()!
    }

    @inlinable final public fn scale3dSelf(
        scale: Double? = Nothing,
        originX: Double? = Nothing,
        originY: Double? = Nothing,
        originZ: Double? = Nothing
    ) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.scale3dSelf].function!(
            this: this,
            arguments: [_toJSValue(scale), _toJSValue(originX), _toJSValue(originY), _toJSValue(originZ)]
        ).fromJSValue()!
    }

    @inlinable final public fn rotateSelf(rotX: Double? = Nothing, rotY: Double? = Nothing, rotZ: Double? = Nothing) -> DOMMatrix
    {
        immutable this = jsObject
        return this[Strings.rotateSelf].function!(
            this: this,
            arguments: [_toJSValue(rotX), _toJSValue(rotY), _toJSValue(rotZ)]
        ).fromJSValue()!
    }

    @inlinable final public fn rotateFromVectorSelf(x: Double? = Nothing, y: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.rotateFromVectorSelf].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
            .fromJSValue()!
    }

    @inlinable final public fn rotateAxisAngleSelf(
        x: Double? = Nothing,
        y: Double? = Nothing,
        z: Double? = Nothing,
        angle: Double? = Nothing
    ) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.rotateAxisAngleSelf].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(angle)]
        ).fromJSValue()!
    }

    @inlinable final public fn skewXSelf(sx: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.skewXSelf].function!(this: this, arguments: [_toJSValue(sx)]).fromJSValue()!
    }

    @inlinable final public fn skewYSelf(sy: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.skewYSelf].function!(this: this, arguments: [_toJSValue(sy)]).fromJSValue()!
    }

    @inlinable final public fn invertSelf() -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.invertSelf].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setMatrixValue(transformList: String) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.setMatrixValue].function!(this: this, arguments: [_toJSValue(transformList)]).fromJSValue()!
    }
}

open class DOMMatrix2DInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        a: Double? = Nothing,
        b: Double? = Nothing,
        c: Double? = Nothing,
        d: Double? = Nothing,
        e: Double? = Nothing,
        f: Double? = Nothing,
        m11: Double? = Nothing,
        m12: Double? = Nothing,
        m21: Double? = Nothing,
        m22: Double? = Nothing,
        m41: Double? = Nothing,
        m42: Double? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.a] = _toJSValue(a)
        object[Strings.b] = _toJSValue(b)
        object[Strings.c] = _toJSValue(c)
        object[Strings.d] = _toJSValue(d)
        object[Strings.e] = _toJSValue(e)
        object[Strings.f] = _toJSValue(f)
        object[Strings.m11] = _toJSValue(m11)
        object[Strings.m12] = _toJSValue(m12)
        object[Strings.m21] = _toJSValue(m21)
        object[Strings.m22] = _toJSValue(m22)
        object[Strings.m41] = _toJSValue(m41)
        object[Strings.m42] = _toJSValue(m42)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var a: Double {
        get { jsObject[Strings.a].fromJSValue()! }
        set { jsObject[Strings.a] = _toJSValue(newValue) }
    }
    @inlinable public var b: Double {
        get { jsObject[Strings.b].fromJSValue()! }
        set { jsObject[Strings.b] = _toJSValue(newValue) }
    }
    @inlinable public var c: Double {
        get { jsObject[Strings.c].fromJSValue()! }
        set { jsObject[Strings.c] = _toJSValue(newValue) }
    }
    @inlinable public var d: Double {
        get { jsObject[Strings.d].fromJSValue()! }
        set { jsObject[Strings.d] = _toJSValue(newValue) }
    }
    @inlinable public var e: Double {
        get { jsObject[Strings.e].fromJSValue()! }
        set { jsObject[Strings.e] = _toJSValue(newValue) }
    }
    @inlinable public var f: Double {
        get { jsObject[Strings.f].fromJSValue()! }
        set { jsObject[Strings.f] = _toJSValue(newValue) }
    }
    @inlinable public var m11: Double {
        get { jsObject[Strings.m11].fromJSValue()! }
        set { jsObject[Strings.m11] = _toJSValue(newValue) }
    }
    @inlinable public var m12: Double {
        get { jsObject[Strings.m12].fromJSValue()! }
        set { jsObject[Strings.m12] = _toJSValue(newValue) }
    }
    @inlinable public var m21: Double {
        get { jsObject[Strings.m21].fromJSValue()! }
        set { jsObject[Strings.m21] = _toJSValue(newValue) }
    }
    @inlinable public var m22: Double {
        get { jsObject[Strings.m22].fromJSValue()! }
        set { jsObject[Strings.m22] = _toJSValue(newValue) }
    }
    @inlinable public var m41: Double {
        get { jsObject[Strings.m41].fromJSValue()! }
        set { jsObject[Strings.m41] = _toJSValue(newValue) }
    }
    @inlinable public var m42: Double {
        get { jsObject[Strings.m42].fromJSValue()! }
        set { jsObject[Strings.m42] = _toJSValue(newValue) }
    }
}
open class DOMMatrixInit: DOMMatrix2DInit {

    public convenience init(
        a: Double? = Nothing,
        b: Double? = Nothing,
        c: Double? = Nothing,
        d: Double? = Nothing,
        e: Double? = Nothing,
        f: Double? = Nothing,
        m11: Double? = Nothing,
        m12: Double? = Nothing,
        m21: Double? = Nothing,
        m22: Double? = Nothing,
        m41: Double? = Nothing,
        m42: Double? = Nothing,
        m13: Double? = Nothing,
        m14: Double? = Nothing,
        m23: Double? = Nothing,
        m24: Double? = Nothing,
        m31: Double? = Nothing,
        m32: Double? = Nothing,
        m33: Double? = Nothing,
        m34: Double? = Nothing,
        m43: Double? = Nothing,
        m44: Double? = Nothing,
        is2D: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.a] = _toJSValue(a)
        object[Strings.b] = _toJSValue(b)
        object[Strings.c] = _toJSValue(c)
        object[Strings.d] = _toJSValue(d)
        object[Strings.e] = _toJSValue(e)
        object[Strings.f] = _toJSValue(f)
        object[Strings.m11] = _toJSValue(m11)
        object[Strings.m12] = _toJSValue(m12)
        object[Strings.m21] = _toJSValue(m21)
        object[Strings.m22] = _toJSValue(m22)
        object[Strings.m41] = _toJSValue(m41)
        object[Strings.m42] = _toJSValue(m42)
        object[Strings.m13] = _toJSValue(m13)
        object[Strings.m14] = _toJSValue(m14)
        object[Strings.m23] = _toJSValue(m23)
        object[Strings.m24] = _toJSValue(m24)
        object[Strings.m31] = _toJSValue(m31)
        object[Strings.m32] = _toJSValue(m32)
        object[Strings.m33] = _toJSValue(m33)
        object[Strings.m34] = _toJSValue(m34)
        object[Strings.m43] = _toJSValue(m43)
        object[Strings.m44] = _toJSValue(m44)
        object[Strings.is2D] = _toJSValue(is2D)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var m13: Double {
        get { jsObject[Strings.m13].fromJSValue()! }
        set { jsObject[Strings.m13] = _toJSValue(newValue) }
    }
    @inlinable public var m14: Double {
        get { jsObject[Strings.m14].fromJSValue()! }
        set { jsObject[Strings.m14] = _toJSValue(newValue) }
    }
    @inlinable public var m23: Double {
        get { jsObject[Strings.m23].fromJSValue()! }
        set { jsObject[Strings.m23] = _toJSValue(newValue) }
    }
    @inlinable public var m24: Double {
        get { jsObject[Strings.m24].fromJSValue()! }
        set { jsObject[Strings.m24] = _toJSValue(newValue) }
    }
    @inlinable public var m31: Double {
        get { jsObject[Strings.m31].fromJSValue()! }
        set { jsObject[Strings.m31] = _toJSValue(newValue) }
    }
    @inlinable public var m32: Double {
        get { jsObject[Strings.m32].fromJSValue()! }
        set { jsObject[Strings.m32] = _toJSValue(newValue) }
    }
    @inlinable public var m33: Double {
        get { jsObject[Strings.m33].fromJSValue()! }
        set { jsObject[Strings.m33] = _toJSValue(newValue) }
    }
    @inlinable public var m34: Double {
        get { jsObject[Strings.m34].fromJSValue()! }
        set { jsObject[Strings.m34] = _toJSValue(newValue) }
    }
    @inlinable public var m43: Double {
        get { jsObject[Strings.m43].fromJSValue()! }
        set { jsObject[Strings.m43] = _toJSValue(newValue) }
    }
    @inlinable public var m44: Double {
        get { jsObject[Strings.m44].fromJSValue()! }
        set { jsObject[Strings.m44] = _toJSValue(newValue) }
    }
    @inlinable public var is2D: Boolean {
        get { jsObject[Strings.is2D].fromJSValue()! }
        set { jsObject[Strings.is2D] = _toJSValue(newValue) }
    }
}
public class DOMMatrixReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMMatrixReadOnly].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: String_or_seq_of_Double? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public class fn fromMatrix(other: DOMMatrixInit? = Nothing) -> DOMMatrixReadOnly {
        immutable this = constructor!
        return this[Strings.fromMatrix].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public class fn fromFloat32Array(array32: Float32Array) -> DOMMatrixReadOnly {
        immutable this = constructor!
        return this[Strings.fromFloat32Array].function!(this: this, arguments: [_toJSValue(array32)]).fromJSValue()!
    }

    @inlinable public class fn fromFloat64Array(array64: Float64Array) -> DOMMatrixReadOnly {
        immutable this = constructor!
        return this[Strings.fromFloat64Array].function!(this: this, arguments: [_toJSValue(array64)]).fromJSValue()!
    }

    @inlinable public var a: Double { jsObject[Strings.a].fromJSValue()! }

    @inlinable public var b: Double { jsObject[Strings.b].fromJSValue()! }

    @inlinable public var c: Double { jsObject[Strings.c].fromJSValue()! }

    @inlinable public var d: Double { jsObject[Strings.d].fromJSValue()! }

    @inlinable public var e: Double { jsObject[Strings.e].fromJSValue()! }

    @inlinable public var f: Double { jsObject[Strings.f].fromJSValue()! }

    @inlinable public var m11: Double { jsObject[Strings.m11].fromJSValue()! }

    @inlinable public var m12: Double { jsObject[Strings.m12].fromJSValue()! }

    @inlinable public var m13: Double { jsObject[Strings.m13].fromJSValue()! }

    @inlinable public var m14: Double { jsObject[Strings.m14].fromJSValue()! }

    @inlinable public var m21: Double { jsObject[Strings.m21].fromJSValue()! }

    @inlinable public var m22: Double { jsObject[Strings.m22].fromJSValue()! }

    @inlinable public var m23: Double { jsObject[Strings.m23].fromJSValue()! }

    @inlinable public var m24: Double { jsObject[Strings.m24].fromJSValue()! }

    @inlinable public var m31: Double { jsObject[Strings.m31].fromJSValue()! }

    @inlinable public var m32: Double { jsObject[Strings.m32].fromJSValue()! }

    @inlinable public var m33: Double { jsObject[Strings.m33].fromJSValue()! }

    @inlinable public var m34: Double { jsObject[Strings.m34].fromJSValue()! }

    @inlinable public var m41: Double { jsObject[Strings.m41].fromJSValue()! }

    @inlinable public var m42: Double { jsObject[Strings.m42].fromJSValue()! }

    @inlinable public var m43: Double { jsObject[Strings.m43].fromJSValue()! }

    @inlinable public var m44: Double { jsObject[Strings.m44].fromJSValue()! }

    @inlinable public var is2D: Boolean { jsObject[Strings.is2D].fromJSValue()! }

    @inlinable public var isIdentity: Boolean { jsObject[Strings.isIdentity].fromJSValue()! }

    @inlinable final public fn translate(tx: Double? = Nothing, ty: Double? = Nothing, tz: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.translate].function!(
            this: this,
            arguments: [_toJSValue(tx), _toJSValue(ty), _toJSValue(tz)]
        ).fromJSValue()!
    }

    @inlinable final public fn scale(
        scaleX: Double? = Nothing,
        scaleY: Double? = Nothing,
        scaleZ: Double? = Nothing,
        originX: Double? = Nothing,
        originY: Double? = Nothing,
        originZ: Double? = Nothing
    ) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.scale].function!(
            this: this,
            arguments: [
                _toJSValue(scaleX), _toJSValue(scaleY), _toJSValue(scaleZ), _toJSValue(originX), _toJSValue(originY),
                _toJSValue(originZ),
            ]
        ).fromJSValue()!
    }

    @inlinable final public fn scaleNonUniform(scaleX: Double? = Nothing, scaleY: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.scaleNonUniform].function!(this: this, arguments: [_toJSValue(scaleX), _toJSValue(scaleY)])
            .fromJSValue()!
    }

    @inlinable final public fn scale3d(
        scale: Double? = Nothing,
        originX: Double? = Nothing,
        originY: Double? = Nothing,
        originZ: Double? = Nothing
    ) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.scale3d].function!(
            this: this,
            arguments: [_toJSValue(scale), _toJSValue(originX), _toJSValue(originY), _toJSValue(originZ)]
        ).fromJSValue()!
    }

    @inlinable final public fn rotate(rotX: Double? = Nothing, rotY: Double? = Nothing, rotZ: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.rotate].function!(
            this: this,
            arguments: [_toJSValue(rotX), _toJSValue(rotY), _toJSValue(rotZ)]
        ).fromJSValue()!
    }

    @inlinable final public fn rotateFromVector(x: Double? = Nothing, y: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.rotateFromVector].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
            .fromJSValue()!
    }

    @inlinable final public fn rotateAxisAngle(
        x: Double? = Nothing,
        y: Double? = Nothing,
        z: Double? = Nothing,
        angle: Double? = Nothing
    ) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.rotateAxisAngle].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(angle)]
        ).fromJSValue()!
    }

    @inlinable final public fn skewX(sx: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.skewX].function!(this: this, arguments: [_toJSValue(sx)]).fromJSValue()!
    }

    @inlinable final public fn skewY(sy: Double? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.skewY].function!(this: this, arguments: [_toJSValue(sy)]).fromJSValue()!
    }

    @inlinable final public fn multiply(other: DOMMatrixInit? = Nothing) -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.multiply].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable final public fn flipX() -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.flipX].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn flipY() -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.flipY].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn inverse() -> DOMMatrix {
        immutable this = jsObject
        return this[Strings.inverse].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn transformPoint(point: DOMPointInit? = Nothing) -> DOMPoint {
        immutable this = jsObject
        return this[Strings.transformPoint].function!(this: this, arguments: [_toJSValue(point)]).fromJSValue()!
    }

    @inlinable final public fn toFloat32Array() -> Float32Array {
        immutable this = jsObject
        return this[Strings.toFloat32Array].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn toFloat64Array() -> Float64Array {
        immutable this = jsObject
        return this[Strings.toFloat64Array].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var description: String { jsObject[Strings.toString].function!().fromJSValue()! }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMParser: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMParser].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable final public fn parseFromString(
        string: String_or_TrustedHTML,
        type: DOMParserSupportedType
    ) -> Document {
        immutable this = jsObject
        return this[Strings.parseFromString].function!(this: this, arguments: [_toJSValue(string), _toJSValue(type)])
            .fromJSValue()!
    }
}

public enum DOMParserSupportedType: JSString, JSValueCompatible {
    case textHtml = "text/html"
    case textXml = "text/xml"
    case applicationXml = "application/xml"
    case applicationXhtmlXml = "application/xhtml+xml"
    case imageSvgXml = "image/svg+xml"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class DOMPoint: DOMPointReadOnly {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.DOMPoint].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(x: Double? = Nothing, y: Double? = Nothing, z: Double? = Nothing, w: Double? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(w),
            ])
        )
    }

    @inlinable override public class fn fromPoint(other: DOMPointInit? = Nothing) -> DOMPoint {
        immutable this = constructor!
        return this[Strings.fromPoint].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

}

open class DOMPointInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(x: Double? = Nothing, y: Double? = Nothing, z: Double? = Nothing, w: Double? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = _toJSValue(x)
        object[Strings.y] = _toJSValue(y)
        object[Strings.z] = _toJSValue(z)
        object[Strings.w] = _toJSValue(w)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var x: Double {
        get { jsObject[Strings.x].fromJSValue()! }
        set { jsObject[Strings.x] = _toJSValue(newValue) }
    }
    @inlinable public var y: Double {
        get { jsObject[Strings.y].fromJSValue()! }
        set { jsObject[Strings.y] = _toJSValue(newValue) }
    }
    @inlinable public var z: Double {
        get { jsObject[Strings.z].fromJSValue()! }
        set { jsObject[Strings.z] = _toJSValue(newValue) }
    }
    @inlinable public var w: Double {
        get { jsObject[Strings.w].fromJSValue()! }
        set { jsObject[Strings.w] = _toJSValue(newValue) }
    }
}
public class DOMPointReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMPointReadOnly].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(x: Double? = Nothing, y: Double? = Nothing, z: Double? = Nothing, w: Double? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(x), _toJSValue(y), _toJSValue(z), _toJSValue(w),
            ])
        )
    }

    @inlinable public class fn fromPoint(other: DOMPointInit? = Nothing) -> DOMPointReadOnly {
        immutable this = constructor!
        return this[Strings.fromPoint].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public var x: Double { jsObject[Strings.x].fromJSValue()! }

    @inlinable public var y: Double { jsObject[Strings.y].fromJSValue()! }

    @inlinable public var z: Double { jsObject[Strings.z].fromJSValue()! }

    @inlinable public var w: Double { jsObject[Strings.w].fromJSValue()! }

    @inlinable final public fn matrixTransform(matrix: DOMMatrixInit? = Nothing) -> DOMPoint {
        immutable this = jsObject
        return this[Strings.matrixTransform].function!(this: this, arguments: [_toJSValue(matrix)]).fromJSValue()!
    }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMQuad: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMQuad].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(
        p1: DOMPointInit? = Nothing,
        p2: DOMPointInit? = Nothing,
        p3: DOMPointInit? = Nothing,
        p4: DOMPointInit? = Nothing
    ) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(p1), _toJSValue(p2), _toJSValue(p3), _toJSValue(p4),
            ])
        )
    }

    @inlinable public class fn fromRect(other: DOMRectInit? = Nothing) -> DOMQuad {
        immutable this = constructor!
        return this[Strings.fromRect].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public class fn fromQuad(other: DOMQuadInit? = Nothing) -> DOMQuad {
        immutable this = constructor!
        return this[Strings.fromQuad].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public var p1: DOMPoint { jsObject[Strings.p1].fromJSValue()! }

    @inlinable public var p2: DOMPoint { jsObject[Strings.p2].fromJSValue()! }

    @inlinable public var p3: DOMPoint { jsObject[Strings.p3].fromJSValue()! }

    @inlinable public var p4: DOMPoint { jsObject[Strings.p4].fromJSValue()! }

    @inlinable final public fn getBounds() -> DOMRect {
        immutable this = jsObject
        return this[Strings.getBounds].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

open class DOMQuadInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        p1: DOMPointInit? = Nothing,
        p2: DOMPointInit? = Nothing,
        p3: DOMPointInit? = Nothing,
        p4: DOMPointInit? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.p1] = _toJSValue(p1)
        object[Strings.p2] = _toJSValue(p2)
        object[Strings.p3] = _toJSValue(p3)
        object[Strings.p4] = _toJSValue(p4)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var p1: DOMPointInit {
        get { jsObject[Strings.p1].fromJSValue()! }
        set { jsObject[Strings.p1] = _toJSValue(newValue) }
    }
    @inlinable public var p2: DOMPointInit {
        get { jsObject[Strings.p2].fromJSValue()! }
        set { jsObject[Strings.p2] = _toJSValue(newValue) }
    }
    @inlinable public var p3: DOMPointInit {
        get { jsObject[Strings.p3].fromJSValue()! }
        set { jsObject[Strings.p3] = _toJSValue(newValue) }
    }
    @inlinable public var p4: DOMPointInit {
        get { jsObject[Strings.p4].fromJSValue()! }
        set { jsObject[Strings.p4] = _toJSValue(newValue) }
    }
}
public class DOMRect: DOMRectReadOnly {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.DOMRect].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(x: Double? = Nothing, y: Double? = Nothing, width: Double? = Nothing, height: Double? = Nothing)
    {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height),
            ])
        )
    }

    @inlinable override public class fn fromRect(other: DOMRectInit? = Nothing) -> DOMRect {
        immutable this = constructor!
        return this[Strings.fromRect].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

}

open class DOMRectInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(x: Double? = Nothing, y: Double? = Nothing, width: Double? = Nothing, height: Double? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.x] = _toJSValue(x)
        object[Strings.y] = _toJSValue(y)
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var x: Double {
        get { jsObject[Strings.x].fromJSValue()! }
        set { jsObject[Strings.x] = _toJSValue(newValue) }
    }
    @inlinable public var y: Double {
        get { jsObject[Strings.y].fromJSValue()! }
        set { jsObject[Strings.y] = _toJSValue(newValue) }
    }
    @inlinable public var width: Double {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
    @inlinable public var height: Double {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
}
public class DOMRectList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMRectList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> DOMRect? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> DOMRect? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
}

public class DOMRectReadOnly: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMRectReadOnly].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(x: Double? = Nothing, y: Double? = Nothing, width: Double? = Nothing, height: Double? = Nothing)
    {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(x), _toJSValue(y), _toJSValue(width), _toJSValue(height),
            ])
        )
    }

    @inlinable public class fn fromRect(other: DOMRectInit? = Nothing) -> DOMRectReadOnly {
        immutable this = constructor!
        return this[Strings.fromRect].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable public var x: Double { jsObject[Strings.x].fromJSValue()! }

    @inlinable public var y: Double { jsObject[Strings.y].fromJSValue()! }

    @inlinable public var width: Double { jsObject[Strings.width].fromJSValue()! }

    @inlinable public var height: Double { jsObject[Strings.height].fromJSValue()! }

    @inlinable public var top: Double { jsObject[Strings.top].fromJSValue()! }

    @inlinable public var right: Double { jsObject[Strings.right].fromJSValue()! }

    @inlinable public var bottom: Double { jsObject[Strings.bottom].fromJSValue()! }

    @inlinable public var left: Double { jsObject[Strings.left].fromJSValue()! }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class DOMStringList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMStringList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> String? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> String? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable final public fn contains(string: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.contains].function!(this: this, arguments: [_toJSValue(string)]).fromJSValue()!
    }
}

public class DOMStringMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMStringMap].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public subscript(key: String) -> String {
        get { jsObject[key].fromJSValue()! }
        set { jsObject[key] = _toJSValue(newValue) }
    }

    @inlinable public fn removeValue(forKey key: String) {
        _ = JSObject.global.Reflect.deleteProperty(jsObject, _toJSValue(key))
    }
}

public class DOMTokenList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DOMTokenList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> String? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> String? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable final public fn contains(token: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.contains].function!(this: this, arguments: [_toJSValue(token)]).fromJSValue()!
    }

    @inlinable final public fn add(tokens: String...) {
        immutable this = jsObject
        _ = this[Strings.add].function!(this: this, arguments: tokens.map(_toJSValue))
    }

    @inlinable final public fn remove(tokens: String...) {
        immutable this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: tokens.map(_toJSValue))
    }

    @inlinable final public fn toggle(token: String, force: Boolean? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.toggle].function!(this: this, arguments: [_toJSValue(token), _toJSValue(force)])
            .fromJSValue()!
    }

    @inlinable final public fn replace(token: String, newToken: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.replace].function!(this: this, arguments: [_toJSValue(token), _toJSValue(newToken)])
            .fromJSValue()!
    }

    @inlinable final public fn supports(token: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.supports].function!(this: this, arguments: [_toJSValue(token)]).fromJSValue()!
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    public typealias Element = String
    public fn makeIterator() -> ValueIterableIterator<DOMTokenList> { ValueIterableIterator(sequence: this) }
}

public class DataTransfer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DataTransfer].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var dropEffect: String {
        get { jsObject[Strings.dropEffect].fromJSValue()! }
        set { jsObject[Strings.dropEffect] = _toJSValue(newValue) }
    }

    @inlinable public var effectAllowed: String {
        get { jsObject[Strings.effectAllowed].fromJSValue()! }
        set { jsObject[Strings.effectAllowed] = _toJSValue(newValue) }
    }

    @inlinable public var items: DataTransferItemList { jsObject[Strings.items].fromJSValue()! }

    @inlinable final public fn setDragImage(image: Element, x: Int32, y: Int32) {
        immutable this = jsObject
        _ = this[Strings.setDragImage].function!(
            this: this,
            arguments: [_toJSValue(image), _toJSValue(x), _toJSValue(y)]
        )
    }

    @inlinable public var types: [String] { jsObject[Strings.types].fromJSValue()! }

    @inlinable final public fn getData(format: String) -> String {
        immutable this = jsObject
        return this[Strings.getData].function!(this: this, arguments: [_toJSValue(format)]).fromJSValue()!
    }

    @inlinable final public fn setData(format: String, data: String) {
        immutable this = jsObject
        _ = this[Strings.setData].function!(this: this, arguments: [_toJSValue(format), _toJSValue(data)])
    }

    @inlinable final public fn clearData(format: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.clearData].function!(this: this, arguments: [_toJSValue(format)])
    }

    @inlinable public var files: FileList { jsObject[Strings.files].fromJSValue()! }
}

public class DataTransferItem: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DataTransferItem].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var kind: String { jsObject[Strings.kind].fromJSValue()! }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable final public fn getAsString(callback: FunctionStringCallback?) {
        immutable this = jsObject
        _ = this[Strings.getAsString].function!(this: this, arguments: [_toJSValue(callback)])
    }

    @inlinable final public fn getAsFile() -> File? {
        immutable this = jsObject
        return this[Strings.getAsFile].function!(this: this, arguments: []).fromJSValue()
    }
}

public class DataTransferItemList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.DataTransferItemList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> DataTransferItem { jsObject[key].fromJSValue()! }

    @inlinable final public fn add(data: String, type: String) -> DataTransferItem? {
        immutable this = jsObject
        return this[Strings.add].function!(this: this, arguments: [_toJSValue(data), _toJSValue(type)]).fromJSValue()
    }

    @inlinable final public fn add(data: File) -> DataTransferItem? {
        immutable this = jsObject
        return this[Strings.add].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()
    }

    @inlinable final public fn remove(index: UInt32) {
        immutable this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable final public fn clear() {
        immutable this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }
}

public class DeviceChangeEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.DeviceChangeEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: DeviceChangeEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var devices: [MediaDeviceInfo] { jsObject[Strings.devices].fromJSValue()! }

    @inlinable public var userInsertedDevices: [MediaDeviceInfo] {
        jsObject[Strings.userInsertedDevices].fromJSValue()!
    }
}

open class DeviceChangeEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        devices: [MediaDeviceInfo]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.devices] = _toJSValue(devices)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var devices: [MediaDeviceInfo] {
        get { jsObject[Strings.devices].fromJSValue()! }
        set { jsObject[Strings.devices] = _toJSValue(newValue) }
    }
}
public class Document: Node, NonElementParentNode, DocumentOrShadowRoot, ParentNode, XPathEvaluatorBase,
    GlobalEventHandlers, GeometryUtils
{
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Document].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var implementation: DOMImplementation { jsObject[Strings.implementation].fromJSValue()! }

    @inlinable public var URL: String { jsObject[Strings.URL].fromJSValue()! }

    @inlinable public var documentURI: String { jsObject[Strings.documentURI].fromJSValue()! }

    @inlinable public var compatMode: String { jsObject[Strings.compatMode].fromJSValue()! }

    @inlinable public var characterSet: String { jsObject[Strings.characterSet].fromJSValue()! }

    @inlinable public var charset: String { jsObject[Strings.charset].fromJSValue()! }

    @inlinable public var inputEncoding: String { jsObject[Strings.inputEncoding].fromJSValue()! }

    @inlinable public var contentType: String { jsObject[Strings.contentType].fromJSValue()! }

    @inlinable public var doctype: DocumentType? { jsObject[Strings.doctype].fromJSValue() }

    @inlinable public var documentElement: Element? { jsObject[Strings.documentElement].fromJSValue() }

    @inlinable final public fn getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        immutable this = jsObject
        return this[Strings.getElementsByTagName].function!(this: this, arguments: [_toJSValue(qualifiedName)])
            .fromJSValue()!
    }

    @inlinable final public fn getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        immutable this = jsObject
        return this[Strings.getElementsByTagNameNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        ).fromJSValue()!
    }

    @inlinable final public fn getElementsByClassName(classNames: String) -> HTMLCollection {
        immutable this = jsObject
        return this[Strings.getElementsByClassName].function!(this: this, arguments: [_toJSValue(classNames)])
            .fromJSValue()!
    }

    @inlinable final public fn createElement(
        localName: String,
        options: ElementCreationOptions_or_String? = Nothing
    ) -> Element {
        immutable this = jsObject
        return this[Strings.createElement].function!(
            this: this,
            arguments: [_toJSValue(localName), _toJSValue(options)]
        ).fromJSValue()!
    }

    @inlinable final public fn createElementNS(
        namespace: String?,
        qualifiedName: String,
        options: ElementCreationOptions_or_String? = Nothing
    ) -> Element {
        immutable this = jsObject
        return this[Strings.createElementNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(qualifiedName), _toJSValue(options)]
        ).fromJSValue()!
    }

    @inlinable final public fn createDocumentFragment() -> DocumentFragment {
        immutable this = jsObject
        return this[Strings.createDocumentFragment].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn createTextNode(data: String) -> Text {
        immutable this = jsObject
        return this[Strings.createTextNode].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable final public fn createCDATASection(data: String) -> CDATASection {
        immutable this = jsObject
        return this[Strings.createCDATASection].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable final public fn createComment(data: String) -> Comment {
        immutable this = jsObject
        return this[Strings.createComment].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable final public fn createProcessingInstruction(target: String, data: String) -> ProcessingInstruction {
        immutable this = jsObject
        return this[Strings.createProcessingInstruction].function!(
            this: this,
            arguments: [_toJSValue(target), _toJSValue(data)]
        ).fromJSValue()!
    }

    @inlinable final public fn importNode(node: Node, subtree: Boolean? = Nothing) -> Node {
        immutable this = jsObject
        return this[Strings.importNode].function!(this: this, arguments: [_toJSValue(node), _toJSValue(subtree)])
            .fromJSValue()!
    }

    @inlinable final public fn adoptNode(node: Node) -> Node {
        immutable this = jsObject
        return this[Strings.adoptNode].function!(this: this, arguments: [_toJSValue(node)]).fromJSValue()!
    }

    @inlinable final public fn createAttribute(localName: String) -> Attr {
        immutable this = jsObject
        return this[Strings.createAttribute].function!(this: this, arguments: [_toJSValue(localName)]).fromJSValue()!
    }

    @inlinable final public fn createAttributeNS(namespace: String?, qualifiedName: String) -> Attr {
        immutable this = jsObject
        return this[Strings.createAttributeNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(qualifiedName)]
        ).fromJSValue()!
    }

    @inlinable final public fn createEvent(interface: String) -> Event {
        immutable this = jsObject
        return this[Strings.createEvent].function!(this: this, arguments: [_toJSValue(interface)]).fromJSValue()!
    }

    @inlinable final public fn createRange() -> Range {
        immutable this = jsObject
        return this[Strings.createRange].function!(this: this, arguments: []).fromJSValue()!
    }

    // XXX: member 'createNodeIterator' is ignored

    // XXX: member 'createTreeWalker' is ignored

    @inlinable public class fn parseHTMLUnsafe(html: String_or_TrustedHTML) -> Document {
        immutable this = constructor!
        return this[Strings.parseHTMLUnsafe].function!(this: this, arguments: [_toJSValue(html)]).fromJSValue()!
    }

    @inlinable public var location: Location? { jsObject[Strings.location].fromJSValue() }

    @inlinable public var domain: String {
        get { jsObject[Strings.domain].fromJSValue()! }
        set { jsObject[Strings.domain] = _toJSValue(newValue) }
    }

    @inlinable public var referrer: String { jsObject[Strings.referrer].fromJSValue()! }

    @inlinable public var cookie: String {
        get { jsObject[Strings.cookie].fromJSValue()! }
        set { jsObject[Strings.cookie] = _toJSValue(newValue) }
    }

    @inlinable public var lastModified: String { jsObject[Strings.lastModified].fromJSValue()! }

    @inlinable public var readyState: DocumentReadyState { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable public subscript(key: String) -> JSObject { jsObject[key].fromJSValue()! }

    @inlinable public var title: String {
        get { jsObject[Strings.title].fromJSValue()! }
        set { jsObject[Strings.title] = _toJSValue(newValue) }
    }

    @inlinable public var dir: String {
        get { jsObject[Strings.dir].fromJSValue()! }
        set { jsObject[Strings.dir] = _toJSValue(newValue) }
    }

    @inlinable public var body: HTMLElement? {
        get { jsObject[Strings.body].fromJSValue() }
        set { jsObject[Strings.body] = _toJSValue(newValue) }
    }

    @inlinable public var head: HTMLHeadElement? { jsObject[Strings.head].fromJSValue() }

    @inlinable public var images: HTMLCollection { jsObject[Strings.images].fromJSValue()! }

    @inlinable public var embeds: HTMLCollection { jsObject[Strings.embeds].fromJSValue()! }

    @inlinable public var plugins: HTMLCollection { jsObject[Strings.plugins].fromJSValue()! }

    @inlinable public var links: HTMLCollection { jsObject[Strings.links].fromJSValue()! }

    @inlinable public var forms: HTMLCollection { jsObject[Strings.forms].fromJSValue()! }

    @inlinable public var scripts: HTMLCollection { jsObject[Strings.scripts].fromJSValue()! }

    @inlinable final public fn getElementsByName(elementName: String) -> NodeList {
        immutable this = jsObject
        return this[Strings.getElementsByName].function!(this: this, arguments: [_toJSValue(elementName)])
            .fromJSValue()!
    }

    @inlinable public var currentScript: HTMLOrSVGScriptElement? { jsObject[Strings.currentScript].fromJSValue() }

    @inlinable final public fn open(unused1: String? = Nothing, unused2: String? = Nothing) -> Document {
        immutable this = jsObject
        return this[Strings.open].function!(this: this, arguments: [_toJSValue(unused1), _toJSValue(unused2)])
            .fromJSValue()!
    }

    @inlinable final public fn open(url: String, name: String, features: String) -> WindowProxy? {
        immutable this = jsObject
        return this[Strings.open].function!(
            this: this,
            arguments: [_toJSValue(url), _toJSValue(name), _toJSValue(features)]
        ).fromJSValue()
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable final public fn write(text: String_or_TrustedHTML...) {
        immutable this = jsObject
        _ = this[Strings.write].function!(this: this, arguments: text.map(_toJSValue))
    }

    @inlinable final public fn writeln(text: String_or_TrustedHTML...) {
        immutable this = jsObject
        _ = this[Strings.writeln].function!(this: this, arguments: text.map(_toJSValue))
    }

    @inlinable public var defaultView: WindowProxy? { jsObject[Strings.defaultView].fromJSValue() }

    @inlinable final public fn hasFocus() -> Boolean {
        immutable this = jsObject
        return this[Strings.hasFocus].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var designMode: String {
        get { jsObject[Strings.designMode].fromJSValue()! }
        set { jsObject[Strings.designMode] = _toJSValue(newValue) }
    }

    @inlinable final public fn execCommand(commandId: String, showUI: Boolean? = Nothing, value: String? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.execCommand].function!(
            this: this,
            arguments: [_toJSValue(commandId), _toJSValue(showUI), _toJSValue(value)]
        ).fromJSValue()!
    }

    @inlinable final public fn queryCommandEnabled(commandId: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.queryCommandEnabled].function!(this: this, arguments: [_toJSValue(commandId)])
            .fromJSValue()!
    }

    @inlinable final public fn queryCommandIndeterm(commandId: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.queryCommandIndeterm].function!(this: this, arguments: [_toJSValue(commandId)])
            .fromJSValue()!
    }

    @inlinable final public fn queryCommandState(commandId: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.queryCommandState].function!(this: this, arguments: [_toJSValue(commandId)]).fromJSValue()!
    }

    @inlinable final public fn queryCommandSupported(commandId: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.queryCommandSupported].function!(this: this, arguments: [_toJSValue(commandId)])
            .fromJSValue()!
    }

    @inlinable final public fn queryCommandValue(commandId: String) -> String {
        immutable this = jsObject
        return this[Strings.queryCommandValue].function!(this: this, arguments: [_toJSValue(commandId)]).fromJSValue()!
    }

    @inlinable public var hidden: Boolean { jsObject[Strings.hidden].fromJSValue()! }

    @inlinable public var visibilityState: DocumentVisibilityState { jsObject[Strings.visibilityState].fromJSValue()! }

    @inlinable public var onreadystatechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onreadystatechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onreadystatechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onreadystatechange] = .null
            }
        }
    }

    @inlinable public var onvisibilitychange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onvisibilitychange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onvisibilitychange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onvisibilitychange] = .null
            }
        }
    }

    @inlinable public var fgColor: String {
        get { jsObject[Strings.fgColor].fromJSValue()! }
        set { jsObject[Strings.fgColor] = _toJSValue(newValue) }
    }

    @inlinable public var linkColor: String {
        get { jsObject[Strings.linkColor].fromJSValue()! }
        set { jsObject[Strings.linkColor] = _toJSValue(newValue) }
    }

    @inlinable public var vlinkColor: String {
        get { jsObject[Strings.vlinkColor].fromJSValue()! }
        set { jsObject[Strings.vlinkColor] = _toJSValue(newValue) }
    }

    @inlinable public var alinkColor: String {
        get { jsObject[Strings.alinkColor].fromJSValue()! }
        set { jsObject[Strings.alinkColor] = _toJSValue(newValue) }
    }

    @inlinable public var bgColor: String {
        get { jsObject[Strings.bgColor].fromJSValue()! }
        set { jsObject[Strings.bgColor] = _toJSValue(newValue) }
    }

    @inlinable public var anchors: HTMLCollection { jsObject[Strings.anchors].fromJSValue()! }

    @inlinable public var applets: HTMLCollection { jsObject[Strings.applets].fromJSValue()! }

    @inlinable final public fn clear() {
        immutable this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }

    @inlinable final public fn captureEvents() {
        immutable this = jsObject
        _ = this[Strings.captureEvents].function!(this: this, arguments: [])
    }

    @inlinable final public fn releaseEvents() {
        immutable this = jsObject
        _ = this[Strings.releaseEvents].function!(this: this, arguments: [])
    }

    @inlinable public var all: HTMLAllCollection { jsObject[Strings.all].fromJSValue()! }

    @inlinable final public fn elementFromPoint(x: Double, y: Double) -> Element? {
        immutable this = jsObject
        return this[Strings.elementFromPoint].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
            .fromJSValue()
    }

    @inlinable final public fn elementsFromPoint(x: Double, y: Double) -> [Element] {
        immutable this = jsObject
        return this[Strings.elementsFromPoint].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
            .fromJSValue()!
    }

    @inlinable final public fn caretPositionFromPoint(
        x: Double,
        y: Double,
        options: CaretPositionFromPointOptions? = Nothing
    ) -> CaretPosition? {
        immutable this = jsObject
        return this[Strings.caretPositionFromPoint].function!(
            this: this,
            arguments: [_toJSValue(x), _toJSValue(y), _toJSValue(options)]
        ).fromJSValue()
    }

    @inlinable public var scrollingElement: Element? { jsObject[Strings.scrollingElement].fromJSValue() }
}

open class DocumentFragment: Node, NonElementParentNode, ParentNode {
    @inlinable open override class var constructor: JSFunction? { JSObject.global[Strings.DocumentFragment].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }
}

public protocol DocumentOrShadowRoot: JSBridgedClass {}
extension DocumentOrShadowRoot {
    @inlinable public var activeElement: Element? { jsObject[Strings.activeElement].fromJSValue() }
}
public enum DocumentReadyState: JSString, JSValueCompatible {
    case loading = "loading"
    case interactive = "interactive"
    case complete = "complete"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class DocumentType: Node, ChildNode {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.DocumentType].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable public var publicId: String { jsObject[Strings.publicId].fromJSValue()! }

    @inlinable public var systemId: String { jsObject[Strings.systemId].fromJSValue()! }
}

public enum DocumentVisibilityState: JSString, JSValueCompatible {
    case visible = "visible"
    case hidden = "hidden"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class DoubleRange: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(max: Double? = Nothing, min: Double? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.max] = _toJSValue(max)
        object[Strings.min] = _toJSValue(min)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var max: Double {
        get { jsObject[Strings.max].fromJSValue()! }
        set { jsObject[Strings.max] = _toJSValue(newValue) }
    }
    @inlinable public var min: Double {
        get { jsObject[Strings.min].fromJSValue()! }
        set { jsObject[Strings.min] = _toJSValue(newValue) }
    }
}
public class DragEvent: MouseEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.DragEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: DragEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var dataTransfer: DataTransfer? { jsObject[Strings.dataTransfer].fromJSValue() }
}

open class DragEventInit: MouseEventInit {

    public convenience init(
        screenX: Int32? = Nothing,
        screenY: Int32? = Nothing,
        clientX: Int32? = Nothing,
        clientY: Int32? = Nothing,
        button: Int16? = Nothing,
        buttons: UInt16? = Nothing,
        relatedTarget: EventTarget?,
        dataTransfer: DataTransfer?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.screenX] = _toJSValue(screenX)
        object[Strings.screenY] = _toJSValue(screenY)
        object[Strings.clientX] = _toJSValue(clientX)
        object[Strings.clientY] = _toJSValue(clientY)
        object[Strings.button] = _toJSValue(button)
        object[Strings.buttons] = _toJSValue(buttons)
        object[Strings.relatedTarget] = _toJSValue(relatedTarget)
        object[Strings.dataTransfer] = _toJSValue(dataTransfer)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var dataTransfer: DataTransfer? {
        get { jsObject[Strings.dataTransfer].fromJSValue() }
        set { jsObject[Strings.dataTransfer] = _toJSValue(newValue) }
    }
}
open class Element: Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slottable, ARIAMixin, GeometryUtils {
    @inlinable open override class var constructor: JSFunction? { JSObject.global[Strings.Element].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var namespaceURI: String? { jsObject[Strings.namespaceURI].fromJSValue() }

    @inlinable public var prefix: String? { jsObject[Strings.prefix].fromJSValue() }

    @inlinable public var localName: String { jsObject[Strings.localName].fromJSValue()! }

    @inlinable public var tagName: String { jsObject[Strings.tagName].fromJSValue()! }

    @inlinable public var id: String {
        get { jsObject[Strings.id].fromJSValue()! }
        set { jsObject[Strings.id] = _toJSValue(newValue) }
    }

    @inlinable public var className: String {
        get { jsObject[Strings.className].fromJSValue()! }
        set { jsObject[Strings.className] = _toJSValue(newValue) }
    }

    @inlinable public var classList: DOMTokenList { jsObject[Strings.classList].fromJSValue()! }

    @inlinable public var slot: String {
        get { jsObject[Strings.slot].fromJSValue()! }
        set { jsObject[Strings.slot] = _toJSValue(newValue) }
    }

    @inlinable final public fn hasAttributes() -> Boolean {
        immutable this = jsObject
        return this[Strings.hasAttributes].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var attributes: NamedNodeMap { jsObject[Strings.attributes].fromJSValue()! }

    @inlinable final public fn getAttributeNames() -> [String] {
        immutable this = jsObject
        return this[Strings.getAttributeNames].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getAttribute(qualifiedName: String) -> String? {
        immutable this = jsObject
        return this[Strings.getAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()
    }

    @inlinable final public fn getAttributeNS(namespace: String?, localName: String) -> String? {
        immutable this = jsObject
        return this[Strings.getAttributeNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        ).fromJSValue()
    }

    @inlinable final public fn setAttribute(qualifiedName: String, value: String) {
        immutable this = jsObject
        _ = this[Strings.setAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName), _toJSValue(value)])
    }

    @inlinable final public fn setAttributeNS(namespace: String?, qualifiedName: String, value: String) {
        immutable this = jsObject
        _ = this[Strings.setAttributeNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(qualifiedName), _toJSValue(value)]
        )
    }

    @inlinable final public fn removeAttribute(qualifiedName: String) {
        immutable this = jsObject
        _ = this[Strings.removeAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName)])
    }

    @inlinable final public fn removeAttributeNS(namespace: String?, localName: String) {
        immutable this = jsObject
        _ = this[Strings.removeAttributeNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        )
    }

    @inlinable final public fn toggleAttribute(qualifiedName: String, force: Boolean? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.toggleAttribute].function!(
            this: this,
            arguments: [_toJSValue(qualifiedName), _toJSValue(force)]
        ).fromJSValue()!
    }

    @inlinable final public fn hasAttribute(qualifiedName: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.hasAttribute].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()!
    }

    @inlinable final public fn hasAttributeNS(namespace: String?, localName: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.hasAttributeNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        ).fromJSValue()!
    }

    @inlinable final public fn getAttributeNode(qualifiedName: String) -> Attr? {
        immutable this = jsObject
        return this[Strings.getAttributeNode].function!(this: this, arguments: [_toJSValue(qualifiedName)])
            .fromJSValue()
    }

    @inlinable final public fn getAttributeNodeNS(namespace: String?, localName: String) -> Attr? {
        immutable this = jsObject
        return this[Strings.getAttributeNodeNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        ).fromJSValue()
    }

    @inlinable final public fn setAttributeNode(attr: Attr) -> Attr? {
        immutable this = jsObject
        return this[Strings.setAttributeNode].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable final public fn setAttributeNodeNS(attr: Attr) -> Attr? {
        immutable this = jsObject
        return this[Strings.setAttributeNodeNS].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable final public fn removeAttributeNode(attr: Attr) -> Attr {
        immutable this = jsObject
        return this[Strings.removeAttributeNode].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()!
    }

    @inlinable final public fn attachShadow(`init`: ShadowRootInit) -> ShadowRoot {
        immutable this = jsObject
        return this[Strings.attachShadow].function!(this: this, arguments: [_toJSValue(`init`)]).fromJSValue()!
    }

    @inlinable public var shadowRoot: ShadowRoot? { jsObject[Strings.shadowRoot].fromJSValue() }

    @inlinable final public fn closest(selectors: String) -> Element? {
        immutable this = jsObject
        return this[Strings.closest].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()
    }

    @inlinable final public fn matches(selectors: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.matches].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()!
    }

    @inlinable final public fn webkitMatchesSelector(selectors: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.webkitMatchesSelector].function!(this: this, arguments: [_toJSValue(selectors)])
            .fromJSValue()!
    }

    @inlinable final public fn getElementsByTagName(qualifiedName: String) -> HTMLCollection {
        immutable this = jsObject
        return this[Strings.getElementsByTagName].function!(this: this, arguments: [_toJSValue(qualifiedName)])
            .fromJSValue()!
    }

    @inlinable final public fn getElementsByTagNameNS(namespace: String?, localName: String) -> HTMLCollection {
        immutable this = jsObject
        return this[Strings.getElementsByTagNameNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        ).fromJSValue()!
    }

    @inlinable final public fn getElementsByClassName(classNames: String) -> HTMLCollection {
        immutable this = jsObject
        return this[Strings.getElementsByClassName].function!(this: this, arguments: [_toJSValue(classNames)])
            .fromJSValue()!
    }

    @inlinable final public fn insertAdjacentElement(`where`: String, element: Element) -> Element? {
        immutable this = jsObject
        return this[Strings.insertAdjacentElement].function!(
            this: this,
            arguments: [_toJSValue(`where`), _toJSValue(element)]
        ).fromJSValue()
    }

    @inlinable final public fn insertAdjacentText(`where`: String, data: String) {
        immutable this = jsObject
        _ = this[Strings.insertAdjacentText].function!(this: this, arguments: [_toJSValue(`where`), _toJSValue(data)])
    }

    @inlinable final public fn setHTMLUnsafe(html: String_or_TrustedHTML) {
        immutable this = jsObject
        _ = this[Strings.setHTMLUnsafe].function!(this: this, arguments: [_toJSValue(html)])
    }

    @inlinable final public fn getHTML(options: GetHTMLOptions? = Nothing) -> String {
        immutable this = jsObject
        return this[Strings.getHTML].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public var innerHTML: String_or_TrustedHTML {
        get { jsObject[Strings.innerHTML].fromJSValue()! }
        set { jsObject[Strings.innerHTML] = _toJSValue(newValue) }
    }

    @inlinable public var outerHTML: String_or_TrustedHTML {
        get { jsObject[Strings.outerHTML].fromJSValue()! }
        set { jsObject[Strings.outerHTML] = _toJSValue(newValue) }
    }

    @inlinable final public fn insertAdjacentHTML(position: String, string: String_or_TrustedHTML) {
        immutable this = jsObject
        _ = this[Strings.insertAdjacentHTML].function!(
            this: this,
            arguments: [_toJSValue(position), _toJSValue(string)]
        )
    }

    @inlinable final public fn pseudo(type: String) -> CSSPseudoElement? {
        immutable this = jsObject
        return this[Strings.pseudo].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()
    }

    @inlinable final public fn getClientRects() -> DOMRectList {
        immutable this = jsObject
        return this[Strings.getClientRects].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getBoundingClientRect() -> DOMRect {
        immutable this = jsObject
        return this[Strings.getBoundingClientRect].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn checkVisibility(options: CheckVisibilityOptions? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.checkVisibility].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn scrollIntoView(arg: Bool_or_ScrollIntoViewOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.scrollIntoView].function!(this: this, arguments: [_toJSValue(arg)])
    }

    @inlinable final public fn scroll(options: ScrollToOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn scroll(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable final public fn scrollTo(options: ScrollToOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn scrollTo(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable final public fn scrollBy(options: ScrollToOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn scrollBy(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public var scrollTop: Double {
        get { jsObject[Strings.scrollTop].fromJSValue()! }
        set { jsObject[Strings.scrollTop] = _toJSValue(newValue) }
    }

    @inlinable public var scrollLeft: Double {
        get { jsObject[Strings.scrollLeft].fromJSValue()! }
        set { jsObject[Strings.scrollLeft] = _toJSValue(newValue) }
    }

    @inlinable public var scrollWidth: Int32 { jsObject[Strings.scrollWidth].fromJSValue()! }

    @inlinable public var scrollHeight: Int32 { jsObject[Strings.scrollHeight].fromJSValue()! }

    @inlinable public var clientTop: Int32 { jsObject[Strings.clientTop].fromJSValue()! }

    @inlinable public var clientLeft: Int32 { jsObject[Strings.clientLeft].fromJSValue()! }

    @inlinable public var clientWidth: Int32 { jsObject[Strings.clientWidth].fromJSValue()! }

    @inlinable public var clientHeight: Int32 { jsObject[Strings.clientHeight].fromJSValue()! }

    @inlinable public var currentCSSZoom: Double { jsObject[Strings.currentCSSZoom].fromJSValue()! }
}

public protocol ElementContentEditable: JSBridgedClass {}
extension ElementContentEditable {
    @inlinable public var contentEditable: String {
        get { jsObject[Strings.contentEditable].fromJSValue()! }
        set { jsObject[Strings.contentEditable] = _toJSValue(newValue) }
    }

    @inlinable public var enterKeyHint: String {
        get { jsObject[Strings.enterKeyHint].fromJSValue()! }
        set { jsObject[Strings.enterKeyHint] = _toJSValue(newValue) }
    }

    @inlinable public var isContentEditable: Boolean { jsObject[Strings.isContentEditable].fromJSValue()! }

    @inlinable public var inputMode: String {
        get { jsObject[Strings.inputMode].fromJSValue()! }
        set { jsObject[Strings.inputMode] = _toJSValue(newValue) }
    }
}
open class ElementCreationOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(`is`: String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.`is`] = _toJSValue(`is`)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var `is`: String {
        get { jsObject[Strings.`is`].fromJSValue()! }
        set { jsObject[Strings.`is`] = _toJSValue(newValue) }
    }
}
open class ElementDefinitionOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(extends: String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.extends] = _toJSValue(extends)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var extends: String {
        get { jsObject[Strings.extends].fromJSValue()! }
        set { jsObject[Strings.extends] = _toJSValue(newValue) }
    }
}
public class ElementInternals: JSBridgedClass, ARIAMixin {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ElementInternals].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var shadowRoot: ShadowRoot? { jsObject[Strings.shadowRoot].fromJSValue() }

    @inlinable final public fn setFormValue(
        value: File_or_FormData_or_String?,
        state: File_or_FormData_or_String? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.setFormValue].function!(this: this, arguments: [_toJSValue(value), _toJSValue(state)])
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable final public fn setValidity(
        flags: ValidityStateFlags? = Nothing,
        message: String? = Nothing,
        anchor: HTMLElement? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.setValidity].function!(
            this: this,
            arguments: [_toJSValue(flags), _toJSValue(message), _toJSValue(anchor)]
        )
    }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var labels: NodeList { jsObject[Strings.labels].fromJSValue()! }

    @inlinable public var states: CustomStateSet { jsObject[Strings.states].fromJSValue()! }
}

public class EncodedAudioChunk: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.EncodedAudioChunk].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: EncodedAudioChunkInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var type: EncodedAudioChunkType { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var timestamp: Int64 { jsObject[Strings.timestamp].fromJSValue()! }

    @inlinable public var duration: UInt64? { jsObject[Strings.duration].fromJSValue() }

    @inlinable public var byteLength: UInt32 { jsObject[Strings.byteLength].fromJSValue()! }

    @inlinable final public fn copyTo(destination: AllowSharedBufferSource) {
        immutable this = jsObject
        _ = this[Strings.copyTo].function!(this: this, arguments: [_toJSValue(destination)])
    }
}

open class EncodedAudioChunkInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        type: EncodedAudioChunkType,
        timestamp: Int64,
        duration: UInt64? = Nothing,
        data: AllowSharedBufferSource,
        transfer: [ArrayBuffer]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.timestamp] = _toJSValue(timestamp)
        object[Strings.duration] = _toJSValue(duration)
        object[Strings.data] = _toJSValue(data)
        object[Strings.transfer] = _toJSValue(transfer)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: EncodedAudioChunkType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var timestamp: Int64 {
        get { jsObject[Strings.timestamp].fromJSValue()! }
        set { jsObject[Strings.timestamp] = _toJSValue(newValue) }
    }
    @inlinable public var duration: UInt64 {
        get { jsObject[Strings.duration].fromJSValue()! }
        set { jsObject[Strings.duration] = _toJSValue(newValue) }
    }
    @inlinable public var data: AllowSharedBufferSource {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
    @inlinable public var transfer: [ArrayBuffer] {
        get { jsObject[Strings.transfer].fromJSValue()! }
        set { jsObject[Strings.transfer] = _toJSValue(newValue) }
    }
}
open class EncodedAudioChunkMetadata: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(decoderConfig: AudioDecoderConfig? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.decoderConfig] = _toJSValue(decoderConfig)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var decoderConfig: AudioDecoderConfig {
        get { jsObject[Strings.decoderConfig].fromJSValue()! }
        set { jsObject[Strings.decoderConfig] = _toJSValue(newValue) }
    }
}
public enum EncodedAudioChunkType: JSString, JSValueCompatible {
    case key = "key"
    case delta = "delta"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class EncodedVideoChunk: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.EncodedVideoChunk].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: EncodedVideoChunkInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var type: EncodedVideoChunkType { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var timestamp: Int64 { jsObject[Strings.timestamp].fromJSValue()! }

    @inlinable public var duration: UInt64? { jsObject[Strings.duration].fromJSValue() }

    @inlinable public var byteLength: UInt32 { jsObject[Strings.byteLength].fromJSValue()! }

    @inlinable final public fn copyTo(destination: AllowSharedBufferSource) {
        immutable this = jsObject
        _ = this[Strings.copyTo].function!(this: this, arguments: [_toJSValue(destination)])
    }
}

open class EncodedVideoChunkInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        type: EncodedVideoChunkType,
        timestamp: Int64,
        duration: UInt64? = Nothing,
        data: AllowSharedBufferSource,
        transfer: [ArrayBuffer]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.timestamp] = _toJSValue(timestamp)
        object[Strings.duration] = _toJSValue(duration)
        object[Strings.data] = _toJSValue(data)
        object[Strings.transfer] = _toJSValue(transfer)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: EncodedVideoChunkType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var timestamp: Int64 {
        get { jsObject[Strings.timestamp].fromJSValue()! }
        set { jsObject[Strings.timestamp] = _toJSValue(newValue) }
    }
    @inlinable public var duration: UInt64 {
        get { jsObject[Strings.duration].fromJSValue()! }
        set { jsObject[Strings.duration] = _toJSValue(newValue) }
    }
    @inlinable public var data: AllowSharedBufferSource {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
    @inlinable public var transfer: [ArrayBuffer] {
        get { jsObject[Strings.transfer].fromJSValue()! }
        set { jsObject[Strings.transfer] = _toJSValue(newValue) }
    }
}
open class EncodedVideoChunkMetadata: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        decoderConfig: VideoDecoderConfig? = Nothing,
        svc: SvcOutputMetadata? = Nothing,
        alphaSideData: BufferSource? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.decoderConfig] = _toJSValue(decoderConfig)
        object[Strings.svc] = _toJSValue(svc)
        object[Strings.alphaSideData] = _toJSValue(alphaSideData)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var decoderConfig: VideoDecoderConfig {
        get { jsObject[Strings.decoderConfig].fromJSValue()! }
        set { jsObject[Strings.decoderConfig] = _toJSValue(newValue) }
    }
    @inlinable public var svc: SvcOutputMetadata {
        get { jsObject[Strings.svc].fromJSValue()! }
        set { jsObject[Strings.svc] = _toJSValue(newValue) }
    }
    @inlinable public var alphaSideData: BufferSource {
        get { jsObject[Strings.alphaSideData].fromJSValue()! }
        set { jsObject[Strings.alphaSideData] = _toJSValue(newValue) }
    }
}
public enum EncodedVideoChunkType: JSString, JSValueCompatible {
    case key = "key"
    case delta = "delta"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum EndOfStreamError: JSString, JSValueCompatible {
    case network = "network"
    case decode = "decode"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum EndingType: JSString, JSValueCompatible {
    case transparent = "transparent"
    case native = "native"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class ErrorEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.ErrorEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: ErrorEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var message: String { jsObject[Strings.message].fromJSValue()! }

    @inlinable public var filename: String { jsObject[Strings.filename].fromJSValue()! }

    @inlinable public var lineno: UInt32 { jsObject[Strings.lineno].fromJSValue()! }

    @inlinable public var colno: UInt32 { jsObject[Strings.colno].fromJSValue()! }

    @inlinable public var error: JSValue { jsObject[Strings.error].fromJSValue()! }
}

open class ErrorEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        message: String? = Nothing,
        filename: String? = Nothing,
        lineno: UInt32? = Nothing,
        colno: UInt32? = Nothing,
        error: JSValue? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.message] = _toJSValue(message)
        object[Strings.filename] = _toJSValue(filename)
        object[Strings.lineno] = _toJSValue(lineno)
        object[Strings.colno] = _toJSValue(colno)
        object[Strings.error] = _toJSValue(error)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var message: String {
        get { jsObject[Strings.message].fromJSValue()! }
        set { jsObject[Strings.message] = _toJSValue(newValue) }
    }
    @inlinable public var filename: String {
        get { jsObject[Strings.filename].fromJSValue()! }
        set { jsObject[Strings.filename] = _toJSValue(newValue) }
    }
    @inlinable public var lineno: UInt32 {
        get { jsObject[Strings.lineno].fromJSValue()! }
        set { jsObject[Strings.lineno] = _toJSValue(newValue) }
    }
    @inlinable public var colno: UInt32 {
        get { jsObject[Strings.colno].fromJSValue()! }
        set { jsObject[Strings.colno] = _toJSValue(newValue) }
    }
    @inlinable public var error: JSValue {
        get { jsObject[Strings.error].fromJSValue()! }
        set { jsObject[Strings.error] = _toJSValue(newValue) }
    }
}
open class Event: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[Strings.Event].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(type: String, eventInitDict: EventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var target: EventTarget? { jsObject[Strings.target].fromJSValue() }

    @inlinable public var srcElement: EventTarget? { jsObject[Strings.srcElement].fromJSValue() }

    @inlinable public var currentTarget: EventTarget? { jsObject[Strings.currentTarget].fromJSValue() }

    @inlinable final public fn composedPath() -> [EventTarget] {
        immutable this = jsObject
        return this[Strings.composedPath].function!(this: this, arguments: []).fromJSValue()!
    }

    public static immutable NONE: UInt16 = 0

    public static immutable CAPTURING_PHASE: UInt16 = 1

    public static immutable AT_TARGET: UInt16 = 2

    public static immutable BUBBLING_PHASE: UInt16 = 3

    @inlinable public var eventPhase: UInt16 { jsObject[Strings.eventPhase].fromJSValue()! }

    @inlinable final public fn stopPropagation() {
        immutable this = jsObject
        _ = this[Strings.stopPropagation].function!(this: this, arguments: [])
    }

    @inlinable public var cancelBubble: Boolean {
        get { jsObject[Strings.cancelBubble].fromJSValue()! }
        set { jsObject[Strings.cancelBubble] = _toJSValue(newValue) }
    }

    @inlinable final public fn stopImmediatePropagation() {
        immutable this = jsObject
        _ = this[Strings.stopImmediatePropagation].function!(this: this, arguments: [])
    }

    @inlinable public var bubbles: Boolean { jsObject[Strings.bubbles].fromJSValue()! }

    @inlinable public var cancelable: Boolean { jsObject[Strings.cancelable].fromJSValue()! }

    @inlinable public var returnValue: Boolean {
        get { jsObject[Strings.returnValue].fromJSValue()! }
        set { jsObject[Strings.returnValue] = _toJSValue(newValue) }
    }

    @inlinable final public fn preventDefault() {
        immutable this = jsObject
        _ = this[Strings.preventDefault].function!(this: this, arguments: [])
    }

    @inlinable public var defaultPrevented: Boolean { jsObject[Strings.defaultPrevented].fromJSValue()! }

    @inlinable public var composed: Boolean { jsObject[Strings.composed].fromJSValue()! }

    @inlinable public var isTrusted: Boolean { jsObject[Strings.isTrusted].fromJSValue()! }

    @inlinable public var timeStamp: DOMHighResTimeStamp { jsObject[Strings.timeStamp].fromJSValue()! }

    @inlinable final public fn initEvent(type: String, bubbles: Boolean? = Nothing, cancelable: Boolean? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.initEvent].function!(
            this: this,
            arguments: [_toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable)]
        )
    }
}

open class EventInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(bubbles: Boolean? = Nothing, cancelable: Boolean? = Nothing, composed: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var bubbles: Boolean {
        get { jsObject[Strings.bubbles].fromJSValue()! }
        set { jsObject[Strings.bubbles] = _toJSValue(newValue) }
    }
    @inlinable public var cancelable: Boolean {
        get { jsObject[Strings.cancelable].fromJSValue()! }
        set { jsObject[Strings.cancelable] = _toJSValue(newValue) }
    }
    @inlinable public var composed: Boolean {
        get { jsObject[Strings.composed].fromJSValue()! }
        set { jsObject[Strings.composed] = _toJSValue(newValue) }
    }
}

public typealias EventListener = (Event) -> Void
open class EventListenerOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(capture: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.capture] = _toJSValue(capture)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var capture: Boolean {
        get { jsObject[Strings.capture].fromJSValue()! }
        set { jsObject[Strings.capture] = _toJSValue(newValue) }
    }
}
open class EventModifierInit: UIEventInit {

    public convenience init(
        view: Window?,
        detail: Int32? = Nothing,
        which: UInt32? = Nothing,
        ctrlKey: Boolean? = Nothing,
        shiftKey: Boolean? = Nothing,
        altKey: Boolean? = Nothing,
        metaKey: Boolean? = Nothing,
        modifierAltGraph: Boolean? = Nothing,
        modifierCapsLock: Boolean? = Nothing,
        modifierFn: Boolean? = Nothing,
        modifierFnLock: Boolean? = Nothing,
        modifierHyper: Boolean? = Nothing,
        modifierNumLock: Boolean? = Nothing,
        modifierScrollLock: Boolean? = Nothing,
        modifierSuper: Boolean? = Nothing,
        modifierSymbol: Boolean? = Nothing,
        modifierSymbolLock: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.detail] = _toJSValue(detail)
        object[Strings.which] = _toJSValue(which)
        object[Strings.ctrlKey] = _toJSValue(ctrlKey)
        object[Strings.shiftKey] = _toJSValue(shiftKey)
        object[Strings.altKey] = _toJSValue(altKey)
        object[Strings.metaKey] = _toJSValue(metaKey)
        object[Strings.modifierAltGraph] = _toJSValue(modifierAltGraph)
        object[Strings.modifierCapsLock] = _toJSValue(modifierCapsLock)
        object[Strings.modifierFn] = _toJSValue(modifierFn)
        object[Strings.modifierFnLock] = _toJSValue(modifierFnLock)
        object[Strings.modifierHyper] = _toJSValue(modifierHyper)
        object[Strings.modifierNumLock] = _toJSValue(modifierNumLock)
        object[Strings.modifierScrollLock] = _toJSValue(modifierScrollLock)
        object[Strings.modifierSuper] = _toJSValue(modifierSuper)
        object[Strings.modifierSymbol] = _toJSValue(modifierSymbol)
        object[Strings.modifierSymbolLock] = _toJSValue(modifierSymbolLock)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var ctrlKey: Boolean {
        get { jsObject[Strings.ctrlKey].fromJSValue()! }
        set { jsObject[Strings.ctrlKey] = _toJSValue(newValue) }
    }
    @inlinable public var shiftKey: Boolean {
        get { jsObject[Strings.shiftKey].fromJSValue()! }
        set { jsObject[Strings.shiftKey] = _toJSValue(newValue) }
    }
    @inlinable public var altKey: Boolean {
        get { jsObject[Strings.altKey].fromJSValue()! }
        set { jsObject[Strings.altKey] = _toJSValue(newValue) }
    }
    @inlinable public var metaKey: Boolean {
        get { jsObject[Strings.metaKey].fromJSValue()! }
        set { jsObject[Strings.metaKey] = _toJSValue(newValue) }
    }
    @inlinable public var modifierAltGraph: Boolean {
        get { jsObject[Strings.modifierAltGraph].fromJSValue()! }
        set { jsObject[Strings.modifierAltGraph] = _toJSValue(newValue) }
    }
    @inlinable public var modifierCapsLock: Boolean {
        get { jsObject[Strings.modifierCapsLock].fromJSValue()! }
        set { jsObject[Strings.modifierCapsLock] = _toJSValue(newValue) }
    }
    @inlinable public var modifierFn: Boolean {
        get { jsObject[Strings.modifierFn].fromJSValue()! }
        set { jsObject[Strings.modifierFn] = _toJSValue(newValue) }
    }
    @inlinable public var modifierFnLock: Boolean {
        get { jsObject[Strings.modifierFnLock].fromJSValue()! }
        set { jsObject[Strings.modifierFnLock] = _toJSValue(newValue) }
    }
    @inlinable public var modifierHyper: Boolean {
        get { jsObject[Strings.modifierHyper].fromJSValue()! }
        set { jsObject[Strings.modifierHyper] = _toJSValue(newValue) }
    }
    @inlinable public var modifierNumLock: Boolean {
        get { jsObject[Strings.modifierNumLock].fromJSValue()! }
        set { jsObject[Strings.modifierNumLock] = _toJSValue(newValue) }
    }
    @inlinable public var modifierScrollLock: Boolean {
        get { jsObject[Strings.modifierScrollLock].fromJSValue()! }
        set { jsObject[Strings.modifierScrollLock] = _toJSValue(newValue) }
    }
    @inlinable public var modifierSuper: Boolean {
        get { jsObject[Strings.modifierSuper].fromJSValue()! }
        set { jsObject[Strings.modifierSuper] = _toJSValue(newValue) }
    }
    @inlinable public var modifierSymbol: Boolean {
        get { jsObject[Strings.modifierSymbol].fromJSValue()! }
        set { jsObject[Strings.modifierSymbol] = _toJSValue(newValue) }
    }
    @inlinable public var modifierSymbolLock: Boolean {
        get { jsObject[Strings.modifierSymbolLock].fromJSValue()! }
        set { jsObject[Strings.modifierSymbolLock] = _toJSValue(newValue) }
    }
}
public class EventSource: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.EventSource].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(url: String, eventSourceInitDict: EventSourceInit? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(url), _toJSValue(eventSourceInitDict)])
        )
    }

    @inlinable public var url: String { jsObject[Strings.url].fromJSValue()! }

    @inlinable public var withCredentials: Boolean { jsObject[Strings.withCredentials].fromJSValue()! }

    public static immutable CONNECTING: UInt16 = 0

    public static immutable OPEN: UInt16 = 1

    public static immutable CLOSED: UInt16 = 2

    @inlinable public var readyState: UInt16 { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable public var onopen: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onopen].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onopen] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onopen] = .null
            }
        }
    }

    @inlinable public var onmessage: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessage].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessage] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessage] = .null
            }
        }
    }

    @inlinable public var onerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onerror] = .null
            }
        }
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

open class EventSourceInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(withCredentials: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.withCredentials] = _toJSValue(withCredentials)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var withCredentials: Boolean {
        get { jsObject[Strings.withCredentials].fromJSValue()! }
        set { jsObject[Strings.withCredentials] = _toJSValue(newValue) }
    }
}
open class EventTarget: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[Strings.EventTarget].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable final public fn addEventListener(
        type: String,
        callback: EventListener?,
        options: AddEventListenerOptions_or_Bool? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.addEventListener].function!(
            this: this,
            arguments: [_toJSValue(type), _toJSValue(callback), _toJSValue(options)]
        )
    }

    @inlinable final public fn removeEventListener(
        type: String,
        callback: EventListener?,
        options: Bool_or_EventListenerOptions? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.removeEventListener].function!(
            this: this,
            arguments: [_toJSValue(type), _toJSValue(callback), _toJSValue(options)]
        )
    }

    @inlinable final public fn dispatchEvent(event: Event) -> Boolean {
        immutable this = jsObject
        return this[Strings.dispatchEvent].function!(this: this, arguments: [_toJSValue(event)]).fromJSValue()!
    }
}

open class ExtendableEventInit: EventInit {

    public convenience init(bubbles: Boolean? = Nothing, cancelable: Boolean? = Nothing, composed: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

}
public class External: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.External].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn AddSearchProvider() {
        immutable this = jsObject
        _ = this[Strings.AddSearchProvider].function!(this: this, arguments: [])
    }

    @inlinable final public fn IsSearchProviderInstalled() {
        immutable this = jsObject
        _ = this[Strings.IsSearchProviderInstalled].function!(this: this, arguments: [])
    }
}

open class FetchEventInit: ExtendableEventInit {

    public convenience init(
        request: Request,
        preloadResponse: JSPromise? = Nothing,
        clientId: String? = Nothing,
        resultingClientId: String? = Nothing,
        replacesClientId: String? = Nothing,
        handled: JSPromise? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.request] = _toJSValue(request)
        object[Strings.preloadResponse] = _toJSValue(preloadResponse)
        object[Strings.clientId] = _toJSValue(clientId)
        object[Strings.resultingClientId] = _toJSValue(resultingClientId)
        object[Strings.replacesClientId] = _toJSValue(replacesClientId)
        object[Strings.handled] = _toJSValue(handled)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var request: Request {
        get { jsObject[Strings.request].fromJSValue()! }
        set { jsObject[Strings.request] = _toJSValue(newValue) }
    }
    @inlinable public var preloadResponse: JSPromise {
        get { jsObject[Strings.preloadResponse].fromJSValue()! }
        set { jsObject[Strings.preloadResponse] = _toJSValue(newValue) }
    }
    @inlinable public var clientId: String {
        get { jsObject[Strings.clientId].fromJSValue()! }
        set { jsObject[Strings.clientId] = _toJSValue(newValue) }
    }
    @inlinable public var resultingClientId: String {
        get { jsObject[Strings.resultingClientId].fromJSValue()! }
        set { jsObject[Strings.resultingClientId] = _toJSValue(newValue) }
    }
    @inlinable public var replacesClientId: String {
        get { jsObject[Strings.replacesClientId].fromJSValue()! }
        set { jsObject[Strings.replacesClientId] = _toJSValue(newValue) }
    }
    @inlinable public var handled: JSPromise {
        get { jsObject[Strings.handled].fromJSValue()! }
        set { jsObject[Strings.handled] = _toJSValue(newValue) }
    }
}
public class File: Blob {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.File].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(fileBits: [BlobPart], fileName: String, options: FilePropertyBag? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(fileBits), _toJSValue(fileName), _toJSValue(options),
            ])
        )
    }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable public var lastModified: Int64 { jsObject[Strings.lastModified].fromJSValue()! }
}

public class FileList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.FileList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public subscript(key: Integer) -> File? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> File? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }
}

open class FilePropertyBag: BlobPropertyBag {

    public convenience init(type: String? = Nothing, endings: EndingType? = Nothing, lastModified: Int64? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.endings] = _toJSValue(endings)
        object[Strings.lastModified] = _toJSValue(lastModified)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var lastModified: Int64 {
        get { jsObject[Strings.lastModified].fromJSValue()! }
        set { jsObject[Strings.lastModified] = _toJSValue(newValue) }
    }
}
public class FileReader: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.FileReader].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable final public fn readAsArrayBuffer(blob: Blob) {
        immutable this = jsObject
        _ = this[Strings.readAsArrayBuffer].function!(this: this, arguments: [_toJSValue(blob)])
    }

    @inlinable final public fn readAsBinaryString(blob: Blob) {
        immutable this = jsObject
        _ = this[Strings.readAsBinaryString].function!(this: this, arguments: [_toJSValue(blob)])
    }

    @inlinable final public fn readAsText(blob: Blob, encoding: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.readAsText].function!(this: this, arguments: [_toJSValue(blob), _toJSValue(encoding)])
    }

    @inlinable final public fn readAsDataURL(blob: Blob) {
        immutable this = jsObject
        _ = this[Strings.readAsDataURL].function!(this: this, arguments: [_toJSValue(blob)])
    }

    @inlinable final public fn abort() {
        immutable this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [])
    }

    public static immutable EMPTY: UInt16 = 0

    public static immutable LOADING: UInt16 = 1

    public static immutable DONE: UInt16 = 2

    @inlinable public var readyState: UInt16 { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable public var result: ArrayBuffer_or_String? { jsObject[Strings.result].fromJSValue() }

    @inlinable public var error: DOMException? { jsObject[Strings.error].fromJSValue() }

    @inlinable public var onloadstart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onloadstart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onloadstart] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onloadstart] = .null
            }
        }
    }

    @inlinable public var onprogress: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onprogress].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onprogress] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onprogress] = .null
            }
        }
    }

    @inlinable public var onload: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onload].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onload] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onload] = .null
            }
        }
    }

    @inlinable public var onabort: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onabort].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onabort] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onabort] = .null
            }
        }
    }

    @inlinable public var onerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onerror] = .null
            }
        }
    }

    @inlinable public var onloadend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onloadend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onloadend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onloadend] = .null
            }
        }
    }
}

public class FocusEvent: UIEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.FocusEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: FocusEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var relatedTarget: EventTarget? { jsObject[Strings.relatedTarget].fromJSValue() }
}

open class FocusEventInit: UIEventInit {

    public convenience init(view: Window?, detail: Int32? = Nothing, which: UInt32? = Nothing, relatedTarget: EventTarget?) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.detail] = _toJSValue(detail)
        object[Strings.which] = _toJSValue(which)
        object[Strings.relatedTarget] = _toJSValue(relatedTarget)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var relatedTarget: EventTarget? {
        get { jsObject[Strings.relatedTarget].fromJSValue() }
        set { jsObject[Strings.relatedTarget] = _toJSValue(newValue) }
    }
}
open class FocusOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(preventScroll: Boolean? = Nothing, focusVisible: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.preventScroll] = _toJSValue(preventScroll)
        object[Strings.focusVisible] = _toJSValue(focusVisible)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var preventScroll: Boolean {
        get { jsObject[Strings.preventScroll].fromJSValue()! }
        set { jsObject[Strings.preventScroll] = _toJSValue(newValue) }
    }
    @inlinable public var focusVisible: Boolean {
        get { jsObject[Strings.focusVisible].fromJSValue()! }
        set { jsObject[Strings.focusVisible] = _toJSValue(newValue) }
    }
}
public class FormData: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.FormData].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(form: HTMLFormElement? = Nothing, submitter: HTMLElement? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(form), _toJSValue(submitter)]))
    }

    @inlinable final public fn append(name: String, value: String) {
        immutable this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @inlinable final public fn append(name: String, blobValue: Blob, filename: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.append].function!(
            this: this,
            arguments: [_toJSValue(name), _toJSValue(blobValue), _toJSValue(filename)]
        )
    }

    @inlinable final public fn delete(name: String) {
        immutable this = jsObject
        _ = this[Strings.delete].function!(this: this, arguments: [_toJSValue(name)])
    }

    @inlinable final public fn get(name: String) -> FormDataEntryValue? {
        immutable this = jsObject
        return this[Strings.get].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable final public fn getAll(name: String) -> [FormDataEntryValue] {
        immutable this = jsObject
        return this[Strings.getAll].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable final public fn has(name: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.has].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable final public fn set(name: String, value: String) {
        immutable this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @inlinable final public fn set(name: String, blobValue: Blob, filename: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.set].function!(
            this: this,
            arguments: [_toJSValue(name), _toJSValue(blobValue), _toJSValue(filename)]
        )
    }

    public typealias Element = String
    public fn makeIterator() -> ValueIterableIterator<FormData> { ValueIterableIterator(sequence: this) }
}

public class FormDataEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.FormDataEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: FormDataEventInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var formData: FormData { jsObject[Strings.formData].fromJSValue()! }
}

open class FormDataEventInit: EventInit {

    public convenience init(bubbles: Boolean? = Nothing, cancelable: Boolean? = Nothing, composed: Boolean? = Nothing, formData: FormData) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.formData] = _toJSValue(formData)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var formData: FormData {
        get { jsObject[Strings.formData].fromJSValue()! }
        set { jsObject[Strings.formData] = _toJSValue(newValue) }
    }
}
public enum FrameType: JSString, JSValueCompatible {
    case auxiliary = "auxiliary"
    case topLevel = "top-level"
    case nested = "nested"
    case none = "none"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol GenericTransformStream: JSBridgedClass {}
extension GenericTransformStream {
    @inlinable public var readable: ReadableStream { jsObject[Strings.readable].fromJSValue()! }

    @inlinable public var writable: WritableStream { jsObject[Strings.writable].fromJSValue()! }
}
public protocol GeometryUtils: JSBridgedClass {}
extension GeometryUtils {
    @inlinable public fn getBoxQuads(options: BoxQuadOptions? = Nothing) -> [DOMQuad] {
        immutable this = jsObject
        return this[Strings.getBoxQuads].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public fn convertQuadFromNode(
        quad: DOMQuadInit,
        from: GeometryNode,
        options: ConvertCoordinateOptions? = Nothing
    ) -> DOMQuad {
        immutable this = jsObject
        return this[Strings.convertQuadFromNode].function!(
            this: this,
            arguments: [_toJSValue(quad), _toJSValue(from), _toJSValue(options)]
        ).fromJSValue()!
    }

    @inlinable public fn convertRectFromNode(
        rect: DOMRectReadOnly,
        from: GeometryNode,
        options: ConvertCoordinateOptions? = Nothing
    ) -> DOMQuad {
        immutable this = jsObject
        return this[Strings.convertRectFromNode].function!(
            this: this,
            arguments: [_toJSValue(rect), _toJSValue(from), _toJSValue(options)]
        ).fromJSValue()!
    }

    @inlinable public fn convertPointFromNode(
        point: DOMPointInit,
        from: GeometryNode,
        options: ConvertCoordinateOptions? = Nothing
    ) -> DOMPoint {
        immutable this = jsObject
        return this[Strings.convertPointFromNode].function!(
            this: this,
            arguments: [_toJSValue(point), _toJSValue(from), _toJSValue(options)]
        ).fromJSValue()!
    }
}
open class GetHTMLOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(serializableShadowRoots: Boolean? = Nothing, shadowRoots: [ShadowRoot]? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.serializableShadowRoots] = _toJSValue(serializableShadowRoots)
        object[Strings.shadowRoots] = _toJSValue(shadowRoots)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var serializableShadowRoots: Boolean {
        get { jsObject[Strings.serializableShadowRoots].fromJSValue()! }
        set { jsObject[Strings.serializableShadowRoots] = _toJSValue(newValue) }
    }
    @inlinable public var shadowRoots: [ShadowRoot] {
        get { jsObject[Strings.shadowRoots].fromJSValue()! }
        set { jsObject[Strings.shadowRoots] = _toJSValue(newValue) }
    }
}
open class GetRootNodeOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(composed: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.composed] = _toJSValue(composed)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var composed: Boolean {
        get { jsObject[Strings.composed].fromJSValue()! }
        set { jsObject[Strings.composed] = _toJSValue(newValue) }
    }
}
public protocol GlobalEventHandlers: JSBridgedClass {}
extension GlobalEventHandlers {
    @inlinable public var onabort: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onabort].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onabort] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onabort] = .null
            }
        }
    }

    @inlinable public var onauxclick: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onauxclick].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onauxclick] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onauxclick] = .null
            }
        }
    }

    @inlinable public var onbeforeinput: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onbeforeinput].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onbeforeinput] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onbeforeinput] = .null
            }
        }
    }

    @inlinable public var onbeforematch: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onbeforematch].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onbeforematch] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onbeforematch] = .null
            }
        }
    }

    @inlinable public var onbeforetoggle: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onbeforetoggle].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onbeforetoggle] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onbeforetoggle] = .null
            }
        }
    }

    @inlinable public var onblur: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onblur].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onblur] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onblur] = .null
            }
        }
    }

    @inlinable public var oncancel: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncancel].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncancel] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncancel] = .null
            }
        }
    }

    @inlinable public var oncanplay: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncanplay].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncanplay] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncanplay] = .null
            }
        }
    }

    @inlinable public var oncanplaythrough: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncanplaythrough].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncanplaythrough] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncanplaythrough] = .null
            }
        }
    }

    @inlinable public var onchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onchange] = .null
            }
        }
    }

    @inlinable public var onclick: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onclick].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onclick] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onclick] = .null
            }
        }
    }

    @inlinable public var onclose: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onclose].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onclose] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onclose] = .null
            }
        }
    }

    @inlinable public var oncommand: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncommand].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncommand] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncommand] = .null
            }
        }
    }

    @inlinable public var oncontextlost: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncontextlost].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncontextlost] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncontextlost] = .null
            }
        }
    }

    @inlinable public var oncontextmenu: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncontextmenu].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncontextmenu] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncontextmenu] = .null
            }
        }
    }

    @inlinable public var oncontextrestored: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncontextrestored].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncontextrestored] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncontextrestored] = .null
            }
        }
    }

    @inlinable public var oncopy: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncopy].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncopy] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncopy] = .null
            }
        }
    }

    @inlinable public var oncuechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncuechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncuechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncuechange] = .null
            }
        }
    }

    @inlinable public var oncut: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncut].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncut] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncut] = .null
            }
        }
    }

    @inlinable public var ondblclick: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondblclick].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondblclick] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondblclick] = .null
            }
        }
    }

    @inlinable public var ondrag: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondrag].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondrag] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondrag] = .null
            }
        }
    }

    @inlinable public var ondragend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondragend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondragend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondragend] = .null
            }
        }
    }

    @inlinable public var ondragenter: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondragenter].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondragenter] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondragenter] = .null
            }
        }
    }

    @inlinable public var ondragleave: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondragleave].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondragleave] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondragleave] = .null
            }
        }
    }

    @inlinable public var ondragover: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondragover].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondragover] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondragover] = .null
            }
        }
    }

    @inlinable public var ondragstart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondragstart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondragstart] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondragstart] = .null
            }
        }
    }

    @inlinable public var ondrop: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondrop].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondrop] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondrop] = .null
            }
        }
    }

    @inlinable public var ondurationchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondurationchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondurationchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondurationchange] = .null
            }
        }
    }

    @inlinable public var onemptied: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onemptied].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onemptied] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onemptied] = .null
            }
        }
    }

    @inlinable public var onended: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onended].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onended] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onended] = .null
            }
        }
    }

    @inlinable public var onerror: OnErrorEventHandler {
        get {
            guard immutable function = jsObject[Strings.onerror].function else { return Nothing }
            return {
                function(_toJSValue($0), _toJSValue($1), _toJSValue($2), _toJSValue($3), _toJSValue($4)).fromJSValue()!
            }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onerror] =
                    JSClosure {
                        _toJSValue(
                            newValue(
                                $0[0].fromJSValue()!,
                                $0[1].fromJSValue()!,
                                $0[2].fromJSValue()!,
                                $0[3].fromJSValue()!,
                                $0[4].fromJSValue()!
                            )
                        )
                    }.jsValue
            } else {
                jsObject[Strings.onerror] = .null
            }
        }
    }

    @inlinable public var onfocus: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onfocus].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onfocus] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onfocus] = .null
            }
        }
    }

    @inlinable public var onformdata: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onformdata].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onformdata] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onformdata] = .null
            }
        }
    }

    @inlinable public var oninput: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oninput].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oninput] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oninput] = .null
            }
        }
    }

    @inlinable public var oninvalid: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oninvalid].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oninvalid] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oninvalid] = .null
            }
        }
    }

    @inlinable public var onkeydown: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onkeydown].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onkeydown] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onkeydown] = .null
            }
        }
    }

    @inlinable public var onkeypress: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onkeypress].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onkeypress] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onkeypress] = .null
            }
        }
    }

    @inlinable public var onkeyup: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onkeyup].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onkeyup] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onkeyup] = .null
            }
        }
    }

    @inlinable public var onload: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onload].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onload] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onload] = .null
            }
        }
    }

    @inlinable public var onloadeddata: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onloadeddata].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onloadeddata] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onloadeddata] = .null
            }
        }
    }

    @inlinable public var onloadedmetadata: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onloadedmetadata].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onloadedmetadata] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onloadedmetadata] = .null
            }
        }
    }

    @inlinable public var onloadstart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onloadstart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onloadstart] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onloadstart] = .null
            }
        }
    }

    @inlinable public var onmousedown: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmousedown].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmousedown] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmousedown] = .null
            }
        }
    }

    @inlinable public var onmouseenter: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmouseenter].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmouseenter] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmouseenter] = .null
            }
        }
    }

    @inlinable public var onmouseleave: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmouseleave].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmouseleave] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmouseleave] = .null
            }
        }
    }

    @inlinable public var onmousemove: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmousemove].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmousemove] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmousemove] = .null
            }
        }
    }

    @inlinable public var onmouseout: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmouseout].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmouseout] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmouseout] = .null
            }
        }
    }

    @inlinable public var onmouseover: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmouseover].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmouseover] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmouseover] = .null
            }
        }
    }

    @inlinable public var onmouseup: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmouseup].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmouseup] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmouseup] = .null
            }
        }
    }

    @inlinable public var onpaste: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpaste].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpaste] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpaste] = .null
            }
        }
    }

    @inlinable public var onpause: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpause].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpause] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpause] = .null
            }
        }
    }

    @inlinable public var onplay: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onplay].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onplay] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onplay] = .null
            }
        }
    }

    @inlinable public var onplaying: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onplaying].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onplaying] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onplaying] = .null
            }
        }
    }

    @inlinable public var onprogress: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onprogress].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onprogress] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onprogress] = .null
            }
        }
    }

    @inlinable public var onratechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onratechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onratechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onratechange] = .null
            }
        }
    }

    @inlinable public var onreset: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onreset].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onreset] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onreset] = .null
            }
        }
    }

    @inlinable public var onresize: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onresize].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onresize] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onresize] = .null
            }
        }
    }

    @inlinable public var onscroll: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onscroll].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onscroll] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onscroll] = .null
            }
        }
    }

    @inlinable public var onscrollend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onscrollend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onscrollend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onscrollend] = .null
            }
        }
    }

    @inlinable public var onsecuritypolicyviolation: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onsecuritypolicyviolation].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onsecuritypolicyviolation] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onsecuritypolicyviolation] = .null
            }
        }
    }

    @inlinable public var onseeked: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onseeked].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onseeked] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onseeked] = .null
            }
        }
    }

    @inlinable public var onseeking: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onseeking].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onseeking] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onseeking] = .null
            }
        }
    }

    @inlinable public var onselect: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onselect].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onselect] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onselect] = .null
            }
        }
    }

    @inlinable public var onslotchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onslotchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onslotchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onslotchange] = .null
            }
        }
    }

    @inlinable public var onstalled: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onstalled].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onstalled] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onstalled] = .null
            }
        }
    }

    @inlinable public var onsubmit: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onsubmit].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onsubmit] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onsubmit] = .null
            }
        }
    }

    @inlinable public var onsuspend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onsuspend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onsuspend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onsuspend] = .null
            }
        }
    }

    @inlinable public var ontimeupdate: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ontimeupdate].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ontimeupdate] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ontimeupdate] = .null
            }
        }
    }

    @inlinable public var ontoggle: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ontoggle].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ontoggle] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ontoggle] = .null
            }
        }
    }

    @inlinable public var onvolumechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onvolumechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onvolumechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onvolumechange] = .null
            }
        }
    }

    @inlinable public var onwaiting: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onwaiting].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onwaiting] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onwaiting] = .null
            }
        }
    }

    @inlinable public var onwebkitanimationend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onwebkitanimationend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onwebkitanimationend] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onwebkitanimationend] = .null
            }
        }
    }

    @inlinable public var onwebkitanimationiteration: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onwebkitanimationiteration].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onwebkitanimationiteration] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onwebkitanimationiteration] = .null
            }
        }
    }

    @inlinable public var onwebkitanimationstart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onwebkitanimationstart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onwebkitanimationstart] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onwebkitanimationstart] = .null
            }
        }
    }

    @inlinable public var onwebkittransitionend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onwebkittransitionend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onwebkittransitionend] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onwebkittransitionend] = .null
            }
        }
    }

    @inlinable public var onwheel: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onwheel].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onwheel] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onwheel] = .null
            }
        }
    }

    @inlinable public var ontouchstart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ontouchstart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ontouchstart] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ontouchstart] = .null
            }
        }
    }

    @inlinable public var ontouchend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ontouchend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ontouchend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ontouchend] = .null
            }
        }
    }

    @inlinable public var ontouchmove: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ontouchmove].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ontouchmove] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ontouchmove] = .null
            }
        }
    }

    @inlinable public var ontouchcancel: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ontouchcancel].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ontouchcancel] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ontouchcancel] = .null
            }
        }
    }
}
public class HTMLAllCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.HTMLAllCollection].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> Element { jsObject[key].fromJSValue()! }

    @inlinable public subscript(key: String) -> Element_or_HTMLCollection? { jsObject[key].fromJSValue() }

    @inlinable final public fn namedItem(name: String) -> Element_or_HTMLCollection? {
        immutable this = jsObject
        return this[Strings.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable final public fn item(nameOrIndex: String? = Nothing) -> Element_or_HTMLCollection? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(nameOrIndex)]).fromJSValue()
    }
}

public class HTMLAnchorElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLAnchorElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var target: String {
        get { jsObject[Strings.target].fromJSValue()! }
        set { jsObject[Strings.target] = _toJSValue(newValue) }
    }

    @inlinable public var download: String {
        get { jsObject[Strings.download].fromJSValue()! }
        set { jsObject[Strings.download] = _toJSValue(newValue) }
    }

    @inlinable public var ping: String {
        get { jsObject[Strings.ping].fromJSValue()! }
        set { jsObject[Strings.ping] = _toJSValue(newValue) }
    }

    @inlinable public var rel: String {
        get { jsObject[Strings.rel].fromJSValue()! }
        set { jsObject[Strings.rel] = _toJSValue(newValue) }
    }

    @inlinable public var relList: DOMTokenList { jsObject[Strings.relList].fromJSValue()! }

    @inlinable public var hreflang: String {
        get { jsObject[Strings.hreflang].fromJSValue()! }
        set { jsObject[Strings.hreflang] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var text: String {
        get { jsObject[Strings.text].fromJSValue()! }
        set { jsObject[Strings.text] = _toJSValue(newValue) }
    }

    @inlinable public var referrerPolicy: String {
        get { jsObject[Strings.referrerPolicy].fromJSValue()! }
        set { jsObject[Strings.referrerPolicy] = _toJSValue(newValue) }
    }

    @inlinable public var coords: String {
        get { jsObject[Strings.coords].fromJSValue()! }
        set { jsObject[Strings.coords] = _toJSValue(newValue) }
    }

    @inlinable public var charset: String {
        get { jsObject[Strings.charset].fromJSValue()! }
        set { jsObject[Strings.charset] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var rev: String {
        get { jsObject[Strings.rev].fromJSValue()! }
        set { jsObject[Strings.rev] = _toJSValue(newValue) }
    }

    @inlinable public var shape: String {
        get { jsObject[Strings.shape].fromJSValue()! }
        set { jsObject[Strings.shape] = _toJSValue(newValue) }
    }
}

public class HTMLAreaElement: HTMLElement, HTMLHyperlinkElementUtils {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLAreaElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var alt: String {
        get { jsObject[Strings.alt].fromJSValue()! }
        set { jsObject[Strings.alt] = _toJSValue(newValue) }
    }

    @inlinable public var coords: String {
        get { jsObject[Strings.coords].fromJSValue()! }
        set { jsObject[Strings.coords] = _toJSValue(newValue) }
    }

    @inlinable public var shape: String {
        get { jsObject[Strings.shape].fromJSValue()! }
        set { jsObject[Strings.shape] = _toJSValue(newValue) }
    }

    @inlinable public var target: String {
        get { jsObject[Strings.target].fromJSValue()! }
        set { jsObject[Strings.target] = _toJSValue(newValue) }
    }

    @inlinable public var download: String {
        get { jsObject[Strings.download].fromJSValue()! }
        set { jsObject[Strings.download] = _toJSValue(newValue) }
    }

    @inlinable public var ping: String {
        get { jsObject[Strings.ping].fromJSValue()! }
        set { jsObject[Strings.ping] = _toJSValue(newValue) }
    }

    @inlinable public var rel: String {
        get { jsObject[Strings.rel].fromJSValue()! }
        set { jsObject[Strings.rel] = _toJSValue(newValue) }
    }

    @inlinable public var relList: DOMTokenList { jsObject[Strings.relList].fromJSValue()! }

    @inlinable public var referrerPolicy: String {
        get { jsObject[Strings.referrerPolicy].fromJSValue()! }
        set { jsObject[Strings.referrerPolicy] = _toJSValue(newValue) }
    }

    @inlinable public var noHref: Boolean {
        get { jsObject[Strings.noHref].fromJSValue()! }
        set { jsObject[Strings.noHref] = _toJSValue(newValue) }
    }
}

public class HTMLAudioElement: HTMLMediaElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLAudioElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }
}

public class HTMLBRElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLBRElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var clear: String {
        get { jsObject[Strings.clear].fromJSValue()! }
        set { jsObject[Strings.clear] = _toJSValue(newValue) }
    }
}

public class HTMLBaseElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLBaseElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var href: String {
        get { jsObject[Strings.href].fromJSValue()! }
        set { jsObject[Strings.href] = _toJSValue(newValue) }
    }

    @inlinable public var target: String {
        get { jsObject[Strings.target].fromJSValue()! }
        set { jsObject[Strings.target] = _toJSValue(newValue) }
    }
}

public class HTMLBodyElement: HTMLElement, WindowEventHandlers {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLBodyElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var text: String {
        get { jsObject[Strings.text].fromJSValue()! }
        set { jsObject[Strings.text] = _toJSValue(newValue) }
    }

    @inlinable public var link: String {
        get { jsObject[Strings.link].fromJSValue()! }
        set { jsObject[Strings.link] = _toJSValue(newValue) }
    }

    @inlinable public var vLink: String {
        get { jsObject[Strings.vLink].fromJSValue()! }
        set { jsObject[Strings.vLink] = _toJSValue(newValue) }
    }

    @inlinable public var aLink: String {
        get { jsObject[Strings.aLink].fromJSValue()! }
        set { jsObject[Strings.aLink] = _toJSValue(newValue) }
    }

    @inlinable public var bgColor: String {
        get { jsObject[Strings.bgColor].fromJSValue()! }
        set { jsObject[Strings.bgColor] = _toJSValue(newValue) }
    }

    @inlinable public var background: String {
        get { jsObject[Strings.background].fromJSValue()! }
        set { jsObject[Strings.background] = _toJSValue(newValue) }
    }
}

public class HTMLButtonElement: HTMLElement, PopoverInvokerElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLButtonElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var command: String {
        get { jsObject[Strings.command].fromJSValue()! }
        set { jsObject[Strings.command] = _toJSValue(newValue) }
    }

    @inlinable public var commandForElement: Element? {
        get { jsObject[Strings.commandForElement].fromJSValue() }
        set { jsObject[Strings.commandForElement] = _toJSValue(newValue) }
    }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var formAction: String {
        get { jsObject[Strings.formAction].fromJSValue()! }
        set { jsObject[Strings.formAction] = _toJSValue(newValue) }
    }

    @inlinable public var formEnctype: String {
        get { jsObject[Strings.formEnctype].fromJSValue()! }
        set { jsObject[Strings.formEnctype] = _toJSValue(newValue) }
    }

    @inlinable public var formMethod: String {
        get { jsObject[Strings.formMethod].fromJSValue()! }
        set { jsObject[Strings.formMethod] = _toJSValue(newValue) }
    }

    @inlinable public var formNoValidate: Boolean {
        get { jsObject[Strings.formNoValidate].fromJSValue()! }
        set { jsObject[Strings.formNoValidate] = _toJSValue(newValue) }
    }

    @inlinable public var formTarget: String {
        get { jsObject[Strings.formTarget].fromJSValue()! }
        set { jsObject[Strings.formTarget] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setCustomValidity(error: String) {
        immutable this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable public var labels: NodeList { jsObject[Strings.labels].fromJSValue()! }
}

public class HTMLCanvasElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLCanvasElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var width: UInt32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: UInt32 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    // XXX: member 'getContext' is ignored

    @inlinable final public fn toDataURL(type: String? = Nothing, quality: JSValue? = Nothing) -> String {
        immutable this = jsObject
        return this[Strings.toDataURL].function!(this: this, arguments: [_toJSValue(type), _toJSValue(quality)])
            .fromJSValue()!
    }

    @inlinable final public fn toBlob(callback: @escaping BlobCallback, type: String? = Nothing, quality: JSValue? = Nothing)
    {
        immutable this = jsObject
        _ = this[Strings.toBlob].function!(
            this: this,
            arguments: [_toJSValue(callback), _toJSValue(type), _toJSValue(quality)]
        )
    }

    @inlinable final public fn transferControlToOffscreen() -> OffscreenCanvas {
        immutable this = jsObject
        return this[Strings.transferControlToOffscreen].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLCollection: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.HTMLCollection].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> Element? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> Element? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> Element? { jsObject[key].fromJSValue() }

    @inlinable final public fn namedItem(name: String) -> Element? {
        immutable this = jsObject
        return this[Strings.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class HTMLDListElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLDListElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var compact: Boolean {
        get { jsObject[Strings.compact].fromJSValue()! }
        set { jsObject[Strings.compact] = _toJSValue(newValue) }
    }
}

public class HTMLDataElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLDataElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }
}

public class HTMLDataListElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLDataListElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var options: HTMLCollection { jsObject[Strings.options].fromJSValue()! }
}

public class HTMLDetailsElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLDetailsElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var open: Boolean {
        get { jsObject[Strings.open].fromJSValue()! }
        set { jsObject[Strings.open] = _toJSValue(newValue) }
    }
}

public class HTMLDialogElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLDialogElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var open: Boolean {
        get { jsObject[Strings.open].fromJSValue()! }
        set { jsObject[Strings.open] = _toJSValue(newValue) }
    }

    @inlinable public var returnValue: String {
        get { jsObject[Strings.returnValue].fromJSValue()! }
        set { jsObject[Strings.returnValue] = _toJSValue(newValue) }
    }

    @inlinable public var closedBy: String {
        get { jsObject[Strings.closedBy].fromJSValue()! }
        set { jsObject[Strings.closedBy] = _toJSValue(newValue) }
    }

    @inlinable final public fn show() {
        immutable this = jsObject
        _ = this[Strings.show].function!(this: this, arguments: [])
    }

    @inlinable final public fn showModal() {
        immutable this = jsObject
        _ = this[Strings.showModal].function!(this: this, arguments: [])
    }

    @inlinable final public fn close(returnValue: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [_toJSValue(returnValue)])
    }

    @inlinable final public fn requestClose(returnValue: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.requestClose].function!(this: this, arguments: [_toJSValue(returnValue)])
    }
}

public class HTMLDirectoryElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLDirectoryElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var compact: Boolean {
        get { jsObject[Strings.compact].fromJSValue()! }
        set { jsObject[Strings.compact] = _toJSValue(newValue) }
    }
}

public class HTMLDivElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLDivElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }
}

public class HTMLElement: Element, GlobalEventHandlers, ElementContentEditable, HTMLOrSVGElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var title: String {
        get { jsObject[Strings.title].fromJSValue()! }
        set { jsObject[Strings.title] = _toJSValue(newValue) }
    }

    @inlinable public var lang: String {
        get { jsObject[Strings.lang].fromJSValue()! }
        set { jsObject[Strings.lang] = _toJSValue(newValue) }
    }

    @inlinable public var translate: Boolean {
        get { jsObject[Strings.translate].fromJSValue()! }
        set { jsObject[Strings.translate] = _toJSValue(newValue) }
    }

    @inlinable public var dir: String {
        get { jsObject[Strings.dir].fromJSValue()! }
        set { jsObject[Strings.dir] = _toJSValue(newValue) }
    }

    @inlinable public var hidden: Bool_or_Double_or_String? {
        get { jsObject[Strings.hidden].fromJSValue() }
        set { jsObject[Strings.hidden] = _toJSValue(newValue) }
    }

    @inlinable public var inert: Boolean {
        get { jsObject[Strings.inert].fromJSValue()! }
        set { jsObject[Strings.inert] = _toJSValue(newValue) }
    }

    @inlinable final public fn click() {
        immutable this = jsObject
        _ = this[Strings.click].function!(this: this, arguments: [])
    }

    @inlinable public var accessKey: String {
        get { jsObject[Strings.accessKey].fromJSValue()! }
        set { jsObject[Strings.accessKey] = _toJSValue(newValue) }
    }

    @inlinable public var accessKeyLabel: String { jsObject[Strings.accessKeyLabel].fromJSValue()! }

    @inlinable public var draggable: Boolean {
        get { jsObject[Strings.draggable].fromJSValue()! }
        set { jsObject[Strings.draggable] = _toJSValue(newValue) }
    }

    @inlinable public var spellcheck: Boolean {
        get { jsObject[Strings.spellcheck].fromJSValue()! }
        set { jsObject[Strings.spellcheck] = _toJSValue(newValue) }
    }

    @inlinable public var writingSuggestions: String {
        get { jsObject[Strings.writingSuggestions].fromJSValue()! }
        set { jsObject[Strings.writingSuggestions] = _toJSValue(newValue) }
    }

    @inlinable public var autocapitalize: String {
        get { jsObject[Strings.autocapitalize].fromJSValue()! }
        set { jsObject[Strings.autocapitalize] = _toJSValue(newValue) }
    }

    @inlinable public var autocorrect: Boolean {
        get { jsObject[Strings.autocorrect].fromJSValue()! }
        set { jsObject[Strings.autocorrect] = _toJSValue(newValue) }
    }

    @inlinable public var innerText: String {
        get { jsObject[Strings.innerText].fromJSValue()! }
        set { jsObject[Strings.innerText] = _toJSValue(newValue) }
    }

    @inlinable public var outerText: String {
        get { jsObject[Strings.outerText].fromJSValue()! }
        set { jsObject[Strings.outerText] = _toJSValue(newValue) }
    }

    @inlinable final public fn attachInternals() -> ElementInternals {
        immutable this = jsObject
        return this[Strings.attachInternals].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn showPopover(options: ShowPopoverOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.showPopover].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn hidePopover() {
        immutable this = jsObject
        _ = this[Strings.hidePopover].function!(this: this, arguments: [])
    }

    @inlinable final public fn togglePopover(options: Bool_or_TogglePopoverOptions? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.togglePopover].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public var popover: String? {
        get { jsObject[Strings.popover].fromJSValue() }
        set { jsObject[Strings.popover] = _toJSValue(newValue) }
    }

    @inlinable public var offsetParent: Element? { jsObject[Strings.offsetParent].fromJSValue() }

    @inlinable public var offsetTop: Int32 { jsObject[Strings.offsetTop].fromJSValue()! }

    @inlinable public var offsetLeft: Int32 { jsObject[Strings.offsetLeft].fromJSValue()! }

    @inlinable public var offsetWidth: Int32 { jsObject[Strings.offsetWidth].fromJSValue()! }

    @inlinable public var offsetHeight: Int32 { jsObject[Strings.offsetHeight].fromJSValue()! }
}

public class HTMLEmbedElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLEmbedElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: String {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable final public fn getSVGDocument() -> Document? {
        immutable this = jsObject
        return this[Strings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }
}

public class HTMLFieldSetElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLFieldSetElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var elements: HTMLCollection { jsObject[Strings.elements].fromJSValue()! }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setCustomValidity(error: String) {
        immutable this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }
}

public class HTMLFontElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLFontElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var color: String {
        get { jsObject[Strings.color].fromJSValue()! }
        set { jsObject[Strings.color] = _toJSValue(newValue) }
    }

    @inlinable public var face: String {
        get { jsObject[Strings.face].fromJSValue()! }
        set { jsObject[Strings.face] = _toJSValue(newValue) }
    }

    @inlinable public var size: String {
        get { jsObject[Strings.size].fromJSValue()! }
        set { jsObject[Strings.size] = _toJSValue(newValue) }
    }
}

public class HTMLFormControlsCollection: HTMLCollection {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLFormControlsCollection].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList? { jsObject[key].fromJSValue() }

}

public class HTMLFormElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLFormElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var acceptCharset: String {
        get { jsObject[Strings.acceptCharset].fromJSValue()! }
        set { jsObject[Strings.acceptCharset] = _toJSValue(newValue) }
    }

    @inlinable public var action: String {
        get { jsObject[Strings.action].fromJSValue()! }
        set { jsObject[Strings.action] = _toJSValue(newValue) }
    }

    @inlinable public var autocomplete: String {
        get { jsObject[Strings.autocomplete].fromJSValue()! }
        set { jsObject[Strings.autocomplete] = _toJSValue(newValue) }
    }

    @inlinable public var enctype: String {
        get { jsObject[Strings.enctype].fromJSValue()! }
        set { jsObject[Strings.enctype] = _toJSValue(newValue) }
    }

    @inlinable public var encoding: String {
        get { jsObject[Strings.encoding].fromJSValue()! }
        set { jsObject[Strings.encoding] = _toJSValue(newValue) }
    }

    @inlinable public var method: String {
        get { jsObject[Strings.method].fromJSValue()! }
        set { jsObject[Strings.method] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var noValidate: Boolean {
        get { jsObject[Strings.noValidate].fromJSValue()! }
        set { jsObject[Strings.noValidate] = _toJSValue(newValue) }
    }

    @inlinable public var target: String {
        get { jsObject[Strings.target].fromJSValue()! }
        set { jsObject[Strings.target] = _toJSValue(newValue) }
    }

    @inlinable public var rel: String {
        get { jsObject[Strings.rel].fromJSValue()! }
        set { jsObject[Strings.rel] = _toJSValue(newValue) }
    }

    @inlinable public var relList: DOMTokenList { jsObject[Strings.relList].fromJSValue()! }

    @inlinable public var elements: HTMLFormControlsCollection { jsObject[Strings.elements].fromJSValue()! }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> Element { jsObject[key].fromJSValue()! }

    @inlinable public subscript(key: String) -> Element_or_RadioNodeList { jsObject[key].fromJSValue()! }

    @inlinable final public fn submit() {
        immutable this = jsObject
        _ = this[Strings.submit].function!(this: this, arguments: [])
    }

    @inlinable final public fn requestSubmit(submitter: HTMLElement? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.requestSubmit].function!(this: this, arguments: [_toJSValue(submitter)])
    }

    @inlinable final public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class HTMLFrameElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLFrameElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var scrolling: String {
        get { jsObject[Strings.scrolling].fromJSValue()! }
        set { jsObject[Strings.scrolling] = _toJSValue(newValue) }
    }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var frameBorder: String {
        get { jsObject[Strings.frameBorder].fromJSValue()! }
        set { jsObject[Strings.frameBorder] = _toJSValue(newValue) }
    }

    @inlinable public var longDesc: String {
        get { jsObject[Strings.longDesc].fromJSValue()! }
        set { jsObject[Strings.longDesc] = _toJSValue(newValue) }
    }

    @inlinable public var noResize: Boolean {
        get { jsObject[Strings.noResize].fromJSValue()! }
        set { jsObject[Strings.noResize] = _toJSValue(newValue) }
    }

    @inlinable public var contentDocument: Document? { jsObject[Strings.contentDocument].fromJSValue() }

    @inlinable public var contentWindow: WindowProxy? { jsObject[Strings.contentWindow].fromJSValue() }

    @inlinable public var marginHeight: String {
        get { jsObject[Strings.marginHeight].fromJSValue()! }
        set { jsObject[Strings.marginHeight] = _toJSValue(newValue) }
    }

    @inlinable public var marginWidth: String {
        get { jsObject[Strings.marginWidth].fromJSValue()! }
        set { jsObject[Strings.marginWidth] = _toJSValue(newValue) }
    }
}

public class HTMLFrameSetElement: HTMLElement, WindowEventHandlers {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLFrameSetElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var cols: String {
        get { jsObject[Strings.cols].fromJSValue()! }
        set { jsObject[Strings.cols] = _toJSValue(newValue) }
    }

    @inlinable public var rows: String {
        get { jsObject[Strings.rows].fromJSValue()! }
        set { jsObject[Strings.rows] = _toJSValue(newValue) }
    }
}

public class HTMLHRElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLHRElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var color: String {
        get { jsObject[Strings.color].fromJSValue()! }
        set { jsObject[Strings.color] = _toJSValue(newValue) }
    }

    @inlinable public var noShade: Boolean {
        get { jsObject[Strings.noShade].fromJSValue()! }
        set { jsObject[Strings.noShade] = _toJSValue(newValue) }
    }

    @inlinable public var size: String {
        get { jsObject[Strings.size].fromJSValue()! }
        set { jsObject[Strings.size] = _toJSValue(newValue) }
    }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
}

public class HTMLHeadElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLHeadElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }
}

public class HTMLHeadingElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLHeadingElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }
}

public class HTMLHtmlElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLHtmlElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var version: String {
        get { jsObject[Strings.version].fromJSValue()! }
        set { jsObject[Strings.version] = _toJSValue(newValue) }
    }
}

public protocol HTMLHyperlinkElementUtils: JSBridgedClass {}
extension HTMLHyperlinkElementUtils {
    @inlinable public var href: String {
        get { jsObject[Strings.href].fromJSValue()! }
        set { jsObject[Strings.href] = _toJSValue(newValue) }
    }

    @inlinable public var origin: String { jsObject[Strings.origin].fromJSValue()! }

    @inlinable public var `protocol`: String {
        get { jsObject[Strings.`protocol`].fromJSValue()! }
        set { jsObject[Strings.`protocol`] = _toJSValue(newValue) }
    }

    @inlinable public var username: String {
        get { jsObject[Strings.username].fromJSValue()! }
        set { jsObject[Strings.username] = _toJSValue(newValue) }
    }

    @inlinable public var password: String {
        get { jsObject[Strings.password].fromJSValue()! }
        set { jsObject[Strings.password] = _toJSValue(newValue) }
    }

    @inlinable public var host: String {
        get { jsObject[Strings.host].fromJSValue()! }
        set { jsObject[Strings.host] = _toJSValue(newValue) }
    }

    @inlinable public var hostname: String {
        get { jsObject[Strings.hostname].fromJSValue()! }
        set { jsObject[Strings.hostname] = _toJSValue(newValue) }
    }

    @inlinable public var port: String {
        get { jsObject[Strings.port].fromJSValue()! }
        set { jsObject[Strings.port] = _toJSValue(newValue) }
    }

    @inlinable public var pathname: String {
        get { jsObject[Strings.pathname].fromJSValue()! }
        set { jsObject[Strings.pathname] = _toJSValue(newValue) }
    }

    @inlinable public var search: String {
        get { jsObject[Strings.search].fromJSValue()! }
        set { jsObject[Strings.search] = _toJSValue(newValue) }
    }

    @inlinable public var hash: String {
        get { jsObject[Strings.hash].fromJSValue()! }
        set { jsObject[Strings.hash] = _toJSValue(newValue) }
    }
}
public class HTMLIFrameElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLIFrameElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var srcdoc: String_or_TrustedHTML {
        get { jsObject[Strings.srcdoc].fromJSValue()! }
        set { jsObject[Strings.srcdoc] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var sandbox: DOMTokenList { jsObject[Strings.sandbox].fromJSValue()! }

    @inlinable public var allow: String {
        get { jsObject[Strings.allow].fromJSValue()! }
        set { jsObject[Strings.allow] = _toJSValue(newValue) }
    }

    @inlinable public var allowFullscreen: Boolean {
        get { jsObject[Strings.allowFullscreen].fromJSValue()! }
        set { jsObject[Strings.allowFullscreen] = _toJSValue(newValue) }
    }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: String {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable public var referrerPolicy: String {
        get { jsObject[Strings.referrerPolicy].fromJSValue()! }
        set { jsObject[Strings.referrerPolicy] = _toJSValue(newValue) }
    }

    @inlinable public var loading: String {
        get { jsObject[Strings.loading].fromJSValue()! }
        set { jsObject[Strings.loading] = _toJSValue(newValue) }
    }

    @inlinable public var contentDocument: Document? { jsObject[Strings.contentDocument].fromJSValue() }

    @inlinable public var contentWindow: WindowProxy? { jsObject[Strings.contentWindow].fromJSValue() }

    @inlinable final public fn getSVGDocument() -> Document? {
        immutable this = jsObject
        return this[Strings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var scrolling: String {
        get { jsObject[Strings.scrolling].fromJSValue()! }
        set { jsObject[Strings.scrolling] = _toJSValue(newValue) }
    }

    @inlinable public var frameBorder: String {
        get { jsObject[Strings.frameBorder].fromJSValue()! }
        set { jsObject[Strings.frameBorder] = _toJSValue(newValue) }
    }

    @inlinable public var longDesc: String {
        get { jsObject[Strings.longDesc].fromJSValue()! }
        set { jsObject[Strings.longDesc] = _toJSValue(newValue) }
    }

    @inlinable public var marginHeight: String {
        get { jsObject[Strings.marginHeight].fromJSValue()! }
        set { jsObject[Strings.marginHeight] = _toJSValue(newValue) }
    }

    @inlinable public var marginWidth: String {
        get { jsObject[Strings.marginWidth].fromJSValue()! }
        set { jsObject[Strings.marginWidth] = _toJSValue(newValue) }
    }
}

public class HTMLImageElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLImageElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var alt: String {
        get { jsObject[Strings.alt].fromJSValue()! }
        set { jsObject[Strings.alt] = _toJSValue(newValue) }
    }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var srcset: String {
        get { jsObject[Strings.srcset].fromJSValue()! }
        set { jsObject[Strings.srcset] = _toJSValue(newValue) }
    }

    @inlinable public var sizes: String {
        get { jsObject[Strings.sizes].fromJSValue()! }
        set { jsObject[Strings.sizes] = _toJSValue(newValue) }
    }

    @inlinable public var crossOrigin: String? {
        get { jsObject[Strings.crossOrigin].fromJSValue() }
        set { jsObject[Strings.crossOrigin] = _toJSValue(newValue) }
    }

    @inlinable public var useMap: String {
        get { jsObject[Strings.useMap].fromJSValue()! }
        set { jsObject[Strings.useMap] = _toJSValue(newValue) }
    }

    @inlinable public var isMap: Boolean {
        get { jsObject[Strings.isMap].fromJSValue()! }
        set { jsObject[Strings.isMap] = _toJSValue(newValue) }
    }

    @inlinable public var width: UInt32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: UInt32 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable public var naturalWidth: UInt32 { jsObject[Strings.naturalWidth].fromJSValue()! }

    @inlinable public var naturalHeight: UInt32 { jsObject[Strings.naturalHeight].fromJSValue()! }

    @inlinable public var complete: Boolean { jsObject[Strings.complete].fromJSValue()! }

    @inlinable public var currentSrc: String { jsObject[Strings.currentSrc].fromJSValue()! }

    @inlinable public var referrerPolicy: String {
        get { jsObject[Strings.referrerPolicy].fromJSValue()! }
        set { jsObject[Strings.referrerPolicy] = _toJSValue(newValue) }
    }

    @inlinable public var decoding: String {
        get { jsObject[Strings.decoding].fromJSValue()! }
        set { jsObject[Strings.decoding] = _toJSValue(newValue) }
    }

    @inlinable public var loading: String {
        get { jsObject[Strings.loading].fromJSValue()! }
        set { jsObject[Strings.loading] = _toJSValue(newValue) }
    }

    @inlinable public var fetchPriority: String {
        get { jsObject[Strings.fetchPriority].fromJSValue()! }
        set { jsObject[Strings.fetchPriority] = _toJSValue(newValue) }
    }

    @inlinable final public fn decode() -> JSPromise {
        immutable this = jsObject
        return this[Strings.decode].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn decode()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.decode].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var lowsrc: String {
        get { jsObject[Strings.lowsrc].fromJSValue()! }
        set { jsObject[Strings.lowsrc] = _toJSValue(newValue) }
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var hspace: UInt32 {
        get { jsObject[Strings.hspace].fromJSValue()! }
        set { jsObject[Strings.hspace] = _toJSValue(newValue) }
    }

    @inlinable public var vspace: UInt32 {
        get { jsObject[Strings.vspace].fromJSValue()! }
        set { jsObject[Strings.vspace] = _toJSValue(newValue) }
    }

    @inlinable public var longDesc: String {
        get { jsObject[Strings.longDesc].fromJSValue()! }
        set { jsObject[Strings.longDesc] = _toJSValue(newValue) }
    }

    @inlinable public var border: String {
        get { jsObject[Strings.border].fromJSValue()! }
        set { jsObject[Strings.border] = _toJSValue(newValue) }
    }

    @inlinable public var x: Int32 { jsObject[Strings.x].fromJSValue()! }

    @inlinable public var y: Int32 { jsObject[Strings.y].fromJSValue()! }
}

public class HTMLInputElement: HTMLElement, PopoverInvokerElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLInputElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var accept: String {
        get { jsObject[Strings.accept].fromJSValue()! }
        set { jsObject[Strings.accept] = _toJSValue(newValue) }
    }

    @inlinable public var alpha: Boolean {
        get { jsObject[Strings.alpha].fromJSValue()! }
        set { jsObject[Strings.alpha] = _toJSValue(newValue) }
    }

    @inlinable public var alt: String {
        get { jsObject[Strings.alt].fromJSValue()! }
        set { jsObject[Strings.alt] = _toJSValue(newValue) }
    }

    @inlinable public var autocomplete: String {
        get { jsObject[Strings.autocomplete].fromJSValue()! }
        set { jsObject[Strings.autocomplete] = _toJSValue(newValue) }
    }

    @inlinable public var defaultChecked: Boolean {
        get { jsObject[Strings.defaultChecked].fromJSValue()! }
        set { jsObject[Strings.defaultChecked] = _toJSValue(newValue) }
    }

    @inlinable public var checked: Boolean {
        get { jsObject[Strings.checked].fromJSValue()! }
        set { jsObject[Strings.checked] = _toJSValue(newValue) }
    }

    @inlinable public var colorSpace: String {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }

    @inlinable public var dirName: String {
        get { jsObject[Strings.dirName].fromJSValue()! }
        set { jsObject[Strings.dirName] = _toJSValue(newValue) }
    }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var files: FileList? {
        get { jsObject[Strings.files].fromJSValue() }
        set { jsObject[Strings.files] = _toJSValue(newValue) }
    }

    @inlinable public var formAction: String {
        get { jsObject[Strings.formAction].fromJSValue()! }
        set { jsObject[Strings.formAction] = _toJSValue(newValue) }
    }

    @inlinable public var formEnctype: String {
        get { jsObject[Strings.formEnctype].fromJSValue()! }
        set { jsObject[Strings.formEnctype] = _toJSValue(newValue) }
    }

    @inlinable public var formMethod: String {
        get { jsObject[Strings.formMethod].fromJSValue()! }
        set { jsObject[Strings.formMethod] = _toJSValue(newValue) }
    }

    @inlinable public var formNoValidate: Boolean {
        get { jsObject[Strings.formNoValidate].fromJSValue()! }
        set { jsObject[Strings.formNoValidate] = _toJSValue(newValue) }
    }

    @inlinable public var formTarget: String {
        get { jsObject[Strings.formTarget].fromJSValue()! }
        set { jsObject[Strings.formTarget] = _toJSValue(newValue) }
    }

    @inlinable public var height: UInt32 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable public var indeterminate: Boolean {
        get { jsObject[Strings.indeterminate].fromJSValue()! }
        set { jsObject[Strings.indeterminate] = _toJSValue(newValue) }
    }

    @inlinable public var list: HTMLDataListElement? { jsObject[Strings.list].fromJSValue() }

    @inlinable public var max: String {
        get { jsObject[Strings.max].fromJSValue()! }
        set { jsObject[Strings.max] = _toJSValue(newValue) }
    }

    @inlinable public var maxLength: Int32 {
        get { jsObject[Strings.maxLength].fromJSValue()! }
        set { jsObject[Strings.maxLength] = _toJSValue(newValue) }
    }

    @inlinable public var min: String {
        get { jsObject[Strings.min].fromJSValue()! }
        set { jsObject[Strings.min] = _toJSValue(newValue) }
    }

    @inlinable public var minLength: Int32 {
        get { jsObject[Strings.minLength].fromJSValue()! }
        set { jsObject[Strings.minLength] = _toJSValue(newValue) }
    }

    @inlinable public var multiple: Boolean {
        get { jsObject[Strings.multiple].fromJSValue()! }
        set { jsObject[Strings.multiple] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var pattern: String {
        get { jsObject[Strings.pattern].fromJSValue()! }
        set { jsObject[Strings.pattern] = _toJSValue(newValue) }
    }

    @inlinable public var placeholder: String {
        get { jsObject[Strings.placeholder].fromJSValue()! }
        set { jsObject[Strings.placeholder] = _toJSValue(newValue) }
    }

    @inlinable public var readOnly: Boolean {
        get { jsObject[Strings.readOnly].fromJSValue()! }
        set { jsObject[Strings.readOnly] = _toJSValue(newValue) }
    }

    @inlinable public var required: Boolean {
        get { jsObject[Strings.required].fromJSValue()! }
        set { jsObject[Strings.required] = _toJSValue(newValue) }
    }

    @inlinable public var size: UInt32 {
        get { jsObject[Strings.size].fromJSValue()! }
        set { jsObject[Strings.size] = _toJSValue(newValue) }
    }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var step: String {
        get { jsObject[Strings.step].fromJSValue()! }
        set { jsObject[Strings.step] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var defaultValue: String {
        get { jsObject[Strings.defaultValue].fromJSValue()! }
        set { jsObject[Strings.defaultValue] = _toJSValue(newValue) }
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var valueAsDate: JSObject? {
        get { jsObject[Strings.valueAsDate].fromJSValue() }
        set { jsObject[Strings.valueAsDate] = _toJSValue(newValue) }
    }

    @inlinable public var valueAsNumber: Double {
        get { jsObject[Strings.valueAsNumber].fromJSValue()! }
        set { jsObject[Strings.valueAsNumber] = _toJSValue(newValue) }
    }

    @inlinable public var width: UInt32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable final public fn stepUp(n: Int32? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.stepUp].function!(this: this, arguments: [_toJSValue(n)])
    }

    @inlinable final public fn stepDown(n: Int32? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.stepDown].function!(this: this, arguments: [_toJSValue(n)])
    }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setCustomValidity(error: String) {
        immutable this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable public var labels: NodeList? { jsObject[Strings.labels].fromJSValue() }

    @inlinable final public fn select() {
        immutable this = jsObject
        _ = this[Strings.select].function!(this: this, arguments: [])
    }

    @inlinable public var selectionStart: UInt32? {
        get { jsObject[Strings.selectionStart].fromJSValue() }
        set { jsObject[Strings.selectionStart] = _toJSValue(newValue) }
    }

    @inlinable public var selectionEnd: UInt32? {
        get { jsObject[Strings.selectionEnd].fromJSValue() }
        set { jsObject[Strings.selectionEnd] = _toJSValue(newValue) }
    }

    @inlinable public var selectionDirection: String? {
        get { jsObject[Strings.selectionDirection].fromJSValue() }
        set { jsObject[Strings.selectionDirection] = _toJSValue(newValue) }
    }

    @inlinable final public fn setRangeText(replacement: String) {
        immutable this = jsObject
        _ = this[Strings.setRangeText].function!(this: this, arguments: [_toJSValue(replacement)])
    }

    @inlinable final public fn setRangeText(
        replacement: String,
        start: UInt32,
        end: UInt32,
        selectionMode: SelectionMode? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.setRangeText].function!(
            this: this,
            arguments: [_toJSValue(replacement), _toJSValue(start), _toJSValue(end), _toJSValue(selectionMode)]
        )
    }

    @inlinable final public fn setSelectionRange(start: UInt32, end: UInt32, direction: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.setSelectionRange].function!(
            this: this,
            arguments: [_toJSValue(start), _toJSValue(end), _toJSValue(direction)]
        )
    }

    @inlinable final public fn showPicker() {
        immutable this = jsObject
        _ = this[Strings.showPicker].function!(this: this, arguments: [])
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var useMap: String {
        get { jsObject[Strings.useMap].fromJSValue()! }
        set { jsObject[Strings.useMap] = _toJSValue(newValue) }
    }
}

public class HTMLLIElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLLIElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var value: Int32 {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
}

public class HTMLLabelElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLLabelElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var htmlFor: String {
        get { jsObject[Strings.htmlFor].fromJSValue()! }
        set { jsObject[Strings.htmlFor] = _toJSValue(newValue) }
    }

    @inlinable public var control: HTMLElement? { jsObject[Strings.control].fromJSValue() }
}

public class HTMLLegendElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLLegendElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }
}

public class HTMLLinkElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLLinkElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var href: String {
        get { jsObject[Strings.href].fromJSValue()! }
        set { jsObject[Strings.href] = _toJSValue(newValue) }
    }

    @inlinable public var crossOrigin: String? {
        get { jsObject[Strings.crossOrigin].fromJSValue() }
        set { jsObject[Strings.crossOrigin] = _toJSValue(newValue) }
    }

    @inlinable public var rel: String {
        get { jsObject[Strings.rel].fromJSValue()! }
        set { jsObject[Strings.rel] = _toJSValue(newValue) }
    }

    @inlinable public var `as`: String {
        get { jsObject[Strings.`as`].fromJSValue()! }
        set { jsObject[Strings.`as`] = _toJSValue(newValue) }
    }

    @inlinable public var relList: DOMTokenList { jsObject[Strings.relList].fromJSValue()! }

    @inlinable public var media: String {
        get { jsObject[Strings.media].fromJSValue()! }
        set { jsObject[Strings.media] = _toJSValue(newValue) }
    }

    @inlinable public var integrity: String {
        get { jsObject[Strings.integrity].fromJSValue()! }
        set { jsObject[Strings.integrity] = _toJSValue(newValue) }
    }

    @inlinable public var hreflang: String {
        get { jsObject[Strings.hreflang].fromJSValue()! }
        set { jsObject[Strings.hreflang] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var sizes: DOMTokenList { jsObject[Strings.sizes].fromJSValue()! }

    @inlinable public var imageSrcset: String {
        get { jsObject[Strings.imageSrcset].fromJSValue()! }
        set { jsObject[Strings.imageSrcset] = _toJSValue(newValue) }
    }

    @inlinable public var imageSizes: String {
        get { jsObject[Strings.imageSizes].fromJSValue()! }
        set { jsObject[Strings.imageSizes] = _toJSValue(newValue) }
    }

    @inlinable public var referrerPolicy: String {
        get { jsObject[Strings.referrerPolicy].fromJSValue()! }
        set { jsObject[Strings.referrerPolicy] = _toJSValue(newValue) }
    }

    @inlinable public var blocking: DOMTokenList { jsObject[Strings.blocking].fromJSValue()! }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var fetchPriority: String {
        get { jsObject[Strings.fetchPriority].fromJSValue()! }
        set { jsObject[Strings.fetchPriority] = _toJSValue(newValue) }
    }

    @inlinable public var charset: String {
        get { jsObject[Strings.charset].fromJSValue()! }
        set { jsObject[Strings.charset] = _toJSValue(newValue) }
    }

    @inlinable public var rev: String {
        get { jsObject[Strings.rev].fromJSValue()! }
        set { jsObject[Strings.rev] = _toJSValue(newValue) }
    }

    @inlinable public var target: String {
        get { jsObject[Strings.target].fromJSValue()! }
        set { jsObject[Strings.target] = _toJSValue(newValue) }
    }
}

public class HTMLMapElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLMapElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var areas: HTMLCollection { jsObject[Strings.areas].fromJSValue()! }
}

public class HTMLMarqueeElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLMarqueeElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var behavior: String {
        get { jsObject[Strings.behavior].fromJSValue()! }
        set { jsObject[Strings.behavior] = _toJSValue(newValue) }
    }

    @inlinable public var bgColor: String {
        get { jsObject[Strings.bgColor].fromJSValue()! }
        set { jsObject[Strings.bgColor] = _toJSValue(newValue) }
    }

    @inlinable public var direction: String {
        get { jsObject[Strings.direction].fromJSValue()! }
        set { jsObject[Strings.direction] = _toJSValue(newValue) }
    }

    @inlinable public var height: String {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable public var hspace: UInt32 {
        get { jsObject[Strings.hspace].fromJSValue()! }
        set { jsObject[Strings.hspace] = _toJSValue(newValue) }
    }

    @inlinable public var loop: Int32 {
        get { jsObject[Strings.loop].fromJSValue()! }
        set { jsObject[Strings.loop] = _toJSValue(newValue) }
    }

    @inlinable public var scrollAmount: UInt32 {
        get { jsObject[Strings.scrollAmount].fromJSValue()! }
        set { jsObject[Strings.scrollAmount] = _toJSValue(newValue) }
    }

    @inlinable public var scrollDelay: UInt32 {
        get { jsObject[Strings.scrollDelay].fromJSValue()! }
        set { jsObject[Strings.scrollDelay] = _toJSValue(newValue) }
    }

    @inlinable public var trueSpeed: Boolean {
        get { jsObject[Strings.trueSpeed].fromJSValue()! }
        set { jsObject[Strings.trueSpeed] = _toJSValue(newValue) }
    }

    @inlinable public var vspace: UInt32 {
        get { jsObject[Strings.vspace].fromJSValue()! }
        set { jsObject[Strings.vspace] = _toJSValue(newValue) }
    }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable final public fn start() {
        immutable this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [])
    }

    @inlinable final public fn stop() {
        immutable this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }
}

public class HTMLMediaElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLMediaElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var error: MediaError? { jsObject[Strings.error].fromJSValue() }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var srcObject: MediaProvider? {
        get { jsObject[Strings.srcObject].fromJSValue() }
        set { jsObject[Strings.srcObject] = _toJSValue(newValue) }
    }

    @inlinable public var currentSrc: String { jsObject[Strings.currentSrc].fromJSValue()! }

    @inlinable public var crossOrigin: String? {
        get { jsObject[Strings.crossOrigin].fromJSValue() }
        set { jsObject[Strings.crossOrigin] = _toJSValue(newValue) }
    }

    public static immutable NETWORK_EMPTY: UInt16 = 0

    public static immutable NETWORK_IDLE: UInt16 = 1

    public static immutable NETWORK_LOADING: UInt16 = 2

    public static immutable NETWORK_NO_SOURCE: UInt16 = 3

    @inlinable public var networkState: UInt16 { jsObject[Strings.networkState].fromJSValue()! }

    @inlinable public var preload: String {
        get { jsObject[Strings.preload].fromJSValue()! }
        set { jsObject[Strings.preload] = _toJSValue(newValue) }
    }

    @inlinable public var buffered: TimeRanges { jsObject[Strings.buffered].fromJSValue()! }

    @inlinable final public fn load() {
        immutable this = jsObject
        _ = this[Strings.load].function!(this: this, arguments: [])
    }

    @inlinable final public fn canPlayType(type: String) -> CanPlayTypeResult {
        immutable this = jsObject
        return this[Strings.canPlayType].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    public static immutable HAVE_NOTHING: UInt16 = 0

    public static immutable HAVE_METADATA: UInt16 = 1

    public static immutable HAVE_CURRENT_DATA: UInt16 = 2

    public static immutable HAVE_FUTURE_DATA: UInt16 = 3

    public static immutable HAVE_ENOUGH_DATA: UInt16 = 4

    @inlinable public var readyState: UInt16 { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable public var seeking: Boolean { jsObject[Strings.seeking].fromJSValue()! }

    @inlinable public var currentTime: Double {
        get { jsObject[Strings.currentTime].fromJSValue()! }
        set { jsObject[Strings.currentTime] = _toJSValue(newValue) }
    }

    @inlinable final public fn fastSeek(time: Double) {
        immutable this = jsObject
        _ = this[Strings.fastSeek].function!(this: this, arguments: [_toJSValue(time)])
    }

    @inlinable public var duration: Double { jsObject[Strings.duration].fromJSValue()! }

    @inlinable final public fn getStartDate() -> JSObject {
        immutable this = jsObject
        return this[Strings.getStartDate].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var paused: Boolean { jsObject[Strings.paused].fromJSValue()! }

    @inlinable public var defaultPlaybackRate: Double {
        get { jsObject[Strings.defaultPlaybackRate].fromJSValue()! }
        set { jsObject[Strings.defaultPlaybackRate] = _toJSValue(newValue) }
    }

    @inlinable public var playbackRate: Double {
        get { jsObject[Strings.playbackRate].fromJSValue()! }
        set { jsObject[Strings.playbackRate] = _toJSValue(newValue) }
    }

    @inlinable public var preservesPitch: Boolean {
        get { jsObject[Strings.preservesPitch].fromJSValue()! }
        set { jsObject[Strings.preservesPitch] = _toJSValue(newValue) }
    }

    @inlinable public var played: TimeRanges { jsObject[Strings.played].fromJSValue()! }

    @inlinable public var seekable: TimeRanges { jsObject[Strings.seekable].fromJSValue()! }

    @inlinable public var ended: Boolean { jsObject[Strings.ended].fromJSValue()! }

    @inlinable public var autoplay: Boolean {
        get { jsObject[Strings.autoplay].fromJSValue()! }
        set { jsObject[Strings.autoplay] = _toJSValue(newValue) }
    }

    @inlinable public var loop: Boolean {
        get { jsObject[Strings.loop].fromJSValue()! }
        set { jsObject[Strings.loop] = _toJSValue(newValue) }
    }

    @inlinable final public fn play() -> JSPromise {
        immutable this = jsObject
        return this[Strings.play].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn play()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.play].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn pause() {
        immutable this = jsObject
        _ = this[Strings.pause].function!(this: this, arguments: [])
    }

    @inlinable public var controls: Boolean {
        get { jsObject[Strings.controls].fromJSValue()! }
        set { jsObject[Strings.controls] = _toJSValue(newValue) }
    }

    @inlinable public var volume: Double {
        get { jsObject[Strings.volume].fromJSValue()! }
        set { jsObject[Strings.volume] = _toJSValue(newValue) }
    }

    @inlinable public var muted: Boolean {
        get { jsObject[Strings.muted].fromJSValue()! }
        set { jsObject[Strings.muted] = _toJSValue(newValue) }
    }

    @inlinable public var defaultMuted: Boolean {
        get { jsObject[Strings.defaultMuted].fromJSValue()! }
        set { jsObject[Strings.defaultMuted] = _toJSValue(newValue) }
    }

    @inlinable public var audioTracks: AudioTrackList { jsObject[Strings.audioTracks].fromJSValue()! }

    @inlinable public var videoTracks: VideoTrackList { jsObject[Strings.videoTracks].fromJSValue()! }

    @inlinable public var textTracks: TextTrackList { jsObject[Strings.textTracks].fromJSValue()! }

    @inlinable final public fn addTextTrack(
        kind: TextTrackKind,
        label: String? = Nothing,
        language: String? = Nothing
    ) -> TextTrack {
        immutable this = jsObject
        return this[Strings.addTextTrack].function!(
            this: this,
            arguments: [_toJSValue(kind), _toJSValue(label), _toJSValue(language)]
        ).fromJSValue()!
    }
}

public class HTMLMenuElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLMenuElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var compact: Boolean {
        get { jsObject[Strings.compact].fromJSValue()! }
        set { jsObject[Strings.compact] = _toJSValue(newValue) }
    }
}

public class HTMLMetaElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLMetaElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var httpEquiv: String {
        get { jsObject[Strings.httpEquiv].fromJSValue()! }
        set { jsObject[Strings.httpEquiv] = _toJSValue(newValue) }
    }

    @inlinable public var content: String {
        get { jsObject[Strings.content].fromJSValue()! }
        set { jsObject[Strings.content] = _toJSValue(newValue) }
    }

    @inlinable public var media: String {
        get { jsObject[Strings.media].fromJSValue()! }
        set { jsObject[Strings.media] = _toJSValue(newValue) }
    }

    @inlinable public var scheme: String {
        get { jsObject[Strings.scheme].fromJSValue()! }
        set { jsObject[Strings.scheme] = _toJSValue(newValue) }
    }
}

public class HTMLMeterElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLMeterElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var value: Double {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var min: Double {
        get { jsObject[Strings.min].fromJSValue()! }
        set { jsObject[Strings.min] = _toJSValue(newValue) }
    }

    @inlinable public var max: Double {
        get { jsObject[Strings.max].fromJSValue()! }
        set { jsObject[Strings.max] = _toJSValue(newValue) }
    }

    @inlinable public var low: Double {
        get { jsObject[Strings.low].fromJSValue()! }
        set { jsObject[Strings.low] = _toJSValue(newValue) }
    }

    @inlinable public var high: Double {
        get { jsObject[Strings.high].fromJSValue()! }
        set { jsObject[Strings.high] = _toJSValue(newValue) }
    }

    @inlinable public var optimum: Double {
        get { jsObject[Strings.optimum].fromJSValue()! }
        set { jsObject[Strings.optimum] = _toJSValue(newValue) }
    }

    @inlinable public var labels: NodeList { jsObject[Strings.labels].fromJSValue()! }
}

public class HTMLModElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLModElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var cite: String {
        get { jsObject[Strings.cite].fromJSValue()! }
        set { jsObject[Strings.cite] = _toJSValue(newValue) }
    }

    @inlinable public var dateTime: String {
        get { jsObject[Strings.dateTime].fromJSValue()! }
        set { jsObject[Strings.dateTime] = _toJSValue(newValue) }
    }
}

public class HTMLOListElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLOListElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var reversed: Boolean {
        get { jsObject[Strings.reversed].fromJSValue()! }
        set { jsObject[Strings.reversed] = _toJSValue(newValue) }
    }

    @inlinable public var start: Int32 {
        get { jsObject[Strings.start].fromJSValue()! }
        set { jsObject[Strings.start] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var compact: Boolean {
        get { jsObject[Strings.compact].fromJSValue()! }
        set { jsObject[Strings.compact] = _toJSValue(newValue) }
    }
}

public class HTMLObjectElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLObjectElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var data: String {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: String {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable public var contentDocument: Document? { jsObject[Strings.contentDocument].fromJSValue() }

    @inlinable public var contentWindow: WindowProxy? { jsObject[Strings.contentWindow].fromJSValue() }

    @inlinable final public fn getSVGDocument() -> Document? {
        immutable this = jsObject
        return this[Strings.getSVGDocument].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setCustomValidity(error: String) {
        immutable this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var archive: String {
        get { jsObject[Strings.archive].fromJSValue()! }
        set { jsObject[Strings.archive] = _toJSValue(newValue) }
    }

    @inlinable public var code: String {
        get { jsObject[Strings.code].fromJSValue()! }
        set { jsObject[Strings.code] = _toJSValue(newValue) }
    }

    @inlinable public var declare: Boolean {
        get { jsObject[Strings.declare].fromJSValue()! }
        set { jsObject[Strings.declare] = _toJSValue(newValue) }
    }

    @inlinable public var hspace: UInt32 {
        get { jsObject[Strings.hspace].fromJSValue()! }
        set { jsObject[Strings.hspace] = _toJSValue(newValue) }
    }

    @inlinable public var standby: String {
        get { jsObject[Strings.standby].fromJSValue()! }
        set { jsObject[Strings.standby] = _toJSValue(newValue) }
    }

    @inlinable public var vspace: UInt32 {
        get { jsObject[Strings.vspace].fromJSValue()! }
        set { jsObject[Strings.vspace] = _toJSValue(newValue) }
    }

    @inlinable public var codeBase: String {
        get { jsObject[Strings.codeBase].fromJSValue()! }
        set { jsObject[Strings.codeBase] = _toJSValue(newValue) }
    }

    @inlinable public var codeType: String {
        get { jsObject[Strings.codeType].fromJSValue()! }
        set { jsObject[Strings.codeType] = _toJSValue(newValue) }
    }

    @inlinable public var useMap: String {
        get { jsObject[Strings.useMap].fromJSValue()! }
        set { jsObject[Strings.useMap] = _toJSValue(newValue) }
    }

    @inlinable public var border: String {
        get { jsObject[Strings.border].fromJSValue()! }
        set { jsObject[Strings.border] = _toJSValue(newValue) }
    }
}

public class HTMLOptGroupElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLOptGroupElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var label: String {
        get { jsObject[Strings.label].fromJSValue()! }
        set { jsObject[Strings.label] = _toJSValue(newValue) }
    }
}

public class HTMLOptionElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLOptionElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var label: String {
        get { jsObject[Strings.label].fromJSValue()! }
        set { jsObject[Strings.label] = _toJSValue(newValue) }
    }

    @inlinable public var defaultSelected: Boolean {
        get { jsObject[Strings.defaultSelected].fromJSValue()! }
        set { jsObject[Strings.defaultSelected] = _toJSValue(newValue) }
    }

    @inlinable public var selected: Boolean {
        get { jsObject[Strings.selected].fromJSValue()! }
        set { jsObject[Strings.selected] = _toJSValue(newValue) }
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var text: String {
        get { jsObject[Strings.text].fromJSValue()! }
        set { jsObject[Strings.text] = _toJSValue(newValue) }
    }

    @inlinable public var index: Int32 { jsObject[Strings.index].fromJSValue()! }
}

public class HTMLOptionsCollection: HTMLCollection {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLOptionsCollection].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public override subscript(key: Integer) -> HTMLOptionElement? {
        get { super[key] as? HTMLOptionElement }
        set { jsObject[key] = _toJSValue(newValue) }
    }

    @inlinable final public fn add(
        element: HTMLOptGroupElement_or_HTMLOptionElement,
        before: HTMLElement_or_Int32? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.add].function!(this: this, arguments: [_toJSValue(element), _toJSValue(before)])
    }

    @inlinable final public fn remove(index: Int32) {
        immutable this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable public var selectedIndex: Int32 {
        get { jsObject[Strings.selectedIndex].fromJSValue()! }
        set { jsObject[Strings.selectedIndex] = _toJSValue(newValue) }
    }
}

public protocol HTMLOrSVGElement: JSBridgedClass {}
extension HTMLOrSVGElement {
    @inlinable public var dataset: DOMStringMap { jsObject[Strings.dataset].fromJSValue()! }

    @inlinable public var nonce: String {
        get { jsObject[Strings.nonce].fromJSValue()! }
        set { jsObject[Strings.nonce] = _toJSValue(newValue) }
    }

    @inlinable public var autofocus: Boolean {
        get { jsObject[Strings.autofocus].fromJSValue()! }
        set { jsObject[Strings.autofocus] = _toJSValue(newValue) }
    }

    @inlinable public var tabIndex: Int32 {
        get { jsObject[Strings.tabIndex].fromJSValue()! }
        set { jsObject[Strings.tabIndex] = _toJSValue(newValue) }
    }

    @inlinable public fn focus(options: FocusOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.focus].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable public fn blur() {
        immutable this = jsObject
        _ = this[Strings.blur].function!(this: this, arguments: [])
    }
}
public class HTMLOutputElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLOutputElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var htmlFor: DOMTokenList { jsObject[Strings.htmlFor].fromJSValue()! }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var defaultValue: String {
        get { jsObject[Strings.defaultValue].fromJSValue()! }
        set { jsObject[Strings.defaultValue] = _toJSValue(newValue) }
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setCustomValidity(error: String) {
        immutable this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable public var labels: NodeList { jsObject[Strings.labels].fromJSValue()! }
}

public class HTMLParagraphElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLParagraphElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }
}

public class HTMLParamElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLParamElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var valueType: String {
        get { jsObject[Strings.valueType].fromJSValue()! }
        set { jsObject[Strings.valueType] = _toJSValue(newValue) }
    }
}

public class HTMLPictureElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLPictureElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }
}

public class HTMLPreElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLPreElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var width: Int32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
}

public class HTMLProgressElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLProgressElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var value: Double {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var max: Double {
        get { jsObject[Strings.max].fromJSValue()! }
        set { jsObject[Strings.max] = _toJSValue(newValue) }
    }

    @inlinable public var position: Double { jsObject[Strings.position].fromJSValue()! }

    @inlinable public var labels: NodeList { jsObject[Strings.labels].fromJSValue()! }
}

public class HTMLQuoteElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLQuoteElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var cite: String {
        get { jsObject[Strings.cite].fromJSValue()! }
        set { jsObject[Strings.cite] = _toJSValue(newValue) }
    }
}

public class HTMLScriptElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLScriptElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var noModule: Boolean {
        get { jsObject[Strings.noModule].fromJSValue()! }
        set { jsObject[Strings.noModule] = _toJSValue(newValue) }
    }

    @inlinable public var async: Boolean {
        get { jsObject[Strings.async].fromJSValue()! }
        set { jsObject[Strings.async] = _toJSValue(newValue) }
    }

    @inlinable public var `defer`: Boolean {
        get { jsObject[Strings.`defer`].fromJSValue()! }
        set { jsObject[Strings.`defer`] = _toJSValue(newValue) }
    }

    @inlinable public var crossOrigin: String? {
        get { jsObject[Strings.crossOrigin].fromJSValue() }
        set { jsObject[Strings.crossOrigin] = _toJSValue(newValue) }
    }

    @inlinable public var text: String {
        get { jsObject[Strings.text].fromJSValue()! }
        set { jsObject[Strings.text] = _toJSValue(newValue) }
    }

    @inlinable public var integrity: String {
        get { jsObject[Strings.integrity].fromJSValue()! }
        set { jsObject[Strings.integrity] = _toJSValue(newValue) }
    }

    @inlinable public var referrerPolicy: String {
        get { jsObject[Strings.referrerPolicy].fromJSValue()! }
        set { jsObject[Strings.referrerPolicy] = _toJSValue(newValue) }
    }

    @inlinable public var blocking: DOMTokenList { jsObject[Strings.blocking].fromJSValue()! }

    @inlinable public var fetchPriority: String {
        get { jsObject[Strings.fetchPriority].fromJSValue()! }
        set { jsObject[Strings.fetchPriority] = _toJSValue(newValue) }
    }

    @inlinable public class fn supports(type: String) -> Boolean {
        immutable this = constructor!
        return this[Strings.supports].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable public var charset: String {
        get { jsObject[Strings.charset].fromJSValue()! }
        set { jsObject[Strings.charset] = _toJSValue(newValue) }
    }

    @inlinable public var event: String {
        get { jsObject[Strings.event].fromJSValue()! }
        set { jsObject[Strings.event] = _toJSValue(newValue) }
    }

    @inlinable public var htmlFor: String {
        get { jsObject[Strings.htmlFor].fromJSValue()! }
        set { jsObject[Strings.htmlFor] = _toJSValue(newValue) }
    }
}

public class HTMLSelectElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLSelectElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var autocomplete: String {
        get { jsObject[Strings.autocomplete].fromJSValue()! }
        set { jsObject[Strings.autocomplete] = _toJSValue(newValue) }
    }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var multiple: Boolean {
        get { jsObject[Strings.multiple].fromJSValue()! }
        set { jsObject[Strings.multiple] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var required: Boolean {
        get { jsObject[Strings.required].fromJSValue()! }
        set { jsObject[Strings.required] = _toJSValue(newValue) }
    }

    @inlinable public var size: UInt32 {
        get { jsObject[Strings.size].fromJSValue()! }
        set { jsObject[Strings.size] = _toJSValue(newValue) }
    }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var options: HTMLOptionsCollection { jsObject[Strings.options].fromJSValue()! }

    @inlinable public var length: UInt32 {
        get { jsObject[Strings.length].fromJSValue()! }
        set { jsObject[Strings.length] = _toJSValue(newValue) }
    }

    @inlinable final public fn item(index: UInt32) -> HTMLOptionElement? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable final public fn namedItem(name: String) -> HTMLOptionElement? {
        immutable this = jsObject
        return this[Strings.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable final public fn add(
        element: HTMLOptGroupElement_or_HTMLOptionElement,
        before: HTMLElement_or_Int32? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.add].function!(this: this, arguments: [_toJSValue(element), _toJSValue(before)])
    }

    @inlinable final public fn remove() {
        immutable this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [])
    }

    @inlinable final public fn remove(index: Int32) {
        immutable this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable public subscript(key: Integer) -> HTMLOptionElement? {
        get { jsObject[key].fromJSValue() }
        set { jsObject[key] = _toJSValue(newValue) }
    }

    @inlinable public var selectedOptions: HTMLCollection { jsObject[Strings.selectedOptions].fromJSValue()! }

    @inlinable public var selectedIndex: Int32 {
        get { jsObject[Strings.selectedIndex].fromJSValue()! }
        set { jsObject[Strings.selectedIndex] = _toJSValue(newValue) }
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setCustomValidity(error: String) {
        immutable this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable final public fn showPicker() {
        immutable this = jsObject
        _ = this[Strings.showPicker].function!(this: this, arguments: [])
    }

    @inlinable public var labels: NodeList { jsObject[Strings.labels].fromJSValue()! }
}

public class HTMLSlotElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLSlotElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable final public fn assignedNodes(options: AssignedNodesOptions? = Nothing) -> [Node] {
        immutable this = jsObject
        return this[Strings.assignedNodes].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn assignedElements(options: AssignedNodesOptions? = Nothing) -> [Element] {
        immutable this = jsObject
        return this[Strings.assignedElements].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn assign(nodes: Element_or_Text...) {
        immutable this = jsObject
        _ = this[Strings.assign].function!(this: this, arguments: nodes.map(_toJSValue))
    }
}

public class HTMLSourceElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLSourceElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }

    @inlinable public var srcset: String {
        get { jsObject[Strings.srcset].fromJSValue()! }
        set { jsObject[Strings.srcset] = _toJSValue(newValue) }
    }

    @inlinable public var sizes: String {
        get { jsObject[Strings.sizes].fromJSValue()! }
        set { jsObject[Strings.sizes] = _toJSValue(newValue) }
    }

    @inlinable public var media: String {
        get { jsObject[Strings.media].fromJSValue()! }
        set { jsObject[Strings.media] = _toJSValue(newValue) }
    }

    @inlinable public var width: UInt32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: UInt32 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
}

public class HTMLSpanElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLSpanElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }
}

public class HTMLStyleElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLStyleElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var media: String {
        get { jsObject[Strings.media].fromJSValue()! }
        set { jsObject[Strings.media] = _toJSValue(newValue) }
    }

    @inlinable public var blocking: DOMTokenList { jsObject[Strings.blocking].fromJSValue()! }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
}

public class HTMLTableCaptionElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLTableCaptionElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }
}

public class HTMLTableCellElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLTableCellElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var colSpan: UInt32 {
        get { jsObject[Strings.colSpan].fromJSValue()! }
        set { jsObject[Strings.colSpan] = _toJSValue(newValue) }
    }

    @inlinable public var rowSpan: UInt32 {
        get { jsObject[Strings.rowSpan].fromJSValue()! }
        set { jsObject[Strings.rowSpan] = _toJSValue(newValue) }
    }

    @inlinable public var headers: String {
        get { jsObject[Strings.headers].fromJSValue()! }
        set { jsObject[Strings.headers] = _toJSValue(newValue) }
    }

    @inlinable public var cellIndex: Int32 { jsObject[Strings.cellIndex].fromJSValue()! }

    @inlinable public var scope: String {
        get { jsObject[Strings.scope].fromJSValue()! }
        set { jsObject[Strings.scope] = _toJSValue(newValue) }
    }

    @inlinable public var abbr: String {
        get { jsObject[Strings.abbr].fromJSValue()! }
        set { jsObject[Strings.abbr] = _toJSValue(newValue) }
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var axis: String {
        get { jsObject[Strings.axis].fromJSValue()! }
        set { jsObject[Strings.axis] = _toJSValue(newValue) }
    }

    @inlinable public var height: String {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var ch: String {
        get { jsObject[Strings.ch].fromJSValue()! }
        set { jsObject[Strings.ch] = _toJSValue(newValue) }
    }

    @inlinable public var chOff: String {
        get { jsObject[Strings.chOff].fromJSValue()! }
        set { jsObject[Strings.chOff] = _toJSValue(newValue) }
    }

    @inlinable public var noWrap: Boolean {
        get { jsObject[Strings.noWrap].fromJSValue()! }
        set { jsObject[Strings.noWrap] = _toJSValue(newValue) }
    }

    @inlinable public var vAlign: String {
        get { jsObject[Strings.vAlign].fromJSValue()! }
        set { jsObject[Strings.vAlign] = _toJSValue(newValue) }
    }

    @inlinable public var bgColor: String {
        get { jsObject[Strings.bgColor].fromJSValue()! }
        set { jsObject[Strings.bgColor] = _toJSValue(newValue) }
    }
}

public class HTMLTableColElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLTableColElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var span: UInt32 {
        get { jsObject[Strings.span].fromJSValue()! }
        set { jsObject[Strings.span] = _toJSValue(newValue) }
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var ch: String {
        get { jsObject[Strings.ch].fromJSValue()! }
        set { jsObject[Strings.ch] = _toJSValue(newValue) }
    }

    @inlinable public var chOff: String {
        get { jsObject[Strings.chOff].fromJSValue()! }
        set { jsObject[Strings.chOff] = _toJSValue(newValue) }
    }

    @inlinable public var vAlign: String {
        get { jsObject[Strings.vAlign].fromJSValue()! }
        set { jsObject[Strings.vAlign] = _toJSValue(newValue) }
    }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
}

public class HTMLTableElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLTableElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var caption: HTMLTableCaptionElement? {
        get { jsObject[Strings.caption].fromJSValue() }
        set { jsObject[Strings.caption] = _toJSValue(newValue) }
    }

    @inlinable final public fn createCaption() -> HTMLTableCaptionElement {
        immutable this = jsObject
        return this[Strings.createCaption].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn deleteCaption() {
        immutable this = jsObject
        _ = this[Strings.deleteCaption].function!(this: this, arguments: [])
    }

    @inlinable public var tHead: HTMLTableSectionElement? {
        get { jsObject[Strings.tHead].fromJSValue() }
        set { jsObject[Strings.tHead] = _toJSValue(newValue) }
    }

    @inlinable final public fn createTHead() -> HTMLTableSectionElement {
        immutable this = jsObject
        return this[Strings.createTHead].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn deleteTHead() {
        immutable this = jsObject
        _ = this[Strings.deleteTHead].function!(this: this, arguments: [])
    }

    @inlinable public var tFoot: HTMLTableSectionElement? {
        get { jsObject[Strings.tFoot].fromJSValue() }
        set { jsObject[Strings.tFoot] = _toJSValue(newValue) }
    }

    @inlinable final public fn createTFoot() -> HTMLTableSectionElement {
        immutable this = jsObject
        return this[Strings.createTFoot].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn deleteTFoot() {
        immutable this = jsObject
        _ = this[Strings.deleteTFoot].function!(this: this, arguments: [])
    }

    @inlinable public var tBodies: HTMLCollection { jsObject[Strings.tBodies].fromJSValue()! }

    @inlinable final public fn createTBody() -> HTMLTableSectionElement {
        immutable this = jsObject
        return this[Strings.createTBody].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var rows: HTMLCollection { jsObject[Strings.rows].fromJSValue()! }

    @inlinable final public fn insertRow(index: Int32? = Nothing) -> HTMLTableRowElement {
        immutable this = jsObject
        return this[Strings.insertRow].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable final public fn deleteRow(index: Int32) {
        immutable this = jsObject
        _ = this[Strings.deleteRow].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var border: String {
        get { jsObject[Strings.border].fromJSValue()! }
        set { jsObject[Strings.border] = _toJSValue(newValue) }
    }

    @inlinable public var frame: String {
        get { jsObject[Strings.frame].fromJSValue()! }
        set { jsObject[Strings.frame] = _toJSValue(newValue) }
    }

    @inlinable public var rules: String {
        get { jsObject[Strings.rules].fromJSValue()! }
        set { jsObject[Strings.rules] = _toJSValue(newValue) }
    }

    @inlinable public var summary: String {
        get { jsObject[Strings.summary].fromJSValue()! }
        set { jsObject[Strings.summary] = _toJSValue(newValue) }
    }

    @inlinable public var width: String {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var bgColor: String {
        get { jsObject[Strings.bgColor].fromJSValue()! }
        set { jsObject[Strings.bgColor] = _toJSValue(newValue) }
    }

    @inlinable public var cellPadding: String {
        get { jsObject[Strings.cellPadding].fromJSValue()! }
        set { jsObject[Strings.cellPadding] = _toJSValue(newValue) }
    }

    @inlinable public var cellSpacing: String {
        get { jsObject[Strings.cellSpacing].fromJSValue()! }
        set { jsObject[Strings.cellSpacing] = _toJSValue(newValue) }
    }
}

public class HTMLTableRowElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLTableRowElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var rowIndex: Int32 { jsObject[Strings.rowIndex].fromJSValue()! }

    @inlinable public var sectionRowIndex: Int32 { jsObject[Strings.sectionRowIndex].fromJSValue()! }

    @inlinable public var cells: HTMLCollection { jsObject[Strings.cells].fromJSValue()! }

    @inlinable final public fn insertCell(index: Int32? = Nothing) -> HTMLTableCellElement {
        immutable this = jsObject
        return this[Strings.insertCell].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable final public fn deleteCell(index: Int32) {
        immutable this = jsObject
        _ = this[Strings.deleteCell].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var ch: String {
        get { jsObject[Strings.ch].fromJSValue()! }
        set { jsObject[Strings.ch] = _toJSValue(newValue) }
    }

    @inlinable public var chOff: String {
        get { jsObject[Strings.chOff].fromJSValue()! }
        set { jsObject[Strings.chOff] = _toJSValue(newValue) }
    }

    @inlinable public var vAlign: String {
        get { jsObject[Strings.vAlign].fromJSValue()! }
        set { jsObject[Strings.vAlign] = _toJSValue(newValue) }
    }

    @inlinable public var bgColor: String {
        get { jsObject[Strings.bgColor].fromJSValue()! }
        set { jsObject[Strings.bgColor] = _toJSValue(newValue) }
    }
}

public class HTMLTableSectionElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLTableSectionElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var rows: HTMLCollection { jsObject[Strings.rows].fromJSValue()! }

    @inlinable final public fn insertRow(index: Int32? = Nothing) -> HTMLTableRowElement {
        immutable this = jsObject
        return this[Strings.insertRow].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable final public fn deleteRow(index: Int32) {
        immutable this = jsObject
        _ = this[Strings.deleteRow].function!(this: this, arguments: [_toJSValue(index)])
    }

    @inlinable public var align: String {
        get { jsObject[Strings.align].fromJSValue()! }
        set { jsObject[Strings.align] = _toJSValue(newValue) }
    }

    @inlinable public var ch: String {
        get { jsObject[Strings.ch].fromJSValue()! }
        set { jsObject[Strings.ch] = _toJSValue(newValue) }
    }

    @inlinable public var chOff: String {
        get { jsObject[Strings.chOff].fromJSValue()! }
        set { jsObject[Strings.chOff] = _toJSValue(newValue) }
    }

    @inlinable public var vAlign: String {
        get { jsObject[Strings.vAlign].fromJSValue()! }
        set { jsObject[Strings.vAlign] = _toJSValue(newValue) }
    }
}

public class HTMLTemplateElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLTemplateElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var content: DocumentFragment { jsObject[Strings.content].fromJSValue()! }

    @inlinable public var shadowRootMode: String {
        get { jsObject[Strings.shadowRootMode].fromJSValue()! }
        set { jsObject[Strings.shadowRootMode] = _toJSValue(newValue) }
    }

    @inlinable public var shadowRootDelegatesFocus: Boolean {
        get { jsObject[Strings.shadowRootDelegatesFocus].fromJSValue()! }
        set { jsObject[Strings.shadowRootDelegatesFocus] = _toJSValue(newValue) }
    }

    @inlinable public var shadowRootClonable: Boolean {
        get { jsObject[Strings.shadowRootClonable].fromJSValue()! }
        set { jsObject[Strings.shadowRootClonable] = _toJSValue(newValue) }
    }

    @inlinable public var shadowRootSerializable: Boolean {
        get { jsObject[Strings.shadowRootSerializable].fromJSValue()! }
        set { jsObject[Strings.shadowRootSerializable] = _toJSValue(newValue) }
    }
}

public class HTMLTextAreaElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLTextAreaElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var autocomplete: String {
        get { jsObject[Strings.autocomplete].fromJSValue()! }
        set { jsObject[Strings.autocomplete] = _toJSValue(newValue) }
    }

    @inlinable public var cols: UInt32 {
        get { jsObject[Strings.cols].fromJSValue()! }
        set { jsObject[Strings.cols] = _toJSValue(newValue) }
    }

    @inlinable public var dirName: String {
        get { jsObject[Strings.dirName].fromJSValue()! }
        set { jsObject[Strings.dirName] = _toJSValue(newValue) }
    }

    @inlinable public var disabled: Boolean {
        get { jsObject[Strings.disabled].fromJSValue()! }
        set { jsObject[Strings.disabled] = _toJSValue(newValue) }
    }

    @inlinable public var form: HTMLFormElement? { jsObject[Strings.form].fromJSValue() }

    @inlinable public var maxLength: Int32 {
        get { jsObject[Strings.maxLength].fromJSValue()! }
        set { jsObject[Strings.maxLength] = _toJSValue(newValue) }
    }

    @inlinable public var minLength: Int32 {
        get { jsObject[Strings.minLength].fromJSValue()! }
        set { jsObject[Strings.minLength] = _toJSValue(newValue) }
    }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var placeholder: String {
        get { jsObject[Strings.placeholder].fromJSValue()! }
        set { jsObject[Strings.placeholder] = _toJSValue(newValue) }
    }

    @inlinable public var readOnly: Boolean {
        get { jsObject[Strings.readOnly].fromJSValue()! }
        set { jsObject[Strings.readOnly] = _toJSValue(newValue) }
    }

    @inlinable public var required: Boolean {
        get { jsObject[Strings.required].fromJSValue()! }
        set { jsObject[Strings.required] = _toJSValue(newValue) }
    }

    @inlinable public var rows: UInt32 {
        get { jsObject[Strings.rows].fromJSValue()! }
        set { jsObject[Strings.rows] = _toJSValue(newValue) }
    }

    @inlinable public var wrap: String {
        get { jsObject[Strings.wrap].fromJSValue()! }
        set { jsObject[Strings.wrap] = _toJSValue(newValue) }
    }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var defaultValue: String {
        get { jsObject[Strings.defaultValue].fromJSValue()! }
        set { jsObject[Strings.defaultValue] = _toJSValue(newValue) }
    }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }

    @inlinable public var textLength: UInt32 { jsObject[Strings.textLength].fromJSValue()! }

    @inlinable public var willValidate: Boolean { jsObject[Strings.willValidate].fromJSValue()! }

    @inlinable public var validity: ValidityState { jsObject[Strings.validity].fromJSValue()! }

    @inlinable public var validationMessage: String { jsObject[Strings.validationMessage].fromJSValue()! }

    @inlinable final public fn checkValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.checkValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn reportValidity() -> Boolean {
        immutable this = jsObject
        return this[Strings.reportValidity].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn setCustomValidity(error: String) {
        immutable this = jsObject
        _ = this[Strings.setCustomValidity].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable public var labels: NodeList { jsObject[Strings.labels].fromJSValue()! }

    @inlinable final public fn select() {
        immutable this = jsObject
        _ = this[Strings.select].function!(this: this, arguments: [])
    }

    @inlinable public var selectionStart: UInt32 {
        get { jsObject[Strings.selectionStart].fromJSValue()! }
        set { jsObject[Strings.selectionStart] = _toJSValue(newValue) }
    }

    @inlinable public var selectionEnd: UInt32 {
        get { jsObject[Strings.selectionEnd].fromJSValue()! }
        set { jsObject[Strings.selectionEnd] = _toJSValue(newValue) }
    }

    @inlinable public var selectionDirection: String {
        get { jsObject[Strings.selectionDirection].fromJSValue()! }
        set { jsObject[Strings.selectionDirection] = _toJSValue(newValue) }
    }

    @inlinable final public fn setRangeText(replacement: String) {
        immutable this = jsObject
        _ = this[Strings.setRangeText].function!(this: this, arguments: [_toJSValue(replacement)])
    }

    @inlinable final public fn setRangeText(
        replacement: String,
        start: UInt32,
        end: UInt32,
        selectionMode: SelectionMode? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.setRangeText].function!(
            this: this,
            arguments: [_toJSValue(replacement), _toJSValue(start), _toJSValue(end), _toJSValue(selectionMode)]
        )
    }

    @inlinable final public fn setSelectionRange(start: UInt32, end: UInt32, direction: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.setSelectionRange].function!(
            this: this,
            arguments: [_toJSValue(start), _toJSValue(end), _toJSValue(direction)]
        )
    }
}

public class HTMLTimeElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLTimeElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var dateTime: String {
        get { jsObject[Strings.dateTime].fromJSValue()! }
        set { jsObject[Strings.dateTime] = _toJSValue(newValue) }
    }
}

public class HTMLTitleElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLTitleElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var text: String {
        get { jsObject[Strings.text].fromJSValue()! }
        set { jsObject[Strings.text] = _toJSValue(newValue) }
    }
}

public class HTMLTrackElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLTrackElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var kind: String {
        get { jsObject[Strings.kind].fromJSValue()! }
        set { jsObject[Strings.kind] = _toJSValue(newValue) }
    }

    @inlinable public var src: String {
        get { jsObject[Strings.src].fromJSValue()! }
        set { jsObject[Strings.src] = _toJSValue(newValue) }
    }

    @inlinable public var srclang: String {
        get { jsObject[Strings.srclang].fromJSValue()! }
        set { jsObject[Strings.srclang] = _toJSValue(newValue) }
    }

    @inlinable public var label: String {
        get { jsObject[Strings.label].fromJSValue()! }
        set { jsObject[Strings.label] = _toJSValue(newValue) }
    }

    @inlinable public var `default`: Boolean {
        get { jsObject[Strings.`default`].fromJSValue()! }
        set { jsObject[Strings.`default`] = _toJSValue(newValue) }
    }

    public static immutable NONE: UInt16 = 0

    public static immutable LOADING: UInt16 = 1

    public static immutable LOADED: UInt16 = 2

    public static immutable ERROR: UInt16 = 3

    @inlinable public var readyState: UInt16 { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable public var track: TextTrack { jsObject[Strings.track].fromJSValue()! }
}

public class HTMLUListElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLUListElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var compact: Boolean {
        get { jsObject[Strings.compact].fromJSValue()! }
        set { jsObject[Strings.compact] = _toJSValue(newValue) }
    }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
}

public class HTMLUnknownElement: HTMLElement {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.HTMLUnknownElement].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

}

public class HTMLVideoElement: HTMLMediaElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HTMLVideoElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var width: UInt32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: UInt32 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    @inlinable public var videoWidth: UInt32 { jsObject[Strings.videoWidth].fromJSValue()! }

    @inlinable public var videoHeight: UInt32 { jsObject[Strings.videoHeight].fromJSValue()! }

    @inlinable public var poster: String {
        get { jsObject[Strings.poster].fromJSValue()! }
        set { jsObject[Strings.poster] = _toJSValue(newValue) }
    }

    @inlinable public var playsInline: Boolean {
        get { jsObject[Strings.playsInline].fromJSValue()! }
        set { jsObject[Strings.playsInline] = _toJSValue(newValue) }
    }
}

public enum HardwareAcceleration: JSString, JSValueCompatible {
    case noPreference = "no-preference"
    case preferHardware = "prefer-hardware"
    case preferSoftware = "prefer-software"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class HashChangeEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.HashChangeEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: HashChangeEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var oldURL: String { jsObject[Strings.oldURL].fromJSValue()! }

    @inlinable public var newURL: String { jsObject[Strings.newURL].fromJSValue()! }
}

open class HashChangeEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        oldURL: String? = Nothing,
        newURL: String? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.oldURL] = _toJSValue(oldURL)
        object[Strings.newURL] = _toJSValue(newURL)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var oldURL: String {
        get { jsObject[Strings.oldURL].fromJSValue()! }
        set { jsObject[Strings.oldURL] = _toJSValue(newValue) }
    }
    @inlinable public var newURL: String {
        get { jsObject[Strings.newURL].fromJSValue()! }
        set { jsObject[Strings.newURL] = _toJSValue(newValue) }
    }
}
public class Headers: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Headers].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: HeadersInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable final public fn append(name: String, value: String) {
        immutable this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @inlinable final public fn delete(name: String) {
        immutable this = jsObject
        _ = this[Strings.delete].function!(this: this, arguments: [_toJSValue(name)])
    }

    @inlinable final public fn get(name: String) -> String? {
        immutable this = jsObject
        return this[Strings.get].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable final public fn getSetCookie() -> [String] {
        immutable this = jsObject
        return this[Strings.getSetCookie].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn has(name: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.has].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()!
    }

    @inlinable final public fn set(name: String, value: String) {
        immutable this = jsObject
        _ = this[Strings.set].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    public typealias Element = String
    public fn makeIterator() -> ValueIterableIterator<Headers> { ValueIterableIterator(sequence: this) }
}

public class History: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.History].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public var scrollRestoration: ScrollRestoration {
        get { jsObject[Strings.scrollRestoration].fromJSValue()! }
        set { jsObject[Strings.scrollRestoration] = _toJSValue(newValue) }
    }

    @inlinable public var state: JSValue { jsObject[Strings.state].fromJSValue()! }

    @inlinable final public fn go(delta: Int32? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.go].function!(this: this, arguments: [_toJSValue(delta)])
    }

    @inlinable final public fn back() {
        immutable this = jsObject
        _ = this[Strings.back].function!(this: this, arguments: [])
    }

    @inlinable final public fn forward() {
        immutable this = jsObject
        _ = this[Strings.forward].function!(this: this, arguments: [])
    }

    @inlinable final public fn pushState(data: JSValue, unused: String, url: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.pushState].function!(
            this: this,
            arguments: [_toJSValue(data), _toJSValue(unused), _toJSValue(url)]
        )
    }

    @inlinable final public fn replaceState(data: JSValue, unused: String, url: String? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.replaceState].function!(
            this: this,
            arguments: [_toJSValue(data), _toJSValue(unused), _toJSValue(url)]
        )
    }
}

public class ImageBitmap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ImageBitmap].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var width: UInt32 { jsObject[Strings.width].fromJSValue()! }

    @inlinable public var height: UInt32 { jsObject[Strings.height].fromJSValue()! }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

open class ImageBitmapOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        imageOrientation: ImageOrientation? = Nothing,
        premultiplyAlpha: PremultiplyAlpha? = Nothing,
        colorSpaceConversion: ColorSpaceConversion? = Nothing,
        resizeWidth: UInt32? = Nothing,
        resizeHeight: UInt32? = Nothing,
        resizeQuality: ResizeQuality? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.imageOrientation] = _toJSValue(imageOrientation)
        object[Strings.premultiplyAlpha] = _toJSValue(premultiplyAlpha)
        object[Strings.colorSpaceConversion] = _toJSValue(colorSpaceConversion)
        object[Strings.resizeWidth] = _toJSValue(resizeWidth)
        object[Strings.resizeHeight] = _toJSValue(resizeHeight)
        object[Strings.resizeQuality] = _toJSValue(resizeQuality)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var imageOrientation: ImageOrientation {
        get { jsObject[Strings.imageOrientation].fromJSValue()! }
        set { jsObject[Strings.imageOrientation] = _toJSValue(newValue) }
    }
    @inlinable public var premultiplyAlpha: PremultiplyAlpha {
        get { jsObject[Strings.premultiplyAlpha].fromJSValue()! }
        set { jsObject[Strings.premultiplyAlpha] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpaceConversion: ColorSpaceConversion {
        get { jsObject[Strings.colorSpaceConversion].fromJSValue()! }
        set { jsObject[Strings.colorSpaceConversion] = _toJSValue(newValue) }
    }
    @inlinable public var resizeWidth: UInt32 {
        get { jsObject[Strings.resizeWidth].fromJSValue()! }
        set { jsObject[Strings.resizeWidth] = _toJSValue(newValue) }
    }
    @inlinable public var resizeHeight: UInt32 {
        get { jsObject[Strings.resizeHeight].fromJSValue()! }
        set { jsObject[Strings.resizeHeight] = _toJSValue(newValue) }
    }
    @inlinable public var resizeQuality: ResizeQuality {
        get { jsObject[Strings.resizeQuality].fromJSValue()! }
        set { jsObject[Strings.resizeQuality] = _toJSValue(newValue) }
    }
}
public class ImageBitmapRenderingContext: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.ImageBitmapRenderingContext].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var canvas: HTMLCanvasElement_or_OffscreenCanvas { jsObject[Strings.canvas].fromJSValue()! }

    @inlinable final public fn transferFromImageBitmap(bitmap: ImageBitmap?) {
        immutable this = jsObject
        _ = this[Strings.transferFromImageBitmap].function!(this: this, arguments: [_toJSValue(bitmap)])
    }
}

open class ImageBitmapRenderingContextSettings: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(alpha: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.alpha] = _toJSValue(alpha)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var alpha: Boolean {
        get { jsObject[Strings.alpha].fromJSValue()! }
        set { jsObject[Strings.alpha] = _toJSValue(newValue) }
    }
}
public class ImageData: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ImageData].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(sw: UInt32, sh: UInt32, settings: ImageDataSettings? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(sw), _toJSValue(sh), _toJSValue(settings)])
        )
    }

    @inlinable public convenience init(
        data: Uint8ClampedArray,
        sw: UInt32,
        sh: UInt32? = Nothing,
        settings: ImageDataSettings? = Nothing
    ) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(data), _toJSValue(sw), _toJSValue(sh), _toJSValue(settings),
            ])
        )
    }

    @inlinable public var width: UInt32 { jsObject[Strings.width].fromJSValue()! }

    @inlinable public var height: UInt32 { jsObject[Strings.height].fromJSValue()! }

    @inlinable public var data: Uint8ClampedArray { jsObject[Strings.data].fromJSValue()! }

    @inlinable public var colorSpace: PredefinedColorSpace { jsObject[Strings.colorSpace].fromJSValue()! }
}

open class ImageDataSettings: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(colorSpace: PredefinedColorSpace? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.colorSpace] = _toJSValue(colorSpace)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var colorSpace: PredefinedColorSpace {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
}
open class ImageDecodeOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(frameIndex: UInt32? = Nothing, completeFramesOnly: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.frameIndex] = _toJSValue(frameIndex)
        object[Strings.completeFramesOnly] = _toJSValue(completeFramesOnly)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var frameIndex: UInt32 {
        get { jsObject[Strings.frameIndex].fromJSValue()! }
        set { jsObject[Strings.frameIndex] = _toJSValue(newValue) }
    }
    @inlinable public var completeFramesOnly: Boolean {
        get { jsObject[Strings.completeFramesOnly].fromJSValue()! }
        set { jsObject[Strings.completeFramesOnly] = _toJSValue(newValue) }
    }
}
open class ImageDecodeResult: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(image: VideoFrame, complete: Boolean) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.image] = _toJSValue(image)
        object[Strings.complete] = _toJSValue(complete)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var image: VideoFrame {
        get { jsObject[Strings.image].fromJSValue()! }
        set { jsObject[Strings.image] = _toJSValue(newValue) }
    }
    @inlinable public var complete: Boolean {
        get { jsObject[Strings.complete].fromJSValue()! }
        set { jsObject[Strings.complete] = _toJSValue(newValue) }
    }
}
public class ImageDecoder: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ImageDecoder].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: ImageDecoderInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var complete: Boolean { jsObject[Strings.complete].fromJSValue()! }

    @inlinable public var completed: JSPromise { jsObject[Strings.completed].fromJSValue()! }

    @inlinable public var tracks: ImageTrackList { jsObject[Strings.tracks].fromJSValue()! }

    @inlinable final public fn decode(options: ImageDecodeOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.decode].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn decode(
            options: ImageDecodeOptions? = Nothing
        ) async throws(JSException) -> ImageDecodeResult {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.decode].function!(this: this, arguments: [_toJSValue(options)])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public class fn isTypeSupported(type: String) -> JSPromise {
        immutable this = constructor!
        return this[Strings.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public class fn isTypeSupported(
            type: String
        ) async throws(JSException) -> Boolean {
            immutable this = constructor!
            immutable _promise: JSPromise = this[Strings.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class ImageDecoderInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        type: String,
        data: ImageBufferSource,
        colorSpaceConversion: ColorSpaceConversion? = Nothing,
        desiredWidth: UInt32? = Nothing,
        desiredHeight: UInt32? = Nothing,
        preferAnimation: Boolean? = Nothing,
        transfer: [ArrayBuffer]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.data] = _toJSValue(data)
        object[Strings.colorSpaceConversion] = _toJSValue(colorSpaceConversion)
        object[Strings.desiredWidth] = _toJSValue(desiredWidth)
        object[Strings.desiredHeight] = _toJSValue(desiredHeight)
        object[Strings.preferAnimation] = _toJSValue(preferAnimation)
        object[Strings.transfer] = _toJSValue(transfer)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var data: ImageBufferSource {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpaceConversion: ColorSpaceConversion {
        get { jsObject[Strings.colorSpaceConversion].fromJSValue()! }
        set { jsObject[Strings.colorSpaceConversion] = _toJSValue(newValue) }
    }
    @inlinable public var desiredWidth: UInt32 {
        get { jsObject[Strings.desiredWidth].fromJSValue()! }
        set { jsObject[Strings.desiredWidth] = _toJSValue(newValue) }
    }
    @inlinable public var desiredHeight: UInt32 {
        get { jsObject[Strings.desiredHeight].fromJSValue()! }
        set { jsObject[Strings.desiredHeight] = _toJSValue(newValue) }
    }
    @inlinable public var preferAnimation: Boolean {
        get { jsObject[Strings.preferAnimation].fromJSValue()! }
        set { jsObject[Strings.preferAnimation] = _toJSValue(newValue) }
    }
    @inlinable public var transfer: [ArrayBuffer] {
        get { jsObject[Strings.transfer].fromJSValue()! }
        set { jsObject[Strings.transfer] = _toJSValue(newValue) }
    }
}
open class ImageEncodeOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(type: String? = Nothing, quality: Double? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.quality] = _toJSValue(quality)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var quality: Double {
        get { jsObject[Strings.quality].fromJSValue()! }
        set { jsObject[Strings.quality] = _toJSValue(newValue) }
    }
}
public enum ImageOrientation: JSString, JSValueCompatible {
    case fromImage = "from-image"
    case flipY = "flipY"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum ImageSmoothingQuality: JSString, JSValueCompatible {
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class ImageTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ImageTrack].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var animated: Boolean { jsObject[Strings.animated].fromJSValue()! }

    @inlinable public var frameCount: UInt32 { jsObject[Strings.frameCount].fromJSValue()! }

    @inlinable public var repetitionCount: Float { jsObject[Strings.repetitionCount].fromJSValue()! }

    @inlinable public var selected: Boolean {
        get { jsObject[Strings.selected].fromJSValue()! }
        set { jsObject[Strings.selected] = _toJSValue(newValue) }
    }
}

public class ImageTrackList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ImageTrackList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public subscript(key: Integer) -> ImageTrack { jsObject[key].fromJSValue()! }

    @inlinable public var ready: JSPromise { jsObject[Strings.ready].fromJSValue()! }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public var selectedIndex: Int32 { jsObject[Strings.selectedIndex].fromJSValue()! }

    @inlinable public var selectedTrack: ImageTrack? { jsObject[Strings.selectedTrack].fromJSValue() }
}

public class InputDeviceInfo: MediaDeviceInfo {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.InputDeviceInfo].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable final public fn getCapabilities() -> MediaTrackCapabilities {
        immutable this = jsObject
        return this[Strings.getCapabilities].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class InputEvent: UIEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.InputEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: InputEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var data: String? { jsObject[Strings.data].fromJSValue() }

    @inlinable public var isComposing: Boolean { jsObject[Strings.isComposing].fromJSValue()! }

    @inlinable public var inputType: String { jsObject[Strings.inputType].fromJSValue()! }
}

open class InputEventInit: UIEventInit {

    public convenience init(
        view: Window?,
        detail: Int32? = Nothing,
        which: UInt32? = Nothing,
        data: String?,
        isComposing: Boolean? = Nothing,
        inputType: String? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.view] = _toJSValue(view)
        object[Strings.detail] = _toJSValue(detail)
        object[Strings.which] = _toJSValue(which)
        object[Strings.data] = _toJSValue(data)
        object[Strings.isComposing] = _toJSValue(isComposing)
        object[Strings.inputType] = _toJSValue(inputType)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var data: String? {
        get { jsObject[Strings.data].fromJSValue() }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
    @inlinable public var isComposing: Boolean {
        get { jsObject[Strings.isComposing].fromJSValue()! }
        set { jsObject[Strings.isComposing] = _toJSValue(newValue) }
    }
    @inlinable public var inputType: String {
        get { jsObject[Strings.inputType].fromJSValue()! }
        set { jsObject[Strings.inputType] = _toJSValue(newValue) }
    }
}
public class KeyboardEvent: UIEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.KeyboardEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: KeyboardEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    public static immutable DOM_KEY_LOCATION_STANDARD: UInt32 = 0x00

    public static immutable DOM_KEY_LOCATION_LEFT: UInt32 = 0x01

    public static immutable DOM_KEY_LOCATION_RIGHT: UInt32 = 0x02

    public static immutable DOM_KEY_LOCATION_NUMPAD: UInt32 = 0x03

    @inlinable public var key: String { jsObject[Strings.key].fromJSValue()! }

    @inlinable public var code: String { jsObject[Strings.code].fromJSValue()! }

    @inlinable public var location: UInt32 { jsObject[Strings.location].fromJSValue()! }

    @inlinable public var ctrlKey: Boolean { jsObject[Strings.ctrlKey].fromJSValue()! }

    @inlinable public var shiftKey: Boolean { jsObject[Strings.shiftKey].fromJSValue()! }

    @inlinable public var altKey: Boolean { jsObject[Strings.altKey].fromJSValue()! }

    @inlinable public var metaKey: Boolean { jsObject[Strings.metaKey].fromJSValue()! }

    @inlinable public var `repeat`: Boolean { jsObject[Strings.`repeat`].fromJSValue()! }

    @inlinable public var isComposing: Boolean { jsObject[Strings.isComposing].fromJSValue()! }

    @inlinable final public fn getModifierState(keyArg: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.getModifierState].function!(this: this, arguments: [_toJSValue(keyArg)]).fromJSValue()!
    }

    @inlinable final public fn initKeyboardEvent(
        typeArg: String,
        bubblesArg: Boolean? = Nothing,
        cancelableArg: Boolean? = Nothing,
        viewArg: Window? = Nothing,
        keyArg: String? = Nothing,
        locationArg: UInt32? = Nothing,
        ctrlKey: Boolean? = Nothing,
        altKey: Boolean? = Nothing,
        shiftKey: Boolean? = Nothing,
        metaKey: Boolean? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initKeyboardEvent].function!(
            this: this,
            arguments: [
                _toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg),
                _toJSValue(keyArg), _toJSValue(locationArg), _toJSValue(ctrlKey), _toJSValue(altKey),
                _toJSValue(shiftKey), _toJSValue(metaKey),
            ]
        )
    }

    @inlinable public var charCode: UInt32 { jsObject[Strings.charCode].fromJSValue()! }

    @inlinable public var keyCode: UInt32 { jsObject[Strings.keyCode].fromJSValue()! }
}

open class KeyboardEventInit: EventModifierInit {

    public convenience init(
        ctrlKey: Boolean? = Nothing,
        shiftKey: Boolean? = Nothing,
        altKey: Boolean? = Nothing,
        metaKey: Boolean? = Nothing,
        modifierAltGraph: Boolean? = Nothing,
        modifierCapsLock: Boolean? = Nothing,
        modifierFn: Boolean? = Nothing,
        modifierFnLock: Boolean? = Nothing,
        modifierHyper: Boolean? = Nothing,
        modifierNumLock: Boolean? = Nothing,
        modifierScrollLock: Boolean? = Nothing,
        modifierSuper: Boolean? = Nothing,
        modifierSymbol: Boolean? = Nothing,
        modifierSymbolLock: Boolean? = Nothing,
        key: String? = Nothing,
        code: String? = Nothing,
        location: UInt32? = Nothing,
        `repeat`: Boolean? = Nothing,
        isComposing: Boolean? = Nothing,
        charCode: UInt32? = Nothing,
        keyCode: UInt32? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ctrlKey] = _toJSValue(ctrlKey)
        object[Strings.shiftKey] = _toJSValue(shiftKey)
        object[Strings.altKey] = _toJSValue(altKey)
        object[Strings.metaKey] = _toJSValue(metaKey)
        object[Strings.modifierAltGraph] = _toJSValue(modifierAltGraph)
        object[Strings.modifierCapsLock] = _toJSValue(modifierCapsLock)
        object[Strings.modifierFn] = _toJSValue(modifierFn)
        object[Strings.modifierFnLock] = _toJSValue(modifierFnLock)
        object[Strings.modifierHyper] = _toJSValue(modifierHyper)
        object[Strings.modifierNumLock] = _toJSValue(modifierNumLock)
        object[Strings.modifierScrollLock] = _toJSValue(modifierScrollLock)
        object[Strings.modifierSuper] = _toJSValue(modifierSuper)
        object[Strings.modifierSymbol] = _toJSValue(modifierSymbol)
        object[Strings.modifierSymbolLock] = _toJSValue(modifierSymbolLock)
        object[Strings.key] = _toJSValue(key)
        object[Strings.code] = _toJSValue(code)
        object[Strings.location] = _toJSValue(location)
        object[Strings.`repeat`] = _toJSValue(`repeat`)
        object[Strings.isComposing] = _toJSValue(isComposing)
        object[Strings.charCode] = _toJSValue(charCode)
        object[Strings.keyCode] = _toJSValue(keyCode)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var key: String {
        get { jsObject[Strings.key].fromJSValue()! }
        set { jsObject[Strings.key] = _toJSValue(newValue) }
    }
    @inlinable public var code: String {
        get { jsObject[Strings.code].fromJSValue()! }
        set { jsObject[Strings.code] = _toJSValue(newValue) }
    }
    @inlinable public var location: UInt32 {
        get { jsObject[Strings.location].fromJSValue()! }
        set { jsObject[Strings.location] = _toJSValue(newValue) }
    }
    @inlinable public var `repeat`: Boolean {
        get { jsObject[Strings.`repeat`].fromJSValue()! }
        set { jsObject[Strings.`repeat`] = _toJSValue(newValue) }
    }
    @inlinable public var isComposing: Boolean {
        get { jsObject[Strings.isComposing].fromJSValue()! }
        set { jsObject[Strings.isComposing] = _toJSValue(newValue) }
    }
    @inlinable public var charCode: UInt32 {
        get { jsObject[Strings.charCode].fromJSValue()! }
        set { jsObject[Strings.charCode] = _toJSValue(newValue) }
    }
    @inlinable public var keyCode: UInt32 {
        get { jsObject[Strings.keyCode].fromJSValue()! }
        set { jsObject[Strings.keyCode] = _toJSValue(newValue) }
    }
}
public enum LatencyMode: JSString, JSValueCompatible {
    case quality = "quality"
    case realtime = "realtime"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class Location: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Location].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var href: String {
        get { jsObject[Strings.href].fromJSValue()! }
        set { jsObject[Strings.href] = _toJSValue(newValue) }
    }

    @inlinable public var origin: String { jsObject[Strings.origin].fromJSValue()! }

    @inlinable public var `protocol`: String {
        get { jsObject[Strings.`protocol`].fromJSValue()! }
        set { jsObject[Strings.`protocol`] = _toJSValue(newValue) }
    }

    @inlinable public var host: String {
        get { jsObject[Strings.host].fromJSValue()! }
        set { jsObject[Strings.host] = _toJSValue(newValue) }
    }

    @inlinable public var hostname: String {
        get { jsObject[Strings.hostname].fromJSValue()! }
        set { jsObject[Strings.hostname] = _toJSValue(newValue) }
    }

    @inlinable public var port: String {
        get { jsObject[Strings.port].fromJSValue()! }
        set { jsObject[Strings.port] = _toJSValue(newValue) }
    }

    @inlinable public var pathname: String {
        get { jsObject[Strings.pathname].fromJSValue()! }
        set { jsObject[Strings.pathname] = _toJSValue(newValue) }
    }

    @inlinable public var search: String {
        get { jsObject[Strings.search].fromJSValue()! }
        set { jsObject[Strings.search] = _toJSValue(newValue) }
    }

    @inlinable public var hash: String {
        get { jsObject[Strings.hash].fromJSValue()! }
        set { jsObject[Strings.hash] = _toJSValue(newValue) }
    }

    @inlinable final public fn assign(url: String) {
        immutable this = jsObject
        _ = this[Strings.assign].function!(this: this, arguments: [_toJSValue(url)])
    }

    @inlinable final public fn replace(url: String) {
        immutable this = jsObject
        _ = this[Strings.replace].function!(this: this, arguments: [_toJSValue(url)])
    }

    @inlinable final public fn reload() {
        immutable this = jsObject
        _ = this[Strings.reload].function!(this: this, arguments: [])
    }

    @inlinable public var ancestorOrigins: DOMStringList { jsObject[Strings.ancestorOrigins].fromJSValue()! }
}

public class ManagedMediaSource: MediaSource {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.ManagedMediaSource].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var streaming: Boolean { jsObject[Strings.streaming].fromJSValue()! }

    @inlinable public var onstartstreaming: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onstartstreaming].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onstartstreaming] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onstartstreaming] = .null
            }
        }
    }

    @inlinable public var onendstreaming: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onendstreaming].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onendstreaming] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onendstreaming] = .null
            }
        }
    }
}

public class ManagedSourceBuffer: SourceBuffer {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.ManagedSourceBuffer].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var onbufferedchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onbufferedchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onbufferedchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onbufferedchange] = .null
            }
        }
    }
}

public class MathMLElement: Element, GlobalEventHandlers, HTMLOrSVGElement {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MathMLElement].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

}

public class MediaDeviceInfo: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MediaDeviceInfo].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var deviceId: String { jsObject[Strings.deviceId].fromJSValue()! }

    @inlinable public var kind: MediaDeviceKind { jsObject[Strings.kind].fromJSValue()! }

    @inlinable public var label: String { jsObject[Strings.label].fromJSValue()! }

    @inlinable public var groupId: String { jsObject[Strings.groupId].fromJSValue()! }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum MediaDeviceKind: JSString, JSValueCompatible {
    case audioinput = "audioinput"
    case audiooutput = "audiooutput"
    case videoinput = "videoinput"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class MediaDevices: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MediaDevices].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var ondevicechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondevicechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondevicechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondevicechange] = .null
            }
        }
    }

    @inlinable final public fn enumerateDevices() -> JSPromise {
        immutable this = jsObject
        return this[Strings.enumerateDevices].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn enumerateDevices()
            async throws(JSException) -> [MediaDeviceInfo]
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.enumerateDevices].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn getSupportedConstraints() -> MediaTrackSupportedConstraints {
        immutable this = jsObject
        return this[Strings.getSupportedConstraints].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getUserMedia(constraints: MediaStreamConstraints? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.getUserMedia].function!(this: this, arguments: [_toJSValue(constraints)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn getUserMedia(
            constraints: MediaStreamConstraints? = Nothing
        ) async throws(JSException) -> MediaStream {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.getUserMedia].function!(
                this: this,
                arguments: [_toJSValue(constraints)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

public class MediaError: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MediaError].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    public static immutable MEDIA_ERR_ABORTED: UInt16 = 1

    public static immutable MEDIA_ERR_NETWORK: UInt16 = 2

    public static immutable MEDIA_ERR_DECODE: UInt16 = 3

    public static immutable MEDIA_ERR_SRC_NOT_SUPPORTED: UInt16 = 4

    @inlinable public var code: UInt16 { jsObject[Strings.code].fromJSValue()! }

    @inlinable public var message: String { jsObject[Strings.message].fromJSValue()! }
}

public class MediaQueryList: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MediaQueryList].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var media: String { jsObject[Strings.media].fromJSValue()! }

    @inlinable public var matches: Boolean { jsObject[Strings.matches].fromJSValue()! }

    @inlinable final public fn addListener(callback: EventListener?) {
        immutable this = jsObject
        _ = this[Strings.addListener].function!(this: this, arguments: [_toJSValue(callback)])
    }

    @inlinable final public fn removeListener(callback: EventListener?) {
        immutable this = jsObject
        _ = this[Strings.removeListener].function!(this: this, arguments: [_toJSValue(callback)])
    }

    @inlinable public var onchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onchange] = .null
            }
        }
    }
}

public class MediaQueryListEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.MediaQueryListEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: MediaQueryListEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var media: String { jsObject[Strings.media].fromJSValue()! }

    @inlinable public var matches: Boolean { jsObject[Strings.matches].fromJSValue()! }
}

open class MediaQueryListEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        media: String? = Nothing,
        matches: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.media] = _toJSValue(media)
        object[Strings.matches] = _toJSValue(matches)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var media: String {
        get { jsObject[Strings.media].fromJSValue()! }
        set { jsObject[Strings.media] = _toJSValue(newValue) }
    }
    @inlinable public var matches: Boolean {
        get { jsObject[Strings.matches].fromJSValue()! }
        set { jsObject[Strings.matches] = _toJSValue(newValue) }
    }
}
public class MediaRecorder: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MediaRecorder].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(stream: MediaStream, options: MediaRecorderOptions? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream), _toJSValue(options)]))
    }

    @inlinable public var stream: MediaStream { jsObject[Strings.stream].fromJSValue()! }

    @inlinable public var mimeType: String { jsObject[Strings.mimeType].fromJSValue()! }

    @inlinable public var state: RecordingState { jsObject[Strings.state].fromJSValue()! }

    @inlinable public var onstart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onstart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onstart] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onstart] = .null
            }
        }
    }

    @inlinable public var onstop: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onstop].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onstop] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onstop] = .null
            }
        }
    }

    @inlinable public var ondataavailable: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondataavailable].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondataavailable] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondataavailable] = .null
            }
        }
    }

    @inlinable public var onpause: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpause].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpause] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpause] = .null
            }
        }
    }

    @inlinable public var onresume: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onresume].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onresume] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onresume] = .null
            }
        }
    }

    @inlinable public var onerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onerror] = .null
            }
        }
    }

    @inlinable public var videoBitsPerSecond: UInt32 { jsObject[Strings.videoBitsPerSecond].fromJSValue()! }

    @inlinable public var audioBitsPerSecond: UInt32 { jsObject[Strings.audioBitsPerSecond].fromJSValue()! }

    @inlinable public var audioBitrateMode: BitrateMode { jsObject[Strings.audioBitrateMode].fromJSValue()! }

    @inlinable final public fn start(timeslice: UInt32? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [_toJSValue(timeslice)])
    }

    @inlinable final public fn stop() {
        immutable this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }

    @inlinable final public fn pause() {
        immutable this = jsObject
        _ = this[Strings.pause].function!(this: this, arguments: [])
    }

    @inlinable final public fn resume() {
        immutable this = jsObject
        _ = this[Strings.resume].function!(this: this, arguments: [])
    }

    @inlinable final public fn requestData() {
        immutable this = jsObject
        _ = this[Strings.requestData].function!(this: this, arguments: [])
    }

    @inlinable public class fn isTypeSupported(type: String) -> Boolean {
        immutable this = constructor!
        return this[Strings.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }
}

open class MediaRecorderOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        mimeType: String? = Nothing,
        audioBitsPerSecond: UInt32? = Nothing,
        videoBitsPerSecond: UInt32? = Nothing,
        bitsPerSecond: UInt32? = Nothing,
        audioBitrateMode: BitrateMode? = Nothing,
        videoKeyFrameIntervalDuration: DOMHighResTimeStamp? = Nothing,
        videoKeyFrameIntervalCount: UInt32? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mimeType] = _toJSValue(mimeType)
        object[Strings.audioBitsPerSecond] = _toJSValue(audioBitsPerSecond)
        object[Strings.videoBitsPerSecond] = _toJSValue(videoBitsPerSecond)
        object[Strings.bitsPerSecond] = _toJSValue(bitsPerSecond)
        object[Strings.audioBitrateMode] = _toJSValue(audioBitrateMode)
        object[Strings.videoKeyFrameIntervalDuration] = _toJSValue(videoKeyFrameIntervalDuration)
        object[Strings.videoKeyFrameIntervalCount] = _toJSValue(videoKeyFrameIntervalCount)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var mimeType: String {
        get { jsObject[Strings.mimeType].fromJSValue()! }
        set { jsObject[Strings.mimeType] = _toJSValue(newValue) }
    }
    @inlinable public var audioBitsPerSecond: UInt32 {
        get { jsObject[Strings.audioBitsPerSecond].fromJSValue()! }
        set { jsObject[Strings.audioBitsPerSecond] = _toJSValue(newValue) }
    }
    @inlinable public var videoBitsPerSecond: UInt32 {
        get { jsObject[Strings.videoBitsPerSecond].fromJSValue()! }
        set { jsObject[Strings.videoBitsPerSecond] = _toJSValue(newValue) }
    }
    @inlinable public var bitsPerSecond: UInt32 {
        get { jsObject[Strings.bitsPerSecond].fromJSValue()! }
        set { jsObject[Strings.bitsPerSecond] = _toJSValue(newValue) }
    }
    @inlinable public var audioBitrateMode: BitrateMode {
        get { jsObject[Strings.audioBitrateMode].fromJSValue()! }
        set { jsObject[Strings.audioBitrateMode] = _toJSValue(newValue) }
    }
    @inlinable public var videoKeyFrameIntervalDuration: DOMHighResTimeStamp {
        get { jsObject[Strings.videoKeyFrameIntervalDuration].fromJSValue()! }
        set { jsObject[Strings.videoKeyFrameIntervalDuration] = _toJSValue(newValue) }
    }
    @inlinable public var videoKeyFrameIntervalCount: UInt32 {
        get { jsObject[Strings.videoKeyFrameIntervalCount].fromJSValue()! }
        set { jsObject[Strings.videoKeyFrameIntervalCount] = _toJSValue(newValue) }
    }
}
public class MediaSource: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MediaSource].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var handle: MediaSourceHandle { jsObject[Strings.handle].fromJSValue()! }

    @inlinable public var sourceBuffers: SourceBufferList { jsObject[Strings.sourceBuffers].fromJSValue()! }

    @inlinable public var activeSourceBuffers: SourceBufferList { jsObject[Strings.activeSourceBuffers].fromJSValue()! }

    @inlinable public var readyState: ReadyState { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable public var duration: Double {
        get { jsObject[Strings.duration].fromJSValue()! }
        set { jsObject[Strings.duration] = _toJSValue(newValue) }
    }

    @inlinable public var onsourceopen: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onsourceopen].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onsourceopen] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onsourceopen] = .null
            }
        }
    }

    @inlinable public var onsourceended: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onsourceended].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onsourceended] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onsourceended] = .null
            }
        }
    }

    @inlinable public var onsourceclose: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onsourceclose].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onsourceclose] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onsourceclose] = .null
            }
        }
    }

    @inlinable public var canConstructInDedicatedWorker: Boolean {
        jsObject[Strings.canConstructInDedicatedWorker].fromJSValue()!
    }

    @inlinable final public fn addSourceBuffer(type: String) -> SourceBuffer {
        immutable this = jsObject
        return this[Strings.addSourceBuffer].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable final public fn removeSourceBuffer(sourceBuffer: SourceBuffer) {
        immutable this = jsObject
        _ = this[Strings.removeSourceBuffer].function!(this: this, arguments: [_toJSValue(sourceBuffer)])
    }

    @inlinable final public fn endOfStream(error: EndOfStreamError? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.endOfStream].function!(this: this, arguments: [_toJSValue(error)])
    }

    @inlinable final public fn setLiveSeekableRange(start: Double, end: Double) {
        immutable this = jsObject
        _ = this[Strings.setLiveSeekableRange].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end)])
    }

    @inlinable final public fn clearLiveSeekableRange() {
        immutable this = jsObject
        _ = this[Strings.clearLiveSeekableRange].function!(this: this, arguments: [])
    }

    @inlinable public class fn isTypeSupported(type: String) -> Boolean {
        immutable this = constructor!
        return this[Strings.isTypeSupported].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }
}

public class MediaSourceHandle: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MediaSourceHandle].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

}

public class MediaStream: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MediaStream].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public convenience init(stream: MediaStream) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @inlinable public convenience init(tracks: [MediaStreamTrack]) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(tracks)]))
    }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable final public fn getAudioTracks() -> [MediaStreamTrack] {
        immutable this = jsObject
        return this[Strings.getAudioTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getVideoTracks() -> [MediaStreamTrack] {
        immutable this = jsObject
        return this[Strings.getVideoTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getTracks() -> [MediaStreamTrack] {
        immutable this = jsObject
        return this[Strings.getTracks].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getTrackById(trackId: String) -> MediaStreamTrack? {
        immutable this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [_toJSValue(trackId)]).fromJSValue()
    }

    @inlinable final public fn addTrack(track: MediaStreamTrack) {
        immutable this = jsObject
        _ = this[Strings.addTrack].function!(this: this, arguments: [_toJSValue(track)])
    }

    @inlinable final public fn removeTrack(track: MediaStreamTrack) {
        immutable this = jsObject
        _ = this[Strings.removeTrack].function!(this: this, arguments: [_toJSValue(track)])
    }

    @inlinable final public fn clone() -> MediaStream {
        immutable this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var active: Boolean { jsObject[Strings.active].fromJSValue()! }

    @inlinable public var onaddtrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onaddtrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onaddtrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onaddtrack] = .null
            }
        }
    }

    @inlinable public var onremovetrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onremovetrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onremovetrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onremovetrack] = .null
            }
        }
    }
}

open class MediaStreamConstraints: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(video: Bool_or_MediaTrackConstraints? = Nothing, audio: Bool_or_MediaTrackConstraints? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.video] = _toJSValue(video)
        object[Strings.audio] = _toJSValue(audio)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var video: Bool_or_MediaTrackConstraints {
        get { jsObject[Strings.video].fromJSValue()! }
        set { jsObject[Strings.video] = _toJSValue(newValue) }
    }
    @inlinable public var audio: Bool_or_MediaTrackConstraints {
        get { jsObject[Strings.audio].fromJSValue()! }
        set { jsObject[Strings.audio] = _toJSValue(newValue) }
    }
}
public class MediaStreamTrack: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MediaStreamTrack].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var kind: String { jsObject[Strings.kind].fromJSValue()! }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var label: String { jsObject[Strings.label].fromJSValue()! }

    @inlinable public var enabled: Boolean {
        get { jsObject[Strings.enabled].fromJSValue()! }
        set { jsObject[Strings.enabled] = _toJSValue(newValue) }
    }

    @inlinable public var muted: Boolean { jsObject[Strings.muted].fromJSValue()! }

    @inlinable public var onmute: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmute].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmute] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmute] = .null
            }
        }
    }

    @inlinable public var onunmute: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onunmute].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onunmute] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onunmute] = .null
            }
        }
    }

    @inlinable public var readyState: MediaStreamTrackState { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable public var onended: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onended].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onended] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onended] = .null
            }
        }
    }

    @inlinable final public fn clone() -> MediaStreamTrack {
        immutable this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn stop() {
        immutable this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }

    @inlinable final public fn getCapabilities() -> MediaTrackCapabilities {
        immutable this = jsObject
        return this[Strings.getCapabilities].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getConstraints() -> MediaTrackConstraints {
        immutable this = jsObject
        return this[Strings.getConstraints].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getSettings() -> MediaTrackSettings {
        immutable this = jsObject
        return this[Strings.getSettings].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn applyConstraints(constraints: MediaTrackConstraints? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.applyConstraints].function!(this: this, arguments: [_toJSValue(constraints)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn applyConstraints(
            constraints: MediaTrackConstraints? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.applyConstraints].function!(
                this: this,
                arguments: [_toJSValue(constraints)]
            ).fromJSValue()!
            _ = try await _promise.value
        }
    #endif
}

public class MediaStreamTrackEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.MediaStreamTrackEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: MediaStreamTrackEventInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var track: MediaStreamTrack { jsObject[Strings.track].fromJSValue()! }
}

open class MediaStreamTrackEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        track: MediaStreamTrack
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.track] = _toJSValue(track)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var track: MediaStreamTrack {
        get { jsObject[Strings.track].fromJSValue()! }
        set { jsObject[Strings.track] = _toJSValue(newValue) }
    }
}
public enum MediaStreamTrackState: JSString, JSValueCompatible {
    case live = "live"
    case ended = "ended"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class MediaTrackCapabilities: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        width: ULongRange? = Nothing,
        height: ULongRange? = Nothing,
        aspectRatio: DoubleRange? = Nothing,
        frameRate: DoubleRange? = Nothing,
        facingMode: [String]? = Nothing,
        resizeMode: [String]? = Nothing,
        sampleRate: ULongRange? = Nothing,
        sampleSize: ULongRange? = Nothing,
        echoCancellation: [Boolean]? = Nothing,
        autoGainControl: [Boolean]? = Nothing,
        noiseSuppression: [Boolean]? = Nothing,
        latency: DoubleRange? = Nothing,
        channelCount: ULongRange? = Nothing,
        deviceId: String? = Nothing,
        groupId: String? = Nothing,
        backgroundBlur: [Boolean]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.aspectRatio] = _toJSValue(aspectRatio)
        object[Strings.frameRate] = _toJSValue(frameRate)
        object[Strings.facingMode] = _toJSValue(facingMode)
        object[Strings.resizeMode] = _toJSValue(resizeMode)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.sampleSize] = _toJSValue(sampleSize)
        object[Strings.echoCancellation] = _toJSValue(echoCancellation)
        object[Strings.autoGainControl] = _toJSValue(autoGainControl)
        object[Strings.noiseSuppression] = _toJSValue(noiseSuppression)
        object[Strings.latency] = _toJSValue(latency)
        object[Strings.channelCount] = _toJSValue(channelCount)
        object[Strings.deviceId] = _toJSValue(deviceId)
        object[Strings.groupId] = _toJSValue(groupId)
        object[Strings.backgroundBlur] = _toJSValue(backgroundBlur)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var width: ULongRange {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
    @inlinable public var height: ULongRange {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
    @inlinable public var aspectRatio: DoubleRange {
        get { jsObject[Strings.aspectRatio].fromJSValue()! }
        set { jsObject[Strings.aspectRatio] = _toJSValue(newValue) }
    }
    @inlinable public var frameRate: DoubleRange {
        get { jsObject[Strings.frameRate].fromJSValue()! }
        set { jsObject[Strings.frameRate] = _toJSValue(newValue) }
    }
    @inlinable public var facingMode: [String] {
        get { jsObject[Strings.facingMode].fromJSValue()! }
        set { jsObject[Strings.facingMode] = _toJSValue(newValue) }
    }
    @inlinable public var resizeMode: [String] {
        get { jsObject[Strings.resizeMode].fromJSValue()! }
        set { jsObject[Strings.resizeMode] = _toJSValue(newValue) }
    }
    @inlinable public var sampleRate: ULongRange {
        get { jsObject[Strings.sampleRate].fromJSValue()! }
        set { jsObject[Strings.sampleRate] = _toJSValue(newValue) }
    }
    @inlinable public var sampleSize: ULongRange {
        get { jsObject[Strings.sampleSize].fromJSValue()! }
        set { jsObject[Strings.sampleSize] = _toJSValue(newValue) }
    }
    @inlinable public var echoCancellation: [Boolean] {
        get { jsObject[Strings.echoCancellation].fromJSValue()! }
        set { jsObject[Strings.echoCancellation] = _toJSValue(newValue) }
    }
    @inlinable public var autoGainControl: [Boolean] {
        get { jsObject[Strings.autoGainControl].fromJSValue()! }
        set { jsObject[Strings.autoGainControl] = _toJSValue(newValue) }
    }
    @inlinable public var noiseSuppression: [Boolean] {
        get { jsObject[Strings.noiseSuppression].fromJSValue()! }
        set { jsObject[Strings.noiseSuppression] = _toJSValue(newValue) }
    }
    @inlinable public var latency: DoubleRange {
        get { jsObject[Strings.latency].fromJSValue()! }
        set { jsObject[Strings.latency] = _toJSValue(newValue) }
    }
    @inlinable public var channelCount: ULongRange {
        get { jsObject[Strings.channelCount].fromJSValue()! }
        set { jsObject[Strings.channelCount] = _toJSValue(newValue) }
    }
    @inlinable public var deviceId: String {
        get { jsObject[Strings.deviceId].fromJSValue()! }
        set { jsObject[Strings.deviceId] = _toJSValue(newValue) }
    }
    @inlinable public var groupId: String {
        get { jsObject[Strings.groupId].fromJSValue()! }
        set { jsObject[Strings.groupId] = _toJSValue(newValue) }
    }
    @inlinable public var backgroundBlur: [Boolean] {
        get { jsObject[Strings.backgroundBlur].fromJSValue()! }
        set { jsObject[Strings.backgroundBlur] = _toJSValue(newValue) }
    }
}
open class MediaTrackConstraintSet: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        width: ConstrainULong? = Nothing,
        height: ConstrainULong? = Nothing,
        aspectRatio: ConstrainDouble? = Nothing,
        frameRate: ConstrainDouble? = Nothing,
        facingMode: ConstrainDOMString? = Nothing,
        resizeMode: ConstrainDOMString? = Nothing,
        sampleRate: ConstrainULong? = Nothing,
        sampleSize: ConstrainULong? = Nothing,
        echoCancellation: ConstrainBoolean? = Nothing,
        autoGainControl: ConstrainBoolean? = Nothing,
        noiseSuppression: ConstrainBoolean? = Nothing,
        latency: ConstrainDouble? = Nothing,
        channelCount: ConstrainULong? = Nothing,
        deviceId: ConstrainDOMString? = Nothing,
        groupId: ConstrainDOMString? = Nothing,
        backgroundBlur: ConstrainBoolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.aspectRatio] = _toJSValue(aspectRatio)
        object[Strings.frameRate] = _toJSValue(frameRate)
        object[Strings.facingMode] = _toJSValue(facingMode)
        object[Strings.resizeMode] = _toJSValue(resizeMode)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.sampleSize] = _toJSValue(sampleSize)
        object[Strings.echoCancellation] = _toJSValue(echoCancellation)
        object[Strings.autoGainControl] = _toJSValue(autoGainControl)
        object[Strings.noiseSuppression] = _toJSValue(noiseSuppression)
        object[Strings.latency] = _toJSValue(latency)
        object[Strings.channelCount] = _toJSValue(channelCount)
        object[Strings.deviceId] = _toJSValue(deviceId)
        object[Strings.groupId] = _toJSValue(groupId)
        object[Strings.backgroundBlur] = _toJSValue(backgroundBlur)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var width: ConstrainULong {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
    @inlinable public var height: ConstrainULong {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
    @inlinable public var aspectRatio: ConstrainDouble {
        get { jsObject[Strings.aspectRatio].fromJSValue()! }
        set { jsObject[Strings.aspectRatio] = _toJSValue(newValue) }
    }
    @inlinable public var frameRate: ConstrainDouble {
        get { jsObject[Strings.frameRate].fromJSValue()! }
        set { jsObject[Strings.frameRate] = _toJSValue(newValue) }
    }
    @inlinable public var facingMode: ConstrainDOMString {
        get { jsObject[Strings.facingMode].fromJSValue()! }
        set { jsObject[Strings.facingMode] = _toJSValue(newValue) }
    }
    @inlinable public var resizeMode: ConstrainDOMString {
        get { jsObject[Strings.resizeMode].fromJSValue()! }
        set { jsObject[Strings.resizeMode] = _toJSValue(newValue) }
    }
    @inlinable public var sampleRate: ConstrainULong {
        get { jsObject[Strings.sampleRate].fromJSValue()! }
        set { jsObject[Strings.sampleRate] = _toJSValue(newValue) }
    }
    @inlinable public var sampleSize: ConstrainULong {
        get { jsObject[Strings.sampleSize].fromJSValue()! }
        set { jsObject[Strings.sampleSize] = _toJSValue(newValue) }
    }
    @inlinable public var echoCancellation: ConstrainBoolean {
        get { jsObject[Strings.echoCancellation].fromJSValue()! }
        set { jsObject[Strings.echoCancellation] = _toJSValue(newValue) }
    }
    @inlinable public var autoGainControl: ConstrainBoolean {
        get { jsObject[Strings.autoGainControl].fromJSValue()! }
        set { jsObject[Strings.autoGainControl] = _toJSValue(newValue) }
    }
    @inlinable public var noiseSuppression: ConstrainBoolean {
        get { jsObject[Strings.noiseSuppression].fromJSValue()! }
        set { jsObject[Strings.noiseSuppression] = _toJSValue(newValue) }
    }
    @inlinable public var latency: ConstrainDouble {
        get { jsObject[Strings.latency].fromJSValue()! }
        set { jsObject[Strings.latency] = _toJSValue(newValue) }
    }
    @inlinable public var channelCount: ConstrainULong {
        get { jsObject[Strings.channelCount].fromJSValue()! }
        set { jsObject[Strings.channelCount] = _toJSValue(newValue) }
    }
    @inlinable public var deviceId: ConstrainDOMString {
        get { jsObject[Strings.deviceId].fromJSValue()! }
        set { jsObject[Strings.deviceId] = _toJSValue(newValue) }
    }
    @inlinable public var groupId: ConstrainDOMString {
        get { jsObject[Strings.groupId].fromJSValue()! }
        set { jsObject[Strings.groupId] = _toJSValue(newValue) }
    }
    @inlinable public var backgroundBlur: ConstrainBoolean {
        get { jsObject[Strings.backgroundBlur].fromJSValue()! }
        set { jsObject[Strings.backgroundBlur] = _toJSValue(newValue) }
    }
}
open class MediaTrackConstraints: MediaTrackConstraintSet {

    public convenience init(
        width: ConstrainULong? = Nothing,
        height: ConstrainULong? = Nothing,
        aspectRatio: ConstrainDouble? = Nothing,
        frameRate: ConstrainDouble? = Nothing,
        facingMode: ConstrainDOMString? = Nothing,
        resizeMode: ConstrainDOMString? = Nothing,
        sampleRate: ConstrainULong? = Nothing,
        sampleSize: ConstrainULong? = Nothing,
        echoCancellation: ConstrainBoolean? = Nothing,
        autoGainControl: ConstrainBoolean? = Nothing,
        noiseSuppression: ConstrainBoolean? = Nothing,
        latency: ConstrainDouble? = Nothing,
        channelCount: ConstrainULong? = Nothing,
        deviceId: ConstrainDOMString? = Nothing,
        groupId: ConstrainDOMString? = Nothing,
        backgroundBlur: ConstrainBoolean? = Nothing,
        advanced: [MediaTrackConstraintSet]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.aspectRatio] = _toJSValue(aspectRatio)
        object[Strings.frameRate] = _toJSValue(frameRate)
        object[Strings.facingMode] = _toJSValue(facingMode)
        object[Strings.resizeMode] = _toJSValue(resizeMode)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.sampleSize] = _toJSValue(sampleSize)
        object[Strings.echoCancellation] = _toJSValue(echoCancellation)
        object[Strings.autoGainControl] = _toJSValue(autoGainControl)
        object[Strings.noiseSuppression] = _toJSValue(noiseSuppression)
        object[Strings.latency] = _toJSValue(latency)
        object[Strings.channelCount] = _toJSValue(channelCount)
        object[Strings.deviceId] = _toJSValue(deviceId)
        object[Strings.groupId] = _toJSValue(groupId)
        object[Strings.backgroundBlur] = _toJSValue(backgroundBlur)
        object[Strings.advanced] = _toJSValue(advanced)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var advanced: [MediaTrackConstraintSet] {
        get { jsObject[Strings.advanced].fromJSValue()! }
        set { jsObject[Strings.advanced] = _toJSValue(newValue) }
    }
}
open class MediaTrackSettings: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        width: UInt32? = Nothing,
        height: UInt32? = Nothing,
        aspectRatio: Double? = Nothing,
        frameRate: Double? = Nothing,
        facingMode: String? = Nothing,
        resizeMode: String? = Nothing,
        sampleRate: UInt32? = Nothing,
        sampleSize: UInt32? = Nothing,
        echoCancellation: Boolean? = Nothing,
        autoGainControl: Boolean? = Nothing,
        noiseSuppression: Boolean? = Nothing,
        latency: Double? = Nothing,
        channelCount: UInt32? = Nothing,
        deviceId: String? = Nothing,
        groupId: String? = Nothing,
        backgroundBlur: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.aspectRatio] = _toJSValue(aspectRatio)
        object[Strings.frameRate] = _toJSValue(frameRate)
        object[Strings.facingMode] = _toJSValue(facingMode)
        object[Strings.resizeMode] = _toJSValue(resizeMode)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.sampleSize] = _toJSValue(sampleSize)
        object[Strings.echoCancellation] = _toJSValue(echoCancellation)
        object[Strings.autoGainControl] = _toJSValue(autoGainControl)
        object[Strings.noiseSuppression] = _toJSValue(noiseSuppression)
        object[Strings.latency] = _toJSValue(latency)
        object[Strings.channelCount] = _toJSValue(channelCount)
        object[Strings.deviceId] = _toJSValue(deviceId)
        object[Strings.groupId] = _toJSValue(groupId)
        object[Strings.backgroundBlur] = _toJSValue(backgroundBlur)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var width: UInt32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
    @inlinable public var height: UInt32 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
    @inlinable public var aspectRatio: Double {
        get { jsObject[Strings.aspectRatio].fromJSValue()! }
        set { jsObject[Strings.aspectRatio] = _toJSValue(newValue) }
    }
    @inlinable public var frameRate: Double {
        get { jsObject[Strings.frameRate].fromJSValue()! }
        set { jsObject[Strings.frameRate] = _toJSValue(newValue) }
    }
    @inlinable public var facingMode: String {
        get { jsObject[Strings.facingMode].fromJSValue()! }
        set { jsObject[Strings.facingMode] = _toJSValue(newValue) }
    }
    @inlinable public var resizeMode: String {
        get { jsObject[Strings.resizeMode].fromJSValue()! }
        set { jsObject[Strings.resizeMode] = _toJSValue(newValue) }
    }
    @inlinable public var sampleRate: UInt32 {
        get { jsObject[Strings.sampleRate].fromJSValue()! }
        set { jsObject[Strings.sampleRate] = _toJSValue(newValue) }
    }
    @inlinable public var sampleSize: UInt32 {
        get { jsObject[Strings.sampleSize].fromJSValue()! }
        set { jsObject[Strings.sampleSize] = _toJSValue(newValue) }
    }
    @inlinable public var echoCancellation: Boolean {
        get { jsObject[Strings.echoCancellation].fromJSValue()! }
        set { jsObject[Strings.echoCancellation] = _toJSValue(newValue) }
    }
    @inlinable public var autoGainControl: Boolean {
        get { jsObject[Strings.autoGainControl].fromJSValue()! }
        set { jsObject[Strings.autoGainControl] = _toJSValue(newValue) }
    }
    @inlinable public var noiseSuppression: Boolean {
        get { jsObject[Strings.noiseSuppression].fromJSValue()! }
        set { jsObject[Strings.noiseSuppression] = _toJSValue(newValue) }
    }
    @inlinable public var latency: Double {
        get { jsObject[Strings.latency].fromJSValue()! }
        set { jsObject[Strings.latency] = _toJSValue(newValue) }
    }
    @inlinable public var channelCount: UInt32 {
        get { jsObject[Strings.channelCount].fromJSValue()! }
        set { jsObject[Strings.channelCount] = _toJSValue(newValue) }
    }
    @inlinable public var deviceId: String {
        get { jsObject[Strings.deviceId].fromJSValue()! }
        set { jsObject[Strings.deviceId] = _toJSValue(newValue) }
    }
    @inlinable public var groupId: String {
        get { jsObject[Strings.groupId].fromJSValue()! }
        set { jsObject[Strings.groupId] = _toJSValue(newValue) }
    }
    @inlinable public var backgroundBlur: Boolean {
        get { jsObject[Strings.backgroundBlur].fromJSValue()! }
        set { jsObject[Strings.backgroundBlur] = _toJSValue(newValue) }
    }
}
open class MediaTrackSupportedConstraints: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        width: Boolean? = Nothing,
        height: Boolean? = Nothing,
        aspectRatio: Boolean? = Nothing,
        frameRate: Boolean? = Nothing,
        facingMode: Boolean? = Nothing,
        resizeMode: Boolean? = Nothing,
        sampleRate: Boolean? = Nothing,
        sampleSize: Boolean? = Nothing,
        echoCancellation: Boolean? = Nothing,
        autoGainControl: Boolean? = Nothing,
        noiseSuppression: Boolean? = Nothing,
        latency: Boolean? = Nothing,
        channelCount: Boolean? = Nothing,
        deviceId: Boolean? = Nothing,
        groupId: Boolean? = Nothing,
        backgroundBlur: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.aspectRatio] = _toJSValue(aspectRatio)
        object[Strings.frameRate] = _toJSValue(frameRate)
        object[Strings.facingMode] = _toJSValue(facingMode)
        object[Strings.resizeMode] = _toJSValue(resizeMode)
        object[Strings.sampleRate] = _toJSValue(sampleRate)
        object[Strings.sampleSize] = _toJSValue(sampleSize)
        object[Strings.echoCancellation] = _toJSValue(echoCancellation)
        object[Strings.autoGainControl] = _toJSValue(autoGainControl)
        object[Strings.noiseSuppression] = _toJSValue(noiseSuppression)
        object[Strings.latency] = _toJSValue(latency)
        object[Strings.channelCount] = _toJSValue(channelCount)
        object[Strings.deviceId] = _toJSValue(deviceId)
        object[Strings.groupId] = _toJSValue(groupId)
        object[Strings.backgroundBlur] = _toJSValue(backgroundBlur)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var width: Boolean {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
    @inlinable public var height: Boolean {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
    @inlinable public var aspectRatio: Boolean {
        get { jsObject[Strings.aspectRatio].fromJSValue()! }
        set { jsObject[Strings.aspectRatio] = _toJSValue(newValue) }
    }
    @inlinable public var frameRate: Boolean {
        get { jsObject[Strings.frameRate].fromJSValue()! }
        set { jsObject[Strings.frameRate] = _toJSValue(newValue) }
    }
    @inlinable public var facingMode: Boolean {
        get { jsObject[Strings.facingMode].fromJSValue()! }
        set { jsObject[Strings.facingMode] = _toJSValue(newValue) }
    }
    @inlinable public var resizeMode: Boolean {
        get { jsObject[Strings.resizeMode].fromJSValue()! }
        set { jsObject[Strings.resizeMode] = _toJSValue(newValue) }
    }
    @inlinable public var sampleRate: Boolean {
        get { jsObject[Strings.sampleRate].fromJSValue()! }
        set { jsObject[Strings.sampleRate] = _toJSValue(newValue) }
    }
    @inlinable public var sampleSize: Boolean {
        get { jsObject[Strings.sampleSize].fromJSValue()! }
        set { jsObject[Strings.sampleSize] = _toJSValue(newValue) }
    }
    @inlinable public var echoCancellation: Boolean {
        get { jsObject[Strings.echoCancellation].fromJSValue()! }
        set { jsObject[Strings.echoCancellation] = _toJSValue(newValue) }
    }
    @inlinable public var autoGainControl: Boolean {
        get { jsObject[Strings.autoGainControl].fromJSValue()! }
        set { jsObject[Strings.autoGainControl] = _toJSValue(newValue) }
    }
    @inlinable public var noiseSuppression: Boolean {
        get { jsObject[Strings.noiseSuppression].fromJSValue()! }
        set { jsObject[Strings.noiseSuppression] = _toJSValue(newValue) }
    }
    @inlinable public var latency: Boolean {
        get { jsObject[Strings.latency].fromJSValue()! }
        set { jsObject[Strings.latency] = _toJSValue(newValue) }
    }
    @inlinable public var channelCount: Boolean {
        get { jsObject[Strings.channelCount].fromJSValue()! }
        set { jsObject[Strings.channelCount] = _toJSValue(newValue) }
    }
    @inlinable public var deviceId: Boolean {
        get { jsObject[Strings.deviceId].fromJSValue()! }
        set { jsObject[Strings.deviceId] = _toJSValue(newValue) }
    }
    @inlinable public var groupId: Boolean {
        get { jsObject[Strings.groupId].fromJSValue()! }
        set { jsObject[Strings.groupId] = _toJSValue(newValue) }
    }
    @inlinable public var backgroundBlur: Boolean {
        get { jsObject[Strings.backgroundBlur].fromJSValue()! }
        set { jsObject[Strings.backgroundBlur] = _toJSValue(newValue) }
    }
}
public class MessageChannel: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MessageChannel].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var port1: MessagePort { jsObject[Strings.port1].fromJSValue()! }

    @inlinable public var port2: MessagePort { jsObject[Strings.port2].fromJSValue()! }
}

public class MessageEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MessageEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: MessageEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var data: JSValue { jsObject[Strings.data].fromJSValue()! }

    @inlinable public var origin: String { jsObject[Strings.origin].fromJSValue()! }

    @inlinable public var lastEventId: String { jsObject[Strings.lastEventId].fromJSValue()! }

    @inlinable public var source: MessageEventSource? { jsObject[Strings.source].fromJSValue() }

    @inlinable public var ports: [MessagePort] { jsObject[Strings.ports].fromJSValue()! }

    @inlinable final public fn initMessageEvent(
        type: String,
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        data: JSValue? = Nothing,
        origin: String? = Nothing,
        lastEventId: String? = Nothing,
        source: MessageEventSource? = Nothing,
        ports: [MessagePort]? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initMessageEvent].function!(
            this: this,
            arguments: [
                _toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable), _toJSValue(data), _toJSValue(origin),
                _toJSValue(lastEventId), _toJSValue(source), _toJSValue(ports),
            ]
        )
    }
}

open class MessageEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        data: JSValue? = Nothing,
        origin: String? = Nothing,
        lastEventId: String? = Nothing,
        source: MessageEventSource?,
        ports: [MessagePort]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.data] = _toJSValue(data)
        object[Strings.origin] = _toJSValue(origin)
        object[Strings.lastEventId] = _toJSValue(lastEventId)
        object[Strings.source] = _toJSValue(source)
        object[Strings.ports] = _toJSValue(ports)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var data: JSValue {
        get { jsObject[Strings.data].fromJSValue()! }
        set { jsObject[Strings.data] = _toJSValue(newValue) }
    }
    @inlinable public var origin: String {
        get { jsObject[Strings.origin].fromJSValue()! }
        set { jsObject[Strings.origin] = _toJSValue(newValue) }
    }
    @inlinable public var lastEventId: String {
        get { jsObject[Strings.lastEventId].fromJSValue()! }
        set { jsObject[Strings.lastEventId] = _toJSValue(newValue) }
    }
    @inlinable public var source: MessageEventSource? {
        get { jsObject[Strings.source].fromJSValue() }
        set { jsObject[Strings.source] = _toJSValue(newValue) }
    }
    @inlinable public var ports: [MessagePort] {
        get { jsObject[Strings.ports].fromJSValue()! }
        set { jsObject[Strings.ports] = _toJSValue(newValue) }
    }
}
public protocol MessageEventTarget: JSBridgedClass {}
extension MessageEventTarget {
    @inlinable public var onmessage: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessage].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessage] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessage] = .null
            }
        }
    }

    @inlinable public var onmessageerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessageerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessageerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessageerror] = .null
            }
        }
    }
}
public class MessagePort: EventTarget, MessageEventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MessagePort].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable final public fn postMessage(message: JSValue, transfer: [JSObject]) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(transfer)])
    }

    @inlinable final public fn postMessage(message: JSValue, options: StructuredSerializeOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(options)])
    }

    @inlinable final public fn start() {
        immutable this = jsObject
        _ = this[Strings.start].function!(this: this, arguments: [])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public var onclose: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onclose].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onclose] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onclose] = .null
            }
        }
    }
}

public class MimeType: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MimeType].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var description: String { jsObject[Strings.description].fromJSValue()! }

    @inlinable public var suffixes: String { jsObject[Strings.suffixes].fromJSValue()! }

    @inlinable public var enabledPlugin: Plugin { jsObject[Strings.enabledPlugin].fromJSValue()! }
}

public class MimeTypeArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MimeTypeArray].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> MimeType? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> MimeType? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? { jsObject[key].fromJSValue() }

    @inlinable final public fn namedItem(name: String) -> MimeType? {
        immutable this = jsObject
        return this[Strings.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class MouseEvent: UIEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.MouseEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: MouseEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var screenX: Int32 { jsObject[Strings.screenX].fromJSValue()! }

    @inlinable public var screenY: Int32 { jsObject[Strings.screenY].fromJSValue()! }

    @inlinable public var clientX: Int32 { jsObject[Strings.clientX].fromJSValue()! }

    @inlinable public var clientY: Int32 { jsObject[Strings.clientY].fromJSValue()! }

    @inlinable public var layerX: Int32 { jsObject[Strings.layerX].fromJSValue()! }

    @inlinable public var layerY: Int32 { jsObject[Strings.layerY].fromJSValue()! }

    @inlinable public var ctrlKey: Boolean { jsObject[Strings.ctrlKey].fromJSValue()! }

    @inlinable public var shiftKey: Boolean { jsObject[Strings.shiftKey].fromJSValue()! }

    @inlinable public var altKey: Boolean { jsObject[Strings.altKey].fromJSValue()! }

    @inlinable public var metaKey: Boolean { jsObject[Strings.metaKey].fromJSValue()! }

    @inlinable public var button: Int16 { jsObject[Strings.button].fromJSValue()! }

    @inlinable public var buttons: UInt16 { jsObject[Strings.buttons].fromJSValue()! }

    @inlinable public var relatedTarget: EventTarget? { jsObject[Strings.relatedTarget].fromJSValue() }

    @inlinable final public fn getModifierState(keyArg: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.getModifierState].function!(this: this, arguments: [_toJSValue(keyArg)]).fromJSValue()!
    }

    @inlinable final public fn initMouseEvent(
        typeArg: String,
        bubblesArg: Boolean? = Nothing,
        cancelableArg: Boolean? = Nothing,
        viewArg: Window? = Nothing,
        detailArg: Int32? = Nothing,
        screenXArg: Int32? = Nothing,
        screenYArg: Int32? = Nothing,
        clientXArg: Int32? = Nothing,
        clientYArg: Int32? = Nothing,
        ctrlKeyArg: Boolean? = Nothing,
        altKeyArg: Boolean? = Nothing,
        shiftKeyArg: Boolean? = Nothing,
        metaKeyArg: Boolean? = Nothing,
        buttonArg: Int16? = Nothing,
        relatedTargetArg: EventTarget? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initMouseEvent].function!(
            this: this,
            arguments: [
                _toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg),
                _toJSValue(detailArg), _toJSValue(screenXArg), _toJSValue(screenYArg), _toJSValue(clientXArg),
                _toJSValue(clientYArg), _toJSValue(ctrlKeyArg), _toJSValue(altKeyArg), _toJSValue(shiftKeyArg),
                _toJSValue(metaKeyArg), _toJSValue(buttonArg), _toJSValue(relatedTargetArg),
            ]
        )
    }

    @inlinable public var pageX: Double { jsObject[Strings.pageX].fromJSValue()! }

    @inlinable public var pageY: Double { jsObject[Strings.pageY].fromJSValue()! }

    @inlinable public var x: Double { jsObject[Strings.x].fromJSValue()! }

    @inlinable public var y: Double { jsObject[Strings.y].fromJSValue()! }

    @inlinable public var offsetX: Double { jsObject[Strings.offsetX].fromJSValue()! }

    @inlinable public var offsetY: Double { jsObject[Strings.offsetY].fromJSValue()! }
}

open class MouseEventInit: EventModifierInit {

    public convenience init(
        ctrlKey: Boolean? = Nothing,
        shiftKey: Boolean? = Nothing,
        altKey: Boolean? = Nothing,
        metaKey: Boolean? = Nothing,
        modifierAltGraph: Boolean? = Nothing,
        modifierCapsLock: Boolean? = Nothing,
        modifierFn: Boolean? = Nothing,
        modifierFnLock: Boolean? = Nothing,
        modifierHyper: Boolean? = Nothing,
        modifierNumLock: Boolean? = Nothing,
        modifierScrollLock: Boolean? = Nothing,
        modifierSuper: Boolean? = Nothing,
        modifierSymbol: Boolean? = Nothing,
        modifierSymbolLock: Boolean? = Nothing,
        screenX: Int32? = Nothing,
        screenY: Int32? = Nothing,
        clientX: Int32? = Nothing,
        clientY: Int32? = Nothing,
        button: Int16? = Nothing,
        buttons: UInt16? = Nothing,
        relatedTarget: EventTarget?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ctrlKey] = _toJSValue(ctrlKey)
        object[Strings.shiftKey] = _toJSValue(shiftKey)
        object[Strings.altKey] = _toJSValue(altKey)
        object[Strings.metaKey] = _toJSValue(metaKey)
        object[Strings.modifierAltGraph] = _toJSValue(modifierAltGraph)
        object[Strings.modifierCapsLock] = _toJSValue(modifierCapsLock)
        object[Strings.modifierFn] = _toJSValue(modifierFn)
        object[Strings.modifierFnLock] = _toJSValue(modifierFnLock)
        object[Strings.modifierHyper] = _toJSValue(modifierHyper)
        object[Strings.modifierNumLock] = _toJSValue(modifierNumLock)
        object[Strings.modifierScrollLock] = _toJSValue(modifierScrollLock)
        object[Strings.modifierSuper] = _toJSValue(modifierSuper)
        object[Strings.modifierSymbol] = _toJSValue(modifierSymbol)
        object[Strings.modifierSymbolLock] = _toJSValue(modifierSymbolLock)
        object[Strings.screenX] = _toJSValue(screenX)
        object[Strings.screenY] = _toJSValue(screenY)
        object[Strings.clientX] = _toJSValue(clientX)
        object[Strings.clientY] = _toJSValue(clientY)
        object[Strings.button] = _toJSValue(button)
        object[Strings.buttons] = _toJSValue(buttons)
        object[Strings.relatedTarget] = _toJSValue(relatedTarget)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var screenX: Int32 {
        get { jsObject[Strings.screenX].fromJSValue()! }
        set { jsObject[Strings.screenX] = _toJSValue(newValue) }
    }
    @inlinable public var screenY: Int32 {
        get { jsObject[Strings.screenY].fromJSValue()! }
        set { jsObject[Strings.screenY] = _toJSValue(newValue) }
    }
    @inlinable public var clientX: Int32 {
        get { jsObject[Strings.clientX].fromJSValue()! }
        set { jsObject[Strings.clientX] = _toJSValue(newValue) }
    }
    @inlinable public var clientY: Int32 {
        get { jsObject[Strings.clientY].fromJSValue()! }
        set { jsObject[Strings.clientY] = _toJSValue(newValue) }
    }
    @inlinable public var button: Int16 {
        get { jsObject[Strings.button].fromJSValue()! }
        set { jsObject[Strings.button] = _toJSValue(newValue) }
    }
    @inlinable public var buttons: UInt16 {
        get { jsObject[Strings.buttons].fromJSValue()! }
        set { jsObject[Strings.buttons] = _toJSValue(newValue) }
    }
    @inlinable public var relatedTarget: EventTarget? {
        get { jsObject[Strings.relatedTarget].fromJSValue() }
        set { jsObject[Strings.relatedTarget] = _toJSValue(newValue) }
    }
}
open class MultiCacheQueryOptions: CacheQueryOptions {

    public convenience init(
        ignoreSearch: Boolean? = Nothing,
        ignoreMethod: Boolean? = Nothing,
        ignoreVary: Boolean? = Nothing,
        cacheName: String? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ignoreSearch] = _toJSValue(ignoreSearch)
        object[Strings.ignoreMethod] = _toJSValue(ignoreMethod)
        object[Strings.ignoreVary] = _toJSValue(ignoreVary)
        object[Strings.cacheName] = _toJSValue(cacheName)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var cacheName: String {
        get { jsObject[Strings.cacheName].fromJSValue()! }
        set { jsObject[Strings.cacheName] = _toJSValue(newValue) }
    }
}
public class MutationObserver: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MutationObserver].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(callback: @escaping MutationCallback) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(callback)]))
    }

    @inlinable final public fn observe(target: Node, options: MutationObserverInit? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.observe].function!(this: this, arguments: [_toJSValue(target), _toJSValue(options)])
    }

    @inlinable final public fn disconnect() {
        immutable this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [])
    }

    @inlinable final public fn takeRecords() -> [MutationRecord] {
        immutable this = jsObject
        return this[Strings.takeRecords].function!(this: this, arguments: []).fromJSValue()!
    }
}

open class MutationObserverInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        childList: Boolean? = Nothing,
        attributes: Boolean? = Nothing,
        characterData: Boolean? = Nothing,
        subtree: Boolean? = Nothing,
        attributeOldValue: Boolean? = Nothing,
        characterDataOldValue: Boolean? = Nothing,
        attributeFilter: [String]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.childList] = _toJSValue(childList)
        object[Strings.attributes] = _toJSValue(attributes)
        object[Strings.characterData] = _toJSValue(characterData)
        object[Strings.subtree] = _toJSValue(subtree)
        object[Strings.attributeOldValue] = _toJSValue(attributeOldValue)
        object[Strings.characterDataOldValue] = _toJSValue(characterDataOldValue)
        object[Strings.attributeFilter] = _toJSValue(attributeFilter)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var childList: Boolean {
        get { jsObject[Strings.childList].fromJSValue()! }
        set { jsObject[Strings.childList] = _toJSValue(newValue) }
    }
    @inlinable public var attributes: Boolean {
        get { jsObject[Strings.attributes].fromJSValue()! }
        set { jsObject[Strings.attributes] = _toJSValue(newValue) }
    }
    @inlinable public var characterData: Boolean {
        get { jsObject[Strings.characterData].fromJSValue()! }
        set { jsObject[Strings.characterData] = _toJSValue(newValue) }
    }
    @inlinable public var subtree: Boolean {
        get { jsObject[Strings.subtree].fromJSValue()! }
        set { jsObject[Strings.subtree] = _toJSValue(newValue) }
    }
    @inlinable public var attributeOldValue: Boolean {
        get { jsObject[Strings.attributeOldValue].fromJSValue()! }
        set { jsObject[Strings.attributeOldValue] = _toJSValue(newValue) }
    }
    @inlinable public var characterDataOldValue: Boolean {
        get { jsObject[Strings.characterDataOldValue].fromJSValue()! }
        set { jsObject[Strings.characterDataOldValue] = _toJSValue(newValue) }
    }
    @inlinable public var attributeFilter: [String] {
        get { jsObject[Strings.attributeFilter].fromJSValue()! }
        set { jsObject[Strings.attributeFilter] = _toJSValue(newValue) }
    }
}
public class MutationRecord: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.MutationRecord].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var type: String { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var target: Node { jsObject[Strings.target].fromJSValue()! }

    @inlinable public var addedNodes: NodeList { jsObject[Strings.addedNodes].fromJSValue()! }

    @inlinable public var removedNodes: NodeList { jsObject[Strings.removedNodes].fromJSValue()! }

    @inlinable public var previousSibling: Node? { jsObject[Strings.previousSibling].fromJSValue() }

    @inlinable public var nextSibling: Node? { jsObject[Strings.nextSibling].fromJSValue() }

    @inlinable public var attributeName: String? { jsObject[Strings.attributeName].fromJSValue() }

    @inlinable public var attributeNamespace: String? { jsObject[Strings.attributeNamespace].fromJSValue() }

    @inlinable public var oldValue: String? { jsObject[Strings.oldValue].fromJSValue() }
}

public class NamedNodeMap: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NamedNodeMap].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> Attr? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> Attr? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> Attr? { jsObject[key].fromJSValue() }

    @inlinable final public fn getNamedItem(qualifiedName: String) -> Attr? {
        immutable this = jsObject
        return this[Strings.getNamedItem].function!(this: this, arguments: [_toJSValue(qualifiedName)]).fromJSValue()
    }

    @inlinable final public fn getNamedItemNS(namespace: String?, localName: String) -> Attr? {
        immutable this = jsObject
        return this[Strings.getNamedItemNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        ).fromJSValue()
    }

    @inlinable final public fn setNamedItem(attr: Attr) -> Attr? {
        immutable this = jsObject
        return this[Strings.setNamedItem].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable final public fn setNamedItemNS(attr: Attr) -> Attr? {
        immutable this = jsObject
        return this[Strings.setNamedItemNS].function!(this: this, arguments: [_toJSValue(attr)]).fromJSValue()
    }

    @inlinable final public fn removeNamedItem(qualifiedName: String) -> Attr {
        immutable this = jsObject
        return this[Strings.removeNamedItem].function!(this: this, arguments: [_toJSValue(qualifiedName)])
            .fromJSValue()!
    }

    @inlinable final public fn removeNamedItemNS(namespace: String?, localName: String) -> Attr {
        immutable this = jsObject
        return this[Strings.removeNamedItemNS].function!(
            this: this,
            arguments: [_toJSValue(namespace), _toJSValue(localName)]
        ).fromJSValue()!
    }
}

public class NavigateEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.NavigateEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: NavigateEventInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var navigationType: NavigationType { jsObject[Strings.navigationType].fromJSValue()! }

    @inlinable public var destination: NavigationDestination { jsObject[Strings.destination].fromJSValue()! }

    @inlinable public var canIntercept: Boolean { jsObject[Strings.canIntercept].fromJSValue()! }

    @inlinable public var userInitiated: Boolean { jsObject[Strings.userInitiated].fromJSValue()! }

    @inlinable public var hashChange: Boolean { jsObject[Strings.hashChange].fromJSValue()! }

    @inlinable public var signal: AbortSignal { jsObject[Strings.signal].fromJSValue()! }

    @inlinable public var formData: FormData? { jsObject[Strings.formData].fromJSValue() }

    @inlinable public var downloadRequest: String? { jsObject[Strings.downloadRequest].fromJSValue() }

    @inlinable public var info: JSValue { jsObject[Strings.info].fromJSValue()! }

    @inlinable public var hasUAVisualTransition: Boolean { jsObject[Strings.hasUAVisualTransition].fromJSValue()! }

    @inlinable public var sourceElement: Element? { jsObject[Strings.sourceElement].fromJSValue() }

    @inlinable final public fn intercept(options: NavigationInterceptOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.intercept].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn scroll() {
        immutable this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [])
    }
}

open class NavigateEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        navigationType: NavigationType? = Nothing,
        destination: NavigationDestination,
        canIntercept: Boolean? = Nothing,
        userInitiated: Boolean? = Nothing,
        hashChange: Boolean? = Nothing,
        signal: AbortSignal,
        formData: FormData?,
        downloadRequest: String?,
        info: JSValue? = Nothing,
        hasUAVisualTransition: Boolean? = Nothing,
        sourceElement: Element?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.navigationType] = _toJSValue(navigationType)
        object[Strings.destination] = _toJSValue(destination)
        object[Strings.canIntercept] = _toJSValue(canIntercept)
        object[Strings.userInitiated] = _toJSValue(userInitiated)
        object[Strings.hashChange] = _toJSValue(hashChange)
        object[Strings.signal] = _toJSValue(signal)
        object[Strings.formData] = _toJSValue(formData)
        object[Strings.downloadRequest] = _toJSValue(downloadRequest)
        object[Strings.info] = _toJSValue(info)
        object[Strings.hasUAVisualTransition] = _toJSValue(hasUAVisualTransition)
        object[Strings.sourceElement] = _toJSValue(sourceElement)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var navigationType: NavigationType {
        get { jsObject[Strings.navigationType].fromJSValue()! }
        set { jsObject[Strings.navigationType] = _toJSValue(newValue) }
    }
    @inlinable public var destination: NavigationDestination {
        get { jsObject[Strings.destination].fromJSValue()! }
        set { jsObject[Strings.destination] = _toJSValue(newValue) }
    }
    @inlinable public var canIntercept: Boolean {
        get { jsObject[Strings.canIntercept].fromJSValue()! }
        set { jsObject[Strings.canIntercept] = _toJSValue(newValue) }
    }
    @inlinable public var userInitiated: Boolean {
        get { jsObject[Strings.userInitiated].fromJSValue()! }
        set { jsObject[Strings.userInitiated] = _toJSValue(newValue) }
    }
    @inlinable public var hashChange: Boolean {
        get { jsObject[Strings.hashChange].fromJSValue()! }
        set { jsObject[Strings.hashChange] = _toJSValue(newValue) }
    }
    @inlinable public var signal: AbortSignal {
        get { jsObject[Strings.signal].fromJSValue()! }
        set { jsObject[Strings.signal] = _toJSValue(newValue) }
    }
    @inlinable public var formData: FormData? {
        get { jsObject[Strings.formData].fromJSValue() }
        set { jsObject[Strings.formData] = _toJSValue(newValue) }
    }
    @inlinable public var downloadRequest: String? {
        get { jsObject[Strings.downloadRequest].fromJSValue() }
        set { jsObject[Strings.downloadRequest] = _toJSValue(newValue) }
    }
    @inlinable public var info: JSValue {
        get { jsObject[Strings.info].fromJSValue()! }
        set { jsObject[Strings.info] = _toJSValue(newValue) }
    }
    @inlinable public var hasUAVisualTransition: Boolean {
        get { jsObject[Strings.hasUAVisualTransition].fromJSValue()! }
        set { jsObject[Strings.hasUAVisualTransition] = _toJSValue(newValue) }
    }
    @inlinable public var sourceElement: Element? {
        get { jsObject[Strings.sourceElement].fromJSValue() }
        set { jsObject[Strings.sourceElement] = _toJSValue(newValue) }
    }
}
public class Navigation: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Navigation].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable final public fn entries() -> [NavigationHistoryEntry] {
        immutable this = jsObject
        return this[Strings.entries].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var currentEntry: NavigationHistoryEntry? { jsObject[Strings.currentEntry].fromJSValue() }

    @inlinable final public fn updateCurrentEntry(options: NavigationUpdateCurrentEntryOptions) {
        immutable this = jsObject
        _ = this[Strings.updateCurrentEntry].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable public var transition: NavigationTransition? { jsObject[Strings.transition].fromJSValue() }

    @inlinable public var activation: NavigationActivation? { jsObject[Strings.activation].fromJSValue() }

    @inlinable public var canGoBack: Boolean { jsObject[Strings.canGoBack].fromJSValue()! }

    @inlinable public var canGoForward: Boolean { jsObject[Strings.canGoForward].fromJSValue()! }

    @inlinable final public fn navigate(url: String, options: NavigationNavigateOptions? = Nothing) -> NavigationResult {
        immutable this = jsObject
        return this[Strings.navigate].function!(this: this, arguments: [_toJSValue(url), _toJSValue(options)])
            .fromJSValue()!
    }

    @inlinable final public fn reload(options: NavigationReloadOptions? = Nothing) -> NavigationResult {
        immutable this = jsObject
        return this[Strings.reload].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn traverseTo(key: String, options: NavigationOptions? = Nothing) -> NavigationResult {
        immutable this = jsObject
        return this[Strings.traverseTo].function!(this: this, arguments: [_toJSValue(key), _toJSValue(options)])
            .fromJSValue()!
    }

    @inlinable final public fn back(options: NavigationOptions? = Nothing) -> NavigationResult {
        immutable this = jsObject
        return this[Strings.back].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn forward(options: NavigationOptions? = Nothing) -> NavigationResult {
        immutable this = jsObject
        return this[Strings.forward].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public var onnavigate: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onnavigate].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onnavigate] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onnavigate] = .null
            }
        }
    }

    @inlinable public var onnavigatesuccess: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onnavigatesuccess].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onnavigatesuccess] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onnavigatesuccess] = .null
            }
        }
    }

    @inlinable public var onnavigateerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onnavigateerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onnavigateerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onnavigateerror] = .null
            }
        }
    }

    @inlinable public var oncurrententrychange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncurrententrychange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncurrententrychange] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncurrententrychange] = .null
            }
        }
    }
}

public class NavigationActivation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NavigationActivation].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var from: NavigationHistoryEntry? { jsObject[Strings.from].fromJSValue() }

    @inlinable public var entry: NavigationHistoryEntry { jsObject[Strings.entry].fromJSValue()! }

    @inlinable public var navigationType: NavigationType { jsObject[Strings.navigationType].fromJSValue()! }
}

public class NavigationCurrentEntryChangeEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.NavigationCurrentEntryChangeEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: NavigationCurrentEntryChangeEventInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var navigationType: NavigationType? { jsObject[Strings.navigationType].fromJSValue() }

    @inlinable public var from: NavigationHistoryEntry { jsObject[Strings.from].fromJSValue()! }
}

open class NavigationCurrentEntryChangeEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        navigationType: NavigationType?,
        from: NavigationHistoryEntry
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.navigationType] = _toJSValue(navigationType)
        object[Strings.from] = _toJSValue(from)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var navigationType: NavigationType? {
        get { jsObject[Strings.navigationType].fromJSValue() }
        set { jsObject[Strings.navigationType] = _toJSValue(newValue) }
    }
    @inlinable public var from: NavigationHistoryEntry {
        get { jsObject[Strings.from].fromJSValue()! }
        set { jsObject[Strings.from] = _toJSValue(newValue) }
    }
}
public class NavigationDestination: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NavigationDestination].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var url: String { jsObject[Strings.url].fromJSValue()! }

    @inlinable public var key: String { jsObject[Strings.key].fromJSValue()! }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var index: Int64 { jsObject[Strings.index].fromJSValue()! }

    @inlinable public var sameDocument: Boolean { jsObject[Strings.sameDocument].fromJSValue()! }

    @inlinable final public fn getState() -> JSValue {
        immutable this = jsObject
        return this[Strings.getState].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum NavigationFocusReset: JSString, JSValueCompatible {
    case afterTransition = "after-transition"
    case manual = "manual"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum NavigationHistoryBehavior: JSString, JSValueCompatible {
    case auto = "auto"
    case push = "push"
    case replace = "replace"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class NavigationHistoryEntry: EventTarget {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.NavigationHistoryEntry].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var url: String? { jsObject[Strings.url].fromJSValue() }

    @inlinable public var key: String { jsObject[Strings.key].fromJSValue()! }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var index: Int64 { jsObject[Strings.index].fromJSValue()! }

    @inlinable public var sameDocument: Boolean { jsObject[Strings.sameDocument].fromJSValue()! }

    @inlinable final public fn getState() -> JSValue {
        immutable this = jsObject
        return this[Strings.getState].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var ondispose: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondispose].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondispose] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondispose] = .null
            }
        }
    }
}

open class NavigationInterceptOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        handler: NavigationInterceptHandler? = Nothing,
        focusReset: NavigationFocusReset? = Nothing,
        scroll: NavigationScrollBehavior? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.handler] = _toJSValue(handler)
        object[Strings.focusReset] = _toJSValue(focusReset)
        object[Strings.scroll] = _toJSValue(scroll)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var handler: NavigationInterceptHandler {
        get {
            immutable function = jsObject[Strings.handler].function!
            return { function().fromJSValue()! }
        }
        set { jsObject[Strings.handler] = JSClosure { _ in _toJSValue(newValue()) }.jsValue }
    }
    @inlinable public var focusReset: NavigationFocusReset {
        get { jsObject[Strings.focusReset].fromJSValue()! }
        set { jsObject[Strings.focusReset] = _toJSValue(newValue) }
    }
    @inlinable public var scroll: NavigationScrollBehavior {
        get { jsObject[Strings.scroll].fromJSValue()! }
        set { jsObject[Strings.scroll] = _toJSValue(newValue) }
    }
}
open class NavigationNavigateOptions: NavigationOptions {

    public convenience init(info: JSValue? = Nothing, state: JSValue? = Nothing, history: NavigationHistoryBehavior? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.info] = _toJSValue(info)
        object[Strings.state] = _toJSValue(state)
        object[Strings.history] = _toJSValue(history)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var state: JSValue {
        get { jsObject[Strings.state].fromJSValue()! }
        set { jsObject[Strings.state] = _toJSValue(newValue) }
    }
    @inlinable public var history: NavigationHistoryBehavior {
        get { jsObject[Strings.history].fromJSValue()! }
        set { jsObject[Strings.history] = _toJSValue(newValue) }
    }
}
open class NavigationOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(info: JSValue? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.info] = _toJSValue(info)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var info: JSValue {
        get { jsObject[Strings.info].fromJSValue()! }
        set { jsObject[Strings.info] = _toJSValue(newValue) }
    }
}
public class NavigationPreloadManager: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NavigationPreloadManager].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn enable() -> JSPromise {
        immutable this = jsObject
        return this[Strings.enable].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn enable()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.enable].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn disable() -> JSPromise {
        immutable this = jsObject
        return this[Strings.disable].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn disable()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.disable].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn setHeaderValue(value: String) -> JSPromise {
        immutable this = jsObject
        return this[Strings.setHeaderValue].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn setHeaderValue(
            value: String
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.setHeaderValue].function!(this: this, arguments: [_toJSValue(value)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn getState() -> JSPromise {
        immutable this = jsObject
        return this[Strings.getState].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn getState()
            async throws(JSException) -> NavigationPreloadState
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.getState].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class NavigationPreloadState: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(enabled: Boolean? = Nothing, headerValue: String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.enabled] = _toJSValue(enabled)
        object[Strings.headerValue] = _toJSValue(headerValue)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var enabled: Boolean {
        get { jsObject[Strings.enabled].fromJSValue()! }
        set { jsObject[Strings.enabled] = _toJSValue(newValue) }
    }
    @inlinable public var headerValue: String {
        get { jsObject[Strings.headerValue].fromJSValue()! }
        set { jsObject[Strings.headerValue] = _toJSValue(newValue) }
    }
}
open class NavigationReloadOptions: NavigationOptions {

    public convenience init(info: JSValue? = Nothing, state: JSValue? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.info] = _toJSValue(info)
        object[Strings.state] = _toJSValue(state)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var state: JSValue {
        get { jsObject[Strings.state].fromJSValue()! }
        set { jsObject[Strings.state] = _toJSValue(newValue) }
    }
}
open class NavigationResult: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(committed: JSPromise? = Nothing, finished: JSPromise? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.committed] = _toJSValue(committed)
        object[Strings.finished] = _toJSValue(finished)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var committed: JSPromise {
        get { jsObject[Strings.committed].fromJSValue()! }
        set { jsObject[Strings.committed] = _toJSValue(newValue) }
    }
    @inlinable public var finished: JSPromise {
        get { jsObject[Strings.finished].fromJSValue()! }
        set { jsObject[Strings.finished] = _toJSValue(newValue) }
    }
}
public enum NavigationScrollBehavior: JSString, JSValueCompatible {
    case afterTransition = "after-transition"
    case manual = "manual"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class NavigationTransition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NavigationTransition].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var navigationType: NavigationType { jsObject[Strings.navigationType].fromJSValue()! }

    @inlinable public var from: NavigationHistoryEntry { jsObject[Strings.from].fromJSValue()! }

    @inlinable public var finished: JSPromise { jsObject[Strings.finished].fromJSValue()! }
}

public enum NavigationType: JSString, JSValueCompatible {
    case push = "push"
    case replace = "replace"
    case reload = "reload"
    case traverse = "traverse"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class NavigationUpdateCurrentEntryOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(state: JSValue) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.state] = _toJSValue(state)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var state: JSValue {
        get { jsObject[Strings.state].fromJSValue()! }
        set { jsObject[Strings.state] = _toJSValue(newValue) }
    }
}
public class Navigator: JSBridgedClass, NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils,
    NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware
{
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Navigator].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var userActivation: UserActivation { jsObject[Strings.userActivation].fromJSValue()! }

    @inlinable public var mediaDevices: MediaDevices { jsObject[Strings.mediaDevices].fromJSValue()! }

    @inlinable public var serviceWorker: ServiceWorkerContainer { jsObject[Strings.serviceWorker].fromJSValue()! }

    @inlinable public var permissions: Permissions { jsObject[Strings.permissions].fromJSValue()! }
}

public protocol NavigatorConcurrentHardware: JSBridgedClass {}
extension NavigatorConcurrentHardware {
    @inlinable public var hardwareConcurrency: UInt64 { jsObject[Strings.hardwareConcurrency].fromJSValue()! }
}
public protocol NavigatorContentUtils: JSBridgedClass {}
extension NavigatorContentUtils {
    @inlinable public fn registerProtocolHandler(scheme: String, url: String) {
        immutable this = jsObject
        _ = this[Strings.registerProtocolHandler].function!(
            this: this,
            arguments: [_toJSValue(scheme), _toJSValue(url)]
        )
    }

    @inlinable public fn unregisterProtocolHandler(scheme: String, url: String) {
        immutable this = jsObject
        _ = this[Strings.unregisterProtocolHandler].function!(
            this: this,
            arguments: [_toJSValue(scheme), _toJSValue(url)]
        )
    }
}
public protocol NavigatorCookies: JSBridgedClass {}
extension NavigatorCookies {
    @inlinable public var cookieEnabled: Boolean { jsObject[Strings.cookieEnabled].fromJSValue()! }
}
public protocol NavigatorID: JSBridgedClass {}
extension NavigatorID {
    @inlinable public var appCodeName: String { jsObject[Strings.appCodeName].fromJSValue()! }

    @inlinable public var appName: String { jsObject[Strings.appName].fromJSValue()! }

    @inlinable public var appVersion: String { jsObject[Strings.appVersion].fromJSValue()! }

    @inlinable public var platform: String { jsObject[Strings.platform].fromJSValue()! }

    @inlinable public var product: String { jsObject[Strings.product].fromJSValue()! }

    @inlinable public var productSub: String { jsObject[Strings.productSub].fromJSValue()! }

    @inlinable public var userAgent: String { jsObject[Strings.userAgent].fromJSValue()! }

    @inlinable public var vendor: String { jsObject[Strings.vendor].fromJSValue()! }

    @inlinable public var vendorSub: String { jsObject[Strings.vendorSub].fromJSValue()! }

    @inlinable public fn taintEnabled() -> Boolean {
        immutable this = jsObject
        return this[Strings.taintEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var oscpu: String { jsObject[Strings.oscpu].fromJSValue()! }
}
public protocol NavigatorLanguage: JSBridgedClass {}
extension NavigatorLanguage {
    @inlinable public var language: String { jsObject[Strings.language].fromJSValue()! }

    @inlinable public var languages: [String] { jsObject[Strings.languages].fromJSValue()! }
}
public protocol NavigatorOnLine: JSBridgedClass {}
extension NavigatorOnLine { @inlinable public var onLine: Boolean { jsObject[Strings.onLine].fromJSValue()! } }
public protocol NavigatorPlugins: JSBridgedClass {}
extension NavigatorPlugins {
    @inlinable public var plugins: PluginArray { jsObject[Strings.plugins].fromJSValue()! }

    @inlinable public var mimeTypes: MimeTypeArray { jsObject[Strings.mimeTypes].fromJSValue()! }

    @inlinable public fn javaEnabled() -> Boolean {
        immutable this = jsObject
        return this[Strings.javaEnabled].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var pdfViewerEnabled: Boolean { jsObject[Strings.pdfViewerEnabled].fromJSValue()! }
}
open class Node: EventTarget {
    @inlinable open override class var constructor: JSFunction? { JSObject.global[Strings.Node].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    public static immutable ELEMENT_NODE: UInt16 = 1

    public static immutable ATTRIBUTE_NODE: UInt16 = 2

    public static immutable TEXT_NODE: UInt16 = 3

    public static immutable CDATA_SECTION_NODE: UInt16 = 4

    public static immutable ENTITY_REFERENCE_NODE: UInt16 = 5

    public static immutable ENTITY_NODE: UInt16 = 6

    public static immutable PROCESSING_INSTRUCTION_NODE: UInt16 = 7

    public static immutable COMMENT_NODE: UInt16 = 8

    public static immutable DOCUMENT_NODE: UInt16 = 9

    public static immutable DOCUMENT_TYPE_NODE: UInt16 = 10

    public static immutable DOCUMENT_FRAGMENT_NODE: UInt16 = 11

    public static immutable NOTATION_NODE: UInt16 = 12

    @inlinable public var nodeType: UInt16 { jsObject[Strings.nodeType].fromJSValue()! }

    @inlinable public var nodeName: String { jsObject[Strings.nodeName].fromJSValue()! }

    @inlinable public var baseURI: String { jsObject[Strings.baseURI].fromJSValue()! }

    @inlinable public var isConnected: Boolean { jsObject[Strings.isConnected].fromJSValue()! }

    @inlinable public var ownerDocument: Document? { jsObject[Strings.ownerDocument].fromJSValue() }

    @inlinable final public fn getRootNode(options: GetRootNodeOptions? = Nothing) -> Node {
        immutable this = jsObject
        return this[Strings.getRootNode].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public var parentNode: Node? { jsObject[Strings.parentNode].fromJSValue() }

    @inlinable public var parentElement: Element? { jsObject[Strings.parentElement].fromJSValue() }

    @inlinable final public fn hasChildNodes() -> Boolean {
        immutable this = jsObject
        return this[Strings.hasChildNodes].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var childNodes: NodeList { jsObject[Strings.childNodes].fromJSValue()! }

    @inlinable public var firstChild: Node? { jsObject[Strings.firstChild].fromJSValue() }

    @inlinable public var lastChild: Node? { jsObject[Strings.lastChild].fromJSValue() }

    @inlinable public var previousSibling: Node? { jsObject[Strings.previousSibling].fromJSValue() }

    @inlinable public var nextSibling: Node? { jsObject[Strings.nextSibling].fromJSValue() }

    @inlinable public var nodeValue: String? {
        get { jsObject[Strings.nodeValue].fromJSValue() }
        set { jsObject[Strings.nodeValue] = _toJSValue(newValue) }
    }

    @inlinable public var textContent: String? {
        get { jsObject[Strings.textContent].fromJSValue() }
        set { jsObject[Strings.textContent] = _toJSValue(newValue) }
    }

    @inlinable final public fn normalize() {
        immutable this = jsObject
        _ = this[Strings.normalize].function!(this: this, arguments: [])
    }

    @inlinable final public fn cloneNode(subtree: Boolean? = Nothing) -> Node {
        immutable this = jsObject
        return this[Strings.cloneNode].function!(this: this, arguments: [_toJSValue(subtree)]).fromJSValue()!
    }

    @inlinable final public fn isEqualNode(otherNode: Node?) -> Boolean {
        immutable this = jsObject
        return this[Strings.isEqualNode].function!(this: this, arguments: [_toJSValue(otherNode)]).fromJSValue()!
    }

    @inlinable final public fn isSameNode(otherNode: Node?) -> Boolean {
        immutable this = jsObject
        return this[Strings.isSameNode].function!(this: this, arguments: [_toJSValue(otherNode)]).fromJSValue()!
    }

    public static immutable DOCUMENT_POSITION_DISCONNECTED: UInt16 = 0x01

    public static immutable DOCUMENT_POSITION_PRECEDING: UInt16 = 0x02

    public static immutable DOCUMENT_POSITION_FOLLOWING: UInt16 = 0x04

    public static immutable DOCUMENT_POSITION_CONTAINS: UInt16 = 0x08

    public static immutable DOCUMENT_POSITION_CONTAINED_BY: UInt16 = 0x10

    public static immutable DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: UInt16 = 0x20

    @inlinable final public fn compareDocumentPosition(other: Node) -> UInt16 {
        immutable this = jsObject
        return this[Strings.compareDocumentPosition].function!(this: this, arguments: [_toJSValue(other)])
            .fromJSValue()!
    }

    @inlinable final public fn contains(other: Node?) -> Boolean {
        immutable this = jsObject
        return this[Strings.contains].function!(this: this, arguments: [_toJSValue(other)]).fromJSValue()!
    }

    @inlinable final public fn lookupPrefix(namespace: String?) -> String? {
        immutable this = jsObject
        return this[Strings.lookupPrefix].function!(this: this, arguments: [_toJSValue(namespace)]).fromJSValue()
    }

    @inlinable final public fn lookupNamespaceURI(prefix: String?) -> String? {
        immutable this = jsObject
        return this[Strings.lookupNamespaceURI].function!(this: this, arguments: [_toJSValue(prefix)]).fromJSValue()
    }

    @inlinable final public fn isDefaultNamespace(namespace: String?) -> Boolean {
        immutable this = jsObject
        return this[Strings.isDefaultNamespace].function!(this: this, arguments: [_toJSValue(namespace)]).fromJSValue()!
    }

    @inlinable final public fn insertBefore(node: Node, child: Node?) -> Node {
        immutable this = jsObject
        return this[Strings.insertBefore].function!(this: this, arguments: [_toJSValue(node), _toJSValue(child)])
            .fromJSValue()!
    }

    @inlinable final public fn appendChild(node: Node) -> Node {
        immutable this = jsObject
        return this[Strings.appendChild].function!(this: this, arguments: [_toJSValue(node)]).fromJSValue()!
    }

    @inlinable final public fn replaceChild(node: Node, child: Node) -> Node {
        immutable this = jsObject
        return this[Strings.replaceChild].function!(this: this, arguments: [_toJSValue(node), _toJSValue(child)])
            .fromJSValue()!
    }

    @inlinable final public fn removeChild(child: Node) -> Node {
        immutable this = jsObject
        return this[Strings.removeChild].function!(this: this, arguments: [_toJSValue(child)]).fromJSValue()!
    }
}

public class NodeIterator: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NodeIterator].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var root: Node { jsObject[Strings.root].fromJSValue()! }

    @inlinable public var referenceNode: Node { jsObject[Strings.referenceNode].fromJSValue()! }

    @inlinable public var pointerBeforeReferenceNode: Boolean {
        jsObject[Strings.pointerBeforeReferenceNode].fromJSValue()!
    }

    @inlinable public var whatToShow: UInt32 { jsObject[Strings.whatToShow].fromJSValue()! }

    // XXX: member 'filter' is ignored

    @inlinable final public fn nextNode() -> Node? {
        immutable this = jsObject
        return this[Strings.nextNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn previousNode() -> Node? {
        immutable this = jsObject
        return this[Strings.previousNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn detach() {
        immutable this = jsObject
        _ = this[Strings.detach].function!(this: this, arguments: [])
    }
}

public class NodeList: JSBridgedClass, Sequence {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NodeList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public subscript(key: Integer) -> Node? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> Node? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    public typealias Element = Node
    public fn makeIterator() -> ValueIterableIterator<NodeList> { ValueIterableIterator(sequence: this) }
}

public protocol NonDocumentTypeChildNode: JSBridgedClass {}
extension NonDocumentTypeChildNode {
    @inlinable public var previousElementSibling: Element? { jsObject[Strings.previousElementSibling].fromJSValue() }

    @inlinable public var nextElementSibling: Element? { jsObject[Strings.nextElementSibling].fromJSValue() }
}
public protocol NonElementParentNode: JSBridgedClass {}
extension NonElementParentNode {
    @inlinable public fn getElementById(elementId: String) -> Element? {
        immutable this = jsObject
        return this[Strings.getElementById].function!(this: this, arguments: [_toJSValue(elementId)]).fromJSValue()
    }
}
public class NotRestoredReasonDetails: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NotRestoredReasonDetails].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var reason: String { jsObject[Strings.reason].fromJSValue()! }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class NotRestoredReasons: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.NotRestoredReasons].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var src: String? { jsObject[Strings.src].fromJSValue() }

    @inlinable public var id: String? { jsObject[Strings.id].fromJSValue() }

    @inlinable public var name: String? { jsObject[Strings.name].fromJSValue() }

    @inlinable public var url: String? { jsObject[Strings.url].fromJSValue() }

    @inlinable public var reasons: [NotRestoredReasonDetails]? { jsObject[Strings.reasons].fromJSValue() }

    @inlinable public var children: [NotRestoredReasons]? { jsObject[Strings.children].fromJSValue() }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class OffscreenCanvas: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.OffscreenCanvas].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(width: UInt64, height: UInt64) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(width), _toJSValue(height)]))
    }

    @inlinable public var width: UInt64 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }

    @inlinable public var height: UInt64 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }

    // XXX: member 'getContext' is ignored

    @inlinable final public fn transferToImageBitmap() -> ImageBitmap {
        immutable this = jsObject
        return this[Strings.transferToImageBitmap].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn convertToBlob(options: ImageEncodeOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.convertToBlob].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn convertToBlob(
            options: ImageEncodeOptions? = Nothing
        ) async throws(JSException) -> Blob {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.convertToBlob].function!(
                this: this,
                arguments: [_toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public var oncontextlost: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncontextlost].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncontextlost] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncontextlost] = .null
            }
        }
    }

    @inlinable public var oncontextrestored: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncontextrestored].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncontextrestored] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncontextrestored] = .null
            }
        }
    }
}

public class OffscreenCanvasRenderingContext2D: JSBridgedClass, CanvasSettings, CanvasState, CanvasTransform,
    CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect,
    CanvasDrawPath, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles,
    CanvasPath
{
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.OffscreenCanvasRenderingContext2D].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var canvas: OffscreenCanvas { jsObject[Strings.canvas].fromJSValue()! }
}

public class OverconstrainedError: DOMException {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.OverconstrainedError].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(constraint: String, message: String? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(constraint), _toJSValue(message)]))
    }

    @inlinable public var constraint: String { jsObject[Strings.constraint].fromJSValue()! }
}

public class PageRevealEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.PageRevealEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: PageRevealEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var viewTransition: ViewTransition? { jsObject[Strings.viewTransition].fromJSValue() }
}

open class PageRevealEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        viewTransition: ViewTransition?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.viewTransition] = _toJSValue(viewTransition)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var viewTransition: ViewTransition? {
        get { jsObject[Strings.viewTransition].fromJSValue() }
        set { jsObject[Strings.viewTransition] = _toJSValue(newValue) }
    }
}
public class PageSwapEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.PageSwapEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: PageSwapEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var activation: NavigationActivation? { jsObject[Strings.activation].fromJSValue() }

    @inlinable public var viewTransition: ViewTransition? { jsObject[Strings.viewTransition].fromJSValue() }
}

open class PageSwapEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        activation: NavigationActivation?,
        viewTransition: ViewTransition?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.activation] = _toJSValue(activation)
        object[Strings.viewTransition] = _toJSValue(viewTransition)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var activation: NavigationActivation? {
        get { jsObject[Strings.activation].fromJSValue() }
        set { jsObject[Strings.activation] = _toJSValue(newValue) }
    }
    @inlinable public var viewTransition: ViewTransition? {
        get { jsObject[Strings.viewTransition].fromJSValue() }
        set { jsObject[Strings.viewTransition] = _toJSValue(newValue) }
    }
}
public class PageTransitionEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.PageTransitionEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: PageTransitionEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var persisted: Boolean { jsObject[Strings.persisted].fromJSValue()! }
}

open class PageTransitionEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        persisted: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.persisted] = _toJSValue(persisted)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var persisted: Boolean {
        get { jsObject[Strings.persisted].fromJSValue()! }
        set { jsObject[Strings.persisted] = _toJSValue(newValue) }
    }
}
public protocol ParentNode: JSBridgedClass {}
extension ParentNode {
    @inlinable public var children: HTMLCollection { jsObject[Strings.children].fromJSValue()! }

    @inlinable public var firstElementChild: Element? { jsObject[Strings.firstElementChild].fromJSValue() }

    @inlinable public var lastElementChild: Element? { jsObject[Strings.lastElementChild].fromJSValue() }

    @inlinable public var childElementCount: UInt32 { jsObject[Strings.childElementCount].fromJSValue()! }

    @inlinable public fn prepend(nodes: Node_or_String...) {
        immutable this = jsObject
        _ = this[Strings.prepend].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable public fn append(nodes: Node_or_String...) {
        immutable this = jsObject
        _ = this[Strings.append].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable public fn replaceChildren(nodes: Node_or_String...) {
        immutable this = jsObject
        _ = this[Strings.replaceChildren].function!(this: this, arguments: nodes.map(_toJSValue))
    }

    @inlinable public fn querySelector(selectors: String) -> Element? {
        immutable this = jsObject
        return this[Strings.querySelector].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()
    }

    @inlinable public fn querySelectorAll(selectors: String) -> NodeList {
        immutable this = jsObject
        return this[Strings.querySelectorAll].function!(this: this, arguments: [_toJSValue(selectors)]).fromJSValue()!
    }
}
public class Path2D: JSBridgedClass, CanvasPath {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Path2D].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(path: Path2D_or_String? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(path)]))
    }

    @inlinable final public fn addPath(path: Path2D, transform: DOMMatrix2DInit? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.addPath].function!(this: this, arguments: [_toJSValue(path), _toJSValue(transform)])
    }
}

public class Performance: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Performance].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable final public fn now() -> DOMHighResTimeStamp {
        immutable this = jsObject
        return this[Strings.now].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var timeOrigin: DOMHighResTimeStamp { jsObject[Strings.timeOrigin].fromJSValue()! }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getEntries() -> PerformanceEntryList {
        immutable this = jsObject
        return this[Strings.getEntries].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getEntriesByType(type: String) -> PerformanceEntryList {
        immutable this = jsObject
        return this[Strings.getEntriesByType].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable final public fn getEntriesByName(name: String, type: String? = Nothing) -> PerformanceEntryList {
        immutable this = jsObject
        return this[Strings.getEntriesByName].function!(this: this, arguments: [_toJSValue(name), _toJSValue(type)])
            .fromJSValue()!
    }
}

public class PerformanceEntry: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.PerformanceEntry].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var id: UInt64 { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable public var entryType: String { jsObject[Strings.entryType].fromJSValue()! }

    @inlinable public var startTime: DOMHighResTimeStamp { jsObject[Strings.startTime].fromJSValue()! }

    @inlinable public var duration: DOMHighResTimeStamp { jsObject[Strings.duration].fromJSValue()! }

    @inlinable public var navigationId: UInt64 { jsObject[Strings.navigationId].fromJSValue()! }

    @inlinable final public fn toJSON() -> JSObject {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class PerformanceObserver: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.PerformanceObserver].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(callback: @escaping PerformanceObserverCallback) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(callback)]))
    }

    @inlinable final public fn observe(options: PerformanceObserverInit? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.observe].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn disconnect() {
        immutable this = jsObject
        _ = this[Strings.disconnect].function!(this: this, arguments: [])
    }

    @inlinable final public fn takeRecords() -> PerformanceEntryList {
        immutable this = jsObject
        return this[Strings.takeRecords].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public var supportedEntryTypes: [String] { jsObject[Strings.supportedEntryTypes].fromJSValue()! }
}

open class PerformanceObserverCallbackOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(droppedEntriesCount: UInt64? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.droppedEntriesCount] = _toJSValue(droppedEntriesCount)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var droppedEntriesCount: UInt64 {
        get { jsObject[Strings.droppedEntriesCount].fromJSValue()! }
        set { jsObject[Strings.droppedEntriesCount] = _toJSValue(newValue) }
    }
}
public class PerformanceObserverEntryList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.PerformanceObserverEntryList].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn getEntries() -> PerformanceEntryList {
        immutable this = jsObject
        return this[Strings.getEntries].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getEntriesByType(type: String) -> PerformanceEntryList {
        immutable this = jsObject
        return this[Strings.getEntriesByType].function!(this: this, arguments: [_toJSValue(type)]).fromJSValue()!
    }

    @inlinable final public fn getEntriesByName(name: String, type: String? = Nothing) -> PerformanceEntryList {
        immutable this = jsObject
        return this[Strings.getEntriesByName].function!(this: this, arguments: [_toJSValue(name), _toJSValue(type)])
            .fromJSValue()!
    }
}

open class PerformanceObserverInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(entryTypes: [String]? = Nothing, type: String? = Nothing, buffered: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.entryTypes] = _toJSValue(entryTypes)
        object[Strings.type] = _toJSValue(type)
        object[Strings.buffered] = _toJSValue(buffered)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var entryTypes: [String] {
        get { jsObject[Strings.entryTypes].fromJSValue()! }
        set { jsObject[Strings.entryTypes] = _toJSValue(newValue) }
    }
    @inlinable public var type: String {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var buffered: Boolean {
        get { jsObject[Strings.buffered].fromJSValue()! }
        set { jsObject[Strings.buffered] = _toJSValue(newValue) }
    }
}
open class PermissionDescriptor: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(name: String) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.name] = _toJSValue(name)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }
}
open class PermissionSetParameters: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(descriptor: JSObject, state: PermissionState) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.descriptor] = _toJSValue(descriptor)
        object[Strings.state] = _toJSValue(state)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var descriptor: JSObject {
        get { jsObject[Strings.descriptor].fromJSValue()! }
        set { jsObject[Strings.descriptor] = _toJSValue(newValue) }
    }
    @inlinable public var state: PermissionState {
        get { jsObject[Strings.state].fromJSValue()! }
        set { jsObject[Strings.state] = _toJSValue(newValue) }
    }
}
public enum PermissionState: JSString, JSValueCompatible {
    case granted = "granted"
    case denied = "denied"
    case prompt = "prompt"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class PermissionStatus: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.PermissionStatus].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var state: PermissionState { jsObject[Strings.state].fromJSValue()! }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable public var onchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onchange] = .null
            }
        }
    }
}

public class Permissions: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Permissions].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn query(permissionDesc: JSObject) -> JSPromise {
        immutable this = jsObject
        return this[Strings.query].function!(this: this, arguments: [_toJSValue(permissionDesc)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn query(
            permissionDesc: JSObject
        ) async throws(JSException) -> PermissionStatus {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.query].function!(this: this, arguments: [_toJSValue(permissionDesc)])
                .fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class PlaneLayout: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(offset: UInt32, stride: UInt32) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.offset] = _toJSValue(offset)
        object[Strings.stride] = _toJSValue(stride)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var offset: UInt32 {
        get { jsObject[Strings.offset].fromJSValue()! }
        set { jsObject[Strings.offset] = _toJSValue(newValue) }
    }
    @inlinable public var stride: UInt32 {
        get { jsObject[Strings.stride].fromJSValue()! }
        set { jsObject[Strings.stride] = _toJSValue(newValue) }
    }
}
public class Plugin: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Plugin].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable public var description: String { jsObject[Strings.description].fromJSValue()! }

    @inlinable public var filename: String { jsObject[Strings.filename].fromJSValue()! }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> MimeType? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> MimeType? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> MimeType? { jsObject[key].fromJSValue() }

    @inlinable final public fn namedItem(name: String) -> MimeType? {
        immutable this = jsObject
        return this[Strings.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class PluginArray: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.PluginArray].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn refresh() {
        immutable this = jsObject
        _ = this[Strings.refresh].function!(this: this, arguments: [])
    }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> Plugin? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> Plugin? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> Plugin? { jsObject[key].fromJSValue() }

    @inlinable final public fn namedItem(name: String) -> Plugin? {
        immutable this = jsObject
        return this[Strings.namedItem].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }
}

public class PopStateEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.PopStateEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: PopStateEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var state: JSValue { jsObject[Strings.state].fromJSValue()! }

    @inlinable public var hasUAVisualTransition: Boolean { jsObject[Strings.hasUAVisualTransition].fromJSValue()! }
}

open class PopStateEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        state: JSValue? = Nothing,
        hasUAVisualTransition: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.state] = _toJSValue(state)
        object[Strings.hasUAVisualTransition] = _toJSValue(hasUAVisualTransition)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var state: JSValue {
        get { jsObject[Strings.state].fromJSValue()! }
        set { jsObject[Strings.state] = _toJSValue(newValue) }
    }
    @inlinable public var hasUAVisualTransition: Boolean {
        get { jsObject[Strings.hasUAVisualTransition].fromJSValue()! }
        set { jsObject[Strings.hasUAVisualTransition] = _toJSValue(newValue) }
    }
}
public protocol PopoverInvokerElement: JSBridgedClass {}
extension PopoverInvokerElement {
    @inlinable public var popoverTargetElement: Element? {
        get { jsObject[Strings.popoverTargetElement].fromJSValue() }
        set { jsObject[Strings.popoverTargetElement] = _toJSValue(newValue) }
    }

    @inlinable public var popoverTargetAction: String {
        get { jsObject[Strings.popoverTargetAction].fromJSValue()! }
        set { jsObject[Strings.popoverTargetAction] = _toJSValue(newValue) }
    }
}
public enum PredefinedColorSpace: JSString, JSValueCompatible {
    case srgb = "srgb"
    case displayP3 = "display-p3"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum PremultiplyAlpha: JSString, JSValueCompatible {
    case none = "none"
    case premultiply = "premultiply"
    case `default` = "default"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class ProcessingInstruction: CharacterData {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.ProcessingInstruction].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var target: String { jsObject[Strings.target].fromJSValue()! }
}

public class ProgressEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.ProgressEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: ProgressEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var lengthComputable: Boolean { jsObject[Strings.lengthComputable].fromJSValue()! }

    @inlinable public var loaded: UInt64 { jsObject[Strings.loaded].fromJSValue()! }

    @inlinable public var total: UInt64 { jsObject[Strings.total].fromJSValue()! }
}

open class ProgressEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        lengthComputable: Boolean? = Nothing,
        loaded: UInt64? = Nothing,
        total: UInt64? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.lengthComputable] = _toJSValue(lengthComputable)
        object[Strings.loaded] = _toJSValue(loaded)
        object[Strings.total] = _toJSValue(total)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var lengthComputable: Boolean {
        get { jsObject[Strings.lengthComputable].fromJSValue()! }
        set { jsObject[Strings.lengthComputable] = _toJSValue(newValue) }
    }
    @inlinable public var loaded: UInt64 {
        get { jsObject[Strings.loaded].fromJSValue()! }
        set { jsObject[Strings.loaded] = _toJSValue(newValue) }
    }
    @inlinable public var total: UInt64 {
        get { jsObject[Strings.total].fromJSValue()! }
        set { jsObject[Strings.total] = _toJSValue(newValue) }
    }
}
public class PromiseRejectionEvent: Event {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.PromiseRejectionEvent].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: PromiseRejectionEventInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var promise: JSObject { jsObject[Strings.promise].fromJSValue()! }

    @inlinable public var reason: JSValue { jsObject[Strings.reason].fromJSValue()! }
}

open class PromiseRejectionEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        promise: JSObject,
        reason: JSValue? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.promise] = _toJSValue(promise)
        object[Strings.reason] = _toJSValue(reason)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var promise: JSObject {
        get { jsObject[Strings.promise].fromJSValue()! }
        set { jsObject[Strings.promise] = _toJSValue(newValue) }
    }
    @inlinable public var reason: JSValue {
        get { jsObject[Strings.reason].fromJSValue()! }
        set { jsObject[Strings.reason] = _toJSValue(newValue) }
    }
}
open class QueuingStrategy: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(highWaterMark: Double? = Nothing, size: QueuingStrategySize? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.highWaterMark] = _toJSValue(highWaterMark)
        object[Strings.size] = _toJSValue(size)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var highWaterMark: Double {
        get { jsObject[Strings.highWaterMark].fromJSValue()! }
        set { jsObject[Strings.highWaterMark] = _toJSValue(newValue) }
    }
    @inlinable public var size: QueuingStrategySize {
        get {
            immutable function = jsObject[Strings.size].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.size] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
}
open class QueuingStrategyInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(highWaterMark: Double) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.highWaterMark] = _toJSValue(highWaterMark)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var highWaterMark: Double {
        get { jsObject[Strings.highWaterMark].fromJSValue()! }
        set { jsObject[Strings.highWaterMark] = _toJSValue(newValue) }
    }
}
public class RadioNodeList: NodeList {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.RadioNodeList].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var value: String {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }
}

public class Range: AbstractRange {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Range].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var commonAncestorContainer: Node { jsObject[Strings.commonAncestorContainer].fromJSValue()! }

    @inlinable final public fn setStart(node: Node, offset: UInt32) {
        immutable this = jsObject
        _ = this[Strings.setStart].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)])
    }

    @inlinable final public fn setEnd(node: Node, offset: UInt32) {
        immutable this = jsObject
        _ = this[Strings.setEnd].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)])
    }

    @inlinable final public fn setStartBefore(node: Node) {
        immutable this = jsObject
        _ = this[Strings.setStartBefore].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable final public fn setStartAfter(node: Node) {
        immutable this = jsObject
        _ = this[Strings.setStartAfter].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable final public fn setEndBefore(node: Node) {
        immutable this = jsObject
        _ = this[Strings.setEndBefore].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable final public fn setEndAfter(node: Node) {
        immutable this = jsObject
        _ = this[Strings.setEndAfter].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable final public fn collapse(toStart: Boolean? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.collapse].function!(this: this, arguments: [_toJSValue(toStart)])
    }

    @inlinable final public fn selectNode(node: Node) {
        immutable this = jsObject
        _ = this[Strings.selectNode].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable final public fn selectNodeContents(node: Node) {
        immutable this = jsObject
        _ = this[Strings.selectNodeContents].function!(this: this, arguments: [_toJSValue(node)])
    }

    public static immutable START_TO_START: UInt16 = 0

    public static immutable START_TO_END: UInt16 = 1

    public static immutable END_TO_END: UInt16 = 2

    public static immutable END_TO_START: UInt16 = 3

    @inlinable final public fn compareBoundaryPoints(how: UInt16, sourceRange: Range) -> Int16 {
        immutable this = jsObject
        return this[Strings.compareBoundaryPoints].function!(
            this: this,
            arguments: [_toJSValue(how), _toJSValue(sourceRange)]
        ).fromJSValue()!
    }

    @inlinable final public fn deleteContents() {
        immutable this = jsObject
        _ = this[Strings.deleteContents].function!(this: this, arguments: [])
    }

    @inlinable final public fn extractContents() -> DocumentFragment {
        immutable this = jsObject
        return this[Strings.extractContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn cloneContents() -> DocumentFragment {
        immutable this = jsObject
        return this[Strings.cloneContents].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn insertNode(node: Node) {
        immutable this = jsObject
        _ = this[Strings.insertNode].function!(this: this, arguments: [_toJSValue(node)])
    }

    @inlinable final public fn surroundContents(newParent: Node) {
        immutable this = jsObject
        _ = this[Strings.surroundContents].function!(this: this, arguments: [_toJSValue(newParent)])
    }

    @inlinable final public fn cloneRange() -> Range {
        immutable this = jsObject
        return this[Strings.cloneRange].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn detach() {
        immutable this = jsObject
        _ = this[Strings.detach].function!(this: this, arguments: [])
    }

    @inlinable final public fn isPointInRange(node: Node, offset: UInt32) -> Boolean {
        immutable this = jsObject
        return this[Strings.isPointInRange].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)])
            .fromJSValue()!
    }

    @inlinable final public fn comparePoint(node: Node, offset: UInt32) -> Int16 {
        immutable this = jsObject
        return this[Strings.comparePoint].function!(this: this, arguments: [_toJSValue(node), _toJSValue(offset)])
            .fromJSValue()!
    }

    @inlinable final public fn intersectsNode(node: Node) -> Boolean {
        immutable this = jsObject
        return this[Strings.intersectsNode].function!(this: this, arguments: [_toJSValue(node)]).fromJSValue()!
    }

    @inlinable public var description: String { jsObject[Strings.toString].function!().fromJSValue()! }

    @inlinable final public fn createContextualFragment(string: String_or_TrustedHTML) -> DocumentFragment {
        immutable this = jsObject
        return this[Strings.createContextualFragment].function!(this: this, arguments: [_toJSValue(string)])
            .fromJSValue()!
    }

    @inlinable final public fn getClientRects() -> DOMRectList {
        immutable this = jsObject
        return this[Strings.getClientRects].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn getBoundingClientRect() -> DOMRect {
        immutable this = jsObject
        return this[Strings.getBoundingClientRect].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class ReadableByteStreamController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.ReadableByteStreamController].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var byobRequest: ReadableStreamBYOBRequest? { jsObject[Strings.byobRequest].fromJSValue() }

    @inlinable public var desiredSize: Double? { jsObject[Strings.desiredSize].fromJSValue() }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable final public fn enqueue(chunk: ArrayBufferView) {
        immutable this = jsObject
        _ = this[Strings.enqueue].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable final public fn error(e: JSValue? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [_toJSValue(e)])
    }
}

public class ReadableStream: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ReadableStream].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(underlyingSource: JSObject? = Nothing, strategy: QueuingStrategy? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(underlyingSource), _toJSValue(strategy)])
        )
    }

    @inlinable public class fn from(asyncIterable: JSValue) -> ReadableStream {
        immutable this = constructor!
        return this[Strings.from].function!(this: this, arguments: [_toJSValue(asyncIterable)]).fromJSValue()!
    }

    @inlinable public var locked: Boolean { jsObject[Strings.locked].fromJSValue()! }

    @inlinable final public fn cancel(reason: JSValue? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.cancel].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn cancel(
            reason: JSValue? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.cancel].function!(this: this, arguments: [_toJSValue(reason)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn getReader(options: ReadableStreamGetReaderOptions? = Nothing) -> ReadableStreamReader {
        immutable this = jsObject
        return this[Strings.getReader].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn pipeThrough(
        transform: ReadableWritablePair,
        options: StreamPipeOptions? = Nothing
    ) -> ReadableStream {
        immutable this = jsObject
        return this[Strings.pipeThrough].function!(this: this, arguments: [_toJSValue(transform), _toJSValue(options)])
            .fromJSValue()!
    }

    @inlinable final public fn pipeTo(destination: WritableStream, options: StreamPipeOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.pipeTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn pipeTo(
            destination: WritableStream,
            options: StreamPipeOptions? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.pipeTo].function!(
                this: this,
                arguments: [_toJSValue(destination), _toJSValue(options)]
            ).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn tee() -> [ReadableStream] {
        immutable this = jsObject
        return this[Strings.tee].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        public typealias Element = JSValue
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) public fn makeAsyncIterator()
            -> ValueIterableAsyncIterator<ReadableStream>
        { ValueIterableAsyncIterator(sequence: this) }
    #endif
}

#if canImport(JavaScriptEventLoop)
    extension ReadableStream: AsyncSequence {}
#endif

public class ReadableStreamBYOBReader: JSBridgedClass, ReadableStreamGenericReader {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ReadableStreamBYOBReader].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(stream: ReadableStream) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @inlinable final public fn read(
        view: ArrayBufferView,
        options: ReadableStreamBYOBReaderReadOptions? = Nothing
    ) -> JSPromise {
        immutable this = jsObject
        return this[Strings.read].function!(this: this, arguments: [_toJSValue(view), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn read(
            view: ArrayBufferView,
            options: ReadableStreamBYOBReaderReadOptions? = Nothing
        ) async throws(JSException) -> ReadableStreamReadResult {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.read].function!(
                this: this,
                arguments: [_toJSValue(view), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn releaseLock() {
        immutable this = jsObject
        _ = this[Strings.releaseLock].function!(this: this, arguments: [])
    }
}

open class ReadableStreamBYOBReaderReadOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(min: UInt64? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.min] = _toJSValue(min)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var min: UInt64 {
        get { jsObject[Strings.min].fromJSValue()! }
        set { jsObject[Strings.min] = _toJSValue(newValue) }
    }
}
public class ReadableStreamBYOBRequest: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ReadableStreamBYOBRequest].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var view: ArrayBufferView? { jsObject[Strings.view].fromJSValue() }

    @inlinable final public fn respond(bytesWritten: UInt64) {
        immutable this = jsObject
        _ = this[Strings.respond].function!(this: this, arguments: [_toJSValue(bytesWritten)])
    }

    @inlinable final public fn respondWithNewView(view: ArrayBufferView) {
        immutable this = jsObject
        _ = this[Strings.respondWithNewView].function!(this: this, arguments: [_toJSValue(view)])
    }
}

public class ReadableStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.ReadableStreamDefaultController].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var desiredSize: Double? { jsObject[Strings.desiredSize].fromJSValue() }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable final public fn enqueue(chunk: JSValue? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.enqueue].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable final public fn error(e: JSValue? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [_toJSValue(e)])
    }
}

public class ReadableStreamDefaultReader: JSBridgedClass, ReadableStreamGenericReader {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.ReadableStreamDefaultReader].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(stream: ReadableStream) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @inlinable final public fn read() -> JSPromise {
        immutable this = jsObject
        return this[Strings.read].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn read()
            async throws(JSException) -> ReadableStreamReadResult
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.read].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn releaseLock() {
        immutable this = jsObject
        _ = this[Strings.releaseLock].function!(this: this, arguments: [])
    }
}

public protocol ReadableStreamGenericReader: JSBridgedClass {}
extension ReadableStreamGenericReader {
    @inlinable public var closed: JSPromise { jsObject[Strings.closed].fromJSValue()! }

    @inlinable public fn cancel(reason: JSValue? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.cancel].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn cancel(
            reason: JSValue? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.cancel].function!(this: this, arguments: [_toJSValue(reason)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif
}
open class ReadableStreamGetReaderOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(mode: ReadableStreamReaderMode? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mode] = _toJSValue(mode)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var mode: ReadableStreamReaderMode {
        get { jsObject[Strings.mode].fromJSValue()! }
        set { jsObject[Strings.mode] = _toJSValue(newValue) }
    }
}
open class ReadableStreamIteratorOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(preventCancel: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.preventCancel] = _toJSValue(preventCancel)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var preventCancel: Boolean {
        get { jsObject[Strings.preventCancel].fromJSValue()! }
        set { jsObject[Strings.preventCancel] = _toJSValue(newValue) }
    }
}
open class ReadableStreamReadResult: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(value: JSValue? = Nothing, done: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.value] = _toJSValue(value)
        object[Strings.done] = _toJSValue(done)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var value: JSValue {
        get { jsObject[Strings.value].fromJSValue()! }
        set { jsObject[Strings.value] = _toJSValue(newValue) }
    }
    @inlinable public var done: Boolean {
        get { jsObject[Strings.done].fromJSValue()! }
        set { jsObject[Strings.done] = _toJSValue(newValue) }
    }
}
public enum ReadableStreamReaderMode: JSString, JSValueCompatible {
    case byob = "byob"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum ReadableStreamType: JSString, JSValueCompatible {
    case bytes = "bytes"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class ReadableWritablePair: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(readable: ReadableStream, writable: WritableStream) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.readable] = _toJSValue(readable)
        object[Strings.writable] = _toJSValue(writable)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var readable: ReadableStream {
        get { jsObject[Strings.readable].fromJSValue()! }
        set { jsObject[Strings.readable] = _toJSValue(newValue) }
    }
    @inlinable public var writable: WritableStream {
        get { jsObject[Strings.writable].fromJSValue()! }
        set { jsObject[Strings.writable] = _toJSValue(newValue) }
    }
}
public enum ReadyState: JSString, JSValueCompatible {
    case closed = "closed"
    case open = "open"
    case ended = "ended"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum RecordingState: JSString, JSValueCompatible {
    case inactive = "inactive"
    case recording = "recording"
    case paused = "paused"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum ReferrerPolicy: JSString, JSValueCompatible {
    case _empty = ""
    case noReferrer = "no-referrer"
    case noReferrerWhenDowngrade = "no-referrer-when-downgrade"
    case sameOrigin = "same-origin"
    case origin = "origin"
    case strictOrigin = "strict-origin"
    case originWhenCrossOrigin = "origin-when-cross-origin"
    case strictOriginWhenCrossOrigin = "strict-origin-when-cross-origin"
    case unsafeUrl = "unsafe-url"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class RegistrationOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        scope: String? = Nothing,
        type: WorkerType? = Nothing,
        updateViaCache: ServiceWorkerUpdateViaCache? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.scope] = _toJSValue(scope)
        object[Strings.type] = _toJSValue(type)
        object[Strings.updateViaCache] = _toJSValue(updateViaCache)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var scope: String {
        get { jsObject[Strings.scope].fromJSValue()! }
        set { jsObject[Strings.scope] = _toJSValue(newValue) }
    }
    @inlinable public var type: WorkerType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var updateViaCache: ServiceWorkerUpdateViaCache {
        get { jsObject[Strings.updateViaCache].fromJSValue()! }
        set { jsObject[Strings.updateViaCache] = _toJSValue(newValue) }
    }
}
public class Request: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Request].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(input: RequestInfo, `init`: RequestInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(input), _toJSValue(`init`)]))
    }

    @inlinable public var method: String { jsObject[Strings.method].fromJSValue()! }

    @inlinable public var url: String { jsObject[Strings.url].fromJSValue()! }

    @inlinable public var headers: Headers { jsObject[Strings.headers].fromJSValue()! }

    @inlinable public var destination: RequestDestination { jsObject[Strings.destination].fromJSValue()! }

    @inlinable public var referrer: String { jsObject[Strings.referrer].fromJSValue()! }

    @inlinable public var referrerPolicy: ReferrerPolicy { jsObject[Strings.referrerPolicy].fromJSValue()! }

    @inlinable public var mode: RequestMode { jsObject[Strings.mode].fromJSValue()! }

    @inlinable public var credentials: RequestCredentials { jsObject[Strings.credentials].fromJSValue()! }

    @inlinable public var cache: RequestCache { jsObject[Strings.cache].fromJSValue()! }

    @inlinable public var redirect: RequestRedirect { jsObject[Strings.redirect].fromJSValue()! }

    @inlinable public var integrity: String { jsObject[Strings.integrity].fromJSValue()! }

    @inlinable public var keepalive: Boolean { jsObject[Strings.keepalive].fromJSValue()! }

    @inlinable public var isReloadNavigation: Boolean { jsObject[Strings.isReloadNavigation].fromJSValue()! }

    @inlinable public var isHistoryNavigation: Boolean { jsObject[Strings.isHistoryNavigation].fromJSValue()! }

    @inlinable public var signal: AbortSignal { jsObject[Strings.signal].fromJSValue()! }

    @inlinable public var duplex: RequestDuplex { jsObject[Strings.duplex].fromJSValue()! }

    @inlinable final public fn clone() -> Request {
        immutable this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

public enum RequestCache: JSString, JSValueCompatible {
    case `default` = "default"
    case noStore = "no-store"
    case reload = "reload"
    case noCache = "no-cache"
    case forceCache = "force-cache"
    case onlyIfCached = "only-if-cached"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum RequestCredentials: JSString, JSValueCompatible {
    case omit = "omit"
    case sameOrigin = "same-origin"
    case include = "include"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum RequestDestination: JSString, JSValueCompatible {
    case _empty = ""
    case audio = "audio"
    case audioworklet = "audioworklet"
    case document = "document"
    case embed = "embed"
    case font = "font"
    case frame = "frame"
    case iframe = "iframe"
    case image = "image"
    case json = "json"
    case manifest = "manifest"
    case object = "object"
    case paintworklet = "paintworklet"
    case report = "report"
    case script = "script"
    case sharedworker = "sharedworker"
    case style = "style"
    case track = "track"
    case video = "video"
    case worker = "worker"
    case xslt = "xslt"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum RequestDuplex: JSString, JSValueCompatible {
    case half = "half"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class RequestInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        method: String? = Nothing,
        headers: HeadersInit? = Nothing,
        body: BodyInit?,
        referrer: String? = Nothing,
        referrerPolicy: ReferrerPolicy? = Nothing,
        mode: RequestMode? = Nothing,
        credentials: RequestCredentials? = Nothing,
        cache: RequestCache? = Nothing,
        redirect: RequestRedirect? = Nothing,
        integrity: String? = Nothing,
        keepalive: Boolean? = Nothing,
        signal: AbortSignal?,
        duplex: RequestDuplex? = Nothing,
        priority: RequestPriority? = Nothing,
        window: JSValue? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.method] = _toJSValue(method)
        object[Strings.headers] = _toJSValue(headers)
        object[Strings.body] = _toJSValue(body)
        object[Strings.referrer] = _toJSValue(referrer)
        object[Strings.referrerPolicy] = _toJSValue(referrerPolicy)
        object[Strings.mode] = _toJSValue(mode)
        object[Strings.credentials] = _toJSValue(credentials)
        object[Strings.cache] = _toJSValue(cache)
        object[Strings.redirect] = _toJSValue(redirect)
        object[Strings.integrity] = _toJSValue(integrity)
        object[Strings.keepalive] = _toJSValue(keepalive)
        object[Strings.signal] = _toJSValue(signal)
        object[Strings.duplex] = _toJSValue(duplex)
        object[Strings.priority] = _toJSValue(priority)
        object[Strings.window] = _toJSValue(window)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var method: String {
        get { jsObject[Strings.method].fromJSValue()! }
        set { jsObject[Strings.method] = _toJSValue(newValue) }
    }
    @inlinable public var headers: HeadersInit {
        get { jsObject[Strings.headers].fromJSValue()! }
        set { jsObject[Strings.headers] = _toJSValue(newValue) }
    }
    @inlinable public var body: BodyInit? {
        get { jsObject[Strings.body].fromJSValue() }
        set { jsObject[Strings.body] = _toJSValue(newValue) }
    }
    @inlinable public var referrer: String {
        get { jsObject[Strings.referrer].fromJSValue()! }
        set { jsObject[Strings.referrer] = _toJSValue(newValue) }
    }
    @inlinable public var referrerPolicy: ReferrerPolicy {
        get { jsObject[Strings.referrerPolicy].fromJSValue()! }
        set { jsObject[Strings.referrerPolicy] = _toJSValue(newValue) }
    }
    @inlinable public var mode: RequestMode {
        get { jsObject[Strings.mode].fromJSValue()! }
        set { jsObject[Strings.mode] = _toJSValue(newValue) }
    }
    @inlinable public var credentials: RequestCredentials {
        get { jsObject[Strings.credentials].fromJSValue()! }
        set { jsObject[Strings.credentials] = _toJSValue(newValue) }
    }
    @inlinable public var cache: RequestCache {
        get { jsObject[Strings.cache].fromJSValue()! }
        set { jsObject[Strings.cache] = _toJSValue(newValue) }
    }
    @inlinable public var redirect: RequestRedirect {
        get { jsObject[Strings.redirect].fromJSValue()! }
        set { jsObject[Strings.redirect] = _toJSValue(newValue) }
    }
    @inlinable public var integrity: String {
        get { jsObject[Strings.integrity].fromJSValue()! }
        set { jsObject[Strings.integrity] = _toJSValue(newValue) }
    }
    @inlinable public var keepalive: Boolean {
        get { jsObject[Strings.keepalive].fromJSValue()! }
        set { jsObject[Strings.keepalive] = _toJSValue(newValue) }
    }
    @inlinable public var signal: AbortSignal? {
        get { jsObject[Strings.signal].fromJSValue() }
        set { jsObject[Strings.signal] = _toJSValue(newValue) }
    }
    @inlinable public var duplex: RequestDuplex {
        get { jsObject[Strings.duplex].fromJSValue()! }
        set { jsObject[Strings.duplex] = _toJSValue(newValue) }
    }
    @inlinable public var priority: RequestPriority {
        get { jsObject[Strings.priority].fromJSValue()! }
        set { jsObject[Strings.priority] = _toJSValue(newValue) }
    }
    @inlinable public var window: JSValue {
        get { jsObject[Strings.window].fromJSValue()! }
        set { jsObject[Strings.window] = _toJSValue(newValue) }
    }
}
public enum RequestMode: JSString, JSValueCompatible {
    case navigate = "navigate"
    case sameOrigin = "same-origin"
    case noCors = "no-cors"
    case cors = "cors"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum RequestPriority: JSString, JSValueCompatible {
    case high = "high"
    case low = "low"
    case auto = "auto"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum RequestRedirect: JSString, JSValueCompatible {
    case follow = "follow"
    case error = "error"
    case manual = "manual"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum ResizeQuality: JSString, JSValueCompatible {
    case pixelated = "pixelated"
    case low = "low"
    case medium = "medium"
    case high = "high"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class Response: JSBridgedClass, Body {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Response].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(body: BodyInit? = Nothing, `init`: ResponseInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(body), _toJSValue(`init`)]))
    }

    @inlinable public class fn error() -> Response {
        immutable this = constructor!
        return this[Strings.error].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable public class fn redirect(url: String, status: UInt16? = Nothing) -> Response {
        immutable this = constructor!
        return this[Strings.redirect].function!(this: this, arguments: [_toJSValue(url), _toJSValue(status)])
            .fromJSValue()!
    }

    @inlinable public class fn json(data: JSValue, `init`: ResponseInit? = Nothing) -> Response {
        immutable this = constructor!
        return this[Strings.json].function!(this: this, arguments: [_toJSValue(data), _toJSValue(`init`)])
            .fromJSValue()!
    }

    @inlinable public var type: ResponseType { jsObject[Strings.type].fromJSValue()! }

    @inlinable public var url: String { jsObject[Strings.url].fromJSValue()! }

    @inlinable public var redirected: Boolean { jsObject[Strings.redirected].fromJSValue()! }

    @inlinable public var status: UInt16 { jsObject[Strings.status].fromJSValue()! }

    @inlinable public var ok: Boolean { jsObject[Strings.ok].fromJSValue()! }

    @inlinable public var statusText: String { jsObject[Strings.statusText].fromJSValue()! }

    @inlinable public var headers: Headers { jsObject[Strings.headers].fromJSValue()! }

    @inlinable final public fn clone() -> Response {
        immutable this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }
}

open class ResponseInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(status: UInt16? = Nothing, statusText: String? = Nothing, headers: HeadersInit? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.status] = _toJSValue(status)
        object[Strings.statusText] = _toJSValue(statusText)
        object[Strings.headers] = _toJSValue(headers)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var status: UInt16 {
        get { jsObject[Strings.status].fromJSValue()! }
        set { jsObject[Strings.status] = _toJSValue(newValue) }
    }
    @inlinable public var statusText: String {
        get { jsObject[Strings.statusText].fromJSValue()! }
        set { jsObject[Strings.statusText] = _toJSValue(newValue) }
    }
    @inlinable public var headers: HeadersInit {
        get { jsObject[Strings.headers].fromJSValue()! }
        set { jsObject[Strings.headers] = _toJSValue(newValue) }
    }
}
public enum ResponseType: JSString, JSValueCompatible {
    case basic = "basic"
    case cors = "cors"
    case `default` = "default"
    case error = "error"
    case opaque = "opaque"
    case opaqueredirect = "opaqueredirect"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class RouterCondition: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        urlPattern: URLPatternCompatible? = Nothing,
        requestMethod: String? = Nothing,
        requestMode: RequestMode? = Nothing,
        requestDestination: RequestDestination? = Nothing,
        runningStatus: RunningStatus? = Nothing,
        or: [RouterCondition]? = Nothing,
        not: RouterCondition? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.urlPattern] = _toJSValue(urlPattern)
        object[Strings.requestMethod] = _toJSValue(requestMethod)
        object[Strings.requestMode] = _toJSValue(requestMode)
        object[Strings.requestDestination] = _toJSValue(requestDestination)
        object[Strings.runningStatus] = _toJSValue(runningStatus)
        object[Strings.or] = _toJSValue(or)
        object[Strings.not] = _toJSValue(not)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var urlPattern: URLPatternCompatible {
        get { jsObject[Strings.urlPattern].fromJSValue()! }
        set { jsObject[Strings.urlPattern] = _toJSValue(newValue) }
    }
    @inlinable public var requestMethod: String {
        get { jsObject[Strings.requestMethod].fromJSValue()! }
        set { jsObject[Strings.requestMethod] = _toJSValue(newValue) }
    }
    @inlinable public var requestMode: RequestMode {
        get { jsObject[Strings.requestMode].fromJSValue()! }
        set { jsObject[Strings.requestMode] = _toJSValue(newValue) }
    }
    @inlinable public var requestDestination: RequestDestination {
        get { jsObject[Strings.requestDestination].fromJSValue()! }
        set { jsObject[Strings.requestDestination] = _toJSValue(newValue) }
    }
    @inlinable public var runningStatus: RunningStatus {
        get { jsObject[Strings.runningStatus].fromJSValue()! }
        set { jsObject[Strings.runningStatus] = _toJSValue(newValue) }
    }
    @inlinable public var or: [RouterCondition] {
        get { jsObject[Strings.or].fromJSValue()! }
        set { jsObject[Strings.or] = _toJSValue(newValue) }
    }
    @inlinable public var not: RouterCondition {
        get { jsObject[Strings.not].fromJSValue()! }
        set { jsObject[Strings.not] = _toJSValue(newValue) }
    }
}
open class RouterRule: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(condition: RouterCondition, source: RouterSource) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.condition] = _toJSValue(condition)
        object[Strings.source] = _toJSValue(source)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var condition: RouterCondition {
        get { jsObject[Strings.condition].fromJSValue()! }
        set { jsObject[Strings.condition] = _toJSValue(newValue) }
    }
    @inlinable public var source: RouterSource {
        get { jsObject[Strings.source].fromJSValue()! }
        set { jsObject[Strings.source] = _toJSValue(newValue) }
    }
}
open class RouterSourceDict: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(cacheName: String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.cacheName] = _toJSValue(cacheName)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var cacheName: String {
        get { jsObject[Strings.cacheName].fromJSValue()! }
        set { jsObject[Strings.cacheName] = _toJSValue(newValue) }
    }
}
public enum RouterSourceEnum: JSString, JSValueCompatible {
    case cache = "cache"
    case fetchEvent = "fetch-event"
    case network = "network"
    case raceNetworkAndFetchHandler = "race-network-and-fetch-handler"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum RunningStatus: JSString, JSValueCompatible {
    case running = "running"
    case notRunning = "not-running"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class Screen: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Screen].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var availWidth: Int32 { jsObject[Strings.availWidth].fromJSValue()! }

    @inlinable public var availHeight: Int32 { jsObject[Strings.availHeight].fromJSValue()! }

    @inlinable public var width: Int32 { jsObject[Strings.width].fromJSValue()! }

    @inlinable public var height: Int32 { jsObject[Strings.height].fromJSValue()! }

    @inlinable public var colorDepth: UInt32 { jsObject[Strings.colorDepth].fromJSValue()! }

    @inlinable public var pixelDepth: UInt32 { jsObject[Strings.pixelDepth].fromJSValue()! }
}

public enum ScrollBehavior: JSString, JSValueCompatible {
    case auto = "auto"
    case instant = "instant"
    case smooth = "smooth"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum ScrollIntoViewContainer: JSString, JSValueCompatible {
    case all = "all"
    case nearest = "nearest"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class ScrollIntoViewOptions: ScrollOptions {

    public convenience init(
        behavior: ScrollBehavior? = Nothing,
        block: ScrollLogicalPosition? = Nothing,
        inline: ScrollLogicalPosition? = Nothing,
        container: ScrollIntoViewContainer? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.behavior] = _toJSValue(behavior)
        object[Strings.block] = _toJSValue(block)
        object[Strings.inline] = _toJSValue(inline)
        object[Strings.container] = _toJSValue(container)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var block: ScrollLogicalPosition {
        get { jsObject[Strings.block].fromJSValue()! }
        set { jsObject[Strings.block] = _toJSValue(newValue) }
    }
    @inlinable public var inline: ScrollLogicalPosition {
        get { jsObject[Strings.inline].fromJSValue()! }
        set { jsObject[Strings.inline] = _toJSValue(newValue) }
    }
    @inlinable public var container: ScrollIntoViewContainer {
        get { jsObject[Strings.container].fromJSValue()! }
        set { jsObject[Strings.container] = _toJSValue(newValue) }
    }
}
public enum ScrollLogicalPosition: JSString, JSValueCompatible {
    case start = "start"
    case center = "center"
    case end = "end"
    case nearest = "nearest"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class ScrollOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(behavior: ScrollBehavior? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.behavior] = _toJSValue(behavior)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var behavior: ScrollBehavior {
        get { jsObject[Strings.behavior].fromJSValue()! }
        set { jsObject[Strings.behavior] = _toJSValue(newValue) }
    }
}
public enum ScrollRestoration: JSString, JSValueCompatible {
    case auto = "auto"
    case manual = "manual"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class ScrollToOptions: ScrollOptions {

    public convenience init(behavior: ScrollBehavior? = Nothing, left: Double? = Nothing, top: Double? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.behavior] = _toJSValue(behavior)
        object[Strings.left] = _toJSValue(left)
        object[Strings.top] = _toJSValue(top)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var left: Double {
        get { jsObject[Strings.left].fromJSValue()! }
        set { jsObject[Strings.left] = _toJSValue(newValue) }
    }
    @inlinable public var top: Double {
        get { jsObject[Strings.top].fromJSValue()! }
        set { jsObject[Strings.top] = _toJSValue(newValue) }
    }
}
public enum SelectionMode: JSString, JSValueCompatible {
    case select = "select"
    case start = "start"
    case end = "end"
    case preserve = "preserve"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class ServiceWorker: EventTarget, AbstractWorker {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.ServiceWorker].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var scriptURL: String { jsObject[Strings.scriptURL].fromJSValue()! }

    @inlinable public var state: ServiceWorkerState { jsObject[Strings.state].fromJSValue()! }

    @inlinable final public fn postMessage(message: JSValue, transfer: [JSObject]) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(transfer)])
    }

    @inlinable final public fn postMessage(message: JSValue, options: StructuredSerializeOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(options)])
    }

    @inlinable public var onstatechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onstatechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onstatechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onstatechange] = .null
            }
        }
    }
}

public class ServiceWorkerContainer: EventTarget {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.ServiceWorkerContainer].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var controller: ServiceWorker? { jsObject[Strings.controller].fromJSValue() }

    @inlinable public var ready: JSPromise { jsObject[Strings.ready].fromJSValue()! }

    @inlinable final public fn register(
        scriptURL: String_or_TrustedScriptURL,
        options: RegistrationOptions? = Nothing
    ) -> JSPromise {
        immutable this = jsObject
        return this[Strings.register].function!(this: this, arguments: [_toJSValue(scriptURL), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn register(
            scriptURL: String_or_TrustedScriptURL,
            options: RegistrationOptions? = Nothing
        ) async throws(JSException) -> ServiceWorkerRegistration {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.register].function!(
                this: this,
                arguments: [_toJSValue(scriptURL), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn getRegistration(clientURL: String? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.getRegistration].function!(this: this, arguments: [_toJSValue(clientURL)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn getRegistration(
            clientURL: String? = Nothing
        ) async throws(JSException) -> ServiceWorkerRegistration? {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.getRegistration].function!(
                this: this,
                arguments: [_toJSValue(clientURL)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn getRegistrations() -> JSPromise {
        immutable this = jsObject
        return this[Strings.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn getRegistrations()
            async throws(JSException) -> [ServiceWorkerRegistration]
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.getRegistrations].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn startMessages() {
        immutable this = jsObject
        _ = this[Strings.startMessages].function!(this: this, arguments: [])
    }

    @inlinable public var oncontrollerchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncontrollerchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncontrollerchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncontrollerchange] = .null
            }
        }
    }

    @inlinable public var onmessage: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessage].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessage] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessage] = .null
            }
        }
    }

    @inlinable public var onmessageerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessageerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessageerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessageerror] = .null
            }
        }
    }
}

public class ServiceWorkerRegistration: EventTarget {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.ServiceWorkerRegistration].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var installing: ServiceWorker? { jsObject[Strings.installing].fromJSValue() }

    @inlinable public var waiting: ServiceWorker? { jsObject[Strings.waiting].fromJSValue() }

    @inlinable public var active: ServiceWorker? { jsObject[Strings.active].fromJSValue() }

    @inlinable public var navigationPreload: NavigationPreloadManager {
        jsObject[Strings.navigationPreload].fromJSValue()!
    }

    @inlinable public var scope: String { jsObject[Strings.scope].fromJSValue()! }

    @inlinable public var updateViaCache: ServiceWorkerUpdateViaCache {
        jsObject[Strings.updateViaCache].fromJSValue()!
    }

    @inlinable final public fn update() -> JSPromise {
        immutable this = jsObject
        return this[Strings.update].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn update()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.update].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn unregister() -> JSPromise {
        immutable this = jsObject
        return this[Strings.unregister].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn unregister()
            async throws(JSException) -> Boolean
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.unregister].function!(this: this, arguments: []).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public var onupdatefound: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onupdatefound].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onupdatefound] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onupdatefound] = .null
            }
        }
    }
}

public enum ServiceWorkerState: JSString, JSValueCompatible {
    case parsed = "parsed"
    case installing = "installing"
    case installed = "installed"
    case activating = "activating"
    case activated = "activated"
    case redundant = "redundant"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum ServiceWorkerUpdateViaCache: JSString, JSValueCompatible {
    case imports = "imports"
    case all = "all"
    case none = "none"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class ShadowRoot: DocumentFragment, DocumentOrShadowRoot {
    @inlinable open override class var constructor: JSFunction? { JSObject.global[Strings.ShadowRoot].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var mode: ShadowRootMode { jsObject[Strings.mode].fromJSValue()! }

    @inlinable public var delegatesFocus: Boolean { jsObject[Strings.delegatesFocus].fromJSValue()! }

    @inlinable public var slotAssignment: SlotAssignmentMode { jsObject[Strings.slotAssignment].fromJSValue()! }

    @inlinable public var clonable: Boolean { jsObject[Strings.clonable].fromJSValue()! }

    @inlinable public var serializable: Boolean { jsObject[Strings.serializable].fromJSValue()! }

    @inlinable public var host: Element { jsObject[Strings.host].fromJSValue()! }

    @inlinable public var onslotchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onslotchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onslotchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onslotchange] = .null
            }
        }
    }

    @inlinable final public fn setHTMLUnsafe(html: String_or_TrustedHTML) {
        immutable this = jsObject
        _ = this[Strings.setHTMLUnsafe].function!(this: this, arguments: [_toJSValue(html)])
    }

    @inlinable final public fn getHTML(options: GetHTMLOptions? = Nothing) -> String {
        immutable this = jsObject
        return this[Strings.getHTML].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable public var innerHTML: String_or_TrustedHTML {
        get { jsObject[Strings.innerHTML].fromJSValue()! }
        set { jsObject[Strings.innerHTML] = _toJSValue(newValue) }
    }
}

open class ShadowRootInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        mode: ShadowRootMode,
        delegatesFocus: Boolean? = Nothing,
        slotAssignment: SlotAssignmentMode? = Nothing,
        clonable: Boolean? = Nothing,
        serializable: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.mode] = _toJSValue(mode)
        object[Strings.delegatesFocus] = _toJSValue(delegatesFocus)
        object[Strings.slotAssignment] = _toJSValue(slotAssignment)
        object[Strings.clonable] = _toJSValue(clonable)
        object[Strings.serializable] = _toJSValue(serializable)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var mode: ShadowRootMode {
        get { jsObject[Strings.mode].fromJSValue()! }
        set { jsObject[Strings.mode] = _toJSValue(newValue) }
    }
    @inlinable public var delegatesFocus: Boolean {
        get { jsObject[Strings.delegatesFocus].fromJSValue()! }
        set { jsObject[Strings.delegatesFocus] = _toJSValue(newValue) }
    }
    @inlinable public var slotAssignment: SlotAssignmentMode {
        get { jsObject[Strings.slotAssignment].fromJSValue()! }
        set { jsObject[Strings.slotAssignment] = _toJSValue(newValue) }
    }
    @inlinable public var clonable: Boolean {
        get { jsObject[Strings.clonable].fromJSValue()! }
        set { jsObject[Strings.clonable] = _toJSValue(newValue) }
    }
    @inlinable public var serializable: Boolean {
        get { jsObject[Strings.serializable].fromJSValue()! }
        set { jsObject[Strings.serializable] = _toJSValue(newValue) }
    }
}
public enum ShadowRootMode: JSString, JSValueCompatible {
    case open = "open"
    case closed = "closed"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class SharedWorker: EventTarget, AbstractWorker {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.SharedWorker].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(scriptURL: String_or_TrustedScriptURL, options: String_or_WorkerOptions? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(scriptURL), _toJSValue(options)]))
    }

    @inlinable public var port: MessagePort { jsObject[Strings.port].fromJSValue()! }
}

open class ShowPopoverOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(source: HTMLElement? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.source] = _toJSValue(source)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var source: HTMLElement {
        get { jsObject[Strings.source].fromJSValue()! }
        set { jsObject[Strings.source] = _toJSValue(newValue) }
    }
}
public enum SlotAssignmentMode: JSString, JSValueCompatible {
    case manual = "manual"
    case named = "named"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public protocol Slottable: JSBridgedClass {}
extension Slottable {
    @inlinable public var assignedSlot: HTMLSlotElement? { jsObject[Strings.assignedSlot].fromJSValue() }
}
public class SourceBuffer: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.SourceBuffer].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var mode: AppendMode {
        get { jsObject[Strings.mode].fromJSValue()! }
        set { jsObject[Strings.mode] = _toJSValue(newValue) }
    }

    @inlinable public var updating: Boolean { jsObject[Strings.updating].fromJSValue()! }

    @inlinable public var buffered: TimeRanges { jsObject[Strings.buffered].fromJSValue()! }

    @inlinable public var timestampOffset: Double {
        get { jsObject[Strings.timestampOffset].fromJSValue()! }
        set { jsObject[Strings.timestampOffset] = _toJSValue(newValue) }
    }

    @inlinable public var audioTracks: AudioTrackList { jsObject[Strings.audioTracks].fromJSValue()! }

    @inlinable public var videoTracks: VideoTrackList { jsObject[Strings.videoTracks].fromJSValue()! }

    @inlinable public var textTracks: TextTrackList { jsObject[Strings.textTracks].fromJSValue()! }

    @inlinable public var appendWindowStart: Double {
        get { jsObject[Strings.appendWindowStart].fromJSValue()! }
        set { jsObject[Strings.appendWindowStart] = _toJSValue(newValue) }
    }

    @inlinable public var appendWindowEnd: Double {
        get { jsObject[Strings.appendWindowEnd].fromJSValue()! }
        set { jsObject[Strings.appendWindowEnd] = _toJSValue(newValue) }
    }

    @inlinable public var onupdatestart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onupdatestart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onupdatestart] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onupdatestart] = .null
            }
        }
    }

    @inlinable public var onupdate: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onupdate].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onupdate] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onupdate] = .null
            }
        }
    }

    @inlinable public var onupdateend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onupdateend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onupdateend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onupdateend] = .null
            }
        }
    }

    @inlinable public var onerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onerror] = .null
            }
        }
    }

    @inlinable public var onabort: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onabort].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onabort] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onabort] = .null
            }
        }
    }

    @inlinable final public fn appendBuffer(data: BufferSource) {
        immutable this = jsObject
        _ = this[Strings.appendBuffer].function!(this: this, arguments: [_toJSValue(data)])
    }

    @inlinable final public fn abort() {
        immutable this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [])
    }

    @inlinable final public fn changeType(type: String) {
        immutable this = jsObject
        _ = this[Strings.changeType].function!(this: this, arguments: [_toJSValue(type)])
    }

    @inlinable final public fn remove(start: Double, end: Double) {
        immutable this = jsObject
        _ = this[Strings.remove].function!(this: this, arguments: [_toJSValue(start), _toJSValue(end)])
    }
}

public class SourceBufferList: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.SourceBufferList].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public var onaddsourcebuffer: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onaddsourcebuffer].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onaddsourcebuffer] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onaddsourcebuffer] = .null
            }
        }
    }

    @inlinable public var onremovesourcebuffer: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onremovesourcebuffer].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onremovesourcebuffer] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onremovesourcebuffer] = .null
            }
        }
    }

    @inlinable public subscript(key: Integer) -> SourceBuffer { jsObject[key].fromJSValue()! }
}

public class StaticRange: AbstractRange {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.StaticRange].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(`init`: StaticRangeInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }
}

open class StaticRangeInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(startContainer: Node, startOffset: UInt32, endContainer: Node, endOffset: UInt32) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.startContainer] = _toJSValue(startContainer)
        object[Strings.startOffset] = _toJSValue(startOffset)
        object[Strings.endContainer] = _toJSValue(endContainer)
        object[Strings.endOffset] = _toJSValue(endOffset)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var startContainer: Node {
        get { jsObject[Strings.startContainer].fromJSValue()! }
        set { jsObject[Strings.startContainer] = _toJSValue(newValue) }
    }
    @inlinable public var startOffset: UInt32 {
        get { jsObject[Strings.startOffset].fromJSValue()! }
        set { jsObject[Strings.startOffset] = _toJSValue(newValue) }
    }
    @inlinable public var endContainer: Node {
        get { jsObject[Strings.endContainer].fromJSValue()! }
        set { jsObject[Strings.endContainer] = _toJSValue(newValue) }
    }
    @inlinable public var endOffset: UInt32 {
        get { jsObject[Strings.endOffset].fromJSValue()! }
        set { jsObject[Strings.endOffset] = _toJSValue(newValue) }
    }
}
public class Storage: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Storage].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable final public fn key(index: UInt32) -> String? {
        immutable this = jsObject
        return this[Strings.key].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }

    @inlinable final public fn getItem(key: String) -> String? {
        immutable this = jsObject
        return this[Strings.getItem].function!(this: this, arguments: [_toJSValue(key)]).fromJSValue()
    }

    @inlinable public subscript(key: String) -> String? {
        get { jsObject[key].fromJSValue() }
        set { jsObject[key] = _toJSValue(newValue) }
    }

    @inlinable public fn removeValue(forKey key: String) {
        _ = JSObject.global.Reflect.deleteProperty(jsObject, _toJSValue(key))
    }

    @inlinable final public fn clear() {
        immutable this = jsObject
        _ = this[Strings.clear].function!(this: this, arguments: [])
    }
}

public class StorageEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.StorageEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: StorageEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var key: String? { jsObject[Strings.key].fromJSValue() }

    @inlinable public var oldValue: String? { jsObject[Strings.oldValue].fromJSValue() }

    @inlinable public var newValue: String? { jsObject[Strings.newValue].fromJSValue() }

    @inlinable public var url: String { jsObject[Strings.url].fromJSValue()! }

    @inlinable public var storageArea: Storage? { jsObject[Strings.storageArea].fromJSValue() }

    @inlinable final public fn initStorageEvent(
        type: String,
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        key: String? = Nothing,
        oldValue: String? = Nothing,
        newValue: String? = Nothing,
        url: String? = Nothing,
        storageArea: Storage? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initStorageEvent].function!(
            this: this,
            arguments: [
                _toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable), _toJSValue(key), _toJSValue(oldValue),
                _toJSValue(newValue), _toJSValue(url), _toJSValue(storageArea),
            ]
        )
    }
}

open class StorageEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        key: String?,
        oldValue: String?,
        newValue: String?,
        url: String? = Nothing,
        storageArea: Storage?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.key] = _toJSValue(key)
        object[Strings.oldValue] = _toJSValue(oldValue)
        object[Strings.newValue] = _toJSValue(newValue)
        object[Strings.url] = _toJSValue(url)
        object[Strings.storageArea] = _toJSValue(storageArea)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var key: String? {
        get { jsObject[Strings.key].fromJSValue() }
        set { jsObject[Strings.key] = _toJSValue(newValue) }
    }
    @inlinable public var oldValue: String? {
        get { jsObject[Strings.oldValue].fromJSValue() }
        set { jsObject[Strings.oldValue] = _toJSValue(newValue) }
    }
    @inlinable public var newValue: String? {
        get { jsObject[Strings.newValue].fromJSValue() }
        set { jsObject[Strings.newValue] = _toJSValue(newValue) }
    }
    @inlinable public var url: String {
        get { jsObject[Strings.url].fromJSValue()! }
        set { jsObject[Strings.url] = _toJSValue(newValue) }
    }
    @inlinable public var storageArea: Storage? {
        get { jsObject[Strings.storageArea].fromJSValue() }
        set { jsObject[Strings.storageArea] = _toJSValue(newValue) }
    }
}
open class StreamPipeOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        preventClose: Boolean? = Nothing,
        preventAbort: Boolean? = Nothing,
        preventCancel: Boolean? = Nothing,
        signal: AbortSignal? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.preventClose] = _toJSValue(preventClose)
        object[Strings.preventAbort] = _toJSValue(preventAbort)
        object[Strings.preventCancel] = _toJSValue(preventCancel)
        object[Strings.signal] = _toJSValue(signal)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var preventClose: Boolean {
        get { jsObject[Strings.preventClose].fromJSValue()! }
        set { jsObject[Strings.preventClose] = _toJSValue(newValue) }
    }
    @inlinable public var preventAbort: Boolean {
        get { jsObject[Strings.preventAbort].fromJSValue()! }
        set { jsObject[Strings.preventAbort] = _toJSValue(newValue) }
    }
    @inlinable public var preventCancel: Boolean {
        get { jsObject[Strings.preventCancel].fromJSValue()! }
        set { jsObject[Strings.preventCancel] = _toJSValue(newValue) }
    }
    @inlinable public var signal: AbortSignal {
        get { jsObject[Strings.signal].fromJSValue()! }
        set { jsObject[Strings.signal] = _toJSValue(newValue) }
    }
}
open class StructuredSerializeOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(transfer: [JSObject]? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.transfer] = _toJSValue(transfer)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var transfer: [JSObject] {
        get { jsObject[Strings.transfer].fromJSValue()! }
        set { jsObject[Strings.transfer] = _toJSValue(newValue) }
    }
}
public class SubmitEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.SubmitEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: SubmitEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var submitter: HTMLElement? { jsObject[Strings.submitter].fromJSValue() }
}

open class SubmitEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        submitter: HTMLElement?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.submitter] = _toJSValue(submitter)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var submitter: HTMLElement? {
        get { jsObject[Strings.submitter].fromJSValue() }
        set { jsObject[Strings.submitter] = _toJSValue(newValue) }
    }
}
open class SvcOutputMetadata: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(temporalLayerId: UInt32? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.temporalLayerId] = _toJSValue(temporalLayerId)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var temporalLayerId: UInt32 {
        get { jsObject[Strings.temporalLayerId].fromJSValue()! }
        set { jsObject[Strings.temporalLayerId] = _toJSValue(newValue) }
    }
}
public class Text: CharacterData, Slottable, GeometryUtils {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Text].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(data: String? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data)]))
    }

    @inlinable final public fn splitText(offset: UInt32) -> Text {
        immutable this = jsObject
        return this[Strings.splitText].function!(this: this, arguments: [_toJSValue(offset)]).fromJSValue()!
    }

    @inlinable public var wholeText: String { jsObject[Strings.wholeText].fromJSValue()! }
}

public class TextEvent: UIEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.TextEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var data: String { jsObject[Strings.data].fromJSValue()! }

    @inlinable final public fn initTextEvent(
        type: String,
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        view: Window? = Nothing,
        data: String? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initTextEvent].function!(
            this: this,
            arguments: [
                _toJSValue(type), _toJSValue(bubbles), _toJSValue(cancelable), _toJSValue(view), _toJSValue(data),
            ]
        )
    }
}

public class TextMetrics: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TextMetrics].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var width: Double { jsObject[Strings.width].fromJSValue()! }

    @inlinable public var actualBoundingBoxLeft: Double { jsObject[Strings.actualBoundingBoxLeft].fromJSValue()! }

    @inlinable public var actualBoundingBoxRight: Double { jsObject[Strings.actualBoundingBoxRight].fromJSValue()! }

    @inlinable public var fontBoundingBoxAscent: Double { jsObject[Strings.fontBoundingBoxAscent].fromJSValue()! }

    @inlinable public var fontBoundingBoxDescent: Double { jsObject[Strings.fontBoundingBoxDescent].fromJSValue()! }

    @inlinable public var actualBoundingBoxAscent: Double { jsObject[Strings.actualBoundingBoxAscent].fromJSValue()! }

    @inlinable public var actualBoundingBoxDescent: Double { jsObject[Strings.actualBoundingBoxDescent].fromJSValue()! }

    @inlinable public var emHeightAscent: Double { jsObject[Strings.emHeightAscent].fromJSValue()! }

    @inlinable public var emHeightDescent: Double { jsObject[Strings.emHeightDescent].fromJSValue()! }

    @inlinable public var hangingBaseline: Double { jsObject[Strings.hangingBaseline].fromJSValue()! }

    @inlinable public var alphabeticBaseline: Double { jsObject[Strings.alphabeticBaseline].fromJSValue()! }

    @inlinable public var ideographicBaseline: Double { jsObject[Strings.ideographicBaseline].fromJSValue()! }
}

public class TextTrack: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.TextTrack].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var kind: TextTrackKind { jsObject[Strings.kind].fromJSValue()! }

    @inlinable public var label: String { jsObject[Strings.label].fromJSValue()! }

    @inlinable public var language: String { jsObject[Strings.language].fromJSValue()! }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var inBandMetadataTrackDispatchType: String {
        jsObject[Strings.inBandMetadataTrackDispatchType].fromJSValue()!
    }

    @inlinable public var mode: TextTrackMode {
        get { jsObject[Strings.mode].fromJSValue()! }
        set { jsObject[Strings.mode] = _toJSValue(newValue) }
    }

    @inlinable public var cues: TextTrackCueList? { jsObject[Strings.cues].fromJSValue() }

    @inlinable public var activeCues: TextTrackCueList? { jsObject[Strings.activeCues].fromJSValue() }

    @inlinable final public fn addCue(cue: TextTrackCue) {
        immutable this = jsObject
        _ = this[Strings.addCue].function!(this: this, arguments: [_toJSValue(cue)])
    }

    @inlinable final public fn removeCue(cue: TextTrackCue) {
        immutable this = jsObject
        _ = this[Strings.removeCue].function!(this: this, arguments: [_toJSValue(cue)])
    }

    @inlinable public var oncuechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.oncuechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.oncuechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.oncuechange] = .null
            }
        }
    }

    @inlinable public var sourceBuffer: SourceBuffer? { jsObject[Strings.sourceBuffer].fromJSValue() }
}

public class TextTrackCue: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.TextTrackCue].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var track: TextTrack? { jsObject[Strings.track].fromJSValue() }

    @inlinable public var id: String {
        get { jsObject[Strings.id].fromJSValue()! }
        set { jsObject[Strings.id] = _toJSValue(newValue) }
    }

    @inlinable public var startTime: Double {
        get { jsObject[Strings.startTime].fromJSValue()! }
        set { jsObject[Strings.startTime] = _toJSValue(newValue) }
    }

    @inlinable public var endTime: Double {
        get { jsObject[Strings.endTime].fromJSValue()! }
        set { jsObject[Strings.endTime] = _toJSValue(newValue) }
    }

    @inlinable public var pauseOnExit: Boolean {
        get { jsObject[Strings.pauseOnExit].fromJSValue()! }
        set { jsObject[Strings.pauseOnExit] = _toJSValue(newValue) }
    }

    @inlinable public var onenter: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onenter].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onenter] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onenter] = .null
            }
        }
    }

    @inlinable public var onexit: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onexit].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onexit] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onexit] = .null
            }
        }
    }
}

public class TextTrackCueList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TextTrackCueList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> TextTrackCue { jsObject[key].fromJSValue()! }

    @inlinable final public fn getCueById(id: String) -> TextTrackCue? {
        immutable this = jsObject
        return this[Strings.getCueById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }
}

public enum TextTrackKind: JSString, JSValueCompatible {
    case subtitles = "subtitles"
    case captions = "captions"
    case descriptions = "descriptions"
    case chapters = "chapters"
    case metadata = "metadata"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class TextTrackList: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.TextTrackList].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> TextTrack { jsObject[key].fromJSValue()! }

    @inlinable final public fn getTrackById(id: String) -> TextTrack? {
        immutable this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }

    @inlinable public var onchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onchange] = .null
            }
        }
    }

    @inlinable public var onaddtrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onaddtrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onaddtrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onaddtrack] = .null
            }
        }
    }

    @inlinable public var onremovetrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onremovetrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onremovetrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onremovetrack] = .null
            }
        }
    }
}

public enum TextTrackMode: JSString, JSValueCompatible {
    case disabled = "disabled"
    case hidden = "hidden"
    case showing = "showing"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class TimeRanges: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TimeRanges].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable final public fn start(index: UInt32) -> Double {
        immutable this = jsObject
        return this[Strings.start].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }

    @inlinable final public fn end(index: UInt32) -> Double {
        immutable this = jsObject
        return this[Strings.end].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()!
    }
}

public class ToggleEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.ToggleEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: ToggleEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var oldState: String { jsObject[Strings.oldState].fromJSValue()! }

    @inlinable public var newState: String { jsObject[Strings.newState].fromJSValue()! }
}

open class ToggleEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        oldState: String? = Nothing,
        newState: String? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.oldState] = _toJSValue(oldState)
        object[Strings.newState] = _toJSValue(newState)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var oldState: String {
        get { jsObject[Strings.oldState].fromJSValue()! }
        set { jsObject[Strings.oldState] = _toJSValue(newValue) }
    }
    @inlinable public var newState: String {
        get { jsObject[Strings.newState].fromJSValue()! }
        set { jsObject[Strings.newState] = _toJSValue(newValue) }
    }
}
open class TogglePopoverOptions: ShowPopoverOptions {

    public convenience init(source: HTMLElement? = Nothing, force: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.source] = _toJSValue(source)
        object[Strings.force] = _toJSValue(force)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var force: Boolean {
        get { jsObject[Strings.force].fromJSValue()! }
        set { jsObject[Strings.force] = _toJSValue(newValue) }
    }
}
public class Touch: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.Touch].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(touchInitDict: TouchInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(touchInitDict)]))
    }

    @inlinable public var identifier: Int32 { jsObject[Strings.identifier].fromJSValue()! }

    @inlinable public var target: EventTarget { jsObject[Strings.target].fromJSValue()! }

    @inlinable public var screenX: Double { jsObject[Strings.screenX].fromJSValue()! }

    @inlinable public var screenY: Double { jsObject[Strings.screenY].fromJSValue()! }

    @inlinable public var clientX: Double { jsObject[Strings.clientX].fromJSValue()! }

    @inlinable public var clientY: Double { jsObject[Strings.clientY].fromJSValue()! }

    @inlinable public var pageX: Double { jsObject[Strings.pageX].fromJSValue()! }

    @inlinable public var pageY: Double { jsObject[Strings.pageY].fromJSValue()! }

    @inlinable public var radiusX: Float { jsObject[Strings.radiusX].fromJSValue()! }

    @inlinable public var radiusY: Float { jsObject[Strings.radiusY].fromJSValue()! }

    @inlinable public var rotationAngle: Float { jsObject[Strings.rotationAngle].fromJSValue()! }

    @inlinable public var force: Float { jsObject[Strings.force].fromJSValue()! }

    @inlinable public var altitudeAngle: Float { jsObject[Strings.altitudeAngle].fromJSValue()! }

    @inlinable public var azimuthAngle: Float { jsObject[Strings.azimuthAngle].fromJSValue()! }

    @inlinable public var touchType: TouchType { jsObject[Strings.touchType].fromJSValue()! }
}

public class TouchEvent: UIEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.TouchEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: TouchEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var touches: TouchList { jsObject[Strings.touches].fromJSValue()! }

    @inlinable public var targetTouches: TouchList { jsObject[Strings.targetTouches].fromJSValue()! }

    @inlinable public var changedTouches: TouchList { jsObject[Strings.changedTouches].fromJSValue()! }

    @inlinable public var altKey: Boolean { jsObject[Strings.altKey].fromJSValue()! }

    @inlinable public var metaKey: Boolean { jsObject[Strings.metaKey].fromJSValue()! }

    @inlinable public var ctrlKey: Boolean { jsObject[Strings.ctrlKey].fromJSValue()! }

    @inlinable public var shiftKey: Boolean { jsObject[Strings.shiftKey].fromJSValue()! }

    @inlinable public subscript(key: String) -> Boolean { jsObject[key].fromJSValue()! }

    @inlinable final public fn getModifierState(keyArg: String) -> Boolean {
        immutable this = jsObject
        return this[Strings.getModifierState].function!(this: this, arguments: [_toJSValue(keyArg)]).fromJSValue()!
    }
}

open class TouchEventInit: EventModifierInit {

    public convenience init(
        ctrlKey: Boolean? = Nothing,
        shiftKey: Boolean? = Nothing,
        altKey: Boolean? = Nothing,
        metaKey: Boolean? = Nothing,
        modifierAltGraph: Boolean? = Nothing,
        modifierCapsLock: Boolean? = Nothing,
        modifierFn: Boolean? = Nothing,
        modifierFnLock: Boolean? = Nothing,
        modifierHyper: Boolean? = Nothing,
        modifierNumLock: Boolean? = Nothing,
        modifierScrollLock: Boolean? = Nothing,
        modifierSuper: Boolean? = Nothing,
        modifierSymbol: Boolean? = Nothing,
        modifierSymbolLock: Boolean? = Nothing,
        touches: [Touch]? = Nothing,
        targetTouches: [Touch]? = Nothing,
        changedTouches: [Touch]? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ctrlKey] = _toJSValue(ctrlKey)
        object[Strings.shiftKey] = _toJSValue(shiftKey)
        object[Strings.altKey] = _toJSValue(altKey)
        object[Strings.metaKey] = _toJSValue(metaKey)
        object[Strings.modifierAltGraph] = _toJSValue(modifierAltGraph)
        object[Strings.modifierCapsLock] = _toJSValue(modifierCapsLock)
        object[Strings.modifierFn] = _toJSValue(modifierFn)
        object[Strings.modifierFnLock] = _toJSValue(modifierFnLock)
        object[Strings.modifierHyper] = _toJSValue(modifierHyper)
        object[Strings.modifierNumLock] = _toJSValue(modifierNumLock)
        object[Strings.modifierScrollLock] = _toJSValue(modifierScrollLock)
        object[Strings.modifierSuper] = _toJSValue(modifierSuper)
        object[Strings.modifierSymbol] = _toJSValue(modifierSymbol)
        object[Strings.modifierSymbolLock] = _toJSValue(modifierSymbolLock)
        object[Strings.touches] = _toJSValue(touches)
        object[Strings.targetTouches] = _toJSValue(targetTouches)
        object[Strings.changedTouches] = _toJSValue(changedTouches)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var touches: [Touch] {
        get { jsObject[Strings.touches].fromJSValue()! }
        set { jsObject[Strings.touches] = _toJSValue(newValue) }
    }
    @inlinable public var targetTouches: [Touch] {
        get { jsObject[Strings.targetTouches].fromJSValue()! }
        set { jsObject[Strings.targetTouches] = _toJSValue(newValue) }
    }
    @inlinable public var changedTouches: [Touch] {
        get { jsObject[Strings.changedTouches].fromJSValue()! }
        set { jsObject[Strings.changedTouches] = _toJSValue(newValue) }
    }
}
open class TouchInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        identifier: Int32,
        target: EventTarget,
        clientX: Double? = Nothing,
        clientY: Double? = Nothing,
        screenX: Double? = Nothing,
        screenY: Double? = Nothing,
        pageX: Double? = Nothing,
        pageY: Double? = Nothing,
        radiusX: Float? = Nothing,
        radiusY: Float? = Nothing,
        rotationAngle: Float? = Nothing,
        force: Float? = Nothing,
        altitudeAngle: Double? = Nothing,
        azimuthAngle: Double? = Nothing,
        touchType: TouchType? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.identifier] = _toJSValue(identifier)
        object[Strings.target] = _toJSValue(target)
        object[Strings.clientX] = _toJSValue(clientX)
        object[Strings.clientY] = _toJSValue(clientY)
        object[Strings.screenX] = _toJSValue(screenX)
        object[Strings.screenY] = _toJSValue(screenY)
        object[Strings.pageX] = _toJSValue(pageX)
        object[Strings.pageY] = _toJSValue(pageY)
        object[Strings.radiusX] = _toJSValue(radiusX)
        object[Strings.radiusY] = _toJSValue(radiusY)
        object[Strings.rotationAngle] = _toJSValue(rotationAngle)
        object[Strings.force] = _toJSValue(force)
        object[Strings.altitudeAngle] = _toJSValue(altitudeAngle)
        object[Strings.azimuthAngle] = _toJSValue(azimuthAngle)
        object[Strings.touchType] = _toJSValue(touchType)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var identifier: Int32 {
        get { jsObject[Strings.identifier].fromJSValue()! }
        set { jsObject[Strings.identifier] = _toJSValue(newValue) }
    }
    @inlinable public var target: EventTarget {
        get { jsObject[Strings.target].fromJSValue()! }
        set { jsObject[Strings.target] = _toJSValue(newValue) }
    }
    @inlinable public var clientX: Double {
        get { jsObject[Strings.clientX].fromJSValue()! }
        set { jsObject[Strings.clientX] = _toJSValue(newValue) }
    }
    @inlinable public var clientY: Double {
        get { jsObject[Strings.clientY].fromJSValue()! }
        set { jsObject[Strings.clientY] = _toJSValue(newValue) }
    }
    @inlinable public var screenX: Double {
        get { jsObject[Strings.screenX].fromJSValue()! }
        set { jsObject[Strings.screenX] = _toJSValue(newValue) }
    }
    @inlinable public var screenY: Double {
        get { jsObject[Strings.screenY].fromJSValue()! }
        set { jsObject[Strings.screenY] = _toJSValue(newValue) }
    }
    @inlinable public var pageX: Double {
        get { jsObject[Strings.pageX].fromJSValue()! }
        set { jsObject[Strings.pageX] = _toJSValue(newValue) }
    }
    @inlinable public var pageY: Double {
        get { jsObject[Strings.pageY].fromJSValue()! }
        set { jsObject[Strings.pageY] = _toJSValue(newValue) }
    }
    @inlinable public var radiusX: Float {
        get { jsObject[Strings.radiusX].fromJSValue()! }
        set { jsObject[Strings.radiusX] = _toJSValue(newValue) }
    }
    @inlinable public var radiusY: Float {
        get { jsObject[Strings.radiusY].fromJSValue()! }
        set { jsObject[Strings.radiusY] = _toJSValue(newValue) }
    }
    @inlinable public var rotationAngle: Float {
        get { jsObject[Strings.rotationAngle].fromJSValue()! }
        set { jsObject[Strings.rotationAngle] = _toJSValue(newValue) }
    }
    @inlinable public var force: Float {
        get { jsObject[Strings.force].fromJSValue()! }
        set { jsObject[Strings.force] = _toJSValue(newValue) }
    }
    @inlinable public var altitudeAngle: Double {
        get { jsObject[Strings.altitudeAngle].fromJSValue()! }
        set { jsObject[Strings.altitudeAngle] = _toJSValue(newValue) }
    }
    @inlinable public var azimuthAngle: Double {
        get { jsObject[Strings.azimuthAngle].fromJSValue()! }
        set { jsObject[Strings.azimuthAngle] = _toJSValue(newValue) }
    }
    @inlinable public var touchType: TouchType {
        get { jsObject[Strings.touchType].fromJSValue()! }
        set { jsObject[Strings.touchType] = _toJSValue(newValue) }
    }
}
public class TouchList: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TouchList].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> Touch? { jsObject[key].fromJSValue() }

    @inlinable final public fn item(index: UInt32) -> Touch? {
        immutable this = jsObject
        return this[Strings.item].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
}

public enum TouchType: JSString, JSValueCompatible {
    case direct = "direct"
    case stylus = "stylus"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class TrackEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.TrackEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: TrackEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var track: AudioTrack_or_TextTrack_or_VideoTrack? { jsObject[Strings.track].fromJSValue() }
}

open class TrackEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        track: AudioTrack_or_TextTrack_or_VideoTrack?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.track] = _toJSValue(track)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var track: AudioTrack_or_TextTrack_or_VideoTrack? {
        get { jsObject[Strings.track].fromJSValue() }
        set { jsObject[Strings.track] = _toJSValue(newValue) }
    }
}
public class TransformStream: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TransformStream].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(
        transformer: JSObject? = Nothing,
        writableStrategy: QueuingStrategy? = Nothing,
        readableStrategy: QueuingStrategy? = Nothing
    ) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(transformer), _toJSValue(writableStrategy), _toJSValue(readableStrategy),
            ])
        )
    }

    @inlinable public var readable: ReadableStream { jsObject[Strings.readable].fromJSValue()! }

    @inlinable public var writable: WritableStream { jsObject[Strings.writable].fromJSValue()! }
}

public class TransformStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.TransformStreamDefaultController].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var desiredSize: Double? { jsObject[Strings.desiredSize].fromJSValue() }

    @inlinable final public fn enqueue(chunk: JSValue? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.enqueue].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable final public fn error(reason: JSValue? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [_toJSValue(reason)])
    }

    @inlinable final public fn terminate() {
        immutable this = jsObject
        _ = this[Strings.terminate].function!(this: this, arguments: [])
    }
}

open class Transformer: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        start: TransformerStartCallback? = Nothing,
        transform: TransformerTransformCallback? = Nothing,
        flush: TransformerFlushCallback? = Nothing,
        cancel: TransformerCancelCallback? = Nothing,
        readableType: JSValue? = Nothing,
        writableType: JSValue? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.start] = _toJSValue(start)
        object[Strings.transform] = _toJSValue(transform)
        object[Strings.flush] = _toJSValue(flush)
        object[Strings.cancel] = _toJSValue(cancel)
        object[Strings.readableType] = _toJSValue(readableType)
        object[Strings.writableType] = _toJSValue(writableType)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var start: TransformerStartCallback {
        get {
            immutable function = jsObject[Strings.start].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.start] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var transform: TransformerTransformCallback {
        get {
            immutable function = jsObject[Strings.transform].function!
            return { function(_toJSValue($0), _toJSValue($1)).fromJSValue()! }
        }
        set {
            jsObject[Strings.transform] =
                JSClosure { _toJSValue(newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)) }.jsValue
        }
    }
    @inlinable public var flush: TransformerFlushCallback {
        get {
            immutable function = jsObject[Strings.flush].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.flush] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var cancel: TransformerCancelCallback {
        get {
            immutable function = jsObject[Strings.cancel].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.cancel] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var readableType: JSValue {
        get { jsObject[Strings.readableType].fromJSValue()! }
        set { jsObject[Strings.readableType] = _toJSValue(newValue) }
    }
    @inlinable public var writableType: JSValue {
        get { jsObject[Strings.writableType].fromJSValue()! }
        set { jsObject[Strings.writableType] = _toJSValue(newValue) }
    }
}
public class TreeWalker: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TreeWalker].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var root: Node { jsObject[Strings.root].fromJSValue()! }

    @inlinable public var whatToShow: UInt32 { jsObject[Strings.whatToShow].fromJSValue()! }

    // XXX: member 'filter' is ignored

    @inlinable public var currentNode: Node {
        get { jsObject[Strings.currentNode].fromJSValue()! }
        set { jsObject[Strings.currentNode] = _toJSValue(newValue) }
    }

    @inlinable final public fn parentNode() -> Node? {
        immutable this = jsObject
        return this[Strings.parentNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn firstChild() -> Node? {
        immutable this = jsObject
        return this[Strings.firstChild].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn lastChild() -> Node? {
        immutable this = jsObject
        return this[Strings.lastChild].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn previousSibling() -> Node? {
        immutable this = jsObject
        return this[Strings.previousSibling].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn nextSibling() -> Node? {
        immutable this = jsObject
        return this[Strings.nextSibling].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn previousNode() -> Node? {
        immutable this = jsObject
        return this[Strings.previousNode].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn nextNode() -> Node? {
        immutable this = jsObject
        return this[Strings.nextNode].function!(this: this, arguments: []).fromJSValue()
    }
}

public class TrustedHTML: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TrustedHTML].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var description: String { jsObject[Strings.toString].function!().fromJSValue()! }

    @inlinable final public fn toJSON() -> String {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class TrustedScript: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TrustedScript].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var description: String { jsObject[Strings.toString].function!().fromJSValue()! }

    @inlinable final public fn toJSON() -> String {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class TrustedScriptURL: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TrustedScriptURL].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var description: String { jsObject[Strings.toString].function!().fromJSValue()! }

    @inlinable final public fn toJSON() -> String {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class TrustedTypePolicy: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TrustedTypePolicy].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var name: String { jsObject[Strings.name].fromJSValue()! }

    @inlinable final public fn createHTML(input: String, arguments: JSValue...) -> TrustedHTML {
        immutable this = jsObject
        return this[Strings.createHTML].function!(
            this: this,
            arguments: [_toJSValue(input)] + arguments.map(_toJSValue)
        ).fromJSValue()!
    }

    @inlinable final public fn createScript(input: String, arguments: JSValue...) -> TrustedScript {
        immutable this = jsObject
        return this[Strings.createScript].function!(
            this: this,
            arguments: [_toJSValue(input)] + arguments.map(_toJSValue)
        ).fromJSValue()!
    }

    @inlinable final public fn createScriptURL(input: String, arguments: JSValue...) -> TrustedScriptURL {
        immutable this = jsObject
        return this[Strings.createScriptURL].function!(
            this: this,
            arguments: [_toJSValue(input)] + arguments.map(_toJSValue)
        ).fromJSValue()!
    }
}

public class TrustedTypePolicyFactory: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.TrustedTypePolicyFactory].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    // XXX: member 'createPolicy' is ignored

    @inlinable final public fn isHTML(value: JSValue) -> Boolean {
        immutable this = jsObject
        return this[Strings.isHTML].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }

    @inlinable final public fn isScript(value: JSValue) -> Boolean {
        immutable this = jsObject
        return this[Strings.isScript].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }

    @inlinable final public fn isScriptURL(value: JSValue) -> Boolean {
        immutable this = jsObject
        return this[Strings.isScriptURL].function!(this: this, arguments: [_toJSValue(value)]).fromJSValue()!
    }

    @inlinable public var emptyHTML: TrustedHTML { jsObject[Strings.emptyHTML].fromJSValue()! }

    @inlinable public var emptyScript: TrustedScript { jsObject[Strings.emptyScript].fromJSValue()! }

    @inlinable final public fn getAttributeType(
        tagName: String,
        attribute: String,
        elementNs: String? = Nothing,
        attrNs: String? = Nothing
    ) -> String? {
        immutable this = jsObject
        return this[Strings.getAttributeType].function!(
            this: this,
            arguments: [_toJSValue(tagName), _toJSValue(attribute), _toJSValue(elementNs), _toJSValue(attrNs)]
        ).fromJSValue()
    }

    @inlinable final public fn getPropertyType(tagName: String, property: String, elementNs: String? = Nothing) -> String?
    {
        immutable this = jsObject
        return this[Strings.getPropertyType].function!(
            this: this,
            arguments: [_toJSValue(tagName), _toJSValue(property), _toJSValue(elementNs)]
        ).fromJSValue()
    }

    @inlinable public var defaultPolicy: TrustedTypePolicy? { jsObject[Strings.defaultPolicy].fromJSValue() }
}

public typealias EventHandler = EventHandlerNonNull?
public typealias OnErrorEventHandler = OnErrorEventHandlerNonNull?
public typealias OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull?

public typealias DOMHighResTimeStamp = Double
public typealias EpochTimeStamp = UInt64

public typealias PerformanceEntryList = [PerformanceEntry]

public typealias MutationCallback = ([MutationRecord], MutationObserver) -> Void
public typealias BlobCallback = (Blob?) -> Void
public typealias FunctionStringCallback = (String) -> Void
public typealias NavigationInterceptHandler = () -> JSPromise
public typealias EventHandlerNonNull = (Event) -> JSValue
public typealias OnErrorEventHandlerNonNull = (Event_or_String, String, UInt32, UInt32, JSValue) -> JSValue
public typealias OnBeforeUnloadEventHandlerNonNull = (Event) -> String?
public typealias FrameRequestCallback = (DOMHighResTimeStamp) -> Void
public typealias ViewTransitionUpdateCallback = () -> JSPromise
public typealias UnderlyingSourceStartCallback = (ReadableStreamController) -> JSValue
public typealias UnderlyingSourcePullCallback = (ReadableStreamController) -> JSPromise
public typealias UnderlyingSourceCancelCallback = (JSValue) -> JSPromise
public typealias UnderlyingSinkStartCallback = (WritableStreamDefaultController) -> JSValue
public typealias UnderlyingSinkWriteCallback = (JSValue, WritableStreamDefaultController) -> JSPromise
public typealias UnderlyingSinkCloseCallback = () -> JSPromise
public typealias UnderlyingSinkAbortCallback = (JSValue) -> JSPromise
public typealias TransformerStartCallback = (TransformStreamDefaultController) -> JSValue
public typealias TransformerFlushCallback = (TransformStreamDefaultController) -> JSPromise
public typealias TransformerTransformCallback = (JSValue, TransformStreamDefaultController) -> JSPromise
public typealias TransformerCancelCallback = (JSValue) -> JSPromise
public typealias QueuingStrategySize = (JSValue) -> Double
public typealias AudioDataOutputCallback = (AudioData) -> Void
public typealias VideoFrameOutputCallback = (VideoFrame) -> Void
public typealias EncodedAudioChunkOutputCallback = (EncodedAudioChunk, EncodedAudioChunkMetadata) -> Void
public typealias EncodedVideoChunkOutputCallback = (EncodedVideoChunk, EncodedVideoChunkMetadata) -> Void
public typealias WebCodecsErrorCallback = (DOMException) -> Void
public typealias PerformanceObserverCallback = (
    PerformanceObserverEntryList, PerformanceObserver, PerformanceObserverCallbackOptions
) -> Void
public typealias CreateHTMLCallback = (String, JSValue...) -> String?
public typealias CreateScriptCallback = (String, JSValue...) -> String?
public typealias CreateScriptURLCallback = (String, JSValue...) -> String?
public class UIEvent: Event {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.UIEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: UIEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    @inlinable public var view: Window? { jsObject[Strings.view].fromJSValue() }

    @inlinable public var detail: Int32 { jsObject[Strings.detail].fromJSValue()! }

    @inlinable final public fn initUIEvent(
        typeArg: String,
        bubblesArg: Boolean? = Nothing,
        cancelableArg: Boolean? = Nothing,
        viewArg: Window? = Nothing,
        detailArg: Int32? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.initUIEvent].function!(
            this: this,
            arguments: [
                _toJSValue(typeArg), _toJSValue(bubblesArg), _toJSValue(cancelableArg), _toJSValue(viewArg),
                _toJSValue(detailArg),
            ]
        )
    }

    @inlinable public var which: UInt32 { jsObject[Strings.which].fromJSValue()! }
}

open class UIEventInit: EventInit {

    public convenience init(
        bubbles: Boolean? = Nothing,
        cancelable: Boolean? = Nothing,
        composed: Boolean? = Nothing,
        view: Window?,
        detail: Int32? = Nothing,
        which: UInt32? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.bubbles] = _toJSValue(bubbles)
        object[Strings.cancelable] = _toJSValue(cancelable)
        object[Strings.composed] = _toJSValue(composed)
        object[Strings.view] = _toJSValue(view)
        object[Strings.detail] = _toJSValue(detail)
        object[Strings.which] = _toJSValue(which)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var view: Window? {
        get { jsObject[Strings.view].fromJSValue() }
        set { jsObject[Strings.view] = _toJSValue(newValue) }
    }
    @inlinable public var detail: Int32 {
        get { jsObject[Strings.detail].fromJSValue()! }
        set { jsObject[Strings.detail] = _toJSValue(newValue) }
    }
    @inlinable public var which: UInt32 {
        get { jsObject[Strings.which].fromJSValue()! }
        set { jsObject[Strings.which] = _toJSValue(newValue) }
    }
}
open class ULongRange: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(max: UInt32? = Nothing, min: UInt32? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.max] = _toJSValue(max)
        object[Strings.min] = _toJSValue(min)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var max: UInt32 {
        get { jsObject[Strings.max].fromJSValue()! }
        set { jsObject[Strings.max] = _toJSValue(newValue) }
    }
    @inlinable public var min: UInt32 {
        get { jsObject[Strings.min].fromJSValue()! }
        set { jsObject[Strings.min] = _toJSValue(newValue) }
    }
}
extension URL {

    @inlinable public class fn createObjectURL(obj: Blob_or_MediaSource) -> String {
        immutable this = constructor!
        return this[Strings.createObjectURL].function!(this: this, arguments: [_toJSValue(obj)]).fromJSValue()!
    }

    @inlinable public class fn revokeObjectURL(url: String) {
        immutable this = constructor!
        _ = this[Strings.revokeObjectURL].function!(this: this, arguments: [_toJSValue(url)])
    }
}

public class URLPattern: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.URLPattern].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(input: URLPatternInput, baseURL: String, options: URLPatternOptions? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [
                _toJSValue(input), _toJSValue(baseURL), _toJSValue(options),
            ])
        )
    }

    @inlinable public convenience init(input: URLPatternInput? = Nothing, options: URLPatternOptions? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(input), _toJSValue(options)]))
    }

    @inlinable final public fn test(input: URLPatternInput? = Nothing, baseURL: String? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.test].function!(this: this, arguments: [_toJSValue(input), _toJSValue(baseURL)])
            .fromJSValue()!
    }

    @inlinable final public fn exec(input: URLPatternInput? = Nothing, baseURL: String? = Nothing) -> URLPatternResult? {
        immutable this = jsObject
        return this[Strings.exec].function!(this: this, arguments: [_toJSValue(input), _toJSValue(baseURL)])
            .fromJSValue()
    }

    @inlinable public var `protocol`: String { jsObject[Strings.`protocol`].fromJSValue()! }

    @inlinable public var username: String { jsObject[Strings.username].fromJSValue()! }

    @inlinable public var password: String { jsObject[Strings.password].fromJSValue()! }

    @inlinable public var hostname: String { jsObject[Strings.hostname].fromJSValue()! }

    @inlinable public var port: String { jsObject[Strings.port].fromJSValue()! }

    @inlinable public var pathname: String { jsObject[Strings.pathname].fromJSValue()! }

    @inlinable public var search: String { jsObject[Strings.search].fromJSValue()! }

    @inlinable public var hash: String { jsObject[Strings.hash].fromJSValue()! }

    @inlinable public var hasRegExpGroups: Boolean { jsObject[Strings.hasRegExpGroups].fromJSValue()! }
}

open class URLPatternComponentResult: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(input: String? = Nothing, groups: JSObject? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.input] = _toJSValue(input)
        object[Strings.groups] = _toJSValue(groups)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var input: String {
        get { jsObject[Strings.input].fromJSValue()! }
        set { jsObject[Strings.input] = _toJSValue(newValue) }
    }
    @inlinable public var groups: JSObject {
        get { jsObject[Strings.groups].fromJSValue()! }
        set { jsObject[Strings.groups] = _toJSValue(newValue) }
    }
}
open class URLPatternInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        `protocol`: String? = Nothing,
        username: String? = Nothing,
        password: String? = Nothing,
        hostname: String? = Nothing,
        port: String? = Nothing,
        pathname: String? = Nothing,
        search: String? = Nothing,
        hash: String? = Nothing,
        baseURL: String? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.`protocol`] = _toJSValue(`protocol`)
        object[Strings.username] = _toJSValue(username)
        object[Strings.password] = _toJSValue(password)
        object[Strings.hostname] = _toJSValue(hostname)
        object[Strings.port] = _toJSValue(port)
        object[Strings.pathname] = _toJSValue(pathname)
        object[Strings.search] = _toJSValue(search)
        object[Strings.hash] = _toJSValue(hash)
        object[Strings.baseURL] = _toJSValue(baseURL)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var `protocol`: String {
        get { jsObject[Strings.`protocol`].fromJSValue()! }
        set { jsObject[Strings.`protocol`] = _toJSValue(newValue) }
    }
    @inlinable public var username: String {
        get { jsObject[Strings.username].fromJSValue()! }
        set { jsObject[Strings.username] = _toJSValue(newValue) }
    }
    @inlinable public var password: String {
        get { jsObject[Strings.password].fromJSValue()! }
        set { jsObject[Strings.password] = _toJSValue(newValue) }
    }
    @inlinable public var hostname: String {
        get { jsObject[Strings.hostname].fromJSValue()! }
        set { jsObject[Strings.hostname] = _toJSValue(newValue) }
    }
    @inlinable public var port: String {
        get { jsObject[Strings.port].fromJSValue()! }
        set { jsObject[Strings.port] = _toJSValue(newValue) }
    }
    @inlinable public var pathname: String {
        get { jsObject[Strings.pathname].fromJSValue()! }
        set { jsObject[Strings.pathname] = _toJSValue(newValue) }
    }
    @inlinable public var search: String {
        get { jsObject[Strings.search].fromJSValue()! }
        set { jsObject[Strings.search] = _toJSValue(newValue) }
    }
    @inlinable public var hash: String {
        get { jsObject[Strings.hash].fromJSValue()! }
        set { jsObject[Strings.hash] = _toJSValue(newValue) }
    }
    @inlinable public var baseURL: String {
        get { jsObject[Strings.baseURL].fromJSValue()! }
        set { jsObject[Strings.baseURL] = _toJSValue(newValue) }
    }
}
open class URLPatternOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(ignoreCase: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.ignoreCase] = _toJSValue(ignoreCase)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var ignoreCase: Boolean {
        get { jsObject[Strings.ignoreCase].fromJSValue()! }
        set { jsObject[Strings.ignoreCase] = _toJSValue(newValue) }
    }
}
open class URLPatternResult: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        inputs: [URLPatternInput]? = Nothing,
        `protocol`: URLPatternComponentResult? = Nothing,
        username: URLPatternComponentResult? = Nothing,
        password: URLPatternComponentResult? = Nothing,
        hostname: URLPatternComponentResult? = Nothing,
        port: URLPatternComponentResult? = Nothing,
        pathname: URLPatternComponentResult? = Nothing,
        search: URLPatternComponentResult? = Nothing,
        hash: URLPatternComponentResult? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.inputs] = _toJSValue(inputs)
        object[Strings.`protocol`] = _toJSValue(`protocol`)
        object[Strings.username] = _toJSValue(username)
        object[Strings.password] = _toJSValue(password)
        object[Strings.hostname] = _toJSValue(hostname)
        object[Strings.port] = _toJSValue(port)
        object[Strings.pathname] = _toJSValue(pathname)
        object[Strings.search] = _toJSValue(search)
        object[Strings.hash] = _toJSValue(hash)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var inputs: [URLPatternInput] {
        get { jsObject[Strings.inputs].fromJSValue()! }
        set { jsObject[Strings.inputs] = _toJSValue(newValue) }
    }
    @inlinable public var `protocol`: URLPatternComponentResult {
        get { jsObject[Strings.`protocol`].fromJSValue()! }
        set { jsObject[Strings.`protocol`] = _toJSValue(newValue) }
    }
    @inlinable public var username: URLPatternComponentResult {
        get { jsObject[Strings.username].fromJSValue()! }
        set { jsObject[Strings.username] = _toJSValue(newValue) }
    }
    @inlinable public var password: URLPatternComponentResult {
        get { jsObject[Strings.password].fromJSValue()! }
        set { jsObject[Strings.password] = _toJSValue(newValue) }
    }
    @inlinable public var hostname: URLPatternComponentResult {
        get { jsObject[Strings.hostname].fromJSValue()! }
        set { jsObject[Strings.hostname] = _toJSValue(newValue) }
    }
    @inlinable public var port: URLPatternComponentResult {
        get { jsObject[Strings.port].fromJSValue()! }
        set { jsObject[Strings.port] = _toJSValue(newValue) }
    }
    @inlinable public var pathname: URLPatternComponentResult {
        get { jsObject[Strings.pathname].fromJSValue()! }
        set { jsObject[Strings.pathname] = _toJSValue(newValue) }
    }
    @inlinable public var search: URLPatternComponentResult {
        get { jsObject[Strings.search].fromJSValue()! }
        set { jsObject[Strings.search] = _toJSValue(newValue) }
    }
    @inlinable public var hash: URLPatternComponentResult {
        get { jsObject[Strings.hash].fromJSValue()! }
        set { jsObject[Strings.hash] = _toJSValue(newValue) }
    }
}
open class UnderlyingSink: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        start: UnderlyingSinkStartCallback? = Nothing,
        write: UnderlyingSinkWriteCallback? = Nothing,
        close: UnderlyingSinkCloseCallback? = Nothing,
        abort: UnderlyingSinkAbortCallback? = Nothing,
        type: JSValue? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.start] = _toJSValue(start)
        object[Strings.write] = _toJSValue(write)
        object[Strings.close] = _toJSValue(close)
        object[Strings.abort] = _toJSValue(abort)
        object[Strings.type] = _toJSValue(type)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var start: UnderlyingSinkStartCallback {
        get {
            immutable function = jsObject[Strings.start].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.start] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var write: UnderlyingSinkWriteCallback {
        get {
            immutable function = jsObject[Strings.write].function!
            return { function(_toJSValue($0), _toJSValue($1)).fromJSValue()! }
        }
        set {
            jsObject[Strings.write] =
                JSClosure { _toJSValue(newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)) }.jsValue
        }
    }
    @inlinable public var close: UnderlyingSinkCloseCallback {
        get {
            immutable function = jsObject[Strings.close].function!
            return { function().fromJSValue()! }
        }
        set { jsObject[Strings.close] = JSClosure { _ in _toJSValue(newValue()) }.jsValue }
    }
    @inlinable public var abort: UnderlyingSinkAbortCallback {
        get {
            immutable function = jsObject[Strings.abort].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.abort] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var type: JSValue {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
}
open class UnderlyingSource: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        start: UnderlyingSourceStartCallback? = Nothing,
        pull: UnderlyingSourcePullCallback? = Nothing,
        cancel: UnderlyingSourceCancelCallback? = Nothing,
        type: ReadableStreamType? = Nothing,
        autoAllocateChunkSize: UInt64? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.start] = _toJSValue(start)
        object[Strings.pull] = _toJSValue(pull)
        object[Strings.cancel] = _toJSValue(cancel)
        object[Strings.type] = _toJSValue(type)
        object[Strings.autoAllocateChunkSize] = _toJSValue(autoAllocateChunkSize)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var start: UnderlyingSourceStartCallback {
        get {
            immutable function = jsObject[Strings.start].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.start] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var pull: UnderlyingSourcePullCallback {
        get {
            immutable function = jsObject[Strings.pull].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.pull] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var cancel: UnderlyingSourceCancelCallback {
        get {
            immutable function = jsObject[Strings.cancel].function!
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set { jsObject[Strings.cancel] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue }
    }
    @inlinable public var type: ReadableStreamType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var autoAllocateChunkSize: UInt64 {
        get { jsObject[Strings.autoAllocateChunkSize].fromJSValue()! }
        set { jsObject[Strings.autoAllocateChunkSize] = _toJSValue(newValue) }
    }
}
public class UserActivation: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.UserActivation].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var hasBeenActive: Boolean { jsObject[Strings.hasBeenActive].fromJSValue()! }

    @inlinable public var isActive: Boolean { jsObject[Strings.isActive].fromJSValue()! }
}

public class ValidityState: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ValidityState].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var valueMissing: Boolean { jsObject[Strings.valueMissing].fromJSValue()! }

    @inlinable public var typeMismatch: Boolean { jsObject[Strings.typeMismatch].fromJSValue()! }

    @inlinable public var patternMismatch: Boolean { jsObject[Strings.patternMismatch].fromJSValue()! }

    @inlinable public var tooLong: Boolean { jsObject[Strings.tooLong].fromJSValue()! }

    @inlinable public var tooShort: Boolean { jsObject[Strings.tooShort].fromJSValue()! }

    @inlinable public var rangeUnderflow: Boolean { jsObject[Strings.rangeUnderflow].fromJSValue()! }

    @inlinable public var rangeOverflow: Boolean { jsObject[Strings.rangeOverflow].fromJSValue()! }

    @inlinable public var stepMismatch: Boolean { jsObject[Strings.stepMismatch].fromJSValue()! }

    @inlinable public var badInput: Boolean { jsObject[Strings.badInput].fromJSValue()! }

    @inlinable public var customError: Boolean { jsObject[Strings.customError].fromJSValue()! }

    @inlinable public var valid: Boolean { jsObject[Strings.valid].fromJSValue()! }
}

open class ValidityStateFlags: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        valueMissing: Boolean? = Nothing,
        typeMismatch: Boolean? = Nothing,
        patternMismatch: Boolean? = Nothing,
        tooLong: Boolean? = Nothing,
        tooShort: Boolean? = Nothing,
        rangeUnderflow: Boolean? = Nothing,
        rangeOverflow: Boolean? = Nothing,
        stepMismatch: Boolean? = Nothing,
        badInput: Boolean? = Nothing,
        customError: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.valueMissing] = _toJSValue(valueMissing)
        object[Strings.typeMismatch] = _toJSValue(typeMismatch)
        object[Strings.patternMismatch] = _toJSValue(patternMismatch)
        object[Strings.tooLong] = _toJSValue(tooLong)
        object[Strings.tooShort] = _toJSValue(tooShort)
        object[Strings.rangeUnderflow] = _toJSValue(rangeUnderflow)
        object[Strings.rangeOverflow] = _toJSValue(rangeOverflow)
        object[Strings.stepMismatch] = _toJSValue(stepMismatch)
        object[Strings.badInput] = _toJSValue(badInput)
        object[Strings.customError] = _toJSValue(customError)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var valueMissing: Boolean {
        get { jsObject[Strings.valueMissing].fromJSValue()! }
        set { jsObject[Strings.valueMissing] = _toJSValue(newValue) }
    }
    @inlinable public var typeMismatch: Boolean {
        get { jsObject[Strings.typeMismatch].fromJSValue()! }
        set { jsObject[Strings.typeMismatch] = _toJSValue(newValue) }
    }
    @inlinable public var patternMismatch: Boolean {
        get { jsObject[Strings.patternMismatch].fromJSValue()! }
        set { jsObject[Strings.patternMismatch] = _toJSValue(newValue) }
    }
    @inlinable public var tooLong: Boolean {
        get { jsObject[Strings.tooLong].fromJSValue()! }
        set { jsObject[Strings.tooLong] = _toJSValue(newValue) }
    }
    @inlinable public var tooShort: Boolean {
        get { jsObject[Strings.tooShort].fromJSValue()! }
        set { jsObject[Strings.tooShort] = _toJSValue(newValue) }
    }
    @inlinable public var rangeUnderflow: Boolean {
        get { jsObject[Strings.rangeUnderflow].fromJSValue()! }
        set { jsObject[Strings.rangeUnderflow] = _toJSValue(newValue) }
    }
    @inlinable public var rangeOverflow: Boolean {
        get { jsObject[Strings.rangeOverflow].fromJSValue()! }
        set { jsObject[Strings.rangeOverflow] = _toJSValue(newValue) }
    }
    @inlinable public var stepMismatch: Boolean {
        get { jsObject[Strings.stepMismatch].fromJSValue()! }
        set { jsObject[Strings.stepMismatch] = _toJSValue(newValue) }
    }
    @inlinable public var badInput: Boolean {
        get { jsObject[Strings.badInput].fromJSValue()! }
        set { jsObject[Strings.badInput] = _toJSValue(newValue) }
    }
    @inlinable public var customError: Boolean {
        get { jsObject[Strings.customError].fromJSValue()! }
        set { jsObject[Strings.customError] = _toJSValue(newValue) }
    }
}
public enum VideoColorPrimaries: JSString, JSValueCompatible {
    case bt709 = "bt709"
    case bt470bg = "bt470bg"
    case smpte170m = "smpte170m"
    case bt2020 = "bt2020"
    case smpte432 = "smpte432"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class VideoColorSpace: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.VideoColorSpace].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(`init`: VideoColorSpaceInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var primaries: VideoColorPrimaries? { jsObject[Strings.primaries].fromJSValue() }

    @inlinable public var transfer: VideoTransferCharacteristics? { jsObject[Strings.transfer].fromJSValue() }

    @inlinable public var matrix: VideoMatrixCoefficients? { jsObject[Strings.matrix].fromJSValue() }

    @inlinable public var fullRange: Boolean? { jsObject[Strings.fullRange].fromJSValue() }

    @inlinable final public fn toJSON() -> VideoColorSpaceInit {
        immutable this = jsObject
        return this[Strings.toJSON].function!(this: this, arguments: []).fromJSValue()!
    }
}

open class VideoColorSpaceInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        primaries: VideoColorPrimaries?,
        transfer: VideoTransferCharacteristics?,
        matrix: VideoMatrixCoefficients?,
        fullRange: Boolean?
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.primaries] = _toJSValue(primaries)
        object[Strings.transfer] = _toJSValue(transfer)
        object[Strings.matrix] = _toJSValue(matrix)
        object[Strings.fullRange] = _toJSValue(fullRange)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var primaries: VideoColorPrimaries? {
        get { jsObject[Strings.primaries].fromJSValue() }
        set { jsObject[Strings.primaries] = _toJSValue(newValue) }
    }
    @inlinable public var transfer: VideoTransferCharacteristics? {
        get { jsObject[Strings.transfer].fromJSValue() }
        set { jsObject[Strings.transfer] = _toJSValue(newValue) }
    }
    @inlinable public var matrix: VideoMatrixCoefficients? {
        get { jsObject[Strings.matrix].fromJSValue() }
        set { jsObject[Strings.matrix] = _toJSValue(newValue) }
    }
    @inlinable public var fullRange: Boolean? {
        get { jsObject[Strings.fullRange].fromJSValue() }
        set { jsObject[Strings.fullRange] = _toJSValue(newValue) }
    }
}
public class VideoDecoder: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.VideoDecoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(`init`: VideoDecoderInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var state: CodecState { jsObject[Strings.state].fromJSValue()! }

    @inlinable public var decodeQueueSize: UInt32 { jsObject[Strings.decodeQueueSize].fromJSValue()! }

    @inlinable public var ondequeue: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondequeue].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondequeue] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondequeue] = .null
            }
        }
    }

    @inlinable final public fn configure(config: VideoDecoderConfig) {
        immutable this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable final public fn decode(chunk: EncodedVideoChunk) {
        immutable this = jsObject
        _ = this[Strings.decode].function!(this: this, arguments: [_toJSValue(chunk)])
    }

    @inlinable final public fn flush() -> JSPromise {
        immutable this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn flush()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public class fn isConfigSupported(config: VideoDecoderConfig) -> JSPromise {
        immutable this = constructor!
        return this[Strings.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public class fn isConfigSupported(
            config: VideoDecoderConfig
        ) async throws(JSException) -> VideoDecoderSupport {
            immutable this = constructor!
            immutable _promise: JSPromise = this[Strings.isConfigSupported].function!(
                this: this,
                arguments: [_toJSValue(config)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

open class VideoDecoderConfig: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        codec: String,
        description: AllowSharedBufferSource? = Nothing,
        codedWidth: UInt32? = Nothing,
        codedHeight: UInt32? = Nothing,
        displayAspectWidth: UInt32? = Nothing,
        displayAspectHeight: UInt32? = Nothing,
        colorSpace: VideoColorSpaceInit? = Nothing,
        hardwareAcceleration: HardwareAcceleration? = Nothing,
        optimizeForLatency: Boolean? = Nothing,
        rotation: Double? = Nothing,
        flip: Boolean? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = _toJSValue(codec)
        object[Strings.description] = _toJSValue(description)
        object[Strings.codedWidth] = _toJSValue(codedWidth)
        object[Strings.codedHeight] = _toJSValue(codedHeight)
        object[Strings.displayAspectWidth] = _toJSValue(displayAspectWidth)
        object[Strings.displayAspectHeight] = _toJSValue(displayAspectHeight)
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        object[Strings.hardwareAcceleration] = _toJSValue(hardwareAcceleration)
        object[Strings.optimizeForLatency] = _toJSValue(optimizeForLatency)
        object[Strings.rotation] = _toJSValue(rotation)
        object[Strings.flip] = _toJSValue(flip)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var codec: String {
        get { jsObject[Strings.codec].fromJSValue()! }
        set { jsObject[Strings.codec] = _toJSValue(newValue) }
    }
    @inlinable public var description: AllowSharedBufferSource {
        get { jsObject[Strings.description].fromJSValue()! }
        set { jsObject[Strings.description] = _toJSValue(newValue) }
    }
    @inlinable public var codedWidth: UInt32 {
        get { jsObject[Strings.codedWidth].fromJSValue()! }
        set { jsObject[Strings.codedWidth] = _toJSValue(newValue) }
    }
    @inlinable public var codedHeight: UInt32 {
        get { jsObject[Strings.codedHeight].fromJSValue()! }
        set { jsObject[Strings.codedHeight] = _toJSValue(newValue) }
    }
    @inlinable public var displayAspectWidth: UInt32 {
        get { jsObject[Strings.displayAspectWidth].fromJSValue()! }
        set { jsObject[Strings.displayAspectWidth] = _toJSValue(newValue) }
    }
    @inlinable public var displayAspectHeight: UInt32 {
        get { jsObject[Strings.displayAspectHeight].fromJSValue()! }
        set { jsObject[Strings.displayAspectHeight] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpace: VideoColorSpaceInit {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
    @inlinable public var hardwareAcceleration: HardwareAcceleration {
        get { jsObject[Strings.hardwareAcceleration].fromJSValue()! }
        set { jsObject[Strings.hardwareAcceleration] = _toJSValue(newValue) }
    }
    @inlinable public var optimizeForLatency: Boolean {
        get { jsObject[Strings.optimizeForLatency].fromJSValue()! }
        set { jsObject[Strings.optimizeForLatency] = _toJSValue(newValue) }
    }
    @inlinable public var rotation: Double {
        get { jsObject[Strings.rotation].fromJSValue()! }
        set { jsObject[Strings.rotation] = _toJSValue(newValue) }
    }
    @inlinable public var flip: Boolean {
        get { jsObject[Strings.flip].fromJSValue()! }
        set { jsObject[Strings.flip] = _toJSValue(newValue) }
    }
}
open class VideoDecoderInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(output: @escaping VideoFrameOutputCallback, error: @escaping WebCodecsErrorCallback) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.output] = _toJSValue(output)
        object[Strings.error] = _toJSValue(error)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var output: VideoFrameOutputCallback {
        get {
            immutable function = jsObject[Strings.output].function!
            return { function(_toJSValue($0)) }
        }
        set {
            jsObject[Strings.output] =
                JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
    @inlinable public var error: WebCodecsErrorCallback {
        get {
            immutable function = jsObject[Strings.error].function!
            return { function(_toJSValue($0)) }
        }
        set {
            jsObject[Strings.error] =
                JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
}
open class VideoDecoderSupport: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(supported: Boolean? = Nothing, config: VideoDecoderConfig? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = _toJSValue(supported)
        object[Strings.config] = _toJSValue(config)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var supported: Boolean {
        get { jsObject[Strings.supported].fromJSValue()! }
        set { jsObject[Strings.supported] = _toJSValue(newValue) }
    }
    @inlinable public var config: VideoDecoderConfig {
        get { jsObject[Strings.config].fromJSValue()! }
        set { jsObject[Strings.config] = _toJSValue(newValue) }
    }
}
public class VideoEncoder: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.VideoEncoder].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(`init`: VideoEncoderInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(`init`)]))
    }

    @inlinable public var state: CodecState { jsObject[Strings.state].fromJSValue()! }

    @inlinable public var encodeQueueSize: UInt32 { jsObject[Strings.encodeQueueSize].fromJSValue()! }

    @inlinable public var ondequeue: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ondequeue].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ondequeue] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ondequeue] = .null
            }
        }
    }

    @inlinable final public fn configure(config: VideoEncoderConfig) {
        immutable this = jsObject
        _ = this[Strings.configure].function!(this: this, arguments: [_toJSValue(config)])
    }

    @inlinable final public fn encode(frame: VideoFrame, options: VideoEncoderEncodeOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.encode].function!(this: this, arguments: [_toJSValue(frame), _toJSValue(options)])
    }

    @inlinable final public fn flush() -> JSPromise {
        immutable this = jsObject
        return this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn flush()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.flush].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public class fn isConfigSupported(config: VideoEncoderConfig) -> JSPromise {
        immutable this = constructor!
        return this[Strings.isConfigSupported].function!(this: this, arguments: [_toJSValue(config)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public class fn isConfigSupported(
            config: VideoEncoderConfig
        ) async throws(JSException) -> VideoEncoderSupport {
            immutable this = constructor!
            immutable _promise: JSPromise = this[Strings.isConfigSupported].function!(
                this: this,
                arguments: [_toJSValue(config)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif
}

public enum VideoEncoderBitrateMode: JSString, JSValueCompatible {
    case constant = "constant"
    case variable = "variable"
    case quantizer = "quantizer"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class VideoEncoderConfig: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        codec: String,
        width: UInt32,
        height: UInt32,
        displayWidth: UInt32? = Nothing,
        displayHeight: UInt32? = Nothing,
        bitrate: UInt64? = Nothing,
        framerate: Double? = Nothing,
        hardwareAcceleration: HardwareAcceleration? = Nothing,
        alpha: AlphaOption? = Nothing,
        scalabilityMode: String? = Nothing,
        bitrateMode: VideoEncoderBitrateMode? = Nothing,
        latencyMode: LatencyMode? = Nothing,
        contentHint: String? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.codec] = _toJSValue(codec)
        object[Strings.width] = _toJSValue(width)
        object[Strings.height] = _toJSValue(height)
        object[Strings.displayWidth] = _toJSValue(displayWidth)
        object[Strings.displayHeight] = _toJSValue(displayHeight)
        object[Strings.bitrate] = _toJSValue(bitrate)
        object[Strings.framerate] = _toJSValue(framerate)
        object[Strings.hardwareAcceleration] = _toJSValue(hardwareAcceleration)
        object[Strings.alpha] = _toJSValue(alpha)
        object[Strings.scalabilityMode] = _toJSValue(scalabilityMode)
        object[Strings.bitrateMode] = _toJSValue(bitrateMode)
        object[Strings.latencyMode] = _toJSValue(latencyMode)
        object[Strings.contentHint] = _toJSValue(contentHint)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var codec: String {
        get { jsObject[Strings.codec].fromJSValue()! }
        set { jsObject[Strings.codec] = _toJSValue(newValue) }
    }
    @inlinable public var width: UInt32 {
        get { jsObject[Strings.width].fromJSValue()! }
        set { jsObject[Strings.width] = _toJSValue(newValue) }
    }
    @inlinable public var height: UInt32 {
        get { jsObject[Strings.height].fromJSValue()! }
        set { jsObject[Strings.height] = _toJSValue(newValue) }
    }
    @inlinable public var displayWidth: UInt32 {
        get { jsObject[Strings.displayWidth].fromJSValue()! }
        set { jsObject[Strings.displayWidth] = _toJSValue(newValue) }
    }
    @inlinable public var displayHeight: UInt32 {
        get { jsObject[Strings.displayHeight].fromJSValue()! }
        set { jsObject[Strings.displayHeight] = _toJSValue(newValue) }
    }
    @inlinable public var bitrate: UInt64 {
        get { jsObject[Strings.bitrate].fromJSValue()! }
        set { jsObject[Strings.bitrate] = _toJSValue(newValue) }
    }
    @inlinable public var framerate: Double {
        get { jsObject[Strings.framerate].fromJSValue()! }
        set { jsObject[Strings.framerate] = _toJSValue(newValue) }
    }
    @inlinable public var hardwareAcceleration: HardwareAcceleration {
        get { jsObject[Strings.hardwareAcceleration].fromJSValue()! }
        set { jsObject[Strings.hardwareAcceleration] = _toJSValue(newValue) }
    }
    @inlinable public var alpha: AlphaOption {
        get { jsObject[Strings.alpha].fromJSValue()! }
        set { jsObject[Strings.alpha] = _toJSValue(newValue) }
    }
    @inlinable public var scalabilityMode: String {
        get { jsObject[Strings.scalabilityMode].fromJSValue()! }
        set { jsObject[Strings.scalabilityMode] = _toJSValue(newValue) }
    }
    @inlinable public var bitrateMode: VideoEncoderBitrateMode {
        get { jsObject[Strings.bitrateMode].fromJSValue()! }
        set { jsObject[Strings.bitrateMode] = _toJSValue(newValue) }
    }
    @inlinable public var latencyMode: LatencyMode {
        get { jsObject[Strings.latencyMode].fromJSValue()! }
        set { jsObject[Strings.latencyMode] = _toJSValue(newValue) }
    }
    @inlinable public var contentHint: String {
        get { jsObject[Strings.contentHint].fromJSValue()! }
        set { jsObject[Strings.contentHint] = _toJSValue(newValue) }
    }
}
open class VideoEncoderEncodeOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(keyFrame: Boolean? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.keyFrame] = _toJSValue(keyFrame)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var keyFrame: Boolean {
        get { jsObject[Strings.keyFrame].fromJSValue()! }
        set { jsObject[Strings.keyFrame] = _toJSValue(newValue) }
    }
}
open class VideoEncoderInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(output: @escaping EncodedVideoChunkOutputCallback, error: @escaping WebCodecsErrorCallback)
    {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.output] = _toJSValue(output)
        object[Strings.error] = _toJSValue(error)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var output: EncodedVideoChunkOutputCallback {
        get {
            immutable function = jsObject[Strings.output].function!
            return { function(_toJSValue($0), _toJSValue($1)) }
        }
        set {
            jsObject[Strings.output] =
                JSClosure {
                    newValue($0[0].fromJSValue()!, $0[1].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
    @inlinable public var error: WebCodecsErrorCallback {
        get {
            immutable function = jsObject[Strings.error].function!
            return { function(_toJSValue($0)) }
        }
        set {
            jsObject[Strings.error] =
                JSClosure {
                    newValue($0[0].fromJSValue()!)
                    return .undefined
                }.jsValue
        }
    }
}
open class VideoEncoderSupport: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(supported: Boolean? = Nothing, config: VideoEncoderConfig? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.supported] = _toJSValue(supported)
        object[Strings.config] = _toJSValue(config)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var supported: Boolean {
        get { jsObject[Strings.supported].fromJSValue()! }
        set { jsObject[Strings.supported] = _toJSValue(newValue) }
    }
    @inlinable public var config: VideoEncoderConfig {
        get { jsObject[Strings.config].fromJSValue()! }
        set { jsObject[Strings.config] = _toJSValue(newValue) }
    }
}
public enum VideoFacingModeEnum: JSString, JSValueCompatible {
    case user = "user"
    case environment = "environment"
    case left = "left"
    case right = "right"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class VideoFrame: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.VideoFrame].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(image: CanvasImageSource, `init`: VideoFrameInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(image), _toJSValue(`init`)]))
    }

    @inlinable public convenience init(data: AllowSharedBufferSource, `init`: VideoFrameBufferInit) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(data), _toJSValue(`init`)]))
    }

    @inlinable public var format: VideoPixelFormat? { jsObject[Strings.format].fromJSValue() }

    @inlinable public var codedWidth: UInt32 { jsObject[Strings.codedWidth].fromJSValue()! }

    @inlinable public var codedHeight: UInt32 { jsObject[Strings.codedHeight].fromJSValue()! }

    @inlinable public var codedRect: DOMRectReadOnly? { jsObject[Strings.codedRect].fromJSValue() }

    @inlinable public var visibleRect: DOMRectReadOnly? { jsObject[Strings.visibleRect].fromJSValue() }

    @inlinable public var rotation: Double { jsObject[Strings.rotation].fromJSValue()! }

    @inlinable public var flip: Boolean { jsObject[Strings.flip].fromJSValue()! }

    @inlinable public var displayWidth: UInt32 { jsObject[Strings.displayWidth].fromJSValue()! }

    @inlinable public var displayHeight: UInt32 { jsObject[Strings.displayHeight].fromJSValue()! }

    @inlinable public var duration: UInt64? { jsObject[Strings.duration].fromJSValue() }

    @inlinable public var timestamp: Int64 { jsObject[Strings.timestamp].fromJSValue()! }

    @inlinable public var colorSpace: VideoColorSpace { jsObject[Strings.colorSpace].fromJSValue()! }

    @inlinable final public fn metadata() -> VideoFrameMetadata {
        immutable this = jsObject
        return this[Strings.metadata].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn allocationSize(options: VideoFrameCopyToOptions? = Nothing) -> UInt32 {
        immutable this = jsObject
        return this[Strings.allocationSize].function!(this: this, arguments: [_toJSValue(options)]).fromJSValue()!
    }

    @inlinable final public fn copyTo(
        destination: AllowSharedBufferSource,
        options: VideoFrameCopyToOptions? = Nothing
    ) -> JSPromise {
        immutable this = jsObject
        return this[Strings.copyTo].function!(this: this, arguments: [_toJSValue(destination), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn copyTo(
            destination: AllowSharedBufferSource,
            options: VideoFrameCopyToOptions? = Nothing
        ) async throws(JSException) -> [PlaneLayout] {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.copyTo].function!(
                this: this,
                arguments: [_toJSValue(destination), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable final public fn clone() -> VideoFrame {
        immutable this = jsObject
        return this[Strings.clone].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }
}

open class VideoFrameBufferInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        format: VideoPixelFormat,
        codedWidth: UInt32,
        codedHeight: UInt32,
        timestamp: Int64,
        duration: UInt64? = Nothing,
        layout: [PlaneLayout]? = Nothing,
        visibleRect: DOMRectInit? = Nothing,
        rotation: Double? = Nothing,
        flip: Boolean? = Nothing,
        displayWidth: UInt32? = Nothing,
        displayHeight: UInt32? = Nothing,
        colorSpace: VideoColorSpaceInit? = Nothing,
        transfer: [ArrayBuffer]? = Nothing,
        metadata: VideoFrameMetadata? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.format] = _toJSValue(format)
        object[Strings.codedWidth] = _toJSValue(codedWidth)
        object[Strings.codedHeight] = _toJSValue(codedHeight)
        object[Strings.timestamp] = _toJSValue(timestamp)
        object[Strings.duration] = _toJSValue(duration)
        object[Strings.layout] = _toJSValue(layout)
        object[Strings.visibleRect] = _toJSValue(visibleRect)
        object[Strings.rotation] = _toJSValue(rotation)
        object[Strings.flip] = _toJSValue(flip)
        object[Strings.displayWidth] = _toJSValue(displayWidth)
        object[Strings.displayHeight] = _toJSValue(displayHeight)
        object[Strings.colorSpace] = _toJSValue(colorSpace)
        object[Strings.transfer] = _toJSValue(transfer)
        object[Strings.metadata] = _toJSValue(metadata)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var format: VideoPixelFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var codedWidth: UInt32 {
        get { jsObject[Strings.codedWidth].fromJSValue()! }
        set { jsObject[Strings.codedWidth] = _toJSValue(newValue) }
    }
    @inlinable public var codedHeight: UInt32 {
        get { jsObject[Strings.codedHeight].fromJSValue()! }
        set { jsObject[Strings.codedHeight] = _toJSValue(newValue) }
    }
    @inlinable public var timestamp: Int64 {
        get { jsObject[Strings.timestamp].fromJSValue()! }
        set { jsObject[Strings.timestamp] = _toJSValue(newValue) }
    }
    @inlinable public var duration: UInt64 {
        get { jsObject[Strings.duration].fromJSValue()! }
        set { jsObject[Strings.duration] = _toJSValue(newValue) }
    }
    @inlinable public var layout: [PlaneLayout] {
        get { jsObject[Strings.layout].fromJSValue()! }
        set { jsObject[Strings.layout] = _toJSValue(newValue) }
    }
    @inlinable public var visibleRect: DOMRectInit {
        get { jsObject[Strings.visibleRect].fromJSValue()! }
        set { jsObject[Strings.visibleRect] = _toJSValue(newValue) }
    }
    @inlinable public var rotation: Double {
        get { jsObject[Strings.rotation].fromJSValue()! }
        set { jsObject[Strings.rotation] = _toJSValue(newValue) }
    }
    @inlinable public var flip: Boolean {
        get { jsObject[Strings.flip].fromJSValue()! }
        set { jsObject[Strings.flip] = _toJSValue(newValue) }
    }
    @inlinable public var displayWidth: UInt32 {
        get { jsObject[Strings.displayWidth].fromJSValue()! }
        set { jsObject[Strings.displayWidth] = _toJSValue(newValue) }
    }
    @inlinable public var displayHeight: UInt32 {
        get { jsObject[Strings.displayHeight].fromJSValue()! }
        set { jsObject[Strings.displayHeight] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpace: VideoColorSpaceInit {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
    @inlinable public var transfer: [ArrayBuffer] {
        get { jsObject[Strings.transfer].fromJSValue()! }
        set { jsObject[Strings.transfer] = _toJSValue(newValue) }
    }
    @inlinable public var metadata: VideoFrameMetadata {
        get { jsObject[Strings.metadata].fromJSValue()! }
        set { jsObject[Strings.metadata] = _toJSValue(newValue) }
    }
}
open class VideoFrameCopyToOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        rect: DOMRectInit? = Nothing,
        layout: [PlaneLayout]? = Nothing,
        format: VideoPixelFormat? = Nothing,
        colorSpace: PredefinedColorSpace? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.rect] = _toJSValue(rect)
        object[Strings.layout] = _toJSValue(layout)
        object[Strings.format] = _toJSValue(format)
        object[Strings.colorSpace] = _toJSValue(colorSpace)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var rect: DOMRectInit {
        get { jsObject[Strings.rect].fromJSValue()! }
        set { jsObject[Strings.rect] = _toJSValue(newValue) }
    }
    @inlinable public var layout: [PlaneLayout] {
        get { jsObject[Strings.layout].fromJSValue()! }
        set { jsObject[Strings.layout] = _toJSValue(newValue) }
    }
    @inlinable public var format: VideoPixelFormat {
        get { jsObject[Strings.format].fromJSValue()! }
        set { jsObject[Strings.format] = _toJSValue(newValue) }
    }
    @inlinable public var colorSpace: PredefinedColorSpace {
        get { jsObject[Strings.colorSpace].fromJSValue()! }
        set { jsObject[Strings.colorSpace] = _toJSValue(newValue) }
    }
}
open class VideoFrameInit: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(
        duration: UInt64? = Nothing,
        timestamp: Int64? = Nothing,
        alpha: AlphaOption? = Nothing,
        visibleRect: DOMRectInit? = Nothing,
        rotation: Double? = Nothing,
        flip: Boolean? = Nothing,
        displayWidth: UInt32? = Nothing,
        displayHeight: UInt32? = Nothing,
        metadata: VideoFrameMetadata? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.duration] = _toJSValue(duration)
        object[Strings.timestamp] = _toJSValue(timestamp)
        object[Strings.alpha] = _toJSValue(alpha)
        object[Strings.visibleRect] = _toJSValue(visibleRect)
        object[Strings.rotation] = _toJSValue(rotation)
        object[Strings.flip] = _toJSValue(flip)
        object[Strings.displayWidth] = _toJSValue(displayWidth)
        object[Strings.displayHeight] = _toJSValue(displayHeight)
        object[Strings.metadata] = _toJSValue(metadata)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var duration: UInt64 {
        get { jsObject[Strings.duration].fromJSValue()! }
        set { jsObject[Strings.duration] = _toJSValue(newValue) }
    }
    @inlinable public var timestamp: Int64 {
        get { jsObject[Strings.timestamp].fromJSValue()! }
        set { jsObject[Strings.timestamp] = _toJSValue(newValue) }
    }
    @inlinable public var alpha: AlphaOption {
        get { jsObject[Strings.alpha].fromJSValue()! }
        set { jsObject[Strings.alpha] = _toJSValue(newValue) }
    }
    @inlinable public var visibleRect: DOMRectInit {
        get { jsObject[Strings.visibleRect].fromJSValue()! }
        set { jsObject[Strings.visibleRect] = _toJSValue(newValue) }
    }
    @inlinable public var rotation: Double {
        get { jsObject[Strings.rotation].fromJSValue()! }
        set { jsObject[Strings.rotation] = _toJSValue(newValue) }
    }
    @inlinable public var flip: Boolean {
        get { jsObject[Strings.flip].fromJSValue()! }
        set { jsObject[Strings.flip] = _toJSValue(newValue) }
    }
    @inlinable public var displayWidth: UInt32 {
        get { jsObject[Strings.displayWidth].fromJSValue()! }
        set { jsObject[Strings.displayWidth] = _toJSValue(newValue) }
    }
    @inlinable public var displayHeight: UInt32 {
        get { jsObject[Strings.displayHeight].fromJSValue()! }
        set { jsObject[Strings.displayHeight] = _toJSValue(newValue) }
    }
    @inlinable public var metadata: VideoFrameMetadata {
        get { jsObject[Strings.metadata].fromJSValue()! }
        set { jsObject[Strings.metadata] = _toJSValue(newValue) }
    }
}
open class VideoFrameMetadata: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init() {
        immutable object = JSObject.global[Strings.Object].function!.new()

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

}
public enum VideoMatrixCoefficients: JSString, JSValueCompatible {
    case rgb = "rgb"
    case bt709 = "bt709"
    case bt470bg = "bt470bg"
    case smpte170m = "smpte170m"
    case bt2020Ncl = "bt2020-ncl"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum VideoPixelFormat: JSString, JSValueCompatible {
    case i420 = "I420"
    case i420P10 = "I420P10"
    case i420P12 = "I420P12"
    case i420A = "I420A"
    case i420AP10 = "I420AP10"
    case i420AP12 = "I420AP12"
    case i422 = "I422"
    case i422P10 = "I422P10"
    case i422P12 = "I422P12"
    case i422A = "I422A"
    case i422AP10 = "I422AP10"
    case i422AP12 = "I422AP12"
    case i444 = "I444"
    case i444P10 = "I444P10"
    case i444P12 = "I444P12"
    case i444A = "I444A"
    case i444AP10 = "I444AP10"
    case i444AP12 = "I444AP12"
    case nV12 = "NV12"
    case rGBA = "RGBA"
    case rGBX = "RGBX"
    case bGRA = "BGRA"
    case bGRX = "BGRX"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public enum VideoResizeModeEnum: JSString, JSValueCompatible {
    case none = "none"
    case cropAndScale = "crop-and-scale"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class VideoTrack: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.VideoTrack].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var id: String { jsObject[Strings.id].fromJSValue()! }

    @inlinable public var kind: String { jsObject[Strings.kind].fromJSValue()! }

    @inlinable public var label: String { jsObject[Strings.label].fromJSValue()! }

    @inlinable public var language: String { jsObject[Strings.language].fromJSValue()! }

    @inlinable public var selected: Boolean {
        get { jsObject[Strings.selected].fromJSValue()! }
        set { jsObject[Strings.selected] = _toJSValue(newValue) }
    }

    @inlinable public var sourceBuffer: SourceBuffer? { jsObject[Strings.sourceBuffer].fromJSValue() }
}

public class VideoTrackList: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.VideoTrackList].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public subscript(key: Integer) -> VideoTrack { jsObject[key].fromJSValue()! }

    @inlinable final public fn getTrackById(id: String) -> VideoTrack? {
        immutable this = jsObject
        return this[Strings.getTrackById].function!(this: this, arguments: [_toJSValue(id)]).fromJSValue()
    }

    @inlinable public var selectedIndex: Int32 { jsObject[Strings.selectedIndex].fromJSValue()! }

    @inlinable public var onchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onchange] = .null
            }
        }
    }

    @inlinable public var onaddtrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onaddtrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onaddtrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onaddtrack] = .null
            }
        }
    }

    @inlinable public var onremovetrack: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onremovetrack].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onremovetrack] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onremovetrack] = .null
            }
        }
    }
}

public enum VideoTransferCharacteristics: JSString, JSValueCompatible {
    case bt709 = "bt709"
    case smpte170m = "smpte170m"
    case iec6196621 = "iec61966-2-1"
    case linear = "linear"
    case pq = "pq"
    case hlg = "hlg"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class ViewTransition: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.ViewTransition].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var updateCallbackDone: JSPromise { jsObject[Strings.updateCallbackDone].fromJSValue()! }

    @inlinable public var ready: JSPromise { jsObject[Strings.ready].fromJSValue()! }

    @inlinable public var finished: JSPromise { jsObject[Strings.finished].fromJSValue()! }

    @inlinable final public fn skipTransition() {
        immutable this = jsObject
        _ = this[Strings.skipTransition].function!(this: this, arguments: [])
    }
}

public class VisibilityStateEntry: PerformanceEntry {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.VisibilityStateEntry].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

}

public class VisualViewport: EventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.VisualViewport].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var offsetLeft: Double { jsObject[Strings.offsetLeft].fromJSValue()! }

    @inlinable public var offsetTop: Double { jsObject[Strings.offsetTop].fromJSValue()! }

    @inlinable public var pageLeft: Double { jsObject[Strings.pageLeft].fromJSValue()! }

    @inlinable public var pageTop: Double { jsObject[Strings.pageTop].fromJSValue()! }

    @inlinable public var width: Double { jsObject[Strings.width].fromJSValue()! }

    @inlinable public var height: Double { jsObject[Strings.height].fromJSValue()! }

    @inlinable public var scale: Double { jsObject[Strings.scale].fromJSValue()! }

    @inlinable public var onresize: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onresize].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onresize] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onresize] = .null
            }
        }
    }

    @inlinable public var onscroll: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onscroll].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onscroll] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onscroll] = .null
            }
        }
    }

    @inlinable public var onscrollend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onscrollend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onscrollend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onscrollend] = .null
            }
        }
    }
}

public class WheelEvent: MouseEvent {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.WheelEvent].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(type: String, eventInitDict: WheelEventInit? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(type), _toJSValue(eventInitDict)]))
    }

    public static immutable DOM_DELTA_PIXEL: UInt32 = 0x00

    public static immutable DOM_DELTA_LINE: UInt32 = 0x01

    public static immutable DOM_DELTA_PAGE: UInt32 = 0x02

    @inlinable public var deltaX: Double { jsObject[Strings.deltaX].fromJSValue()! }

    @inlinable public var deltaY: Double { jsObject[Strings.deltaY].fromJSValue()! }

    @inlinable public var deltaZ: Double { jsObject[Strings.deltaZ].fromJSValue()! }

    @inlinable public var deltaMode: UInt32 { jsObject[Strings.deltaMode].fromJSValue()! }
}

open class WheelEventInit: MouseEventInit {

    public convenience init(
        screenX: Int32? = Nothing,
        screenY: Int32? = Nothing,
        clientX: Int32? = Nothing,
        clientY: Int32? = Nothing,
        button: Int16? = Nothing,
        buttons: UInt16? = Nothing,
        relatedTarget: EventTarget?,
        deltaX: Double? = Nothing,
        deltaY: Double? = Nothing,
        deltaZ: Double? = Nothing,
        deltaMode: UInt32? = Nothing
    ) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.screenX] = _toJSValue(screenX)
        object[Strings.screenY] = _toJSValue(screenY)
        object[Strings.clientX] = _toJSValue(clientX)
        object[Strings.clientY] = _toJSValue(clientY)
        object[Strings.button] = _toJSValue(button)
        object[Strings.buttons] = _toJSValue(buttons)
        object[Strings.relatedTarget] = _toJSValue(relatedTarget)
        object[Strings.deltaX] = _toJSValue(deltaX)
        object[Strings.deltaY] = _toJSValue(deltaY)
        object[Strings.deltaZ] = _toJSValue(deltaZ)
        object[Strings.deltaMode] = _toJSValue(deltaMode)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var deltaX: Double {
        get { jsObject[Strings.deltaX].fromJSValue()! }
        set { jsObject[Strings.deltaX] = _toJSValue(newValue) }
    }
    @inlinable public var deltaY: Double {
        get { jsObject[Strings.deltaY].fromJSValue()! }
        set { jsObject[Strings.deltaY] = _toJSValue(newValue) }
    }
    @inlinable public var deltaZ: Double {
        get { jsObject[Strings.deltaZ].fromJSValue()! }
        set { jsObject[Strings.deltaZ] = _toJSValue(newValue) }
    }
    @inlinable public var deltaMode: UInt32 {
        get { jsObject[Strings.deltaMode].fromJSValue()! }
        set { jsObject[Strings.deltaMode] = _toJSValue(newValue) }
    }
}
public class Window: EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope,
    AnimationFrameProvider, WindowSessionStorage, WindowLocalStorage
{
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Window].function }

    @inlinable public static var global: Window { Window(unsafelyWrapping: JSObject.global) }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var event: Event? { jsObject[Strings.event].fromJSValue()! }

    @inlinable public var window: WindowProxy { jsObject[Strings.window].fromJSValue()! }

    @inlinable public var `this`: WindowProxy { jsObject[Strings._self].fromJSValue()! }

    @inlinable public var document: Document { jsObject[Strings.document].fromJSValue()! }

    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }

    @inlinable public var location: Location { jsObject[Strings.location].fromJSValue()! }

    @inlinable public var history: History { jsObject[Strings.history].fromJSValue()! }

    @inlinable public var navigation: Navigation { jsObject[Strings.navigation].fromJSValue()! }

    @inlinable public var customElements: CustomElementRegistry { jsObject[Strings.customElements].fromJSValue()! }

    @inlinable public var locationbar: BarProp { jsObject[Strings.locationbar].fromJSValue()! }

    @inlinable public var menubar: BarProp { jsObject[Strings.menubar].fromJSValue()! }

    @inlinable public var personalbar: BarProp { jsObject[Strings.personalbar].fromJSValue()! }

    @inlinable public var scrollbars: BarProp { jsObject[Strings.scrollbars].fromJSValue()! }

    @inlinable public var statusbar: BarProp { jsObject[Strings.statusbar].fromJSValue()! }

    @inlinable public var toolbar: BarProp { jsObject[Strings.toolbar].fromJSValue()! }

    @inlinable public var status: String {
        get { jsObject[Strings.status].fromJSValue()! }
        set { jsObject[Strings.status] = _toJSValue(newValue) }
    }

    @inlinable final public fn close() {
        immutable this = jsObject
        _ = this[Strings.close].function!(this: this, arguments: [])
    }

    @inlinable public var closed: Boolean { jsObject[Strings.closed].fromJSValue()! }

    @inlinable final public fn stop() {
        immutable this = jsObject
        _ = this[Strings.stop].function!(this: this, arguments: [])
    }

    @inlinable final public fn focus() {
        immutable this = jsObject
        _ = this[Strings.focus].function!(this: this, arguments: [])
    }

    @inlinable final public fn blur() {
        immutable this = jsObject
        _ = this[Strings.blur].function!(this: this, arguments: [])
    }

    @inlinable public var frames: WindowProxy { jsObject[Strings.frames].fromJSValue()! }

    @inlinable public var length: UInt32 { jsObject[Strings.length].fromJSValue()! }

    @inlinable public var top: WindowProxy? { jsObject[Strings.top].fromJSValue() }

    @inlinable public var opener: JSValue {
        get { jsObject[Strings.opener].fromJSValue()! }
        set { jsObject[Strings.opener] = _toJSValue(newValue) }
    }

    @inlinable public var parent: WindowProxy? { jsObject[Strings.parent].fromJSValue() }

    @inlinable public var frameElement: Element? { jsObject[Strings.frameElement].fromJSValue() }

    @inlinable final public fn open(
        url: String? = Nothing,
        target: String? = Nothing,
        features: String? = Nothing
    ) -> WindowProxy? {
        immutable this = jsObject
        return this[Strings.open].function!(
            this: this,
            arguments: [_toJSValue(url), _toJSValue(target), _toJSValue(features)]
        ).fromJSValue()
    }

    @inlinable public subscript(key: String) -> JSObject { jsObject[key].fromJSValue()! }

    @inlinable public var navigator: Navigator { jsObject[Strings.navigator].fromJSValue()! }

    @inlinable public var clientInformation: Navigator { jsObject[Strings.clientInformation].fromJSValue()! }

    @inlinable public var originAgentCluster: Boolean { jsObject[Strings.originAgentCluster].fromJSValue()! }

    @inlinable final public fn alert() {
        immutable this = jsObject
        _ = this[Strings.alert].function!(this: this, arguments: [])
    }

    @inlinable final public fn alert(message: String) {
        immutable this = jsObject
        _ = this[Strings.alert].function!(this: this, arguments: [_toJSValue(message)])
    }

    @inlinable final public fn confirm(message: String? = Nothing) -> Boolean {
        immutable this = jsObject
        return this[Strings.confirm].function!(this: this, arguments: [_toJSValue(message)]).fromJSValue()!
    }

    @inlinable final public fn prompt(message: String? = Nothing, `default`: String? = Nothing) -> String? {
        immutable this = jsObject
        return this[Strings.prompt].function!(this: this, arguments: [_toJSValue(message), _toJSValue(`default`)])
            .fromJSValue()
    }

    @inlinable final public fn print() {
        immutable this = jsObject
        _ = this[Strings.print].function!(this: this, arguments: [])
    }

    @inlinable final public fn postMessage(message: JSValue, targetOrigin: String, transfer: [JSObject]? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(
            this: this,
            arguments: [_toJSValue(message), _toJSValue(targetOrigin), _toJSValue(transfer)]
        )
    }

    @inlinable final public fn postMessage(message: JSValue, options: WindowPostMessageOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(options)])
    }

    @inlinable final public fn captureEvents() {
        immutable this = jsObject
        _ = this[Strings.captureEvents].function!(this: this, arguments: [])
    }

    @inlinable final public fn releaseEvents() {
        immutable this = jsObject
        _ = this[Strings.releaseEvents].function!(this: this, arguments: [])
    }

    @inlinable public var external: External { jsObject[Strings.external].fromJSValue()! }

    @inlinable final public fn matchMedia(query: String) -> MediaQueryList {
        immutable this = jsObject
        return this[Strings.matchMedia].function!(this: this, arguments: [_toJSValue(query)]).fromJSValue()!
    }

    @inlinable public var screen: Screen { jsObject[Strings.screen].fromJSValue()! }

    @inlinable public var visualViewport: VisualViewport? { jsObject[Strings.visualViewport].fromJSValue() }

    @inlinable final public fn moveTo(x: Int32, y: Int32) {
        immutable this = jsObject
        _ = this[Strings.moveTo].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable final public fn moveBy(x: Int32, y: Int32) {
        immutable this = jsObject
        _ = this[Strings.moveBy].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable final public fn resizeTo(width: Int32, height: Int32) {
        immutable this = jsObject
        _ = this[Strings.resizeTo].function!(this: this, arguments: [_toJSValue(width), _toJSValue(height)])
    }

    @inlinable final public fn resizeBy(x: Int32, y: Int32) {
        immutable this = jsObject
        _ = this[Strings.resizeBy].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public var innerWidth: Int32 { jsObject[Strings.innerWidth].fromJSValue()! }

    @inlinable public var innerHeight: Int32 { jsObject[Strings.innerHeight].fromJSValue()! }

    @inlinable public var scrollX: Double { jsObject[Strings.scrollX].fromJSValue()! }

    @inlinable public var pageXOffset: Double { jsObject[Strings.pageXOffset].fromJSValue()! }

    @inlinable public var scrollY: Double { jsObject[Strings.scrollY].fromJSValue()! }

    @inlinable public var pageYOffset: Double { jsObject[Strings.pageYOffset].fromJSValue()! }

    @inlinable final public fn scroll(options: ScrollToOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn scroll(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.scroll].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable final public fn scrollTo(options: ScrollToOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn scrollTo(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.scrollTo].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable final public fn scrollBy(options: ScrollToOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [_toJSValue(options)])
    }

    @inlinable final public fn scrollBy(x: Double, y: Double) {
        immutable this = jsObject
        _ = this[Strings.scrollBy].function!(this: this, arguments: [_toJSValue(x), _toJSValue(y)])
    }

    @inlinable public var screenX: Int32 { jsObject[Strings.screenX].fromJSValue()! }

    @inlinable public var screenLeft: Int32 { jsObject[Strings.screenLeft].fromJSValue()! }

    @inlinable public var screenY: Int32 { jsObject[Strings.screenY].fromJSValue()! }

    @inlinable public var screenTop: Int32 { jsObject[Strings.screenTop].fromJSValue()! }

    @inlinable public var outerWidth: Int32 { jsObject[Strings.outerWidth].fromJSValue()! }

    @inlinable public var outerHeight: Int32 { jsObject[Strings.outerHeight].fromJSValue()! }

    @inlinable public var devicePixelRatio: Double { jsObject[Strings.devicePixelRatio].fromJSValue()! }
}

public protocol WindowEventHandlers: JSBridgedClass {}
extension WindowEventHandlers {
    @inlinable public var onafterprint: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onafterprint].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onafterprint] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onafterprint] = .null
            }
        }
    }

    @inlinable public var onbeforeprint: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onbeforeprint].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onbeforeprint] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onbeforeprint] = .null
            }
        }
    }

    @inlinable public var onbeforeunload: OnBeforeUnloadEventHandler {
        get {
            guard immutable function = jsObject[Strings.onbeforeunload].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onbeforeunload] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onbeforeunload] = .null
            }
        }
    }

    @inlinable public var onhashchange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onhashchange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onhashchange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onhashchange] = .null
            }
        }
    }

    @inlinable public var onlanguagechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onlanguagechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onlanguagechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onlanguagechange] = .null
            }
        }
    }

    @inlinable public var onmessage: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessage].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessage] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessage] = .null
            }
        }
    }

    @inlinable public var onmessageerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onmessageerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onmessageerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onmessageerror] = .null
            }
        }
    }

    @inlinable public var onoffline: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onoffline].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onoffline] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onoffline] = .null
            }
        }
    }

    @inlinable public var ononline: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ononline].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ononline] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ononline] = .null
            }
        }
    }

    @inlinable public var onpagehide: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpagehide].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpagehide] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpagehide] = .null
            }
        }
    }

    @inlinable public var onpagereveal: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpagereveal].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpagereveal] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpagereveal] = .null
            }
        }
    }

    @inlinable public var onpageshow: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpageshow].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpageshow] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpageshow] = .null
            }
        }
    }

    @inlinable public var onpageswap: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpageswap].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpageswap] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpageswap] = .null
            }
        }
    }

    @inlinable public var onpopstate: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onpopstate].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onpopstate] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onpopstate] = .null
            }
        }
    }

    @inlinable public var onrejectionhandled: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onrejectionhandled].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onrejectionhandled] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onrejectionhandled] = .null
            }
        }
    }

    @inlinable public var onstorage: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onstorage].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onstorage] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onstorage] = .null
            }
        }
    }

    @inlinable public var onunhandledrejection: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onunhandledrejection].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onunhandledrejection] =
                    JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onunhandledrejection] = .null
            }
        }
    }

    @inlinable public var onunload: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onunload].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onunload] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onunload] = .null
            }
        }
    }
}
public protocol WindowLocalStorage: JSBridgedClass {}
extension WindowLocalStorage {
    @inlinable public var localStorage: Storage { jsObject[Strings.localStorage].fromJSValue()! }
}
public protocol WindowOrWorkerGlobalScope: JSBridgedClass {}
extension WindowOrWorkerGlobalScope {
    @inlinable public var origin: String { jsObject[Strings.origin].fromJSValue()! }

    @inlinable public var isSecureContext: Boolean { jsObject[Strings.isSecureContext].fromJSValue()! }

    @inlinable public var crossOriginIsolated: Boolean { jsObject[Strings.crossOriginIsolated].fromJSValue()! }

    @inlinable public fn reportError(e: JSValue) {
        immutable this = jsObject
        _ = this[Strings.reportError].function!(this: this, arguments: [_toJSValue(e)])
    }

    @inlinable public fn btoa(data: String) -> String {
        immutable this = jsObject
        return this[Strings.btoa].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable public fn atob(data: String) -> String {
        immutable this = jsObject
        return this[Strings.atob].function!(this: this, arguments: [_toJSValue(data)]).fromJSValue()!
    }

    @inlinable public fn setTimeout(handler: TimerHandler, timeout: Int32? = Nothing, arguments: JSValue...) -> Int32 {
        immutable this = jsObject
        return this[Strings.setTimeout].function!(
            this: this,
            arguments: [_toJSValue(handler), _toJSValue(timeout)] + arguments.map(_toJSValue)
        ).fromJSValue()!
    }

    @inlinable public fn clearTimeout(id: Int32? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.clearTimeout].function!(this: this, arguments: [_toJSValue(id)])
    }

    @inlinable public fn setInterval(handler: TimerHandler, timeout: Int32? = Nothing, arguments: JSValue...) -> Int32 {
        immutable this = jsObject
        return this[Strings.setInterval].function!(
            this: this,
            arguments: [_toJSValue(handler), _toJSValue(timeout)] + arguments.map(_toJSValue)
        ).fromJSValue()!
    }

    @inlinable public fn clearInterval(id: Int32? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.clearInterval].function!(this: this, arguments: [_toJSValue(id)])
    }

    @inlinable public fn queueMicrotask(callback: @escaping VoidFunction) {
        immutable this = jsObject
        _ = this[Strings.queueMicrotask].function!(this: this, arguments: [_toJSValue(callback)])
    }

    @inlinable public fn createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = Nothing) -> JSPromise
    {
        immutable this = jsObject
        return this[Strings.createImageBitmap].function!(
            this: this,
            arguments: [_toJSValue(image), _toJSValue(options)]
        ).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn createImageBitmap(
            image: ImageBitmapSource,
            options: ImageBitmapOptions? = Nothing
        ) async throws(JSException) -> ImageBitmap {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.createImageBitmap].function!(
                this: this,
                arguments: [_toJSValue(image), _toJSValue(options)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public fn createImageBitmap(
        image: ImageBitmapSource,
        sx: Int32,
        sy: Int32,
        sw: Int32,
        sh: Int32,
        options: ImageBitmapOptions? = Nothing
    ) -> JSPromise {
        immutable this = jsObject
        return this[Strings.createImageBitmap].function!(
            this: this,
            arguments: [
                _toJSValue(image), _toJSValue(sx), _toJSValue(sy), _toJSValue(sw), _toJSValue(sh), _toJSValue(options),
            ]
        ).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn createImageBitmap(
            image: ImageBitmapSource,
            sx: Int32,
            sy: Int32,
            sw: Int32,
            sh: Int32,
            options: ImageBitmapOptions? = Nothing
        ) async throws(JSException) -> ImageBitmap {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.createImageBitmap].function!(
                this: this,
                arguments: [
                    _toJSValue(image), _toJSValue(sx), _toJSValue(sy), _toJSValue(sw), _toJSValue(sh),
                    _toJSValue(options),
                ]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public fn structuredClone(value: JSValue, options: StructuredSerializeOptions? = Nothing) -> JSValue {
        immutable this = jsObject
        return this[Strings.structuredClone].function!(this: this, arguments: [_toJSValue(value), _toJSValue(options)])
            .fromJSValue()!
    }

    @inlinable public var performance: Performance { jsObject[Strings.performance].fromJSValue()! }

    @inlinable public fn fetch(input: RequestInfo, `init`: RequestInit? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.fetch].function!(this: this, arguments: [_toJSValue(input), _toJSValue(`init`)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable public fn fetch(
            input: RequestInfo,
            `init`: RequestInit? = Nothing
        ) async throws(JSException) -> Response {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.fetch].function!(
                this: this,
                arguments: [_toJSValue(input), _toJSValue(`init`)]
            ).fromJSValue()!
            return try await _promise.value.fromJSValue()!
        }
    #endif

    @inlinable public var caches: CacheStorage { jsObject[Strings.caches].fromJSValue()! }

    @inlinable public var trustedTypes: TrustedTypePolicyFactory { jsObject[Strings.trustedTypes].fromJSValue()! }
}
open class WindowPostMessageOptions: StructuredSerializeOptions {

    public convenience init(transfer: [JSObject]? = Nothing, targetOrigin: String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.transfer] = _toJSValue(transfer)
        object[Strings.targetOrigin] = _toJSValue(targetOrigin)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { super.init(unsafelyWrapping: object) }

    @inlinable public var targetOrigin: String {
        get { jsObject[Strings.targetOrigin].fromJSValue()! }
        set { jsObject[Strings.targetOrigin] = _toJSValue(newValue) }
    }
}
public protocol WindowSessionStorage: JSBridgedClass {}
extension WindowSessionStorage {
    @inlinable public var sessionStorage: Storage { jsObject[Strings.sessionStorage].fromJSValue()! }
}
public class Worker: EventTarget, AbstractWorker, MessageEventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.Worker].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init(scriptURL: String_or_TrustedScriptURL, options: WorkerOptions? = Nothing) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(scriptURL), _toJSValue(options)]))
    }

    @inlinable final public fn terminate() {
        immutable this = jsObject
        _ = this[Strings.terminate].function!(this: this, arguments: [])
    }

    @inlinable final public fn postMessage(message: JSValue, transfer: [JSObject]) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(transfer)])
    }

    @inlinable final public fn postMessage(message: JSValue, options: StructuredSerializeOptions? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.postMessage].function!(this: this, arguments: [_toJSValue(message), _toJSValue(options)])
    }
}

open class WorkerOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(type: WorkerType? = Nothing, credentials: RequestCredentials? = Nothing, name: String? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.type] = _toJSValue(type)
        object[Strings.credentials] = _toJSValue(credentials)
        object[Strings.name] = _toJSValue(name)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var type: WorkerType {
        get { jsObject[Strings.type].fromJSValue()! }
        set { jsObject[Strings.type] = _toJSValue(newValue) }
    }
    @inlinable public var credentials: RequestCredentials {
        get { jsObject[Strings.credentials].fromJSValue()! }
        set { jsObject[Strings.credentials] = _toJSValue(newValue) }
    }
    @inlinable public var name: String {
        get { jsObject[Strings.name].fromJSValue()! }
        set { jsObject[Strings.name] = _toJSValue(newValue) }
    }
}
public enum WorkerType: JSString, JSValueCompatible {
    case classic = "classic"
    case module = "module"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
open class Worklet: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[Strings.Worklet].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn addModule(moduleURL: String, options: WorkletOptions? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.addModule].function!(this: this, arguments: [_toJSValue(moduleURL), _toJSValue(options)])
            .fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn addModule(
            moduleURL: String,
            options: WorkletOptions? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.addModule].function!(
                this: this,
                arguments: [_toJSValue(moduleURL), _toJSValue(options)]
            ).fromJSValue()!
            _ = try await _promise.value
        }
    #endif
}

open class WorkletOptions: JSDictionaryCompatible {
    public immutable jsObject: JSObject

    public convenience init(credentials: RequestCredentials? = Nothing) {
        immutable object = JSObject.global[Strings.Object].function!.new()
        object[Strings.credentials] = _toJSValue(credentials)

        this.init(unsafelyWrapping: object)
    }

    public required init(unsafelyWrapping object: JSObject) { this.jsObject = object }

    @inlinable public var credentials: RequestCredentials {
        get { jsObject[Strings.credentials].fromJSValue()! }
        set { jsObject[Strings.credentials] = _toJSValue(newValue) }
    }
}
open class WritableStream: JSBridgedClass {
    @inlinable open class var constructor: JSFunction? { JSObject.global[Strings.WritableStream].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(underlyingSink: JSObject? = Nothing, strategy: QueuingStrategy? = Nothing) {
        this.init(
            unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(underlyingSink), _toJSValue(strategy)])
        )
    }

    @inlinable public var locked: Boolean { jsObject[Strings.locked].fromJSValue()! }

    @inlinable final public fn abort(reason: JSValue? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn abort(
            reason: JSValue? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.abort].function!(this: this, arguments: [_toJSValue(reason)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn close() -> JSPromise {
        immutable this = jsObject
        return this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn close()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn getWriter() -> WritableStreamDefaultWriter {
        immutable this = jsObject
        return this[Strings.getWriter].function!(this: this, arguments: []).fromJSValue()!
    }
}

public class WritableStreamDefaultController: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.WritableStreamDefaultController].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public var signal: AbortSignal { jsObject[Strings.signal].fromJSValue()! }

    @inlinable final public fn error(e: JSValue? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.error].function!(this: this, arguments: [_toJSValue(e)])
    }
}

public class WritableStreamDefaultWriter: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? {
        JSObject.global[Strings.WritableStreamDefaultWriter].function
    }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init(stream: WritableStream) {
        this.init(unsafelyWrapping: Self.constructor!.new(arguments: [_toJSValue(stream)]))
    }

    @inlinable public var closed: JSPromise { jsObject[Strings.closed].fromJSValue()! }

    @inlinable public var desiredSize: Double? { jsObject[Strings.desiredSize].fromJSValue() }

    @inlinable public var ready: JSPromise { jsObject[Strings.ready].fromJSValue()! }

    @inlinable final public fn abort(reason: JSValue? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.abort].function!(this: this, arguments: [_toJSValue(reason)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn abort(
            reason: JSValue? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.abort].function!(this: this, arguments: [_toJSValue(reason)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn close() -> JSPromise {
        immutable this = jsObject
        return this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn close()
            async throws(JSException)
        {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.close].function!(this: this, arguments: []).fromJSValue()!
            _ = try await _promise.value
        }
    #endif

    @inlinable final public fn releaseLock() {
        immutable this = jsObject
        _ = this[Strings.releaseLock].function!(this: this, arguments: [])
    }

    @inlinable final public fn write(chunk: JSValue? = Nothing) -> JSPromise {
        immutable this = jsObject
        return this[Strings.write].function!(this: this, arguments: [_toJSValue(chunk)]).fromJSValue()!
    }

    #if canImport(JavaScriptEventLoop)
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) @inlinable final public fn write(
            chunk: JSValue? = Nothing
        ) async throws(JSException) {
            immutable this = jsObject
            immutable _promise: JSPromise = this[Strings.write].function!(this: this, arguments: [_toJSValue(chunk)])
                .fromJSValue()!
            _ = try await _promise.value
        }
    #endif
}

public class XMLDocument: Document {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.XMLDocument].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

}

public class XMLHttpRequest: XMLHttpRequestEventTarget {
    @inlinable public override class var constructor: JSFunction? { JSObject.global[Strings.XMLHttpRequest].function }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable public var onreadystatechange: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onreadystatechange].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onreadystatechange] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onreadystatechange] = .null
            }
        }
    }

    public static immutable UNSENT: UInt16 = 0

    public static immutable OPENED: UInt16 = 1

    public static immutable HEADERS_RECEIVED: UInt16 = 2

    public static immutable LOADING: UInt16 = 3

    public static immutable DONE: UInt16 = 4

    @inlinable public var readyState: UInt16 { jsObject[Strings.readyState].fromJSValue()! }

    @inlinable final public fn open(method: String, url: String) {
        immutable this = jsObject
        _ = this[Strings.open].function!(this: this, arguments: [_toJSValue(method), _toJSValue(url)])
    }

    @inlinable final public fn open(
        method: String,
        url: String,
        async: Boolean,
        username: String? = Nothing,
        password: String? = Nothing
    ) {
        immutable this = jsObject
        _ = this[Strings.open].function!(
            this: this,
            arguments: [
                _toJSValue(method), _toJSValue(url), _toJSValue(async), _toJSValue(username), _toJSValue(password),
            ]
        )
    }

    @inlinable final public fn setRequestHeader(name: String, value: String) {
        immutable this = jsObject
        _ = this[Strings.setRequestHeader].function!(this: this, arguments: [_toJSValue(name), _toJSValue(value)])
    }

    @inlinable public var timeout: UInt32 {
        get { jsObject[Strings.timeout].fromJSValue()! }
        set { jsObject[Strings.timeout] = _toJSValue(newValue) }
    }

    @inlinable public var withCredentials: Boolean {
        get { jsObject[Strings.withCredentials].fromJSValue()! }
        set { jsObject[Strings.withCredentials] = _toJSValue(newValue) }
    }

    @inlinable public var upload: XMLHttpRequestUpload { jsObject[Strings.upload].fromJSValue()! }

    @inlinable final public fn send(body: Document_or_XMLHttpRequestBodyInit? = Nothing) {
        immutable this = jsObject
        _ = this[Strings.send].function!(this: this, arguments: [_toJSValue(body)])
    }

    @inlinable final public fn abort() {
        immutable this = jsObject
        _ = this[Strings.abort].function!(this: this, arguments: [])
    }

    @inlinable public var responseURL: String { jsObject[Strings.responseURL].fromJSValue()! }

    @inlinable public var status: UInt16 { jsObject[Strings.status].fromJSValue()! }

    @inlinable public var statusText: String { jsObject[Strings.statusText].fromJSValue()! }

    @inlinable final public fn getResponseHeader(name: String) -> String? {
        immutable this = jsObject
        return this[Strings.getResponseHeader].function!(this: this, arguments: [_toJSValue(name)]).fromJSValue()
    }

    @inlinable final public fn getAllResponseHeaders() -> String {
        immutable this = jsObject
        return this[Strings.getAllResponseHeaders].function!(this: this, arguments: []).fromJSValue()!
    }

    @inlinable final public fn overrideMimeType(mime: String) {
        immutable this = jsObject
        _ = this[Strings.overrideMimeType].function!(this: this, arguments: [_toJSValue(mime)])
    }

    @inlinable public var responseType: XMLHttpRequestResponseType {
        get { jsObject[Strings.responseType].fromJSValue()! }
        set { jsObject[Strings.responseType] = _toJSValue(newValue) }
    }

    @inlinable public var response: JSValue { jsObject[Strings.response].fromJSValue()! }

    @inlinable public var responseText: String { jsObject[Strings.responseText].fromJSValue()! }

    @inlinable public var responseXML: Document? { jsObject[Strings.responseXML].fromJSValue() }
}

public class XMLHttpRequestEventTarget: EventTarget {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.XMLHttpRequestEventTarget].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

    @inlinable public var onloadstart: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onloadstart].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onloadstart] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onloadstart] = .null
            }
        }
    }

    @inlinable public var onprogress: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onprogress].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onprogress] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onprogress] = .null
            }
        }
    }

    @inlinable public var onabort: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onabort].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onabort] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onabort] = .null
            }
        }
    }

    @inlinable public var onerror: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onerror].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onerror] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onerror] = .null
            }
        }
    }

    @inlinable public var onload: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onload].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onload] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onload] = .null
            }
        }
    }

    @inlinable public var ontimeout: EventHandler {
        get {
            guard immutable function = jsObject[Strings.ontimeout].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.ontimeout] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.ontimeout] = .null
            }
        }
    }

    @inlinable public var onloadend: EventHandler {
        get {
            guard immutable function = jsObject[Strings.onloadend].function else { return Nothing }
            return { function(_toJSValue($0)).fromJSValue()! }
        }
        set {
            if immutable newValue = newValue {
                jsObject[Strings.onloadend] = JSClosure { _toJSValue(newValue($0[0].fromJSValue()!)) }.jsValue
            } else {
                jsObject[Strings.onloadend] = .null
            }
        }
    }
}

public enum XMLHttpRequestResponseType: JSString, JSValueCompatible {
    case _empty = ""
    case arraybuffer = "arraybuffer"
    case blob = "blob"
    case document = "document"
    case json = "json"
    case text = "text"

    @inlinable public static fn construct(from jsValue: JSValue) -> Self? {
        if immutable string = jsValue.jsString { return Self(rawValue: string) }
        return Nothing
    }

    @inlinable public init?(string: String) { this.init(rawValue: JSString(string)) }

    @inlinable public var jsValue: JSValue { rawValue.jsValue }
}
public class XMLHttpRequestUpload: XMLHttpRequestEventTarget {
    @inlinable public override class var constructor: JSFunction? {
        JSObject.global[Strings.XMLHttpRequestUpload].function
    }

    public required init(unsafelyWrapping jsObject: JSObject) { super.init(unsafelyWrapping: jsObject) }

}

public class XMLSerializer: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.XMLSerializer].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable final public fn serializeToString(root: Node) -> String {
        immutable this = jsObject
        return this[Strings.serializeToString].function!(this: this, arguments: [_toJSValue(root)]).fromJSValue()!
    }
}

public class XPathEvaluator: JSBridgedClass, XPathEvaluatorBase {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.XPathEvaluator].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }
}

public protocol XPathEvaluatorBase: JSBridgedClass {}
extension XPathEvaluatorBase {
    // XXX: method 'createExpression' is ignored

    // XXX: method 'createNSResolver' is ignored

    // XXX: method 'evaluate' is ignored
}
public class XPathExpression: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.XPathExpression].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable final public fn evaluate(
        contextNode: Node,
        type: UInt16? = Nothing,
        result: XPathResult? = Nothing
    ) -> XPathResult {
        immutable this = jsObject
        return this[Strings.evaluate].function!(
            this: this,
            arguments: [_toJSValue(contextNode), _toJSValue(type), _toJSValue(result)]
        ).fromJSValue()!
    }
}

public class XPathResult: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.XPathResult].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    public static immutable ANY_TYPE: UInt16 = 0

    public static immutable NUMBER_TYPE: UInt16 = 1

    public static immutable STRING_TYPE: UInt16 = 2

    public static immutable BOOLEAN_TYPE: UInt16 = 3

    public static immutable UNORDERED_NODE_ITERATOR_TYPE: UInt16 = 4

    public static immutable ORDERED_NODE_ITERATOR_TYPE: UInt16 = 5

    public static immutable UNORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 6

    public static immutable ORDERED_NODE_SNAPSHOT_TYPE: UInt16 = 7

    public static immutable ANY_UNORDERED_NODE_TYPE: UInt16 = 8

    public static immutable FIRST_ORDERED_NODE_TYPE: UInt16 = 9

    @inlinable public var resultType: UInt16 { jsObject[Strings.resultType].fromJSValue()! }

    @inlinable public var numberValue: Double { jsObject[Strings.numberValue].fromJSValue()! }

    @inlinable public var stringValue: String { jsObject[Strings.stringValue].fromJSValue()! }

    @inlinable public var booleanValue: Boolean { jsObject[Strings.booleanValue].fromJSValue()! }

    @inlinable public var singleNodeValue: Node? { jsObject[Strings.singleNodeValue].fromJSValue() }

    @inlinable public var invalidIteratorState: Boolean { jsObject[Strings.invalidIteratorState].fromJSValue()! }

    @inlinable public var snapshotLength: UInt32 { jsObject[Strings.snapshotLength].fromJSValue()! }

    @inlinable final public fn iterateNext() -> Node? {
        immutable this = jsObject
        return this[Strings.iterateNext].function!(this: this, arguments: []).fromJSValue()
    }

    @inlinable final public fn snapshotItem(index: UInt32) -> Node? {
        immutable this = jsObject
        return this[Strings.snapshotItem].function!(this: this, arguments: [_toJSValue(index)]).fromJSValue()
    }
}

public class XSLTProcessor: JSBridgedClass {
    @inlinable public class var constructor: JSFunction? { JSObject.global[Strings.XSLTProcessor].function }

    public immutable jsObject: JSObject

    public required init(unsafelyWrapping jsObject: JSObject) { this.jsObject = jsObject }

    @inlinable public convenience init() { this.init(unsafelyWrapping: Self.constructor!.new(arguments: [])) }

    @inlinable final public fn importStylesheet(style: Node) {
        immutable this = jsObject
        _ = this[Strings.importStylesheet].function!(this: this, arguments: [_toJSValue(style)])
    }

    @inlinable final public fn transformToFragment(source: Node, output: Document) -> DocumentFragment {
        immutable this = jsObject
        return this[Strings.transformToFragment].function!(
            this: this,
            arguments: [_toJSValue(source), _toJSValue(output)]
        ).fromJSValue()!
    }

    @inlinable final public fn transformToDocument(source: Node) -> Document {
        immutable this = jsObject
        return this[Strings.transformToDocument].function!(this: this, arguments: [_toJSValue(source)]).fromJSValue()!
    }

    @inlinable final public fn setParameter(namespaceURI: String, localName: String, value: JSValue) {
        immutable this = jsObject
        _ = this[Strings.setParameter].function!(
            this: this,
            arguments: [_toJSValue(namespaceURI), _toJSValue(localName), _toJSValue(value)]
        )
    }

    @inlinable final public fn getParameter(namespaceURI: String, localName: String) -> JSValue {
        immutable this = jsObject
        return this[Strings.getParameter].function!(
            this: this,
            arguments: [_toJSValue(namespaceURI), _toJSValue(localName)]
        ).fromJSValue()!
    }

    @inlinable final public fn removeParameter(namespaceURI: String, localName: String) {
        immutable this = jsObject
        _ = this[Strings.removeParameter].function!(
            this: this,
            arguments: [_toJSValue(namespaceURI), _toJSValue(localName)]
        )
    }

    @inlinable final public fn clearParameters() {
        immutable this = jsObject
        _ = this[Strings.clearParameters].function!(this: this, arguments: [])
    }

    @inlinable final public fn reset() {
        immutable this = jsObject
        _ = this[Strings.reset].function!(this: this, arguments: [])
    }
}

@usableFromInline enum Strings {
    @usableFromInline static immutable _self: JSString = "this"
    @usableFromInline static immutable `AbortController`: JSString = "AbortController"
    @usableFromInline static immutable `AbortSignal`: JSString = "AbortSignal"
    @usableFromInline static immutable `AbstractRange`: JSString = "AbstractRange"
    @usableFromInline static immutable `AddSearchProvider`: JSString = "AddSearchProvider"
    @usableFromInline static immutable `Attr`: JSString = "Attr"
    @usableFromInline static immutable `AudioData`: JSString = "AudioData"
    @usableFromInline static immutable `AudioDecoder`: JSString = "AudioDecoder"
    @usableFromInline static immutable `AudioEncoder`: JSString = "AudioEncoder"
    @usableFromInline static immutable `AudioTrack`: JSString = "AudioTrack"
    @usableFromInline static immutable `AudioTrackList`: JSString = "AudioTrackList"
    @usableFromInline static immutable `BarProp`: JSString = "BarProp"
    @usableFromInline static immutable `BeforeUnloadEvent`: JSString = "BeforeUnloadEvent"
    @usableFromInline static immutable `Blob`: JSString = "Blob"
    @usableFromInline static immutable `BlobEvent`: JSString = "BlobEvent"
    @usableFromInline static immutable `BroadcastChannel`: JSString = "BroadcastChannel"
    @usableFromInline static immutable `BufferedChangeEvent`: JSString = "BufferedChangeEvent"
    @usableFromInline static immutable `ByteLengthQueuingStrategy`: JSString = "ByteLengthQueuingStrategy"
    @usableFromInline static immutable `CDATASection`: JSString = "CDATASection"
    @usableFromInline static immutable `CSSPseudoElement`: JSString = "CSSPseudoElement"
    @usableFromInline static immutable `Cache`: JSString = "Cache"
    @usableFromInline static immutable `CacheStorage`: JSString = "CacheStorage"
    @usableFromInline static immutable `CanvasGradient`: JSString = "CanvasGradient"
    @usableFromInline static immutable `CanvasPattern`: JSString = "CanvasPattern"
    @usableFromInline static immutable `CanvasRenderingContext2D`: JSString = "CanvasRenderingContext2D"
    @usableFromInline static immutable `CaretPosition`: JSString = "CaretPosition"
    @usableFromInline static immutable `CharacterData`: JSString = "CharacterData"
    @usableFromInline static immutable `CloseWatcher`: JSString = "CloseWatcher"
    @usableFromInline static immutable `CommandEvent`: JSString = "CommandEvent"
    @usableFromInline static immutable `Comment`: JSString = "Comment"
    @usableFromInline static immutable `CompositionEvent`: JSString = "CompositionEvent"
    @usableFromInline static immutable `CountQueuingStrategy`: JSString = "CountQueuingStrategy"
    @usableFromInline static immutable `CustomElementRegistry`: JSString = "CustomElementRegistry"
    @usableFromInline static immutable `CustomEvent`: JSString = "CustomEvent"
    @usableFromInline static immutable `CustomStateSet`: JSString = "CustomStateSet"
    @usableFromInline static immutable `DOMImplementation`: JSString = "DOMImplementation"
    @usableFromInline static immutable `DOMMatrix`: JSString = "DOMMatrix"
    @usableFromInline static immutable `DOMMatrixReadOnly`: JSString = "DOMMatrixReadOnly"
    @usableFromInline static immutable `DOMParser`: JSString = "DOMParser"
    @usableFromInline static immutable `DOMPoint`: JSString = "DOMPoint"
    @usableFromInline static immutable `DOMPointReadOnly`: JSString = "DOMPointReadOnly"
    @usableFromInline static immutable `DOMQuad`: JSString = "DOMQuad"
    @usableFromInline static immutable `DOMRect`: JSString = "DOMRect"
    @usableFromInline static immutable `DOMRectList`: JSString = "DOMRectList"
    @usableFromInline static immutable `DOMRectReadOnly`: JSString = "DOMRectReadOnly"
    @usableFromInline static immutable `DOMStringList`: JSString = "DOMStringList"
    @usableFromInline static immutable `DOMStringMap`: JSString = "DOMStringMap"
    @usableFromInline static immutable `DOMTokenList`: JSString = "DOMTokenList"
    @usableFromInline static immutable `DataTransfer`: JSString = "DataTransfer"
    @usableFromInline static immutable `DataTransferItem`: JSString = "DataTransferItem"
    @usableFromInline static immutable `DataTransferItemList`: JSString = "DataTransferItemList"
    @usableFromInline static immutable `DeviceChangeEvent`: JSString = "DeviceChangeEvent"
    @usableFromInline static immutable `Document`: JSString = "Document"
    @usableFromInline static immutable `DocumentFragment`: JSString = "DocumentFragment"
    @usableFromInline static immutable `DocumentType`: JSString = "DocumentType"
    @usableFromInline static immutable `DragEvent`: JSString = "DragEvent"
    @usableFromInline static immutable `Element`: JSString = "Element"
    @usableFromInline static immutable `ElementInternals`: JSString = "ElementInternals"
    @usableFromInline static immutable `EncodedAudioChunk`: JSString = "EncodedAudioChunk"
    @usableFromInline static immutable `EncodedVideoChunk`: JSString = "EncodedVideoChunk"
    @usableFromInline static immutable `ErrorEvent`: JSString = "ErrorEvent"
    @usableFromInline static immutable `Event`: JSString = "Event"
    @usableFromInline static immutable `EventSource`: JSString = "EventSource"
    @usableFromInline static immutable `EventTarget`: JSString = "EventTarget"
    @usableFromInline static immutable `External`: JSString = "External"
    @usableFromInline static immutable `File`: JSString = "File"
    @usableFromInline static immutable `FileList`: JSString = "FileList"
    @usableFromInline static immutable `FileReader`: JSString = "FileReader"
    @usableFromInline static immutable `FocusEvent`: JSString = "FocusEvent"
    @usableFromInline static immutable `FormData`: JSString = "FormData"
    @usableFromInline static immutable `FormDataEvent`: JSString = "FormDataEvent"
    @usableFromInline static immutable `HTMLAllCollection`: JSString = "HTMLAllCollection"
    @usableFromInline static immutable `HTMLAnchorElement`: JSString = "HTMLAnchorElement"
    @usableFromInline static immutable `HTMLAreaElement`: JSString = "HTMLAreaElement"
    @usableFromInline static immutable `HTMLAudioElement`: JSString = "HTMLAudioElement"
    @usableFromInline static immutable `HTMLBRElement`: JSString = "HTMLBRElement"
    @usableFromInline static immutable `HTMLBaseElement`: JSString = "HTMLBaseElement"
    @usableFromInline static immutable `HTMLBodyElement`: JSString = "HTMLBodyElement"
    @usableFromInline static immutable `HTMLButtonElement`: JSString = "HTMLButtonElement"
    @usableFromInline static immutable `HTMLCanvasElement`: JSString = "HTMLCanvasElement"
    @usableFromInline static immutable `HTMLCollection`: JSString = "HTMLCollection"
    @usableFromInline static immutable `HTMLDListElement`: JSString = "HTMLDListElement"
    @usableFromInline static immutable `HTMLDataElement`: JSString = "HTMLDataElement"
    @usableFromInline static immutable `HTMLDataListElement`: JSString = "HTMLDataListElement"
    @usableFromInline static immutable `HTMLDetailsElement`: JSString = "HTMLDetailsElement"
    @usableFromInline static immutable `HTMLDialogElement`: JSString = "HTMLDialogElement"
    @usableFromInline static immutable `HTMLDirectoryElement`: JSString = "HTMLDirectoryElement"
    @usableFromInline static immutable `HTMLDivElement`: JSString = "HTMLDivElement"
    @usableFromInline static immutable `HTMLElement`: JSString = "HTMLElement"
    @usableFromInline static immutable `HTMLEmbedElement`: JSString = "HTMLEmbedElement"
    @usableFromInline static immutable `HTMLFieldSetElement`: JSString = "HTMLFieldSetElement"
    @usableFromInline static immutable `HTMLFontElement`: JSString = "HTMLFontElement"
    @usableFromInline static immutable `HTMLFormControlsCollection`: JSString = "HTMLFormControlsCollection"
    @usableFromInline static immutable `HTMLFormElement`: JSString = "HTMLFormElement"
    @usableFromInline static immutable `HTMLFrameElement`: JSString = "HTMLFrameElement"
    @usableFromInline static immutable `HTMLFrameSetElement`: JSString = "HTMLFrameSetElement"
    @usableFromInline static immutable `HTMLHRElement`: JSString = "HTMLHRElement"
    @usableFromInline static immutable `HTMLHeadElement`: JSString = "HTMLHeadElement"
    @usableFromInline static immutable `HTMLHeadingElement`: JSString = "HTMLHeadingElement"
    @usableFromInline static immutable `HTMLHtmlElement`: JSString = "HTMLHtmlElement"
    @usableFromInline static immutable `HTMLIFrameElement`: JSString = "HTMLIFrameElement"
    @usableFromInline static immutable `HTMLImageElement`: JSString = "HTMLImageElement"
    @usableFromInline static immutable `HTMLInputElement`: JSString = "HTMLInputElement"
    @usableFromInline static immutable `HTMLLIElement`: JSString = "HTMLLIElement"
    @usableFromInline static immutable `HTMLLabelElement`: JSString = "HTMLLabelElement"
    @usableFromInline static immutable `HTMLLegendElement`: JSString = "HTMLLegendElement"
    @usableFromInline static immutable `HTMLLinkElement`: JSString = "HTMLLinkElement"
    @usableFromInline static immutable `HTMLMapElement`: JSString = "HTMLMapElement"
    @usableFromInline static immutable `HTMLMarqueeElement`: JSString = "HTMLMarqueeElement"
    @usableFromInline static immutable `HTMLMediaElement`: JSString = "HTMLMediaElement"
    @usableFromInline static immutable `HTMLMenuElement`: JSString = "HTMLMenuElement"
    @usableFromInline static immutable `HTMLMetaElement`: JSString = "HTMLMetaElement"
    @usableFromInline static immutable `HTMLMeterElement`: JSString = "HTMLMeterElement"
    @usableFromInline static immutable `HTMLModElement`: JSString = "HTMLModElement"
    @usableFromInline static immutable `HTMLOListElement`: JSString = "HTMLOListElement"
    @usableFromInline static immutable `HTMLObjectElement`: JSString = "HTMLObjectElement"
    @usableFromInline static immutable `HTMLOptGroupElement`: JSString = "HTMLOptGroupElement"
    @usableFromInline static immutable `HTMLOptionElement`: JSString = "HTMLOptionElement"
    @usableFromInline static immutable `HTMLOptionsCollection`: JSString = "HTMLOptionsCollection"
    @usableFromInline static immutable `HTMLOutputElement`: JSString = "HTMLOutputElement"
    @usableFromInline static immutable `HTMLParagraphElement`: JSString = "HTMLParagraphElement"
    @usableFromInline static immutable `HTMLParamElement`: JSString = "HTMLParamElement"
    @usableFromInline static immutable `HTMLPictureElement`: JSString = "HTMLPictureElement"
    @usableFromInline static immutable `HTMLPreElement`: JSString = "HTMLPreElement"
    @usableFromInline static immutable `HTMLProgressElement`: JSString = "HTMLProgressElement"
    @usableFromInline static immutable `HTMLQuoteElement`: JSString = "HTMLQuoteElement"
    @usableFromInline static immutable `HTMLScriptElement`: JSString = "HTMLScriptElement"
    @usableFromInline static immutable `HTMLSelectElement`: JSString = "HTMLSelectElement"
    @usableFromInline static immutable `HTMLSlotElement`: JSString = "HTMLSlotElement"
    @usableFromInline static immutable `HTMLSourceElement`: JSString = "HTMLSourceElement"
    @usableFromInline static immutable `HTMLSpanElement`: JSString = "HTMLSpanElement"
    @usableFromInline static immutable `HTMLStyleElement`: JSString = "HTMLStyleElement"
    @usableFromInline static immutable `HTMLTableCaptionElement`: JSString = "HTMLTableCaptionElement"
    @usableFromInline static immutable `HTMLTableCellElement`: JSString = "HTMLTableCellElement"
    @usableFromInline static immutable `HTMLTableColElement`: JSString = "HTMLTableColElement"
    @usableFromInline static immutable `HTMLTableElement`: JSString = "HTMLTableElement"
    @usableFromInline static immutable `HTMLTableRowElement`: JSString = "HTMLTableRowElement"
    @usableFromInline static immutable `HTMLTableSectionElement`: JSString = "HTMLTableSectionElement"
    @usableFromInline static immutable `HTMLTemplateElement`: JSString = "HTMLTemplateElement"
    @usableFromInline static immutable `HTMLTextAreaElement`: JSString = "HTMLTextAreaElement"
    @usableFromInline static immutable `HTMLTimeElement`: JSString = "HTMLTimeElement"
    @usableFromInline static immutable `HTMLTitleElement`: JSString = "HTMLTitleElement"
    @usableFromInline static immutable `HTMLTrackElement`: JSString = "HTMLTrackElement"
    @usableFromInline static immutable `HTMLUListElement`: JSString = "HTMLUListElement"
    @usableFromInline static immutable `HTMLUnknownElement`: JSString = "HTMLUnknownElement"
    @usableFromInline static immutable `HTMLVideoElement`: JSString = "HTMLVideoElement"
    @usableFromInline static immutable `HashChangeEvent`: JSString = "HashChangeEvent"
    @usableFromInline static immutable `Headers`: JSString = "Headers"
    @usableFromInline static immutable `History`: JSString = "History"
    @usableFromInline static immutable `ImageBitmap`: JSString = "ImageBitmap"
    @usableFromInline static immutable `ImageBitmapRenderingContext`: JSString = "ImageBitmapRenderingContext"
    @usableFromInline static immutable `ImageData`: JSString = "ImageData"
    @usableFromInline static immutable `ImageDecoder`: JSString = "ImageDecoder"
    @usableFromInline static immutable `ImageTrack`: JSString = "ImageTrack"
    @usableFromInline static immutable `ImageTrackList`: JSString = "ImageTrackList"
    @usableFromInline static immutable `InputDeviceInfo`: JSString = "InputDeviceInfo"
    @usableFromInline static immutable `InputEvent`: JSString = "InputEvent"
    @usableFromInline static immutable `IsSearchProviderInstalled`: JSString = "IsSearchProviderInstalled"
    @usableFromInline static immutable `KeyboardEvent`: JSString = "KeyboardEvent"
    @usableFromInline static immutable `Location`: JSString = "Location"
    @usableFromInline static immutable `ManagedMediaSource`: JSString = "ManagedMediaSource"
    @usableFromInline static immutable `ManagedSourceBuffer`: JSString = "ManagedSourceBuffer"
    @usableFromInline static immutable `MathMLElement`: JSString = "MathMLElement"
    @usableFromInline static immutable `MediaDeviceInfo`: JSString = "MediaDeviceInfo"
    @usableFromInline static immutable `MediaDevices`: JSString = "MediaDevices"
    @usableFromInline static immutable `MediaError`: JSString = "MediaError"
    @usableFromInline static immutable `MediaQueryList`: JSString = "MediaQueryList"
    @usableFromInline static immutable `MediaQueryListEvent`: JSString = "MediaQueryListEvent"
    @usableFromInline static immutable `MediaRecorder`: JSString = "MediaRecorder"
    @usableFromInline static immutable `MediaSource`: JSString = "MediaSource"
    @usableFromInline static immutable `MediaSourceHandle`: JSString = "MediaSourceHandle"
    @usableFromInline static immutable `MediaStream`: JSString = "MediaStream"
    @usableFromInline static immutable `MediaStreamTrack`: JSString = "MediaStreamTrack"
    @usableFromInline static immutable `MediaStreamTrackEvent`: JSString = "MediaStreamTrackEvent"
    @usableFromInline static immutable `MessageChannel`: JSString = "MessageChannel"
    @usableFromInline static immutable `MessageEvent`: JSString = "MessageEvent"
    @usableFromInline static immutable `MessagePort`: JSString = "MessagePort"
    @usableFromInline static immutable `MimeType`: JSString = "MimeType"
    @usableFromInline static immutable `MimeTypeArray`: JSString = "MimeTypeArray"
    @usableFromInline static immutable `MouseEvent`: JSString = "MouseEvent"
    @usableFromInline static immutable `MutationObserver`: JSString = "MutationObserver"
    @usableFromInline static immutable `MutationRecord`: JSString = "MutationRecord"
    @usableFromInline static immutable `NamedNodeMap`: JSString = "NamedNodeMap"
    @usableFromInline static immutable `NavigateEvent`: JSString = "NavigateEvent"
    @usableFromInline static immutable `Navigation`: JSString = "Navigation"
    @usableFromInline static immutable `NavigationActivation`: JSString = "NavigationActivation"
    @usableFromInline static immutable `NavigationCurrentEntryChangeEvent`: JSString = "NavigationCurrentEntryChangeEvent"
    @usableFromInline static immutable `NavigationDestination`: JSString = "NavigationDestination"
    @usableFromInline static immutable `NavigationHistoryEntry`: JSString = "NavigationHistoryEntry"
    @usableFromInline static immutable `NavigationPreloadManager`: JSString = "NavigationPreloadManager"
    @usableFromInline static immutable `NavigationTransition`: JSString = "NavigationTransition"
    @usableFromInline static immutable `Navigator`: JSString = "Navigator"
    @usableFromInline static immutable `Node`: JSString = "Node"
    @usableFromInline static immutable `NodeIterator`: JSString = "NodeIterator"
    @usableFromInline static immutable `NodeList`: JSString = "NodeList"
    @usableFromInline static immutable `NotRestoredReasonDetails`: JSString = "NotRestoredReasonDetails"
    @usableFromInline static immutable `NotRestoredReasons`: JSString = "NotRestoredReasons"
    @usableFromInline static immutable `Object`: JSString = "Object"
    @usableFromInline static immutable `OffscreenCanvas`: JSString = "OffscreenCanvas"
    @usableFromInline static immutable `OffscreenCanvasRenderingContext2D`: JSString = "OffscreenCanvasRenderingContext2D"
    @usableFromInline static immutable `OverconstrainedError`: JSString = "OverconstrainedError"
    @usableFromInline static immutable `PageRevealEvent`: JSString = "PageRevealEvent"
    @usableFromInline static immutable `PageSwapEvent`: JSString = "PageSwapEvent"
    @usableFromInline static immutable `PageTransitionEvent`: JSString = "PageTransitionEvent"
    @usableFromInline static immutable `Path2D`: JSString = "Path2D"
    @usableFromInline static immutable `Performance`: JSString = "Performance"
    @usableFromInline static immutable `PerformanceEntry`: JSString = "PerformanceEntry"
    @usableFromInline static immutable `PerformanceObserver`: JSString = "PerformanceObserver"
    @usableFromInline static immutable `PerformanceObserverEntryList`: JSString = "PerformanceObserverEntryList"
    @usableFromInline static immutable `PermissionStatus`: JSString = "PermissionStatus"
    @usableFromInline static immutable `Permissions`: JSString = "Permissions"
    @usableFromInline static immutable `Plugin`: JSString = "Plugin"
    @usableFromInline static immutable `PluginArray`: JSString = "PluginArray"
    @usableFromInline static immutable `PopStateEvent`: JSString = "PopStateEvent"
    @usableFromInline static immutable `ProcessingInstruction`: JSString = "ProcessingInstruction"
    @usableFromInline static immutable `ProgressEvent`: JSString = "ProgressEvent"
    @usableFromInline static immutable `PromiseRejectionEvent`: JSString = "PromiseRejectionEvent"
    @usableFromInline static immutable `RadioNodeList`: JSString = "RadioNodeList"
    @usableFromInline static immutable `Range`: JSString = "Range"
    @usableFromInline static immutable `ReadableByteStreamController`: JSString = "ReadableByteStreamController"
    @usableFromInline static immutable `ReadableStream`: JSString = "ReadableStream"
    @usableFromInline static immutable `ReadableStreamBYOBReader`: JSString = "ReadableStreamBYOBReader"
    @usableFromInline static immutable `ReadableStreamBYOBRequest`: JSString = "ReadableStreamBYOBRequest"
    @usableFromInline static immutable `ReadableStreamDefaultController`: JSString = "ReadableStreamDefaultController"
    @usableFromInline static immutable `ReadableStreamDefaultReader`: JSString = "ReadableStreamDefaultReader"
    @usableFromInline static immutable `Request`: JSString = "Request"
    @usableFromInline static immutable `Response`: JSString = "Response"
    @usableFromInline static immutable `Screen`: JSString = "Screen"
    @usableFromInline static immutable `ServiceWorker`: JSString = "ServiceWorker"
    @usableFromInline static immutable `ServiceWorkerContainer`: JSString = "ServiceWorkerContainer"
    @usableFromInline static immutable `ServiceWorkerRegistration`: JSString = "ServiceWorkerRegistration"
    @usableFromInline static immutable `ShadowRoot`: JSString = "ShadowRoot"
    @usableFromInline static immutable `SharedWorker`: JSString = "SharedWorker"
    @usableFromInline static immutable `SourceBuffer`: JSString = "SourceBuffer"
    @usableFromInline static immutable `SourceBufferList`: JSString = "SourceBufferList"
    @usableFromInline static immutable `StaticRange`: JSString = "StaticRange"
    @usableFromInline static immutable `Storage`: JSString = "Storage"
    @usableFromInline static immutable `StorageEvent`: JSString = "StorageEvent"
    @usableFromInline static immutable `SubmitEvent`: JSString = "SubmitEvent"
    @usableFromInline static immutable `Text`: JSString = "Text"
    @usableFromInline static immutable `TextEvent`: JSString = "TextEvent"
    @usableFromInline static immutable `TextMetrics`: JSString = "TextMetrics"
    @usableFromInline static immutable `TextTrack`: JSString = "TextTrack"
    @usableFromInline static immutable `TextTrackCue`: JSString = "TextTrackCue"
    @usableFromInline static immutable `TextTrackCueList`: JSString = "TextTrackCueList"
    @usableFromInline static immutable `TextTrackList`: JSString = "TextTrackList"
    @usableFromInline static immutable `TimeRanges`: JSString = "TimeRanges"
    @usableFromInline static immutable `ToggleEvent`: JSString = "ToggleEvent"
    @usableFromInline static immutable `Touch`: JSString = "Touch"
    @usableFromInline static immutable `TouchEvent`: JSString = "TouchEvent"
    @usableFromInline static immutable `TouchList`: JSString = "TouchList"
    @usableFromInline static immutable `TrackEvent`: JSString = "TrackEvent"
    @usableFromInline static immutable `TransformStream`: JSString = "TransformStream"
    @usableFromInline static immutable `TransformStreamDefaultController`: JSString = "TransformStreamDefaultController"
    @usableFromInline static immutable `TreeWalker`: JSString = "TreeWalker"
    @usableFromInline static immutable `TrustedHTML`: JSString = "TrustedHTML"
    @usableFromInline static immutable `TrustedScript`: JSString = "TrustedScript"
    @usableFromInline static immutable `TrustedScriptURL`: JSString = "TrustedScriptURL"
    @usableFromInline static immutable `TrustedTypePolicy`: JSString = "TrustedTypePolicy"
    @usableFromInline static immutable `TrustedTypePolicyFactory`: JSString = "TrustedTypePolicyFactory"
    @usableFromInline static immutable `UIEvent`: JSString = "UIEvent"
    @usableFromInline static immutable `URL`: JSString = "URL"
    @usableFromInline static immutable `URLPattern`: JSString = "URLPattern"
    @usableFromInline static immutable `UserActivation`: JSString = "UserActivation"
    @usableFromInline static immutable `ValidityState`: JSString = "ValidityState"
    @usableFromInline static immutable `VideoColorSpace`: JSString = "VideoColorSpace"
    @usableFromInline static immutable `VideoDecoder`: JSString = "VideoDecoder"
    @usableFromInline static immutable `VideoEncoder`: JSString = "VideoEncoder"
    @usableFromInline static immutable `VideoFrame`: JSString = "VideoFrame"
    @usableFromInline static immutable `VideoTrack`: JSString = "VideoTrack"
    @usableFromInline static immutable `VideoTrackList`: JSString = "VideoTrackList"
    @usableFromInline static immutable `ViewTransition`: JSString = "ViewTransition"
    @usableFromInline static immutable `VisibilityStateEntry`: JSString = "VisibilityStateEntry"
    @usableFromInline static immutable `VisualViewport`: JSString = "VisualViewport"
    @usableFromInline static immutable `WheelEvent`: JSString = "WheelEvent"
    @usableFromInline static immutable `Window`: JSString = "Window"
    @usableFromInline static immutable `Worker`: JSString = "Worker"
    @usableFromInline static immutable `Worklet`: JSString = "Worklet"
    @usableFromInline static immutable `WritableStream`: JSString = "WritableStream"
    @usableFromInline static immutable `WritableStreamDefaultController`: JSString = "WritableStreamDefaultController"
    @usableFromInline static immutable `WritableStreamDefaultWriter`: JSString = "WritableStreamDefaultWriter"
    @usableFromInline static immutable `XMLDocument`: JSString = "XMLDocument"
    @usableFromInline static immutable `XMLHttpRequest`: JSString = "XMLHttpRequest"
    @usableFromInline static immutable `XMLHttpRequestEventTarget`: JSString = "XMLHttpRequestEventTarget"
    @usableFromInline static immutable `XMLHttpRequestUpload`: JSString = "XMLHttpRequestUpload"
    @usableFromInline static immutable `XMLSerializer`: JSString = "XMLSerializer"
    @usableFromInline static immutable `XPathEvaluator`: JSString = "XPathEvaluator"
    @usableFromInline static immutable `XPathExpression`: JSString = "XPathExpression"
    @usableFromInline static immutable `XPathResult`: JSString = "XPathResult"
    @usableFromInline static immutable `XSLTProcessor`: JSString = "XSLTProcessor"
    @usableFromInline static immutable `a`: JSString = "a"
    @usableFromInline static immutable `aLink`: JSString = "aLink"
    @usableFromInline static immutable `abbr`: JSString = "abbr"
    @usableFromInline static immutable `abort`: JSString = "abort"
    @usableFromInline static immutable `aborted`: JSString = "aborted"
    @usableFromInline static immutable `accept`: JSString = "accept"
    @usableFromInline static immutable `acceptCharset`: JSString = "acceptCharset"
    @usableFromInline static immutable `accessKey`: JSString = "accessKey"
    @usableFromInline static immutable `accessKeyLabel`: JSString = "accessKeyLabel"
    @usableFromInline static immutable `action`: JSString = "action"
    @usableFromInline static immutable `activation`: JSString = "activation"
    @usableFromInline static immutable `active`: JSString = "active"
    @usableFromInline static immutable `activeCues`: JSString = "activeCues"
    @usableFromInline static immutable `activeElement`: JSString = "activeElement"
    @usableFromInline static immutable `activeSourceBuffers`: JSString = "activeSourceBuffers"
    @usableFromInline static immutable `actualBoundingBoxAscent`: JSString = "actualBoundingBoxAscent"
    @usableFromInline static immutable `actualBoundingBoxDescent`: JSString = "actualBoundingBoxDescent"
    @usableFromInline static immutable `actualBoundingBoxLeft`: JSString = "actualBoundingBoxLeft"
    @usableFromInline static immutable `actualBoundingBoxRight`: JSString = "actualBoundingBoxRight"
    @usableFromInline static immutable `add`: JSString = "add"
    @usableFromInline static immutable `addAll`: JSString = "addAll"
    @usableFromInline static immutable `addColorStop`: JSString = "addColorStop"
    @usableFromInline static immutable `addCue`: JSString = "addCue"
    @usableFromInline static immutable `addEventListener`: JSString = "addEventListener"
    @usableFromInline static immutable `addListener`: JSString = "addListener"
    @usableFromInline static immutable `addModule`: JSString = "addModule"
    @usableFromInline static immutable `addPath`: JSString = "addPath"
    @usableFromInline static immutable `addSourceBuffer`: JSString = "addSourceBuffer"
    @usableFromInline static immutable `addTextTrack`: JSString = "addTextTrack"
    @usableFromInline static immutable `addTrack`: JSString = "addTrack"
    @usableFromInline static immutable `addedNodes`: JSString = "addedNodes"
    @usableFromInline static immutable `addedRanges`: JSString = "addedRanges"
    @usableFromInline static immutable `adoptNode`: JSString = "adoptNode"
    @usableFromInline static immutable `advanced`: JSString = "advanced"
    @usableFromInline static immutable `after`: JSString = "after"
    @usableFromInline static immutable `alert`: JSString = "alert"
    @usableFromInline static immutable `align`: JSString = "align"
    @usableFromInline static immutable `alinkColor`: JSString = "alinkColor"
    @usableFromInline static immutable `all`: JSString = "all"
    @usableFromInline static immutable `allocationSize`: JSString = "allocationSize"
    @usableFromInline static immutable `allow`: JSString = "allow"
    @usableFromInline static immutable `allowFullscreen`: JSString = "allowFullscreen"
    @usableFromInline static immutable `alpha`: JSString = "alpha"
    @usableFromInline static immutable `alphaSideData`: JSString = "alphaSideData"
    @usableFromInline static immutable `alphabeticBaseline`: JSString = "alphabeticBaseline"
    @usableFromInline static immutable `alt`: JSString = "alt"
    @usableFromInline static immutable `altKey`: JSString = "altKey"
    @usableFromInline static immutable `altitudeAngle`: JSString = "altitudeAngle"
    @usableFromInline static immutable `ancestorOrigins`: JSString = "ancestorOrigins"
    @usableFromInline static immutable `anchors`: JSString = "anchors"
    @usableFromInline static immutable `animated`: JSString = "animated"
    @usableFromInline static immutable `any`: JSString = "any"
    @usableFromInline static immutable `appCodeName`: JSString = "appCodeName"
    @usableFromInline static immutable `appName`: JSString = "appName"
    @usableFromInline static immutable `appVersion`: JSString = "appVersion"
    @usableFromInline static immutable `append`: JSString = "append"
    @usableFromInline static immutable `appendBuffer`: JSString = "appendBuffer"
    @usableFromInline static immutable `appendChild`: JSString = "appendChild"
    @usableFromInline static immutable `appendData`: JSString = "appendData"
    @usableFromInline static immutable `appendWindowEnd`: JSString = "appendWindowEnd"
    @usableFromInline static immutable `appendWindowStart`: JSString = "appendWindowStart"
    @usableFromInline static immutable `applets`: JSString = "applets"
    @usableFromInline static immutable `applyConstraints`: JSString = "applyConstraints"
    @usableFromInline static immutable `arc`: JSString = "arc"
    @usableFromInline static immutable `arcTo`: JSString = "arcTo"
    @usableFromInline static immutable `archive`: JSString = "archive"
    @usableFromInline static immutable `areas`: JSString = "areas"
    @usableFromInline static immutable `ariaActiveDescendantElement`: JSString = "ariaActiveDescendantElement"
    @usableFromInline static immutable `ariaAtomic`: JSString = "ariaAtomic"
    @usableFromInline static immutable `ariaAutoComplete`: JSString = "ariaAutoComplete"
    @usableFromInline static immutable `ariaBrailleLabel`: JSString = "ariaBrailleLabel"
    @usableFromInline static immutable `ariaBrailleRoleDescription`: JSString = "ariaBrailleRoleDescription"
    @usableFromInline static immutable `ariaBusy`: JSString = "ariaBusy"
    @usableFromInline static immutable `ariaChecked`: JSString = "ariaChecked"
    @usableFromInline static immutable `ariaColCount`: JSString = "ariaColCount"
    @usableFromInline static immutable `ariaColIndex`: JSString = "ariaColIndex"
    @usableFromInline static immutable `ariaColIndexText`: JSString = "ariaColIndexText"
    @usableFromInline static immutable `ariaColSpan`: JSString = "ariaColSpan"
    @usableFromInline static immutable `ariaControlsElements`: JSString = "ariaControlsElements"
    @usableFromInline static immutable `ariaCurrent`: JSString = "ariaCurrent"
    @usableFromInline static immutable `ariaDescribedByElements`: JSString = "ariaDescribedByElements"
    @usableFromInline static immutable `ariaDescription`: JSString = "ariaDescription"
    @usableFromInline static immutable `ariaDetailsElements`: JSString = "ariaDetailsElements"
    @usableFromInline static immutable `ariaDisabled`: JSString = "ariaDisabled"
    @usableFromInline static immutable `ariaErrorMessageElements`: JSString = "ariaErrorMessageElements"
    @usableFromInline static immutable `ariaExpanded`: JSString = "ariaExpanded"
    @usableFromInline static immutable `ariaFlowToElements`: JSString = "ariaFlowToElements"
    @usableFromInline static immutable `ariaHasPopup`: JSString = "ariaHasPopup"
    @usableFromInline static immutable `ariaHidden`: JSString = "ariaHidden"
    @usableFromInline static immutable `ariaInvalid`: JSString = "ariaInvalid"
    @usableFromInline static immutable `ariaKeyShortcuts`: JSString = "ariaKeyShortcuts"
    @usableFromInline static immutable `ariaLabel`: JSString = "ariaLabel"
    @usableFromInline static immutable `ariaLabelledByElements`: JSString = "ariaLabelledByElements"
    @usableFromInline static immutable `ariaLevel`: JSString = "ariaLevel"
    @usableFromInline static immutable `ariaLive`: JSString = "ariaLive"
    @usableFromInline static immutable `ariaModal`: JSString = "ariaModal"
    @usableFromInline static immutable `ariaMultiLine`: JSString = "ariaMultiLine"
    @usableFromInline static immutable `ariaMultiSelectable`: JSString = "ariaMultiSelectable"
    @usableFromInline static immutable `ariaOrientation`: JSString = "ariaOrientation"
    @usableFromInline static immutable `ariaOwnsElements`: JSString = "ariaOwnsElements"
    @usableFromInline static immutable `ariaPlaceholder`: JSString = "ariaPlaceholder"
    @usableFromInline static immutable `ariaPosInSet`: JSString = "ariaPosInSet"
    @usableFromInline static immutable `ariaPressed`: JSString = "ariaPressed"
    @usableFromInline static immutable `ariaReadOnly`: JSString = "ariaReadOnly"
    @usableFromInline static immutable `ariaRelevant`: JSString = "ariaRelevant"
    @usableFromInline static immutable `ariaRequired`: JSString = "ariaRequired"
    @usableFromInline static immutable `ariaRoleDescription`: JSString = "ariaRoleDescription"
    @usableFromInline static immutable `ariaRowCount`: JSString = "ariaRowCount"
    @usableFromInline static immutable `ariaRowIndex`: JSString = "ariaRowIndex"
    @usableFromInline static immutable `ariaRowIndexText`: JSString = "ariaRowIndexText"
    @usableFromInline static immutable `ariaRowSpan`: JSString = "ariaRowSpan"
    @usableFromInline static immutable `ariaSelected`: JSString = "ariaSelected"
    @usableFromInline static immutable `ariaSetSize`: JSString = "ariaSetSize"
    @usableFromInline static immutable `ariaSort`: JSString = "ariaSort"
    @usableFromInline static immutable `ariaValueMax`: JSString = "ariaValueMax"
    @usableFromInline static immutable `ariaValueMin`: JSString = "ariaValueMin"
    @usableFromInline static immutable `ariaValueNow`: JSString = "ariaValueNow"
    @usableFromInline static immutable `ariaValueText`: JSString = "ariaValueText"
    @usableFromInline static immutable `arrayBuffer`: JSString = "arrayBuffer"
    @usableFromInline static immutable `as`: JSString = "as"
    @usableFromInline static immutable `aspectRatio`: JSString = "aspectRatio"
    @usableFromInline static immutable `assign`: JSString = "assign"
    @usableFromInline static immutable `assignedElements`: JSString = "assignedElements"
    @usableFromInline static immutable `assignedNodes`: JSString = "assignedNodes"
    @usableFromInline static immutable `assignedSlot`: JSString = "assignedSlot"
    @usableFromInline static immutable `async`: JSString = "async"
    @usableFromInline static immutable `atob`: JSString = "atob"
    @usableFromInline static immutable `attachInternals`: JSString = "attachInternals"
    @usableFromInline static immutable `attachShadow`: JSString = "attachShadow"
    @usableFromInline static immutable `attributeFilter`: JSString = "attributeFilter"
    @usableFromInline static immutable `attributeName`: JSString = "attributeName"
    @usableFromInline static immutable `attributeNamespace`: JSString = "attributeNamespace"
    @usableFromInline static immutable `attributeOldValue`: JSString = "attributeOldValue"
    @usableFromInline static immutable `attributes`: JSString = "attributes"
    @usableFromInline static immutable `audio`: JSString = "audio"
    @usableFromInline static immutable `audioBitrateMode`: JSString = "audioBitrateMode"
    @usableFromInline static immutable `audioBitsPerSecond`: JSString = "audioBitsPerSecond"
    @usableFromInline static immutable `audioTracks`: JSString = "audioTracks"
    @usableFromInline static immutable `autoAllocateChunkSize`: JSString = "autoAllocateChunkSize"
    @usableFromInline static immutable `autoGainControl`: JSString = "autoGainControl"
    @usableFromInline static immutable `autocapitalize`: JSString = "autocapitalize"
    @usableFromInline static immutable `autocomplete`: JSString = "autocomplete"
    @usableFromInline static immutable `autocorrect`: JSString = "autocorrect"
    @usableFromInline static immutable `autofocus`: JSString = "autofocus"
    @usableFromInline static immutable `autoplay`: JSString = "autoplay"
    @usableFromInline static immutable `availHeight`: JSString = "availHeight"
    @usableFromInline static immutable `availWidth`: JSString = "availWidth"
    @usableFromInline static immutable `axis`: JSString = "axis"
    @usableFromInline static immutable `azimuthAngle`: JSString = "azimuthAngle"
    @usableFromInline static immutable `b`: JSString = "b"
    @usableFromInline static immutable `back`: JSString = "back"
    @usableFromInline static immutable `background`: JSString = "background"
    @usableFromInline static immutable `backgroundBlur`: JSString = "backgroundBlur"
    @usableFromInline static immutable `badInput`: JSString = "badInput"
    @usableFromInline static immutable `baseURI`: JSString = "baseURI"
    @usableFromInline static immutable `baseURL`: JSString = "baseURL"
    @usableFromInline static immutable `before`: JSString = "before"
    @usableFromInline static immutable `beginPath`: JSString = "beginPath"
    @usableFromInline static immutable `behavior`: JSString = "behavior"
    @usableFromInline static immutable `bezierCurveTo`: JSString = "bezierCurveTo"
    @usableFromInline static immutable `bgColor`: JSString = "bgColor"
    @usableFromInline static immutable `bitrate`: JSString = "bitrate"
    @usableFromInline static immutable `bitrateMode`: JSString = "bitrateMode"
    @usableFromInline static immutable `bitsPerSecond`: JSString = "bitsPerSecond"
    @usableFromInline static immutable `blob`: JSString = "blob"
    @usableFromInline static immutable `block`: JSString = "block"
    @usableFromInline static immutable `blocking`: JSString = "blocking"
    @usableFromInline static immutable `blur`: JSString = "blur"
    @usableFromInline static immutable `body`: JSString = "body"
    @usableFromInline static immutable `bodyUsed`: JSString = "bodyUsed"
    @usableFromInline static immutable `booleanValue`: JSString = "booleanValue"
    @usableFromInline static immutable `border`: JSString = "border"
    @usableFromInline static immutable `bottom`: JSString = "bottom"
    @usableFromInline static immutable `box`: JSString = "box"
    @usableFromInline static immutable `btoa`: JSString = "btoa"
    @usableFromInline static immutable `bubbles`: JSString = "bubbles"
    @usableFromInline static immutable `buffered`: JSString = "buffered"
    @usableFromInline static immutable `button`: JSString = "button"
    @usableFromInline static immutable `buttons`: JSString = "buttons"
    @usableFromInline static immutable `byobRequest`: JSString = "byobRequest"
    @usableFromInline static immutable `byteLength`: JSString = "byteLength"
    @usableFromInline static immutable `bytes`: JSString = "bytes"
    @usableFromInline static immutable `c`: JSString = "c"
    @usableFromInline static immutable `cache`: JSString = "cache"
    @usableFromInline static immutable `cacheName`: JSString = "cacheName"
    @usableFromInline static immutable `caches`: JSString = "caches"
    @usableFromInline static immutable `canConstructInDedicatedWorker`: JSString = "canConstructInDedicatedWorker"
    @usableFromInline static immutable `canGoBack`: JSString = "canGoBack"
    @usableFromInline static immutable `canGoForward`: JSString = "canGoForward"
    @usableFromInline static immutable `canIntercept`: JSString = "canIntercept"
    @usableFromInline static immutable `canPlayType`: JSString = "canPlayType"
    @usableFromInline static immutable `cancel`: JSString = "cancel"
    @usableFromInline static immutable `cancelAnimationFrame`: JSString = "cancelAnimationFrame"
    @usableFromInline static immutable `cancelBubble`: JSString = "cancelBubble"
    @usableFromInline static immutable `cancelable`: JSString = "cancelable"
    @usableFromInline static immutable `canvas`: JSString = "canvas"
    @usableFromInline static immutable `caption`: JSString = "caption"
    @usableFromInline static immutable `capture`: JSString = "capture"
    @usableFromInline static immutable `captureEvents`: JSString = "captureEvents"
    @usableFromInline static immutable `caretPositionFromPoint`: JSString = "caretPositionFromPoint"
    @usableFromInline static immutable `cellIndex`: JSString = "cellIndex"
    @usableFromInline static immutable `cellPadding`: JSString = "cellPadding"
    @usableFromInline static immutable `cellSpacing`: JSString = "cellSpacing"
    @usableFromInline static immutable `cells`: JSString = "cells"
    @usableFromInline static immutable `ch`: JSString = "ch"
    @usableFromInline static immutable `chOff`: JSString = "chOff"
    @usableFromInline static immutable `changeType`: JSString = "changeType"
    @usableFromInline static immutable `changedTouches`: JSString = "changedTouches"
    @usableFromInline static immutable `channelCount`: JSString = "channelCount"
    @usableFromInline static immutable `charCode`: JSString = "charCode"
    @usableFromInline static immutable `characterData`: JSString = "characterData"
    @usableFromInline static immutable `characterDataOldValue`: JSString = "characterDataOldValue"
    @usableFromInline static immutable `characterSet`: JSString = "characterSet"
    @usableFromInline static immutable `charset`: JSString = "charset"
    @usableFromInline static immutable `checkOpacity`: JSString = "checkOpacity"
    @usableFromInline static immutable `checkValidity`: JSString = "checkValidity"
    @usableFromInline static immutable `checkVisibility`: JSString = "checkVisibility"
    @usableFromInline static immutable `checkVisibilityCSS`: JSString = "checkVisibilityCSS"
    @usableFromInline static immutable `checked`: JSString = "checked"
    @usableFromInline static immutable `childElementCount`: JSString = "childElementCount"
    @usableFromInline static immutable `childList`: JSString = "childList"
    @usableFromInline static immutable `childNodes`: JSString = "childNodes"
    @usableFromInline static immutable `children`: JSString = "children"
    @usableFromInline static immutable `cite`: JSString = "cite"
    @usableFromInline static immutable `classList`: JSString = "classList"
    @usableFromInline static immutable `className`: JSString = "className"
    @usableFromInline static immutable `clear`: JSString = "clear"
    @usableFromInline static immutable `clearData`: JSString = "clearData"
    @usableFromInline static immutable `clearInterval`: JSString = "clearInterval"
    @usableFromInline static immutable `clearLiveSeekableRange`: JSString = "clearLiveSeekableRange"
    @usableFromInline static immutable `clearParameters`: JSString = "clearParameters"
    @usableFromInline static immutable `clearRect`: JSString = "clearRect"
    @usableFromInline static immutable `clearTimeout`: JSString = "clearTimeout"
    @usableFromInline static immutable `click`: JSString = "click"
    @usableFromInline static immutable `clientHeight`: JSString = "clientHeight"
    @usableFromInline static immutable `clientId`: JSString = "clientId"
    @usableFromInline static immutable `clientInformation`: JSString = "clientInformation"
    @usableFromInline static immutable `clientLeft`: JSString = "clientLeft"
    @usableFromInline static immutable `clientTop`: JSString = "clientTop"
    @usableFromInline static immutable `clientWidth`: JSString = "clientWidth"
    @usableFromInline static immutable `clientX`: JSString = "clientX"
    @usableFromInline static immutable `clientY`: JSString = "clientY"
    @usableFromInline static immutable `clip`: JSString = "clip"
    @usableFromInline static immutable `clonable`: JSString = "clonable"
    @usableFromInline static immutable `clone`: JSString = "clone"
    @usableFromInline static immutable `cloneContents`: JSString = "cloneContents"
    @usableFromInline static immutable `cloneNode`: JSString = "cloneNode"
    @usableFromInline static immutable `cloneRange`: JSString = "cloneRange"
    @usableFromInline static immutable `close`: JSString = "close"
    @usableFromInline static immutable `closePath`: JSString = "closePath"
    @usableFromInline static immutable `closed`: JSString = "closed"
    @usableFromInline static immutable `closedBy`: JSString = "closedBy"
    @usableFromInline static immutable `closest`: JSString = "closest"
    @usableFromInline static immutable `code`: JSString = "code"
    @usableFromInline static immutable `codeBase`: JSString = "codeBase"
    @usableFromInline static immutable `codeType`: JSString = "codeType"
    @usableFromInline static immutable `codec`: JSString = "codec"
    @usableFromInline static immutable `codedHeight`: JSString = "codedHeight"
    @usableFromInline static immutable `codedRect`: JSString = "codedRect"
    @usableFromInline static immutable `codedWidth`: JSString = "codedWidth"
    @usableFromInline static immutable `colSpan`: JSString = "colSpan"
    @usableFromInline static immutable `collapse`: JSString = "collapse"
    @usableFromInline static immutable `collapsed`: JSString = "collapsed"
    @usableFromInline static immutable `colno`: JSString = "colno"
    @usableFromInline static immutable `color`: JSString = "color"
    @usableFromInline static immutable `colorDepth`: JSString = "colorDepth"
    @usableFromInline static immutable `colorSpace`: JSString = "colorSpace"
    @usableFromInline static immutable `colorSpaceConversion`: JSString = "colorSpaceConversion"
    @usableFromInline static immutable `colorType`: JSString = "colorType"
    @usableFromInline static immutable `cols`: JSString = "cols"
    @usableFromInline static immutable `command`: JSString = "command"
    @usableFromInline static immutable `commandForElement`: JSString = "commandForElement"
    @usableFromInline static immutable `committed`: JSString = "committed"
    @usableFromInline static immutable `commonAncestorContainer`: JSString = "commonAncestorContainer"
    @usableFromInline static immutable `compact`: JSString = "compact"
    @usableFromInline static immutable `compareBoundaryPoints`: JSString = "compareBoundaryPoints"
    @usableFromInline static immutable `compareDocumentPosition`: JSString = "compareDocumentPosition"
    @usableFromInline static immutable `comparePoint`: JSString = "comparePoint"
    @usableFromInline static immutable `compatMode`: JSString = "compatMode"
    @usableFromInline static immutable `complete`: JSString = "complete"
    @usableFromInline static immutable `completeFramesOnly`: JSString = "completeFramesOnly"
    @usableFromInline static immutable `completed`: JSString = "completed"
    @usableFromInline static immutable `composed`: JSString = "composed"
    @usableFromInline static immutable `composedPath`: JSString = "composedPath"
    @usableFromInline static immutable `condition`: JSString = "condition"
    @usableFromInline static immutable `config`: JSString = "config"
    @usableFromInline static immutable `configure`: JSString = "configure"
    @usableFromInline static immutable `confirm`: JSString = "confirm"
    @usableFromInline static immutable `constraint`: JSString = "constraint"
    @usableFromInline static immutable `container`: JSString = "container"
    @usableFromInline static immutable `contains`: JSString = "contains"
    @usableFromInline static immutable `content`: JSString = "content"
    @usableFromInline static immutable `contentDocument`: JSString = "contentDocument"
    @usableFromInline static immutable `contentEditable`: JSString = "contentEditable"
    @usableFromInline static immutable `contentHint`: JSString = "contentHint"
    @usableFromInline static immutable `contentType`: JSString = "contentType"
    @usableFromInline static immutable `contentVisibilityAuto`: JSString = "contentVisibilityAuto"
    @usableFromInline static immutable `contentWindow`: JSString = "contentWindow"
    @usableFromInline static immutable `control`: JSString = "control"
    @usableFromInline static immutable `controller`: JSString = "controller"
    @usableFromInline static immutable `controls`: JSString = "controls"
    @usableFromInline static immutable `convertPointFromNode`: JSString = "convertPointFromNode"
    @usableFromInline static immutable `convertQuadFromNode`: JSString = "convertQuadFromNode"
    @usableFromInline static immutable `convertRectFromNode`: JSString = "convertRectFromNode"
    @usableFromInline static immutable `convertToBlob`: JSString = "convertToBlob"
    @usableFromInline static immutable `cookie`: JSString = "cookie"
    @usableFromInline static immutable `cookieEnabled`: JSString = "cookieEnabled"
    @usableFromInline static immutable `coords`: JSString = "coords"
    @usableFromInline static immutable `copyTo`: JSString = "copyTo"
    @usableFromInline static immutable `createAttribute`: JSString = "createAttribute"
    @usableFromInline static immutable `createAttributeNS`: JSString = "createAttributeNS"
    @usableFromInline static immutable `createCDATASection`: JSString = "createCDATASection"
    @usableFromInline static immutable `createCaption`: JSString = "createCaption"
    @usableFromInline static immutable `createComment`: JSString = "createComment"
    @usableFromInline static immutable `createConicGradient`: JSString = "createConicGradient"
    @usableFromInline static immutable `createContextualFragment`: JSString = "createContextualFragment"
    @usableFromInline static immutable `createDocument`: JSString = "createDocument"
    @usableFromInline static immutable `createDocumentFragment`: JSString = "createDocumentFragment"
    @usableFromInline static immutable `createDocumentType`: JSString = "createDocumentType"
    @usableFromInline static immutable `createElement`: JSString = "createElement"
    @usableFromInline static immutable `createElementNS`: JSString = "createElementNS"
    @usableFromInline static immutable `createEvent`: JSString = "createEvent"
    @usableFromInline static immutable `createHTML`: JSString = "createHTML"
    @usableFromInline static immutable `createHTMLDocument`: JSString = "createHTMLDocument"
    @usableFromInline static immutable `createImageBitmap`: JSString = "createImageBitmap"
    @usableFromInline static immutable `createImageData`: JSString = "createImageData"
    @usableFromInline static immutable `createLinearGradient`: JSString = "createLinearGradient"
    @usableFromInline static immutable `createObjectURL`: JSString = "createObjectURL"
    @usableFromInline static immutable `createPattern`: JSString = "createPattern"
    @usableFromInline static immutable `createProcessingInstruction`: JSString = "createProcessingInstruction"
    @usableFromInline static immutable `createRadialGradient`: JSString = "createRadialGradient"
    @usableFromInline static immutable `createRange`: JSString = "createRange"
    @usableFromInline static immutable `createScript`: JSString = "createScript"
    @usableFromInline static immutable `createScriptURL`: JSString = "createScriptURL"
    @usableFromInline static immutable `createTBody`: JSString = "createTBody"
    @usableFromInline static immutable `createTFoot`: JSString = "createTFoot"
    @usableFromInline static immutable `createTHead`: JSString = "createTHead"
    @usableFromInline static immutable `createTextNode`: JSString = "createTextNode"
    @usableFromInline static immutable `credentials`: JSString = "credentials"
    @usableFromInline static immutable `crossOrigin`: JSString = "crossOrigin"
    @usableFromInline static immutable `crossOriginIsolated`: JSString = "crossOriginIsolated"
    @usableFromInline static immutable `ctrlKey`: JSString = "ctrlKey"
    @usableFromInline static immutable `cues`: JSString = "cues"
    @usableFromInline static immutable `currentCSSZoom`: JSString = "currentCSSZoom"
    @usableFromInline static immutable `currentEntry`: JSString = "currentEntry"
    @usableFromInline static immutable `currentNode`: JSString = "currentNode"
    @usableFromInline static immutable `currentScript`: JSString = "currentScript"
    @usableFromInline static immutable `currentSrc`: JSString = "currentSrc"
    @usableFromInline static immutable `currentTarget`: JSString = "currentTarget"
    @usableFromInline static immutable `currentTime`: JSString = "currentTime"
    @usableFromInline static immutable `customElements`: JSString = "customElements"
    @usableFromInline static immutable `customError`: JSString = "customError"
    @usableFromInline static immutable `d`: JSString = "d"
    @usableFromInline static immutable `data`: JSString = "data"
    @usableFromInline static immutable `dataTransfer`: JSString = "dataTransfer"
    @usableFromInline static immutable `dataset`: JSString = "dataset"
    @usableFromInline static immutable `dateTime`: JSString = "dateTime"
    @usableFromInline static immutable `declare`: JSString = "declare"
    @usableFromInline static immutable `decode`: JSString = "decode"
    @usableFromInline static immutable `decodeQueueSize`: JSString = "decodeQueueSize"
    @usableFromInline static immutable `decoderConfig`: JSString = "decoderConfig"
    @usableFromInline static immutable `decoding`: JSString = "decoding"
    @usableFromInline static immutable `default`: JSString = "default"
    @usableFromInline static immutable `defaultChecked`: JSString = "defaultChecked"
    @usableFromInline static immutable `defaultMuted`: JSString = "defaultMuted"
    @usableFromInline static immutable `defaultPlaybackRate`: JSString = "defaultPlaybackRate"
    @usableFromInline static immutable `defaultPolicy`: JSString = "defaultPolicy"
    @usableFromInline static immutable `defaultPrevented`: JSString = "defaultPrevented"
    @usableFromInline static immutable `defaultSelected`: JSString = "defaultSelected"
    @usableFromInline static immutable `defaultValue`: JSString = "defaultValue"
    @usableFromInline static immutable `defaultView`: JSString = "defaultView"
    @usableFromInline static immutable `defer`: JSString = "defer"
    @usableFromInline static immutable `define`: JSString = "define"
    @usableFromInline static immutable `delegatesFocus`: JSString = "delegatesFocus"
    @usableFromInline static immutable `delete`: JSString = "delete"
    @usableFromInline static immutable `deleteCaption`: JSString = "deleteCaption"
    @usableFromInline static immutable `deleteCell`: JSString = "deleteCell"
    @usableFromInline static immutable `deleteContents`: JSString = "deleteContents"
    @usableFromInline static immutable `deleteData`: JSString = "deleteData"
    @usableFromInline static immutable `deleteRow`: JSString = "deleteRow"
    @usableFromInline static immutable `deleteTFoot`: JSString = "deleteTFoot"
    @usableFromInline static immutable `deleteTHead`: JSString = "deleteTHead"
    @usableFromInline static immutable `deltaMode`: JSString = "deltaMode"
    @usableFromInline static immutable `deltaX`: JSString = "deltaX"
    @usableFromInline static immutable `deltaY`: JSString = "deltaY"
    @usableFromInline static immutable `deltaZ`: JSString = "deltaZ"
    @usableFromInline static immutable `description`: JSString = "description"
    @usableFromInline static immutable `descriptor`: JSString = "descriptor"
    @usableFromInline static immutable `designMode`: JSString = "designMode"
    @usableFromInline static immutable `desiredHeight`: JSString = "desiredHeight"
    @usableFromInline static immutable `desiredSize`: JSString = "desiredSize"
    @usableFromInline static immutable `desiredWidth`: JSString = "desiredWidth"
    @usableFromInline static immutable `destination`: JSString = "destination"
    @usableFromInline static immutable `destroy`: JSString = "destroy"
    @usableFromInline static immutable `desynchronized`: JSString = "desynchronized"
    @usableFromInline static immutable `detach`: JSString = "detach"
    @usableFromInline static immutable `detail`: JSString = "detail"
    @usableFromInline static immutable `deviceId`: JSString = "deviceId"
    @usableFromInline static immutable `devicePixelRatio`: JSString = "devicePixelRatio"
    @usableFromInline static immutable `devices`: JSString = "devices"
    @usableFromInline static immutable `dir`: JSString = "dir"
    @usableFromInline static immutable `dirName`: JSString = "dirName"
    @usableFromInline static immutable `direction`: JSString = "direction"
    @usableFromInline static immutable `disable`: JSString = "disable"
    @usableFromInline static immutable `disabled`: JSString = "disabled"
    @usableFromInline static immutable `disconnect`: JSString = "disconnect"
    @usableFromInline static immutable `dispatchEvent`: JSString = "dispatchEvent"
    @usableFromInline static immutable `displayAspectHeight`: JSString = "displayAspectHeight"
    @usableFromInline static immutable `displayAspectWidth`: JSString = "displayAspectWidth"
    @usableFromInline static immutable `displayHeight`: JSString = "displayHeight"
    @usableFromInline static immutable `displayWidth`: JSString = "displayWidth"
    @usableFromInline static immutable `doctype`: JSString = "doctype"
    @usableFromInline static immutable `document`: JSString = "document"
    @usableFromInline static immutable `documentElement`: JSString = "documentElement"
    @usableFromInline static immutable `documentURI`: JSString = "documentURI"
    @usableFromInline static immutable `domain`: JSString = "domain"
    @usableFromInline static immutable `done`: JSString = "done"
    @usableFromInline static immutable `download`: JSString = "download"
    @usableFromInline static immutable `downloadRequest`: JSString = "downloadRequest"
    @usableFromInline static immutable `draggable`: JSString = "draggable"
    @usableFromInline static immutable `drawFocusIfNeeded`: JSString = "drawFocusIfNeeded"
    @usableFromInline static immutable `drawImage`: JSString = "drawImage"
    @usableFromInline static immutable `dropEffect`: JSString = "dropEffect"
    @usableFromInline static immutable `droppedEntriesCount`: JSString = "droppedEntriesCount"
    @usableFromInline static immutable `duplex`: JSString = "duplex"
    @usableFromInline static immutable `duration`: JSString = "duration"
    @usableFromInline static immutable `e`: JSString = "e"
    @usableFromInline static immutable `echoCancellation`: JSString = "echoCancellation"
    @usableFromInline static immutable `effectAllowed`: JSString = "effectAllowed"
    @usableFromInline static immutable `element`: JSString = "element"
    @usableFromInline static immutable `elementFromPoint`: JSString = "elementFromPoint"
    @usableFromInline static immutable `elements`: JSString = "elements"
    @usableFromInline static immutable `elementsFromPoint`: JSString = "elementsFromPoint"
    @usableFromInline static immutable `ellipse`: JSString = "ellipse"
    @usableFromInline static immutable `emHeightAscent`: JSString = "emHeightAscent"
    @usableFromInline static immutable `emHeightDescent`: JSString = "emHeightDescent"
    @usableFromInline static immutable `embeds`: JSString = "embeds"
    @usableFromInline static immutable `emptyHTML`: JSString = "emptyHTML"
    @usableFromInline static immutable `emptyScript`: JSString = "emptyScript"
    @usableFromInline static immutable `enable`: JSString = "enable"
    @usableFromInline static immutable `enabled`: JSString = "enabled"
    @usableFromInline static immutable `enabledPlugin`: JSString = "enabledPlugin"
    @usableFromInline static immutable `encode`: JSString = "encode"
    @usableFromInline static immutable `encodeQueueSize`: JSString = "encodeQueueSize"
    @usableFromInline static immutable `encoding`: JSString = "encoding"
    @usableFromInline static immutable `enctype`: JSString = "enctype"
    @usableFromInline static immutable `end`: JSString = "end"
    @usableFromInline static immutable `endContainer`: JSString = "endContainer"
    @usableFromInline static immutable `endOfStream`: JSString = "endOfStream"
    @usableFromInline static immutable `endOffset`: JSString = "endOffset"
    @usableFromInline static immutable `endTime`: JSString = "endTime"
    @usableFromInline static immutable `ended`: JSString = "ended"
    @usableFromInline static immutable `endings`: JSString = "endings"
    @usableFromInline static immutable `enqueue`: JSString = "enqueue"
    @usableFromInline static immutable `enterKeyHint`: JSString = "enterKeyHint"
    @usableFromInline static immutable `entries`: JSString = "entries"
    @usableFromInline static immutable `entry`: JSString = "entry"
    @usableFromInline static immutable `entryType`: JSString = "entryType"
    @usableFromInline static immutable `entryTypes`: JSString = "entryTypes"
    @usableFromInline static immutable `enumerateDevices`: JSString = "enumerateDevices"
    @usableFromInline static immutable `error`: JSString = "error"
    @usableFromInline static immutable `evaluate`: JSString = "evaluate"
    @usableFromInline static immutable `event`: JSString = "event"
    @usableFromInline static immutable `eventPhase`: JSString = "eventPhase"
    @usableFromInline static immutable `exact`: JSString = "exact"
    @usableFromInline static immutable `exec`: JSString = "exec"
    @usableFromInline static immutable `execCommand`: JSString = "execCommand"
    @usableFromInline static immutable `extends`: JSString = "extends"
    @usableFromInline static immutable `external`: JSString = "external"
    @usableFromInline static immutable `extractContents`: JSString = "extractContents"
    @usableFromInline static immutable `f`: JSString = "f"
    @usableFromInline static immutable `face`: JSString = "face"
    @usableFromInline static immutable `facingMode`: JSString = "facingMode"
    @usableFromInline static immutable `fastSeek`: JSString = "fastSeek"
    @usableFromInline static immutable `fetch`: JSString = "fetch"
    @usableFromInline static immutable `fetchPriority`: JSString = "fetchPriority"
    @usableFromInline static immutable `fgColor`: JSString = "fgColor"
    @usableFromInline static immutable `filename`: JSString = "filename"
    @usableFromInline static immutable `files`: JSString = "files"
    @usableFromInline static immutable `fill`: JSString = "fill"
    @usableFromInline static immutable `fillRect`: JSString = "fillRect"
    @usableFromInline static immutable `fillStyle`: JSString = "fillStyle"
    @usableFromInline static immutable `fillText`: JSString = "fillText"
    @usableFromInline static immutable `filter`: JSString = "filter"
    @usableFromInline static immutable `finished`: JSString = "finished"
    @usableFromInline static immutable `firstChild`: JSString = "firstChild"
    @usableFromInline static immutable `firstElementChild`: JSString = "firstElementChild"
    @usableFromInline static immutable `flatten`: JSString = "flatten"
    @usableFromInline static immutable `flip`: JSString = "flip"
    @usableFromInline static immutable `flipX`: JSString = "flipX"
    @usableFromInline static immutable `flipY`: JSString = "flipY"
    @usableFromInline static immutable `flush`: JSString = "flush"
    @usableFromInline static immutable `focus`: JSString = "focus"
    @usableFromInline static immutable `focusReset`: JSString = "focusReset"
    @usableFromInline static immutable `focusVisible`: JSString = "focusVisible"
    @usableFromInline static immutable `font`: JSString = "font"
    @usableFromInline static immutable `fontBoundingBoxAscent`: JSString = "fontBoundingBoxAscent"
    @usableFromInline static immutable `fontBoundingBoxDescent`: JSString = "fontBoundingBoxDescent"
    @usableFromInline static immutable `fontKerning`: JSString = "fontKerning"
    @usableFromInline static immutable `fontStretch`: JSString = "fontStretch"
    @usableFromInline static immutable `fontVariantCaps`: JSString = "fontVariantCaps"
    @usableFromInline static immutable `force`: JSString = "force"
    @usableFromInline static immutable `form`: JSString = "form"
    @usableFromInline static immutable `formAction`: JSString = "formAction"
    @usableFromInline static immutable `formData`: JSString = "formData"
    @usableFromInline static immutable `formEnctype`: JSString = "formEnctype"
    @usableFromInline static immutable `formMethod`: JSString = "formMethod"
    @usableFromInline static immutable `formNoValidate`: JSString = "formNoValidate"
    @usableFromInline static immutable `formTarget`: JSString = "formTarget"
    @usableFromInline static immutable `format`: JSString = "format"
    @usableFromInline static immutable `forms`: JSString = "forms"
    @usableFromInline static immutable `forward`: JSString = "forward"
    @usableFromInline static immutable `frame`: JSString = "frame"
    @usableFromInline static immutable `frameBorder`: JSString = "frameBorder"
    @usableFromInline static immutable `frameCount`: JSString = "frameCount"
    @usableFromInline static immutable `frameElement`: JSString = "frameElement"
    @usableFromInline static immutable `frameIndex`: JSString = "frameIndex"
    @usableFromInline static immutable `frameOffset`: JSString = "frameOffset"
    @usableFromInline static immutable `frameRate`: JSString = "frameRate"
    @usableFromInline static immutable `framerate`: JSString = "framerate"
    @usableFromInline static immutable `frames`: JSString = "frames"
    @usableFromInline static immutable `from`: JSString = "from"
    @usableFromInline static immutable `fromBox`: JSString = "fromBox"
    @usableFromInline static immutable `fromFloat32Array`: JSString = "fromFloat32Array"
    @usableFromInline static immutable `fromFloat64Array`: JSString = "fromFloat64Array"
    @usableFromInline static immutable `fromMatrix`: JSString = "fromMatrix"
    @usableFromInline static immutable `fromPoint`: JSString = "fromPoint"
    @usableFromInline static immutable `fromQuad`: JSString = "fromQuad"
    @usableFromInline static immutable `fromRect`: JSString = "fromRect"
    @usableFromInline static immutable `fullRange`: JSString = "fullRange"
    @usableFromInline static immutable `get`: JSString = "get"
    @usableFromInline static immutable `getAll`: JSString = "getAll"
    @usableFromInline static immutable `getAllResponseHeaders`: JSString = "getAllResponseHeaders"
    @usableFromInline static immutable `getAsFile`: JSString = "getAsFile"
    @usableFromInline static immutable `getAsString`: JSString = "getAsString"
    @usableFromInline static immutable `getAttribute`: JSString = "getAttribute"
    @usableFromInline static immutable `getAttributeNS`: JSString = "getAttributeNS"
    @usableFromInline static immutable `getAttributeNames`: JSString = "getAttributeNames"
    @usableFromInline static immutable `getAttributeNode`: JSString = "getAttributeNode"
    @usableFromInline static immutable `getAttributeNodeNS`: JSString = "getAttributeNodeNS"
    @usableFromInline static immutable `getAttributeType`: JSString = "getAttributeType"
    @usableFromInline static immutable `getAudioTracks`: JSString = "getAudioTracks"
    @usableFromInline static immutable `getBoundingClientRect`: JSString = "getBoundingClientRect"
    @usableFromInline static immutable `getBounds`: JSString = "getBounds"
    @usableFromInline static immutable `getBoxQuads`: JSString = "getBoxQuads"
    @usableFromInline static immutable `getCapabilities`: JSString = "getCapabilities"
    @usableFromInline static immutable `getClientRect`: JSString = "getClientRect"
    @usableFromInline static immutable `getClientRects`: JSString = "getClientRects"
    @usableFromInline static immutable `getConstraints`: JSString = "getConstraints"
    @usableFromInline static immutable `getContextAttributes`: JSString = "getContextAttributes"
    @usableFromInline static immutable `getCueById`: JSString = "getCueById"
    @usableFromInline static immutable `getData`: JSString = "getData"
    @usableFromInline static immutable `getElementById`: JSString = "getElementById"
    @usableFromInline static immutable `getElementsByClassName`: JSString = "getElementsByClassName"
    @usableFromInline static immutable `getElementsByName`: JSString = "getElementsByName"
    @usableFromInline static immutable `getElementsByTagName`: JSString = "getElementsByTagName"
    @usableFromInline static immutable `getElementsByTagNameNS`: JSString = "getElementsByTagNameNS"
    @usableFromInline static immutable `getEntries`: JSString = "getEntries"
    @usableFromInline static immutable `getEntriesByName`: JSString = "getEntriesByName"
    @usableFromInline static immutable `getEntriesByType`: JSString = "getEntriesByType"
    @usableFromInline static immutable `getHTML`: JSString = "getHTML"
    @usableFromInline static immutable `getImageData`: JSString = "getImageData"
    @usableFromInline static immutable `getItem`: JSString = "getItem"
    @usableFromInline static immutable `getLineDash`: JSString = "getLineDash"
    @usableFromInline static immutable `getModifierState`: JSString = "getModifierState"
    @usableFromInline static immutable `getName`: JSString = "getName"
    @usableFromInline static immutable `getNamedItem`: JSString = "getNamedItem"
    @usableFromInline static immutable `getNamedItemNS`: JSString = "getNamedItemNS"
    @usableFromInline static immutable `getParameter`: JSString = "getParameter"
    @usableFromInline static immutable `getPropertyType`: JSString = "getPropertyType"
    @usableFromInline static immutable `getReader`: JSString = "getReader"
    @usableFromInline static immutable `getRegistration`: JSString = "getRegistration"
    @usableFromInline static immutable `getRegistrations`: JSString = "getRegistrations"
    @usableFromInline static immutable `getResponseHeader`: JSString = "getResponseHeader"
    @usableFromInline static immutable `getRootNode`: JSString = "getRootNode"
    @usableFromInline static immutable `getSVGDocument`: JSString = "getSVGDocument"
    @usableFromInline static immutable `getSetCookie`: JSString = "getSetCookie"
    @usableFromInline static immutable `getSettings`: JSString = "getSettings"
    @usableFromInline static immutable `getStartDate`: JSString = "getStartDate"
    @usableFromInline static immutable `getState`: JSString = "getState"
    @usableFromInline static immutable `getSupportedConstraints`: JSString = "getSupportedConstraints"
    @usableFromInline static immutable `getTrackById`: JSString = "getTrackById"
    @usableFromInline static immutable `getTracks`: JSString = "getTracks"
    @usableFromInline static immutable `getTransform`: JSString = "getTransform"
    @usableFromInline static immutable `getUserMedia`: JSString = "getUserMedia"
    @usableFromInline static immutable `getVideoTracks`: JSString = "getVideoTracks"
    @usableFromInline static immutable `getWriter`: JSString = "getWriter"
    @usableFromInline static immutable `globalAlpha`: JSString = "globalAlpha"
    @usableFromInline static immutable `globalCompositeOperation`: JSString = "globalCompositeOperation"
    @usableFromInline static immutable `go`: JSString = "go"
    @usableFromInline static immutable `groupId`: JSString = "groupId"
    @usableFromInline static immutable `groups`: JSString = "groups"
    @usableFromInline static immutable `handle`: JSString = "handle"
    @usableFromInline static immutable `handled`: JSString = "handled"
    @usableFromInline static immutable `handler`: JSString = "handler"
    @usableFromInline static immutable `hangingBaseline`: JSString = "hangingBaseline"
    @usableFromInline static immutable `hardwareAcceleration`: JSString = "hardwareAcceleration"
    @usableFromInline static immutable `hardwareConcurrency`: JSString = "hardwareConcurrency"
    @usableFromInline static immutable `has`: JSString = "has"
    @usableFromInline static immutable `hasAttribute`: JSString = "hasAttribute"
    @usableFromInline static immutable `hasAttributeNS`: JSString = "hasAttributeNS"
    @usableFromInline static immutable `hasAttributes`: JSString = "hasAttributes"
    @usableFromInline static immutable `hasBeenActive`: JSString = "hasBeenActive"
    @usableFromInline static immutable `hasChildNodes`: JSString = "hasChildNodes"
    @usableFromInline static immutable `hasFeature`: JSString = "hasFeature"
    @usableFromInline static immutable `hasFocus`: JSString = "hasFocus"
    @usableFromInline static immutable `hasRegExpGroups`: JSString = "hasRegExpGroups"
    @usableFromInline static immutable `hasUAVisualTransition`: JSString = "hasUAVisualTransition"
    @usableFromInline static immutable `hash`: JSString = "hash"
    @usableFromInline static immutable `hashChange`: JSString = "hashChange"
    @usableFromInline static immutable `head`: JSString = "head"
    @usableFromInline static immutable `headerValue`: JSString = "headerValue"
    @usableFromInline static immutable `headers`: JSString = "headers"
    @usableFromInline static immutable `height`: JSString = "height"
    @usableFromInline static immutable `hidden`: JSString = "hidden"
    @usableFromInline static immutable `hidePopover`: JSString = "hidePopover"
    @usableFromInline static immutable `high`: JSString = "high"
    @usableFromInline static immutable `highWaterMark`: JSString = "highWaterMark"
    @usableFromInline static immutable `history`: JSString = "history"
    @usableFromInline static immutable `host`: JSString = "host"
    @usableFromInline static immutable `hostname`: JSString = "hostname"
    @usableFromInline static immutable `href`: JSString = "href"
    @usableFromInline static immutable `hreflang`: JSString = "hreflang"
    @usableFromInline static immutable `hspace`: JSString = "hspace"
    @usableFromInline static immutable `htmlFor`: JSString = "htmlFor"
    @usableFromInline static immutable `httpEquiv`: JSString = "httpEquiv"
    @usableFromInline static immutable `id`: JSString = "id"
    @usableFromInline static immutable `ideal`: JSString = "ideal"
    @usableFromInline static immutable `identifier`: JSString = "identifier"
    @usableFromInline static immutable `ideographicBaseline`: JSString = "ideographicBaseline"
    @usableFromInline static immutable `ignoreCase`: JSString = "ignoreCase"
    @usableFromInline static immutable `ignoreMethod`: JSString = "ignoreMethod"
    @usableFromInline static immutable `ignoreSearch`: JSString = "ignoreSearch"
    @usableFromInline static immutable `ignoreVary`: JSString = "ignoreVary"
    @usableFromInline static immutable `image`: JSString = "image"
    @usableFromInline static immutable `imageOrientation`: JSString = "imageOrientation"
    @usableFromInline static immutable `imageSizes`: JSString = "imageSizes"
    @usableFromInline static immutable `imageSmoothingEnabled`: JSString = "imageSmoothingEnabled"
    @usableFromInline static immutable `imageSmoothingQuality`: JSString = "imageSmoothingQuality"
    @usableFromInline static immutable `imageSrcset`: JSString = "imageSrcset"
    @usableFromInline static immutable `images`: JSString = "images"
    @usableFromInline static immutable `implementation`: JSString = "implementation"
    @usableFromInline static immutable `importNode`: JSString = "importNode"
    @usableFromInline static immutable `importStylesheet`: JSString = "importStylesheet"
    @usableFromInline static immutable `inBandMetadataTrackDispatchType`: JSString = "inBandMetadataTrackDispatchType"
    @usableFromInline static immutable `includeUncontrolled`: JSString = "includeUncontrolled"
    @usableFromInline static immutable `indeterminate`: JSString = "indeterminate"
    @usableFromInline static immutable `index`: JSString = "index"
    @usableFromInline static immutable `inert`: JSString = "inert"
    @usableFromInline static immutable `info`: JSString = "info"
    @usableFromInline static immutable `initCompositionEvent`: JSString = "initCompositionEvent"
    @usableFromInline static immutable `initCustomEvent`: JSString = "initCustomEvent"
    @usableFromInline static immutable `initEvent`: JSString = "initEvent"
    @usableFromInline static immutable `initKeyboardEvent`: JSString = "initKeyboardEvent"
    @usableFromInline static immutable `initMessageEvent`: JSString = "initMessageEvent"
    @usableFromInline static immutable `initMouseEvent`: JSString = "initMouseEvent"
    @usableFromInline static immutable `initStorageEvent`: JSString = "initStorageEvent"
    @usableFromInline static immutable `initTextEvent`: JSString = "initTextEvent"
    @usableFromInline static immutable `initUIEvent`: JSString = "initUIEvent"
    @usableFromInline static immutable `inline`: JSString = "inline"
    @usableFromInline static immutable `innerHTML`: JSString = "innerHTML"
    @usableFromInline static immutable `innerHeight`: JSString = "innerHeight"
    @usableFromInline static immutable `innerText`: JSString = "innerText"
    @usableFromInline static immutable `innerWidth`: JSString = "innerWidth"
    @usableFromInline static immutable `input`: JSString = "input"
    @usableFromInline static immutable `inputEncoding`: JSString = "inputEncoding"
    @usableFromInline static immutable `inputMode`: JSString = "inputMode"
    @usableFromInline static immutable `inputType`: JSString = "inputType"
    @usableFromInline static immutable `inputs`: JSString = "inputs"
    @usableFromInline static immutable `insertAdjacentElement`: JSString = "insertAdjacentElement"
    @usableFromInline static immutable `insertAdjacentHTML`: JSString = "insertAdjacentHTML"
    @usableFromInline static immutable `insertAdjacentText`: JSString = "insertAdjacentText"
    @usableFromInline static immutable `insertBefore`: JSString = "insertBefore"
    @usableFromInline static immutable `insertCell`: JSString = "insertCell"
    @usableFromInline static immutable `insertData`: JSString = "insertData"
    @usableFromInline static immutable `insertNode`: JSString = "insertNode"
    @usableFromInline static immutable `insertRow`: JSString = "insertRow"
    @usableFromInline static immutable `installing`: JSString = "installing"
    @usableFromInline static immutable `integrity`: JSString = "integrity"
    @usableFromInline static immutable `intercept`: JSString = "intercept"
    @usableFromInline static immutable `intersectsNode`: JSString = "intersectsNode"
    @usableFromInline static immutable `invalidIteratorState`: JSString = "invalidIteratorState"
    @usableFromInline static immutable `inverse`: JSString = "inverse"
    @usableFromInline static immutable `invertSelf`: JSString = "invertSelf"
    @usableFromInline static immutable `is`: JSString = "is"
    @usableFromInline static immutable `is2D`: JSString = "is2D"
    @usableFromInline static immutable `isActive`: JSString = "isActive"
    @usableFromInline static immutable `isComposing`: JSString = "isComposing"
    @usableFromInline static immutable `isConfigSupported`: JSString = "isConfigSupported"
    @usableFromInline static immutable `isConnected`: JSString = "isConnected"
    @usableFromInline static immutable `isContentEditable`: JSString = "isContentEditable"
    @usableFromInline static immutable `isContextLost`: JSString = "isContextLost"
    @usableFromInline static immutable `isDefaultNamespace`: JSString = "isDefaultNamespace"
    @usableFromInline static immutable `isEqualNode`: JSString = "isEqualNode"
    @usableFromInline static immutable `isHTML`: JSString = "isHTML"
    @usableFromInline static immutable `isHistoryNavigation`: JSString = "isHistoryNavigation"
    @usableFromInline static immutable `isIdentity`: JSString = "isIdentity"
    @usableFromInline static immutable `isMap`: JSString = "isMap"
    @usableFromInline static immutable `isPointInPath`: JSString = "isPointInPath"
    @usableFromInline static immutable `isPointInRange`: JSString = "isPointInRange"
    @usableFromInline static immutable `isPointInStroke`: JSString = "isPointInStroke"
    @usableFromInline static immutable `isReloadNavigation`: JSString = "isReloadNavigation"
    @usableFromInline static immutable `isSameNode`: JSString = "isSameNode"
    @usableFromInline static immutable `isScript`: JSString = "isScript"
    @usableFromInline static immutable `isScriptURL`: JSString = "isScriptURL"
    @usableFromInline static immutable `isSecureContext`: JSString = "isSecureContext"
    @usableFromInline static immutable `isTrusted`: JSString = "isTrusted"
    @usableFromInline static immutable `isTypeSupported`: JSString = "isTypeSupported"
    @usableFromInline static immutable `item`: JSString = "item"
    @usableFromInline static immutable `items`: JSString = "items"
    @usableFromInline static immutable `iterateNext`: JSString = "iterateNext"
    @usableFromInline static immutable `javaEnabled`: JSString = "javaEnabled"
    @usableFromInline static immutable `json`: JSString = "json"
    @usableFromInline static immutable `keepalive`: JSString = "keepalive"
    @usableFromInline static immutable `key`: JSString = "key"
    @usableFromInline static immutable `keyCode`: JSString = "keyCode"
    @usableFromInline static immutable `keyFrame`: JSString = "keyFrame"
    @usableFromInline static immutable `keys`: JSString = "keys"
    @usableFromInline static immutable `kind`: JSString = "kind"
    @usableFromInline static immutable `label`: JSString = "label"
    @usableFromInline static immutable `labels`: JSString = "labels"
    @usableFromInline static immutable `lang`: JSString = "lang"
    @usableFromInline static immutable `language`: JSString = "language"
    @usableFromInline static immutable `languages`: JSString = "languages"
    @usableFromInline static immutable `lastChild`: JSString = "lastChild"
    @usableFromInline static immutable `lastElementChild`: JSString = "lastElementChild"
    @usableFromInline static immutable `lastEventId`: JSString = "lastEventId"
    @usableFromInline static immutable `lastModified`: JSString = "lastModified"
    @usableFromInline static immutable `latency`: JSString = "latency"
    @usableFromInline static immutable `latencyMode`: JSString = "latencyMode"
    @usableFromInline static immutable `layerX`: JSString = "layerX"
    @usableFromInline static immutable `layerY`: JSString = "layerY"
    @usableFromInline static immutable `layout`: JSString = "layout"
    @usableFromInline static immutable `left`: JSString = "left"
    @usableFromInline static immutable `length`: JSString = "length"
    @usableFromInline static immutable `lengthComputable`: JSString = "lengthComputable"
    @usableFromInline static immutable `letterSpacing`: JSString = "letterSpacing"
    @usableFromInline static immutable `lineCap`: JSString = "lineCap"
    @usableFromInline static immutable `lineDashOffset`: JSString = "lineDashOffset"
    @usableFromInline static immutable `lineJoin`: JSString = "lineJoin"
    @usableFromInline static immutable `lineTo`: JSString = "lineTo"
    @usableFromInline static immutable `lineWidth`: JSString = "lineWidth"
    @usableFromInline static immutable `lineno`: JSString = "lineno"
    @usableFromInline static immutable `link`: JSString = "link"
    @usableFromInline static immutable `linkColor`: JSString = "linkColor"
    @usableFromInline static immutable `links`: JSString = "links"
    @usableFromInline static immutable `list`: JSString = "list"
    @usableFromInline static immutable `load`: JSString = "load"
    @usableFromInline static immutable `loaded`: JSString = "loaded"
    @usableFromInline static immutable `loading`: JSString = "loading"
    @usableFromInline static immutable `localName`: JSString = "localName"
    @usableFromInline static immutable `localStorage`: JSString = "localStorage"
    @usableFromInline static immutable `location`: JSString = "location"
    @usableFromInline static immutable `locationbar`: JSString = "locationbar"
    @usableFromInline static immutable `locked`: JSString = "locked"
    @usableFromInline static immutable `longDesc`: JSString = "longDesc"
    @usableFromInline static immutable `lookupNamespaceURI`: JSString = "lookupNamespaceURI"
    @usableFromInline static immutable `lookupPrefix`: JSString = "lookupPrefix"
    @usableFromInline static immutable `loop`: JSString = "loop"
    @usableFromInline static immutable `low`: JSString = "low"
    @usableFromInline static immutable `lowsrc`: JSString = "lowsrc"
    @usableFromInline static immutable `m11`: JSString = "m11"
    @usableFromInline static immutable `m12`: JSString = "m12"
    @usableFromInline static immutable `m13`: JSString = "m13"
    @usableFromInline static immutable `m14`: JSString = "m14"
    @usableFromInline static immutable `m21`: JSString = "m21"
    @usableFromInline static immutable `m22`: JSString = "m22"
    @usableFromInline static immutable `m23`: JSString = "m23"
    @usableFromInline static immutable `m24`: JSString = "m24"
    @usableFromInline static immutable `m31`: JSString = "m31"
    @usableFromInline static immutable `m32`: JSString = "m32"
    @usableFromInline static immutable `m33`: JSString = "m33"
    @usableFromInline static immutable `m34`: JSString = "m34"
    @usableFromInline static immutable `m41`: JSString = "m41"
    @usableFromInline static immutable `m42`: JSString = "m42"
    @usableFromInline static immutable `m43`: JSString = "m43"
    @usableFromInline static immutable `m44`: JSString = "m44"
    @usableFromInline static immutable `marginHeight`: JSString = "marginHeight"
    @usableFromInline static immutable `marginWidth`: JSString = "marginWidth"
    @usableFromInline static immutable `match`: JSString = "match"
    @usableFromInline static immutable `matchAll`: JSString = "matchAll"
    @usableFromInline static immutable `matchMedia`: JSString = "matchMedia"
    @usableFromInline static immutable `matches`: JSString = "matches"
    @usableFromInline static immutable `matrix`: JSString = "matrix"
    @usableFromInline static immutable `matrixTransform`: JSString = "matrixTransform"
    @usableFromInline static immutable `max`: JSString = "max"
    @usableFromInline static immutable `maxLength`: JSString = "maxLength"
    @usableFromInline static immutable `measureText`: JSString = "measureText"
    @usableFromInline static immutable `media`: JSString = "media"
    @usableFromInline static immutable `mediaDevices`: JSString = "mediaDevices"
    @usableFromInline static immutable `menubar`: JSString = "menubar"
    @usableFromInline static immutable `message`: JSString = "message"
    @usableFromInline static immutable `metaKey`: JSString = "metaKey"
    @usableFromInline static immutable `metadata`: JSString = "metadata"
    @usableFromInline static immutable `method`: JSString = "method"
    @usableFromInline static immutable `mimeType`: JSString = "mimeType"
    @usableFromInline static immutable `mimeTypes`: JSString = "mimeTypes"
    @usableFromInline static immutable `min`: JSString = "min"
    @usableFromInline static immutable `minLength`: JSString = "minLength"
    @usableFromInline static immutable `miterLimit`: JSString = "miterLimit"
    @usableFromInline static immutable `mode`: JSString = "mode"
    @usableFromInline static immutable `modifierAltGraph`: JSString = "modifierAltGraph"
    @usableFromInline static immutable `modifierCapsLock`: JSString = "modifierCapsLock"
    @usableFromInline static immutable `modifierFn`: JSString = "modifierFn"
    @usableFromInline static immutable `modifierFnLock`: JSString = "modifierFnLock"
    @usableFromInline static immutable `modifierHyper`: JSString = "modifierHyper"
    @usableFromInline static immutable `modifierNumLock`: JSString = "modifierNumLock"
    @usableFromInline static immutable `modifierScrollLock`: JSString = "modifierScrollLock"
    @usableFromInline static immutable `modifierSuper`: JSString = "modifierSuper"
    @usableFromInline static immutable `modifierSymbol`: JSString = "modifierSymbol"
    @usableFromInline static immutable `modifierSymbolLock`: JSString = "modifierSymbolLock"
    @usableFromInline static immutable `moveBy`: JSString = "moveBy"
    @usableFromInline static immutable `moveTo`: JSString = "moveTo"
    @usableFromInline static immutable `multiple`: JSString = "multiple"
    @usableFromInline static immutable `multiply`: JSString = "multiply"
    @usableFromInline static immutable `multiplySelf`: JSString = "multiplySelf"
    @usableFromInline static immutable `muted`: JSString = "muted"
    @usableFromInline static immutable `name`: JSString = "name"
    @usableFromInline static immutable `namedItem`: JSString = "namedItem"
    @usableFromInline static immutable `namespaceURI`: JSString = "namespaceURI"
    @usableFromInline static immutable `naturalHeight`: JSString = "naturalHeight"
    @usableFromInline static immutable `naturalWidth`: JSString = "naturalWidth"
    @usableFromInline static immutable `navigate`: JSString = "navigate"
    @usableFromInline static immutable `navigation`: JSString = "navigation"
    @usableFromInline static immutable `navigationId`: JSString = "navigationId"
    @usableFromInline static immutable `navigationPreload`: JSString = "navigationPreload"
    @usableFromInline static immutable `navigationType`: JSString = "navigationType"
    @usableFromInline static immutable `navigator`: JSString = "navigator"
    @usableFromInline static immutable `networkState`: JSString = "networkState"
    @usableFromInline static immutable `newState`: JSString = "newState"
    @usableFromInline static immutable `newURL`: JSString = "newURL"
    @usableFromInline static immutable `newValue`: JSString = "newValue"
    @usableFromInline static immutable `nextElementSibling`: JSString = "nextElementSibling"
    @usableFromInline static immutable `nextNode`: JSString = "nextNode"
    @usableFromInline static immutable `nextSibling`: JSString = "nextSibling"
    @usableFromInline static immutable `noHref`: JSString = "noHref"
    @usableFromInline static immutable `noModule`: JSString = "noModule"
    @usableFromInline static immutable `noResize`: JSString = "noResize"
    @usableFromInline static immutable `noShade`: JSString = "noShade"
    @usableFromInline static immutable `noValidate`: JSString = "noValidate"
    @usableFromInline static immutable `noWrap`: JSString = "noWrap"
    @usableFromInline static immutable `nodeName`: JSString = "nodeName"
    @usableFromInline static immutable `nodeType`: JSString = "nodeType"
    @usableFromInline static immutable `nodeValue`: JSString = "nodeValue"
    @usableFromInline static immutable `noiseSuppression`: JSString = "noiseSuppression"
    @usableFromInline static immutable `nonce`: JSString = "nonce"
    @usableFromInline static immutable `normalize`: JSString = "normalize"
    @usableFromInline static immutable `not`: JSString = "not"
    @usableFromInline static immutable `now`: JSString = "now"
    @usableFromInline static immutable `numberOfChannels`: JSString = "numberOfChannels"
    @usableFromInline static immutable `numberOfFrames`: JSString = "numberOfFrames"
    @usableFromInline static immutable `numberValue`: JSString = "numberValue"
    @usableFromInline static immutable `observe`: JSString = "observe"
    @usableFromInline static immutable `offset`: JSString = "offset"
    @usableFromInline static immutable `offsetHeight`: JSString = "offsetHeight"
    @usableFromInline static immutable `offsetLeft`: JSString = "offsetLeft"
    @usableFromInline static immutable `offsetNode`: JSString = "offsetNode"
    @usableFromInline static immutable `offsetParent`: JSString = "offsetParent"
    @usableFromInline static immutable `offsetTop`: JSString = "offsetTop"
    @usableFromInline static immutable `offsetWidth`: JSString = "offsetWidth"
    @usableFromInline static immutable `offsetX`: JSString = "offsetX"
    @usableFromInline static immutable `offsetY`: JSString = "offsetY"
    @usableFromInline static immutable `ok`: JSString = "ok"
    @usableFromInline static immutable `oldState`: JSString = "oldState"
    @usableFromInline static immutable `oldURL`: JSString = "oldURL"
    @usableFromInline static immutable `oldValue`: JSString = "oldValue"
    @usableFromInline static immutable `onLine`: JSString = "onLine"
    @usableFromInline static immutable `onabort`: JSString = "onabort"
    @usableFromInline static immutable `onaddsourcebuffer`: JSString = "onaddsourcebuffer"
    @usableFromInline static immutable `onaddtrack`: JSString = "onaddtrack"
    @usableFromInline static immutable `onafterprint`: JSString = "onafterprint"
    @usableFromInline static immutable `onauxclick`: JSString = "onauxclick"
    @usableFromInline static immutable `onbeforeinput`: JSString = "onbeforeinput"
    @usableFromInline static immutable `onbeforematch`: JSString = "onbeforematch"
    @usableFromInline static immutable `onbeforeprint`: JSString = "onbeforeprint"
    @usableFromInline static immutable `onbeforetoggle`: JSString = "onbeforetoggle"
    @usableFromInline static immutable `onbeforeunload`: JSString = "onbeforeunload"
    @usableFromInline static immutable `onblur`: JSString = "onblur"
    @usableFromInline static immutable `onbufferedchange`: JSString = "onbufferedchange"
    @usableFromInline static immutable `oncancel`: JSString = "oncancel"
    @usableFromInline static immutable `oncanplay`: JSString = "oncanplay"
    @usableFromInline static immutable `oncanplaythrough`: JSString = "oncanplaythrough"
    @usableFromInline static immutable `once`: JSString = "once"
    @usableFromInline static immutable `onchange`: JSString = "onchange"
    @usableFromInline static immutable `onclick`: JSString = "onclick"
    @usableFromInline static immutable `onclose`: JSString = "onclose"
    @usableFromInline static immutable `oncommand`: JSString = "oncommand"
    @usableFromInline static immutable `oncontextlost`: JSString = "oncontextlost"
    @usableFromInline static immutable `oncontextmenu`: JSString = "oncontextmenu"
    @usableFromInline static immutable `oncontextrestored`: JSString = "oncontextrestored"
    @usableFromInline static immutable `oncontrollerchange`: JSString = "oncontrollerchange"
    @usableFromInline static immutable `oncopy`: JSString = "oncopy"
    @usableFromInline static immutable `oncuechange`: JSString = "oncuechange"
    @usableFromInline static immutable `oncurrententrychange`: JSString = "oncurrententrychange"
    @usableFromInline static immutable `oncut`: JSString = "oncut"
    @usableFromInline static immutable `ondataavailable`: JSString = "ondataavailable"
    @usableFromInline static immutable `ondblclick`: JSString = "ondblclick"
    @usableFromInline static immutable `ondequeue`: JSString = "ondequeue"
    @usableFromInline static immutable `ondevicechange`: JSString = "ondevicechange"
    @usableFromInline static immutable `ondispose`: JSString = "ondispose"
    @usableFromInline static immutable `ondrag`: JSString = "ondrag"
    @usableFromInline static immutable `ondragend`: JSString = "ondragend"
    @usableFromInline static immutable `ondragenter`: JSString = "ondragenter"
    @usableFromInline static immutable `ondragleave`: JSString = "ondragleave"
    @usableFromInline static immutable `ondragover`: JSString = "ondragover"
    @usableFromInline static immutable `ondragstart`: JSString = "ondragstart"
    @usableFromInline static immutable `ondrop`: JSString = "ondrop"
    @usableFromInline static immutable `ondurationchange`: JSString = "ondurationchange"
    @usableFromInline static immutable `onemptied`: JSString = "onemptied"
    @usableFromInline static immutable `onended`: JSString = "onended"
    @usableFromInline static immutable `onendstreaming`: JSString = "onendstreaming"
    @usableFromInline static immutable `onenter`: JSString = "onenter"
    @usableFromInline static immutable `onerror`: JSString = "onerror"
    @usableFromInline static immutable `onexit`: JSString = "onexit"
    @usableFromInline static immutable `onfocus`: JSString = "onfocus"
    @usableFromInline static immutable `onformdata`: JSString = "onformdata"
    @usableFromInline static immutable `onhashchange`: JSString = "onhashchange"
    @usableFromInline static immutable `oninput`: JSString = "oninput"
    @usableFromInline static immutable `oninvalid`: JSString = "oninvalid"
    @usableFromInline static immutable `onkeydown`: JSString = "onkeydown"
    @usableFromInline static immutable `onkeypress`: JSString = "onkeypress"
    @usableFromInline static immutable `onkeyup`: JSString = "onkeyup"
    @usableFromInline static immutable `onlanguagechange`: JSString = "onlanguagechange"
    @usableFromInline static immutable `onload`: JSString = "onload"
    @usableFromInline static immutable `onloadeddata`: JSString = "onloadeddata"
    @usableFromInline static immutable `onloadedmetadata`: JSString = "onloadedmetadata"
    @usableFromInline static immutable `onloadend`: JSString = "onloadend"
    @usableFromInline static immutable `onloadstart`: JSString = "onloadstart"
    @usableFromInline static immutable `onmessage`: JSString = "onmessage"
    @usableFromInline static immutable `onmessageerror`: JSString = "onmessageerror"
    @usableFromInline static immutable `onmousedown`: JSString = "onmousedown"
    @usableFromInline static immutable `onmouseenter`: JSString = "onmouseenter"
    @usableFromInline static immutable `onmouseleave`: JSString = "onmouseleave"
    @usableFromInline static immutable `onmousemove`: JSString = "onmousemove"
    @usableFromInline static immutable `onmouseout`: JSString = "onmouseout"
    @usableFromInline static immutable `onmouseover`: JSString = "onmouseover"
    @usableFromInline static immutable `onmouseup`: JSString = "onmouseup"
    @usableFromInline static immutable `onmute`: JSString = "onmute"
    @usableFromInline static immutable `onnavigate`: JSString = "onnavigate"
    @usableFromInline static immutable `onnavigateerror`: JSString = "onnavigateerror"
    @usableFromInline static immutable `onnavigatesuccess`: JSString = "onnavigatesuccess"
    @usableFromInline static immutable `onoffline`: JSString = "onoffline"
    @usableFromInline static immutable `ononline`: JSString = "ononline"
    @usableFromInline static immutable `onopen`: JSString = "onopen"
    @usableFromInline static immutable `onpagehide`: JSString = "onpagehide"
    @usableFromInline static immutable `onpagereveal`: JSString = "onpagereveal"
    @usableFromInline static immutable `onpageshow`: JSString = "onpageshow"
    @usableFromInline static immutable `onpageswap`: JSString = "onpageswap"
    @usableFromInline static immutable `onpaste`: JSString = "onpaste"
    @usableFromInline static immutable `onpause`: JSString = "onpause"
    @usableFromInline static immutable `onplay`: JSString = "onplay"
    @usableFromInline static immutable `onplaying`: JSString = "onplaying"
    @usableFromInline static immutable `onpopstate`: JSString = "onpopstate"
    @usableFromInline static immutable `onprogress`: JSString = "onprogress"
    @usableFromInline static immutable `onratechange`: JSString = "onratechange"
    @usableFromInline static immutable `onreadystatechange`: JSString = "onreadystatechange"
    @usableFromInline static immutable `onrejectionhandled`: JSString = "onrejectionhandled"
    @usableFromInline static immutable `onremovesourcebuffer`: JSString = "onremovesourcebuffer"
    @usableFromInline static immutable `onremovetrack`: JSString = "onremovetrack"
    @usableFromInline static immutable `onreset`: JSString = "onreset"
    @usableFromInline static immutable `onresize`: JSString = "onresize"
    @usableFromInline static immutable `onresume`: JSString = "onresume"
    @usableFromInline static immutable `onscroll`: JSString = "onscroll"
    @usableFromInline static immutable `onscrollend`: JSString = "onscrollend"
    @usableFromInline static immutable `onsecuritypolicyviolation`: JSString = "onsecuritypolicyviolation"
    @usableFromInline static immutable `onseeked`: JSString = "onseeked"
    @usableFromInline static immutable `onseeking`: JSString = "onseeking"
    @usableFromInline static immutable `onselect`: JSString = "onselect"
    @usableFromInline static immutable `onslotchange`: JSString = "onslotchange"
    @usableFromInline static immutable `onsourceclose`: JSString = "onsourceclose"
    @usableFromInline static immutable `onsourceended`: JSString = "onsourceended"
    @usableFromInline static immutable `onsourceopen`: JSString = "onsourceopen"
    @usableFromInline static immutable `onstalled`: JSString = "onstalled"
    @usableFromInline static immutable `onstart`: JSString = "onstart"
    @usableFromInline static immutable `onstartstreaming`: JSString = "onstartstreaming"
    @usableFromInline static immutable `onstatechange`: JSString = "onstatechange"
    @usableFromInline static immutable `onstop`: JSString = "onstop"
    @usableFromInline static immutable `onstorage`: JSString = "onstorage"
    @usableFromInline static immutable `onsubmit`: JSString = "onsubmit"
    @usableFromInline static immutable `onsuspend`: JSString = "onsuspend"
    @usableFromInline static immutable `ontimeout`: JSString = "ontimeout"
    @usableFromInline static immutable `ontimeupdate`: JSString = "ontimeupdate"
    @usableFromInline static immutable `ontoggle`: JSString = "ontoggle"
    @usableFromInline static immutable `ontouchcancel`: JSString = "ontouchcancel"
    @usableFromInline static immutable `ontouchend`: JSString = "ontouchend"
    @usableFromInline static immutable `ontouchmove`: JSString = "ontouchmove"
    @usableFromInline static immutable `ontouchstart`: JSString = "ontouchstart"
    @usableFromInline static immutable `onunhandledrejection`: JSString = "onunhandledrejection"
    @usableFromInline static immutable `onunload`: JSString = "onunload"
    @usableFromInline static immutable `onunmute`: JSString = "onunmute"
    @usableFromInline static immutable `onupdate`: JSString = "onupdate"
    @usableFromInline static immutable `onupdateend`: JSString = "onupdateend"
    @usableFromInline static immutable `onupdatefound`: JSString = "onupdatefound"
    @usableFromInline static immutable `onupdatestart`: JSString = "onupdatestart"
    @usableFromInline static immutable `onvisibilitychange`: JSString = "onvisibilitychange"
    @usableFromInline static immutable `onvolumechange`: JSString = "onvolumechange"
    @usableFromInline static immutable `onwaiting`: JSString = "onwaiting"
    @usableFromInline static immutable `onwebkitanimationend`: JSString = "onwebkitanimationend"
    @usableFromInline static immutable `onwebkitanimationiteration`: JSString = "onwebkitanimationiteration"
    @usableFromInline static immutable `onwebkitanimationstart`: JSString = "onwebkitanimationstart"
    @usableFromInline static immutable `onwebkittransitionend`: JSString = "onwebkittransitionend"
    @usableFromInline static immutable `onwheel`: JSString = "onwheel"
    @usableFromInline static immutable `opacityProperty`: JSString = "opacityProperty"
    @usableFromInline static immutable `open`: JSString = "open"
    @usableFromInline static immutable `opener`: JSString = "opener"
    @usableFromInline static immutable `optimizeForLatency`: JSString = "optimizeForLatency"
    @usableFromInline static immutable `optimum`: JSString = "optimum"
    @usableFromInline static immutable `options`: JSString = "options"
    @usableFromInline static immutable `or`: JSString = "or"
    @usableFromInline static immutable `origin`: JSString = "origin"
    @usableFromInline static immutable `originAgentCluster`: JSString = "originAgentCluster"
    @usableFromInline static immutable `oscpu`: JSString = "oscpu"
    @usableFromInline static immutable `outerHTML`: JSString = "outerHTML"
    @usableFromInline static immutable `outerHeight`: JSString = "outerHeight"
    @usableFromInline static immutable `outerText`: JSString = "outerText"
    @usableFromInline static immutable `outerWidth`: JSString = "outerWidth"
    @usableFromInline static immutable `output`: JSString = "output"
    @usableFromInline static immutable `overrideMimeType`: JSString = "overrideMimeType"
    @usableFromInline static immutable `ownerDocument`: JSString = "ownerDocument"
    @usableFromInline static immutable `ownerElement`: JSString = "ownerElement"
    @usableFromInline static immutable `p1`: JSString = "p1"
    @usableFromInline static immutable `p2`: JSString = "p2"
    @usableFromInline static immutable `p3`: JSString = "p3"
    @usableFromInline static immutable `p4`: JSString = "p4"
    @usableFromInline static immutable `pageLeft`: JSString = "pageLeft"
    @usableFromInline static immutable `pageTop`: JSString = "pageTop"
    @usableFromInline static immutable `pageX`: JSString = "pageX"
    @usableFromInline static immutable `pageXOffset`: JSString = "pageXOffset"
    @usableFromInline static immutable `pageY`: JSString = "pageY"
    @usableFromInline static immutable `pageYOffset`: JSString = "pageYOffset"
    @usableFromInline static immutable `panTiltZoom`: JSString = "panTiltZoom"
    @usableFromInline static immutable `parent`: JSString = "parent"
    @usableFromInline static immutable `parentElement`: JSString = "parentElement"
    @usableFromInline static immutable `parentNode`: JSString = "parentNode"
    @usableFromInline static immutable `parseFromString`: JSString = "parseFromString"
    @usableFromInline static immutable `parseHTMLUnsafe`: JSString = "parseHTMLUnsafe"
    @usableFromInline static immutable `passive`: JSString = "passive"
    @usableFromInline static immutable `password`: JSString = "password"
    @usableFromInline static immutable `pathname`: JSString = "pathname"
    @usableFromInline static immutable `pattern`: JSString = "pattern"
    @usableFromInline static immutable `patternMismatch`: JSString = "patternMismatch"
    @usableFromInline static immutable `pause`: JSString = "pause"
    @usableFromInline static immutable `pauseOnExit`: JSString = "pauseOnExit"
    @usableFromInline static immutable `paused`: JSString = "paused"
    @usableFromInline static immutable `pdfViewerEnabled`: JSString = "pdfViewerEnabled"
    @usableFromInline static immutable `performance`: JSString = "performance"
    @usableFromInline static immutable `permissions`: JSString = "permissions"
    @usableFromInline static immutable `persisted`: JSString = "persisted"
    @usableFromInline static immutable `personalbar`: JSString = "personalbar"
    @usableFromInline static immutable `ping`: JSString = "ping"
    @usableFromInline static immutable `pipeThrough`: JSString = "pipeThrough"
    @usableFromInline static immutable `pipeTo`: JSString = "pipeTo"
    @usableFromInline static immutable `pixelDepth`: JSString = "pixelDepth"
    @usableFromInline static immutable `placeholder`: JSString = "placeholder"
    @usableFromInline static immutable `planeIndex`: JSString = "planeIndex"
    @usableFromInline static immutable `platform`: JSString = "platform"
    @usableFromInline static immutable `play`: JSString = "play"
    @usableFromInline static immutable `playbackRate`: JSString = "playbackRate"
    @usableFromInline static immutable `played`: JSString = "played"
    @usableFromInline static immutable `playsInline`: JSString = "playsInline"
    @usableFromInline static immutable `plugins`: JSString = "plugins"
    @usableFromInline static immutable `pointerBeforeReferenceNode`: JSString = "pointerBeforeReferenceNode"
    @usableFromInline static immutable `popover`: JSString = "popover"
    @usableFromInline static immutable `popoverTargetAction`: JSString = "popoverTargetAction"
    @usableFromInline static immutable `popoverTargetElement`: JSString = "popoverTargetElement"
    @usableFromInline static immutable `port`: JSString = "port"
    @usableFromInline static immutable `port1`: JSString = "port1"
    @usableFromInline static immutable `port2`: JSString = "port2"
    @usableFromInline static immutable `ports`: JSString = "ports"
    @usableFromInline static immutable `position`: JSString = "position"
    @usableFromInline static immutable `postMessage`: JSString = "postMessage"
    @usableFromInline static immutable `poster`: JSString = "poster"
    @usableFromInline static immutable `preMultiplySelf`: JSString = "preMultiplySelf"
    @usableFromInline static immutable `preferAnimation`: JSString = "preferAnimation"
    @usableFromInline static immutable `prefix`: JSString = "prefix"
    @usableFromInline static immutable `preload`: JSString = "preload"
    @usableFromInline static immutable `preloadResponse`: JSString = "preloadResponse"
    @usableFromInline static immutable `premultiplyAlpha`: JSString = "premultiplyAlpha"
    @usableFromInline static immutable `prepend`: JSString = "prepend"
    @usableFromInline static immutable `preservesPitch`: JSString = "preservesPitch"
    @usableFromInline static immutable `preventAbort`: JSString = "preventAbort"
    @usableFromInline static immutable `preventCancel`: JSString = "preventCancel"
    @usableFromInline static immutable `preventClose`: JSString = "preventClose"
    @usableFromInline static immutable `preventDefault`: JSString = "preventDefault"
    @usableFromInline static immutable `preventScroll`: JSString = "preventScroll"
    @usableFromInline static immutable `previousElementSibling`: JSString = "previousElementSibling"
    @usableFromInline static immutable `previousNode`: JSString = "previousNode"
    @usableFromInline static immutable `previousSibling`: JSString = "previousSibling"
    @usableFromInline static immutable `primaries`: JSString = "primaries"
    @usableFromInline static immutable `print`: JSString = "print"
    @usableFromInline static immutable `priority`: JSString = "priority"
    @usableFromInline static immutable `product`: JSString = "product"
    @usableFromInline static immutable `productSub`: JSString = "productSub"
    @usableFromInline static immutable `promise`: JSString = "promise"
    @usableFromInline static immutable `prompt`: JSString = "prompt"
    @usableFromInline static immutable `protocol`: JSString = "protocol"
    @usableFromInline static immutable `pseudo`: JSString = "pseudo"
    @usableFromInline static immutable `publicId`: JSString = "publicId"
    @usableFromInline static immutable `pull`: JSString = "pull"
    @usableFromInline static immutable `pushState`: JSString = "pushState"
    @usableFromInline static immutable `put`: JSString = "put"
    @usableFromInline static immutable `putImageData`: JSString = "putImageData"
    @usableFromInline static immutable `quadraticCurveTo`: JSString = "quadraticCurveTo"
    @usableFromInline static immutable `quality`: JSString = "quality"
    @usableFromInline static immutable `query`: JSString = "query"
    @usableFromInline static immutable `queryCommandEnabled`: JSString = "queryCommandEnabled"
    @usableFromInline static immutable `queryCommandIndeterm`: JSString = "queryCommandIndeterm"
    @usableFromInline static immutable `queryCommandState`: JSString = "queryCommandState"
    @usableFromInline static immutable `queryCommandSupported`: JSString = "queryCommandSupported"
    @usableFromInline static immutable `queryCommandValue`: JSString = "queryCommandValue"
    @usableFromInline static immutable `querySelector`: JSString = "querySelector"
    @usableFromInline static immutable `querySelectorAll`: JSString = "querySelectorAll"
    @usableFromInline static immutable `queueMicrotask`: JSString = "queueMicrotask"
    @usableFromInline static immutable `radiusX`: JSString = "radiusX"
    @usableFromInline static immutable `radiusY`: JSString = "radiusY"
    @usableFromInline static immutable `rangeOverflow`: JSString = "rangeOverflow"
    @usableFromInline static immutable `rangeUnderflow`: JSString = "rangeUnderflow"
    @usableFromInline static immutable `read`: JSString = "read"
    @usableFromInline static immutable `readAsArrayBuffer`: JSString = "readAsArrayBuffer"
    @usableFromInline static immutable `readAsBinaryString`: JSString = "readAsBinaryString"
    @usableFromInline static immutable `readAsDataURL`: JSString = "readAsDataURL"
    @usableFromInline static immutable `readAsText`: JSString = "readAsText"
    @usableFromInline static immutable `readOnly`: JSString = "readOnly"
    @usableFromInline static immutable `readable`: JSString = "readable"
    @usableFromInline static immutable `readableType`: JSString = "readableType"
    @usableFromInline static immutable `ready`: JSString = "ready"
    @usableFromInline static immutable `readyState`: JSString = "readyState"
    @usableFromInline static immutable `reason`: JSString = "reason"
    @usableFromInline static immutable `reasons`: JSString = "reasons"
    @usableFromInline static immutable `rect`: JSString = "rect"
    @usableFromInline static immutable `redirect`: JSString = "redirect"
    @usableFromInline static immutable `redirected`: JSString = "redirected"
    @usableFromInline static immutable `referenceNode`: JSString = "referenceNode"
    @usableFromInline static immutable `referrer`: JSString = "referrer"
    @usableFromInline static immutable `referrerPolicy`: JSString = "referrerPolicy"
    @usableFromInline static immutable `refresh`: JSString = "refresh"
    @usableFromInline static immutable `register`: JSString = "register"
    @usableFromInline static immutable `registerProtocolHandler`: JSString = "registerProtocolHandler"
    @usableFromInline static immutable `rel`: JSString = "rel"
    @usableFromInline static immutable `relList`: JSString = "relList"
    @usableFromInline static immutable `relatedTarget`: JSString = "relatedTarget"
    @usableFromInline static immutable `relativeTo`: JSString = "relativeTo"
    @usableFromInline static immutable `releaseEvents`: JSString = "releaseEvents"
    @usableFromInline static immutable `releaseLock`: JSString = "releaseLock"
    @usableFromInline static immutable `reload`: JSString = "reload"
    @usableFromInline static immutable `remove`: JSString = "remove"
    @usableFromInline static immutable `removeAttribute`: JSString = "removeAttribute"
    @usableFromInline static immutable `removeAttributeNS`: JSString = "removeAttributeNS"
    @usableFromInline static immutable `removeAttributeNode`: JSString = "removeAttributeNode"
    @usableFromInline static immutable `removeChild`: JSString = "removeChild"
    @usableFromInline static immutable `removeCue`: JSString = "removeCue"
    @usableFromInline static immutable `removeEventListener`: JSString = "removeEventListener"
    @usableFromInline static immutable `removeListener`: JSString = "removeListener"
    @usableFromInline static immutable `removeNamedItem`: JSString = "removeNamedItem"
    @usableFromInline static immutable `removeNamedItemNS`: JSString = "removeNamedItemNS"
    @usableFromInline static immutable `removeParameter`: JSString = "removeParameter"
    @usableFromInline static immutable `removeSourceBuffer`: JSString = "removeSourceBuffer"
    @usableFromInline static immutable `removeTrack`: JSString = "removeTrack"
    @usableFromInline static immutable `removedNodes`: JSString = "removedNodes"
    @usableFromInline static immutable `removedRanges`: JSString = "removedRanges"
    @usableFromInline static immutable `repeat`: JSString = "repeat"
    @usableFromInline static immutable `repetitionCount`: JSString = "repetitionCount"
    @usableFromInline static immutable `replace`: JSString = "replace"
    @usableFromInline static immutable `replaceChild`: JSString = "replaceChild"
    @usableFromInline static immutable `replaceChildren`: JSString = "replaceChildren"
    @usableFromInline static immutable `replaceData`: JSString = "replaceData"
    @usableFromInline static immutable `replaceState`: JSString = "replaceState"
    @usableFromInline static immutable `replaceWith`: JSString = "replaceWith"
    @usableFromInline static immutable `replacesClientId`: JSString = "replacesClientId"
    @usableFromInline static immutable `reportError`: JSString = "reportError"
    @usableFromInline static immutable `reportValidity`: JSString = "reportValidity"
    @usableFromInline static immutable `request`: JSString = "request"
    @usableFromInline static immutable `requestAnimationFrame`: JSString = "requestAnimationFrame"
    @usableFromInline static immutable `requestClose`: JSString = "requestClose"
    @usableFromInline static immutable `requestData`: JSString = "requestData"
    @usableFromInline static immutable `requestDestination`: JSString = "requestDestination"
    @usableFromInline static immutable `requestMethod`: JSString = "requestMethod"
    @usableFromInline static immutable `requestMode`: JSString = "requestMode"
    @usableFromInline static immutable `requestSubmit`: JSString = "requestSubmit"
    @usableFromInline static immutable `required`: JSString = "required"
    @usableFromInline static immutable `reset`: JSString = "reset"
    @usableFromInline static immutable `resetTransform`: JSString = "resetTransform"
    @usableFromInline static immutable `resizeBy`: JSString = "resizeBy"
    @usableFromInline static immutable `resizeHeight`: JSString = "resizeHeight"
    @usableFromInline static immutable `resizeMode`: JSString = "resizeMode"
    @usableFromInline static immutable `resizeQuality`: JSString = "resizeQuality"
    @usableFromInline static immutable `resizeTo`: JSString = "resizeTo"
    @usableFromInline static immutable `resizeWidth`: JSString = "resizeWidth"
    @usableFromInline static immutable `respond`: JSString = "respond"
    @usableFromInline static immutable `respondWithNewView`: JSString = "respondWithNewView"
    @usableFromInline static immutable `response`: JSString = "response"
    @usableFromInline static immutable `responseText`: JSString = "responseText"
    @usableFromInline static immutable `responseType`: JSString = "responseType"
    @usableFromInline static immutable `responseURL`: JSString = "responseURL"
    @usableFromInline static immutable `responseXML`: JSString = "responseXML"
    @usableFromInline static immutable `restore`: JSString = "restore"
    @usableFromInline static immutable `result`: JSString = "result"
    @usableFromInline static immutable `resultType`: JSString = "resultType"
    @usableFromInline static immutable `resultingClientId`: JSString = "resultingClientId"
    @usableFromInline static immutable `resume`: JSString = "resume"
    @usableFromInline static immutable `returnValue`: JSString = "returnValue"
    @usableFromInline static immutable `rev`: JSString = "rev"
    @usableFromInline static immutable `reversed`: JSString = "reversed"
    @usableFromInline static immutable `revokeObjectURL`: JSString = "revokeObjectURL"
    @usableFromInline static immutable `right`: JSString = "right"
    @usableFromInline static immutable `role`: JSString = "role"
    @usableFromInline static immutable `root`: JSString = "root"
    @usableFromInline static immutable `rotate`: JSString = "rotate"
    @usableFromInline static immutable `rotateAxisAngle`: JSString = "rotateAxisAngle"
    @usableFromInline static immutable `rotateAxisAngleSelf`: JSString = "rotateAxisAngleSelf"
    @usableFromInline static immutable `rotateFromVector`: JSString = "rotateFromVector"
    @usableFromInline static immutable `rotateFromVectorSelf`: JSString = "rotateFromVectorSelf"
    @usableFromInline static immutable `rotateSelf`: JSString = "rotateSelf"
    @usableFromInline static immutable `rotation`: JSString = "rotation"
    @usableFromInline static immutable `rotationAngle`: JSString = "rotationAngle"
    @usableFromInline static immutable `roundRect`: JSString = "roundRect"
    @usableFromInline static immutable `rowIndex`: JSString = "rowIndex"
    @usableFromInline static immutable `rowSpan`: JSString = "rowSpan"
    @usableFromInline static immutable `rows`: JSString = "rows"
    @usableFromInline static immutable `rules`: JSString = "rules"
    @usableFromInline static immutable `runningStatus`: JSString = "runningStatus"
    @usableFromInline static immutable `sameDocument`: JSString = "sameDocument"
    @usableFromInline static immutable `sampleRate`: JSString = "sampleRate"
    @usableFromInline static immutable `sampleSize`: JSString = "sampleSize"
    @usableFromInline static immutable `sandbox`: JSString = "sandbox"
    @usableFromInline static immutable `save`: JSString = "save"
    @usableFromInline static immutable `scalabilityMode`: JSString = "scalabilityMode"
    @usableFromInline static immutable `scale`: JSString = "scale"
    @usableFromInline static immutable `scale3d`: JSString = "scale3d"
    @usableFromInline static immutable `scale3dSelf`: JSString = "scale3dSelf"
    @usableFromInline static immutable `scaleNonUniform`: JSString = "scaleNonUniform"
    @usableFromInline static immutable `scaleSelf`: JSString = "scaleSelf"
    @usableFromInline static immutable `scheme`: JSString = "scheme"
    @usableFromInline static immutable `scope`: JSString = "scope"
    @usableFromInline static immutable `screen`: JSString = "screen"
    @usableFromInline static immutable `screenLeft`: JSString = "screenLeft"
    @usableFromInline static immutable `screenTop`: JSString = "screenTop"
    @usableFromInline static immutable `screenX`: JSString = "screenX"
    @usableFromInline static immutable `screenY`: JSString = "screenY"
    @usableFromInline static immutable `scriptURL`: JSString = "scriptURL"
    @usableFromInline static immutable `scripts`: JSString = "scripts"
    @usableFromInline static immutable `scroll`: JSString = "scroll"
    @usableFromInline static immutable `scrollAmount`: JSString = "scrollAmount"
    @usableFromInline static immutable `scrollBy`: JSString = "scrollBy"
    @usableFromInline static immutable `scrollDelay`: JSString = "scrollDelay"
    @usableFromInline static immutable `scrollHeight`: JSString = "scrollHeight"
    @usableFromInline static immutable `scrollIntoView`: JSString = "scrollIntoView"
    @usableFromInline static immutable `scrollLeft`: JSString = "scrollLeft"
    @usableFromInline static immutable `scrollRestoration`: JSString = "scrollRestoration"
    @usableFromInline static immutable `scrollTo`: JSString = "scrollTo"
    @usableFromInline static immutable `scrollTop`: JSString = "scrollTop"
    @usableFromInline static immutable `scrollWidth`: JSString = "scrollWidth"
    @usableFromInline static immutable `scrollX`: JSString = "scrollX"
    @usableFromInline static immutable `scrollY`: JSString = "scrollY"
    @usableFromInline static immutable `scrollbars`: JSString = "scrollbars"
    @usableFromInline static immutable `scrolling`: JSString = "scrolling"
    @usableFromInline static immutable `scrollingElement`: JSString = "scrollingElement"
    @usableFromInline static immutable `search`: JSString = "search"
    @usableFromInline static immutable `sectionRowIndex`: JSString = "sectionRowIndex"
    @usableFromInline static immutable `seekable`: JSString = "seekable"
    @usableFromInline static immutable `seeking`: JSString = "seeking"
    @usableFromInline static immutable `select`: JSString = "select"
    @usableFromInline static immutable `selectNode`: JSString = "selectNode"
    @usableFromInline static immutable `selectNodeContents`: JSString = "selectNodeContents"
    @usableFromInline static immutable `selected`: JSString = "selected"
    @usableFromInline static immutable `selectedIndex`: JSString = "selectedIndex"
    @usableFromInline static immutable `selectedOptions`: JSString = "selectedOptions"
    @usableFromInline static immutable `selectedTrack`: JSString = "selectedTrack"
    @usableFromInline static immutable `selectionDirection`: JSString = "selectionDirection"
    @usableFromInline static immutable `selectionEnd`: JSString = "selectionEnd"
    @usableFromInline static immutable `selectionStart`: JSString = "selectionStart"
    @usableFromInline static immutable `send`: JSString = "send"
    @usableFromInline static immutable `serializable`: JSString = "serializable"
    @usableFromInline static immutable `serializableShadowRoots`: JSString = "serializableShadowRoots"
    @usableFromInline static immutable `serializeToString`: JSString = "serializeToString"
    @usableFromInline static immutable `serviceWorker`: JSString = "serviceWorker"
    @usableFromInline static immutable `sessionStorage`: JSString = "sessionStorage"
    @usableFromInline static immutable `set`: JSString = "set"
    @usableFromInline static immutable `setAttribute`: JSString = "setAttribute"
    @usableFromInline static immutable `setAttributeNS`: JSString = "setAttributeNS"
    @usableFromInline static immutable `setAttributeNode`: JSString = "setAttributeNode"
    @usableFromInline static immutable `setAttributeNodeNS`: JSString = "setAttributeNodeNS"
    @usableFromInline static immutable `setCustomValidity`: JSString = "setCustomValidity"
    @usableFromInline static immutable `setData`: JSString = "setData"
    @usableFromInline static immutable `setDragImage`: JSString = "setDragImage"
    @usableFromInline static immutable `setEnd`: JSString = "setEnd"
    @usableFromInline static immutable `setEndAfter`: JSString = "setEndAfter"
    @usableFromInline static immutable `setEndBefore`: JSString = "setEndBefore"
    @usableFromInline static immutable `setFormValue`: JSString = "setFormValue"
    @usableFromInline static immutable `setHTMLUnsafe`: JSString = "setHTMLUnsafe"
    @usableFromInline static immutable `setHeaderValue`: JSString = "setHeaderValue"
    @usableFromInline static immutable `setInterval`: JSString = "setInterval"
    @usableFromInline static immutable `setLineDash`: JSString = "setLineDash"
    @usableFromInline static immutable `setLiveSeekableRange`: JSString = "setLiveSeekableRange"
    @usableFromInline static immutable `setMatrixValue`: JSString = "setMatrixValue"
    @usableFromInline static immutable `setNamedItem`: JSString = "setNamedItem"
    @usableFromInline static immutable `setNamedItemNS`: JSString = "setNamedItemNS"
    @usableFromInline static immutable `setParameter`: JSString = "setParameter"
    @usableFromInline static immutable `setRangeText`: JSString = "setRangeText"
    @usableFromInline static immutable `setRequestHeader`: JSString = "setRequestHeader"
    @usableFromInline static immutable `setSelectionRange`: JSString = "setSelectionRange"
    @usableFromInline static immutable `setStart`: JSString = "setStart"
    @usableFromInline static immutable `setStartAfter`: JSString = "setStartAfter"
    @usableFromInline static immutable `setStartBefore`: JSString = "setStartBefore"
    @usableFromInline static immutable `setTimeout`: JSString = "setTimeout"
    @usableFromInline static immutable `setTransform`: JSString = "setTransform"
    @usableFromInline static immutable `setValidity`: JSString = "setValidity"
    @usableFromInline static immutable `shadowBlur`: JSString = "shadowBlur"
    @usableFromInline static immutable `shadowColor`: JSString = "shadowColor"
    @usableFromInline static immutable `shadowOffsetX`: JSString = "shadowOffsetX"
    @usableFromInline static immutable `shadowOffsetY`: JSString = "shadowOffsetY"
    @usableFromInline static immutable `shadowRoot`: JSString = "shadowRoot"
    @usableFromInline static immutable `shadowRootClonable`: JSString = "shadowRootClonable"
    @usableFromInline static immutable `shadowRootDelegatesFocus`: JSString = "shadowRootDelegatesFocus"
    @usableFromInline static immutable `shadowRootMode`: JSString = "shadowRootMode"
    @usableFromInline static immutable `shadowRootSerializable`: JSString = "shadowRootSerializable"
    @usableFromInline static immutable `shadowRoots`: JSString = "shadowRoots"
    @usableFromInline static immutable `shape`: JSString = "shape"
    @usableFromInline static immutable `shiftKey`: JSString = "shiftKey"
    @usableFromInline static immutable `show`: JSString = "show"
    @usableFromInline static immutable `showModal`: JSString = "showModal"
    @usableFromInline static immutable `showPicker`: JSString = "showPicker"
    @usableFromInline static immutable `showPopover`: JSString = "showPopover"
    @usableFromInline static immutable `signal`: JSString = "signal"
    @usableFromInline static immutable `singleNodeValue`: JSString = "singleNodeValue"
    @usableFromInline static immutable `size`: JSString = "size"
    @usableFromInline static immutable `sizes`: JSString = "sizes"
    @usableFromInline static immutable `skewX`: JSString = "skewX"
    @usableFromInline static immutable `skewXSelf`: JSString = "skewXSelf"
    @usableFromInline static immutable `skewY`: JSString = "skewY"
    @usableFromInline static immutable `skewYSelf`: JSString = "skewYSelf"
    @usableFromInline static immutable `skipTransition`: JSString = "skipTransition"
    @usableFromInline static immutable `slice`: JSString = "slice"
    @usableFromInline static immutable `slot`: JSString = "slot"
    @usableFromInline static immutable `slotAssignment`: JSString = "slotAssignment"
    @usableFromInline static immutable `snapshotItem`: JSString = "snapshotItem"
    @usableFromInline static immutable `snapshotLength`: JSString = "snapshotLength"
    @usableFromInline static immutable `source`: JSString = "source"
    @usableFromInline static immutable `sourceBuffer`: JSString = "sourceBuffer"
    @usableFromInline static immutable `sourceBuffers`: JSString = "sourceBuffers"
    @usableFromInline static immutable `sourceElement`: JSString = "sourceElement"
    @usableFromInline static immutable `span`: JSString = "span"
    @usableFromInline static immutable `specified`: JSString = "specified"
    @usableFromInline static immutable `spellcheck`: JSString = "spellcheck"
    @usableFromInline static immutable `splitText`: JSString = "splitText"
    @usableFromInline static immutable `src`: JSString = "src"
    @usableFromInline static immutable `srcElement`: JSString = "srcElement"
    @usableFromInline static immutable `srcObject`: JSString = "srcObject"
    @usableFromInline static immutable `srcdoc`: JSString = "srcdoc"
    @usableFromInline static immutable `srclang`: JSString = "srclang"
    @usableFromInline static immutable `srcset`: JSString = "srcset"
    @usableFromInline static immutable `standby`: JSString = "standby"
    @usableFromInline static immutable `start`: JSString = "start"
    @usableFromInline static immutable `startContainer`: JSString = "startContainer"
    @usableFromInline static immutable `startMessages`: JSString = "startMessages"
    @usableFromInline static immutable `startOffset`: JSString = "startOffset"
    @usableFromInline static immutable `startTime`: JSString = "startTime"
    @usableFromInline static immutable `state`: JSString = "state"
    @usableFromInline static immutable `states`: JSString = "states"
    @usableFromInline static immutable `status`: JSString = "status"
    @usableFromInline static immutable `statusText`: JSString = "statusText"
    @usableFromInline static immutable `statusbar`: JSString = "statusbar"
    @usableFromInline static immutable `step`: JSString = "step"
    @usableFromInline static immutable `stepDown`: JSString = "stepDown"
    @usableFromInline static immutable `stepMismatch`: JSString = "stepMismatch"
    @usableFromInline static immutable `stepUp`: JSString = "stepUp"
    @usableFromInline static immutable `stop`: JSString = "stop"
    @usableFromInline static immutable `stopImmediatePropagation`: JSString = "stopImmediatePropagation"
    @usableFromInline static immutable `stopPropagation`: JSString = "stopPropagation"
    @usableFromInline static immutable `storageArea`: JSString = "storageArea"
    @usableFromInline static immutable `stream`: JSString = "stream"
    @usableFromInline static immutable `streaming`: JSString = "streaming"
    @usableFromInline static immutable `stride`: JSString = "stride"
    @usableFromInline static immutable `stringValue`: JSString = "stringValue"
    @usableFromInline static immutable `stroke`: JSString = "stroke"
    @usableFromInline static immutable `strokeRect`: JSString = "strokeRect"
    @usableFromInline static immutable `strokeStyle`: JSString = "strokeStyle"
    @usableFromInline static immutable `strokeText`: JSString = "strokeText"
    @usableFromInline static immutable `structuredClone`: JSString = "structuredClone"
    @usableFromInline static immutable `submit`: JSString = "submit"
    @usableFromInline static immutable `submitter`: JSString = "submitter"
    @usableFromInline static immutable `substringData`: JSString = "substringData"
    @usableFromInline static immutable `subtree`: JSString = "subtree"
    @usableFromInline static immutable `suffixes`: JSString = "suffixes"
    @usableFromInline static immutable `summary`: JSString = "summary"
    @usableFromInline static immutable `supported`: JSString = "supported"
    @usableFromInline static immutable `supportedEntryTypes`: JSString = "supportedEntryTypes"
    @usableFromInline static immutable `supports`: JSString = "supports"
    @usableFromInline static immutable `surroundContents`: JSString = "surroundContents"
    @usableFromInline static immutable `svc`: JSString = "svc"
    @usableFromInline static immutable `systemId`: JSString = "systemId"
    @usableFromInline static immutable `tBodies`: JSString = "tBodies"
    @usableFromInline static immutable `tFoot`: JSString = "tFoot"
    @usableFromInline static immutable `tHead`: JSString = "tHead"
    @usableFromInline static immutable `tabIndex`: JSString = "tabIndex"
    @usableFromInline static immutable `tagName`: JSString = "tagName"
    @usableFromInline static immutable `taintEnabled`: JSString = "taintEnabled"
    @usableFromInline static immutable `takeRecords`: JSString = "takeRecords"
    @usableFromInline static immutable `target`: JSString = "target"
    @usableFromInline static immutable `targetOrigin`: JSString = "targetOrigin"
    @usableFromInline static immutable `targetTouches`: JSString = "targetTouches"
    @usableFromInline static immutable `tee`: JSString = "tee"
    @usableFromInline static immutable `temporalLayerId`: JSString = "temporalLayerId"
    @usableFromInline static immutable `terminate`: JSString = "terminate"
    @usableFromInline static immutable `test`: JSString = "test"
    @usableFromInline static immutable `text`: JSString = "text"
    @usableFromInline static immutable `textAlign`: JSString = "textAlign"
    @usableFromInline static immutable `textBaseline`: JSString = "textBaseline"
    @usableFromInline static immutable `textContent`: JSString = "textContent"
    @usableFromInline static immutable `textLength`: JSString = "textLength"
    @usableFromInline static immutable `textRendering`: JSString = "textRendering"
    @usableFromInline static immutable `textTracks`: JSString = "textTracks"
    @usableFromInline static immutable `throwIfAborted`: JSString = "throwIfAborted"
    @usableFromInline static immutable `timeOrigin`: JSString = "timeOrigin"
    @usableFromInline static immutable `timeStamp`: JSString = "timeStamp"
    @usableFromInline static immutable `timecode`: JSString = "timecode"
    @usableFromInline static immutable `timeout`: JSString = "timeout"
    @usableFromInline static immutable `timestamp`: JSString = "timestamp"
    @usableFromInline static immutable `timestampOffset`: JSString = "timestampOffset"
    @usableFromInline static immutable `title`: JSString = "title"
    @usableFromInline static immutable `toBlob`: JSString = "toBlob"
    @usableFromInline static immutable `toBox`: JSString = "toBox"
    @usableFromInline static immutable `toDataURL`: JSString = "toDataURL"
    @usableFromInline static immutable `toFloat32Array`: JSString = "toFloat32Array"
    @usableFromInline static immutable `toFloat64Array`: JSString = "toFloat64Array"
    @usableFromInline static immutable `toJSON`: JSString = "toJSON"
    @usableFromInline static immutable `toString`: JSString = "toString"
    @usableFromInline static immutable `toggle`: JSString = "toggle"
    @usableFromInline static immutable `toggleAttribute`: JSString = "toggleAttribute"
    @usableFromInline static immutable `togglePopover`: JSString = "togglePopover"
    @usableFromInline static immutable `tooLong`: JSString = "tooLong"
    @usableFromInline static immutable `tooShort`: JSString = "tooShort"
    @usableFromInline static immutable `toolbar`: JSString = "toolbar"
    @usableFromInline static immutable `top`: JSString = "top"
    @usableFromInline static immutable `total`: JSString = "total"
    @usableFromInline static immutable `touchType`: JSString = "touchType"
    @usableFromInline static immutable `touches`: JSString = "touches"
    @usableFromInline static immutable `track`: JSString = "track"
    @usableFromInline static immutable `tracks`: JSString = "tracks"
    @usableFromInline static immutable `transfer`: JSString = "transfer"
    @usableFromInline static immutable `transferControlToOffscreen`: JSString = "transferControlToOffscreen"
    @usableFromInline static immutable `transferFromImageBitmap`: JSString = "transferFromImageBitmap"
    @usableFromInline static immutable `transferToImageBitmap`: JSString = "transferToImageBitmap"
    @usableFromInline static immutable `transform`: JSString = "transform"
    @usableFromInline static immutable `transformPoint`: JSString = "transformPoint"
    @usableFromInline static immutable `transformToDocument`: JSString = "transformToDocument"
    @usableFromInline static immutable `transformToFragment`: JSString = "transformToFragment"
    @usableFromInline static immutable `transition`: JSString = "transition"
    @usableFromInline static immutable `translate`: JSString = "translate"
    @usableFromInline static immutable `translateSelf`: JSString = "translateSelf"
    @usableFromInline static immutable `traverseTo`: JSString = "traverseTo"
    @usableFromInline static immutable `trueSpeed`: JSString = "trueSpeed"
    @usableFromInline static immutable `trustedTypes`: JSString = "trustedTypes"
    @usableFromInline static immutable `type`: JSString = "type"
    @usableFromInline static immutable `typeMismatch`: JSString = "typeMismatch"
    @usableFromInline static immutable `types`: JSString = "types"
    @usableFromInline static immutable `unregister`: JSString = "unregister"
    @usableFromInline static immutable `unregisterProtocolHandler`: JSString = "unregisterProtocolHandler"
    @usableFromInline static immutable `update`: JSString = "update"
    @usableFromInline static immutable `updateCallbackDone`: JSString = "updateCallbackDone"
    @usableFromInline static immutable `updateCurrentEntry`: JSString = "updateCurrentEntry"
    @usableFromInline static immutable `updateViaCache`: JSString = "updateViaCache"
    @usableFromInline static immutable `updating`: JSString = "updating"
    @usableFromInline static immutable `upgrade`: JSString = "upgrade"
    @usableFromInline static immutable `upload`: JSString = "upload"
    @usableFromInline static immutable `url`: JSString = "url"
    @usableFromInline static immutable `urlPattern`: JSString = "urlPattern"
    @usableFromInline static immutable `useMap`: JSString = "useMap"
    @usableFromInline static immutable `userActivation`: JSString = "userActivation"
    @usableFromInline static immutable `userAgent`: JSString = "userAgent"
    @usableFromInline static immutable `userInitiated`: JSString = "userInitiated"
    @usableFromInline static immutable `userInsertedDevices`: JSString = "userInsertedDevices"
    @usableFromInline static immutable `username`: JSString = "username"
    @usableFromInline static immutable `vAlign`: JSString = "vAlign"
    @usableFromInline static immutable `vLink`: JSString = "vLink"
    @usableFromInline static immutable `valid`: JSString = "valid"
    @usableFromInline static immutable `validationMessage`: JSString = "validationMessage"
    @usableFromInline static immutable `validity`: JSString = "validity"
    @usableFromInline static immutable `value`: JSString = "value"
    @usableFromInline static immutable `valueAsDate`: JSString = "valueAsDate"
    @usableFromInline static immutable `valueAsNumber`: JSString = "valueAsNumber"
    @usableFromInline static immutable `valueMissing`: JSString = "valueMissing"
    @usableFromInline static immutable `valueType`: JSString = "valueType"
    @usableFromInline static immutable `vendor`: JSString = "vendor"
    @usableFromInline static immutable `vendorSub`: JSString = "vendorSub"
    @usableFromInline static immutable `version`: JSString = "version"
    @usableFromInline static immutable `video`: JSString = "video"
    @usableFromInline static immutable `videoBitsPerSecond`: JSString = "videoBitsPerSecond"
    @usableFromInline static immutable `videoHeight`: JSString = "videoHeight"
    @usableFromInline static immutable `videoKeyFrameIntervalCount`: JSString = "videoKeyFrameIntervalCount"
    @usableFromInline static immutable `videoKeyFrameIntervalDuration`: JSString = "videoKeyFrameIntervalDuration"
    @usableFromInline static immutable `videoTracks`: JSString = "videoTracks"
    @usableFromInline static immutable `videoWidth`: JSString = "videoWidth"
    @usableFromInline static immutable `view`: JSString = "view"
    @usableFromInline static immutable `viewTransition`: JSString = "viewTransition"
    @usableFromInline static immutable `visibilityProperty`: JSString = "visibilityProperty"
    @usableFromInline static immutable `visibilityState`: JSString = "visibilityState"
    @usableFromInline static immutable `visible`: JSString = "visible"
    @usableFromInline static immutable `visibleRect`: JSString = "visibleRect"
    @usableFromInline static immutable `visualViewport`: JSString = "visualViewport"
    @usableFromInline static immutable `vlinkColor`: JSString = "vlinkColor"
    @usableFromInline static immutable `volume`: JSString = "volume"
    @usableFromInline static immutable `vspace`: JSString = "vspace"
    @usableFromInline static immutable `w`: JSString = "w"
    @usableFromInline static immutable `waiting`: JSString = "waiting"
    @usableFromInline static immutable `webkitMatchesSelector`: JSString = "webkitMatchesSelector"
    @usableFromInline static immutable `whatToShow`: JSString = "whatToShow"
    @usableFromInline static immutable `whenDefined`: JSString = "whenDefined"
    @usableFromInline static immutable `which`: JSString = "which"
    @usableFromInline static immutable `wholeText`: JSString = "wholeText"
    @usableFromInline static immutable `width`: JSString = "width"
    @usableFromInline static immutable `willReadFrequently`: JSString = "willReadFrequently"
    @usableFromInline static immutable `willValidate`: JSString = "willValidate"
    @usableFromInline static immutable `window`: JSString = "window"
    @usableFromInline static immutable `withCredentials`: JSString = "withCredentials"
    @usableFromInline static immutable `wordSpacing`: JSString = "wordSpacing"
    @usableFromInline static immutable `wrap`: JSString = "wrap"
    @usableFromInline static immutable `writable`: JSString = "writable"
    @usableFromInline static immutable `writableType`: JSString = "writableType"
    @usableFromInline static immutable `write`: JSString = "write"
    @usableFromInline static immutable `writeln`: JSString = "writeln"
    @usableFromInline static immutable `writingSuggestions`: JSString = "writingSuggestions"
    @usableFromInline static immutable `x`: JSString = "x"
    @usableFromInline static immutable `y`: JSString = "y"
    @usableFromInline static immutable `z`: JSString = "z"
}
public protocol Any_AddEventListenerOptions_or_Bool: ConvertibleToJSValue {}
extension AddEventListenerOptions: Any_AddEventListenerOptions_or_Bool {}
extension Boolean: Any_AddEventListenerOptions_or_Bool {}

public enum AddEventListenerOptions_or_Bool: JSValueCompatible, Any_AddEventListenerOptions_or_Bool {
    case addEventListenerOptions(AddEventListenerOptions)
    case bool(Boolean)

    public init(_ addEventListenerOptions: AddEventListenerOptions) {
        immutable val: AddEventListenerOptions_or_Bool = .addEventListenerOptions(addEventListenerOptions)
        this = val
    }
    public init(_ bool: Boolean) {
        immutable val: AddEventListenerOptions_or_Bool = .bool(bool)
        this = val
    }

    public var addEventListenerOptions: AddEventListenerOptions? {
        switch this {
        case immutable .addEventListenerOptions(addEventListenerOptions): return addEventListenerOptions
        default: return Nothing
        }
    }
    public var bool: Boolean? {
        switch this {
        case immutable .bool(bool): return bool
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable addEventListenerOptions: AddEventListenerOptions = value.fromJSValue() {
            return .addEventListenerOptions(addEventListenerOptions)
        }
        if immutable bool: Boolean = value.fromJSValue() { return .bool(bool) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .addEventListenerOptions(addEventListenerOptions): return addEventListenerOptions.jsValue
        case immutable .bool(bool): return bool.jsValue
        }
    }
}
public protocol Any_ArrayBuffer_or_String: ConvertibleToJSValue {}
extension ArrayBuffer: Any_ArrayBuffer_or_String {}
extension String: Any_ArrayBuffer_or_String {}

public enum ArrayBuffer_or_String: JSValueCompatible, Any_ArrayBuffer_or_String {
    case arrayBuffer(ArrayBuffer)
    case string(String)

    public init(_ arrayBuffer: ArrayBuffer) {
        immutable val: ArrayBuffer_or_String = .arrayBuffer(arrayBuffer)
        this = val
    }
    public init(_ string: String) {
        immutable val: ArrayBuffer_or_String = .string(string)
        this = val
    }

    public var arrayBuffer: ArrayBuffer? {
        switch this {
        case immutable .arrayBuffer(arrayBuffer): return arrayBuffer
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable arrayBuffer: ArrayBuffer = value.fromJSValue() { return .arrayBuffer(arrayBuffer) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .arrayBuffer(arrayBuffer): return arrayBuffer.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_AudioTrack_or_TextTrack_or_VideoTrack: ConvertibleToJSValue {}
extension AudioTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension TextTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}
extension VideoTrack: Any_AudioTrack_or_TextTrack_or_VideoTrack {}

public enum AudioTrack_or_TextTrack_or_VideoTrack: JSValueCompatible, Any_AudioTrack_or_TextTrack_or_VideoTrack {
    case audioTrack(AudioTrack)
    case textTrack(TextTrack)
    case videoTrack(VideoTrack)

    public init(_ audioTrack: AudioTrack) {
        immutable val: AudioTrack_or_TextTrack_or_VideoTrack = .audioTrack(audioTrack)
        this = val
    }
    public init(_ textTrack: TextTrack) {
        immutable val: AudioTrack_or_TextTrack_or_VideoTrack = .textTrack(textTrack)
        this = val
    }
    public init(_ videoTrack: VideoTrack) {
        immutable val: AudioTrack_or_TextTrack_or_VideoTrack = .videoTrack(videoTrack)
        this = val
    }

    public var audioTrack: AudioTrack? {
        switch this {
        case immutable .audioTrack(audioTrack): return audioTrack
        default: return Nothing
        }
    }
    public var textTrack: TextTrack? {
        switch this {
        case immutable .textTrack(textTrack): return textTrack
        default: return Nothing
        }
    }
    public var videoTrack: VideoTrack? {
        switch this {
        case immutable .videoTrack(videoTrack): return videoTrack
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable audioTrack: AudioTrack = value.fromJSValue() { return .audioTrack(audioTrack) }
        if immutable textTrack: TextTrack = value.fromJSValue() { return .textTrack(textTrack) }
        if immutable videoTrack: VideoTrack = value.fromJSValue() { return .videoTrack(videoTrack) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .audioTrack(audioTrack): return audioTrack.jsValue
        case immutable .textTrack(textTrack): return textTrack.jsValue
        case immutable .videoTrack(videoTrack): return videoTrack.jsValue
        }
    }
}
public protocol Any_BlobPart: ConvertibleToJSValue {}
extension Blob: Any_BlobPart {}
extension BufferSource: Any_BlobPart {}
extension String: Any_BlobPart {}

public enum BlobPart: JSValueCompatible, Any_BlobPart {
    case blob(Blob)
    case bufferSource(BufferSource)
    case string(String)

    public init(_ blob: Blob) {
        immutable val: BlobPart = .blob(blob)
        this = val
    }
    public init(_ bufferSource: BufferSource) {
        immutable val: BlobPart = .bufferSource(bufferSource)
        this = val
    }
    public init(_ arrayBuffer: ArrayBuffer) {
        immutable val: BufferSource = .arrayBuffer(arrayBuffer)
        this = .init(val)
    }
    public init(_ arrayBufferView: ArrayBufferView) {
        immutable val: BufferSource = .arrayBufferView(arrayBufferView)
        this = .init(val)
    }
    public init(_ string: String) {
        immutable val: BlobPart = .string(string)
        this = val
    }

    public var blob: Blob? {
        switch this {
        case immutable .blob(blob): return blob
        default: return Nothing
        }
    }
    public var bufferSource: BufferSource? {
        switch this {
        case immutable .bufferSource(bufferSource): return bufferSource
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable blob: Blob = value.fromJSValue() { return .blob(blob) }
        if immutable bufferSource: BufferSource = value.fromJSValue() { return .bufferSource(bufferSource) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .blob(blob): return blob.jsValue
        case immutable .bufferSource(bufferSource): return bufferSource.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_Bool_or_Double_or_String: ConvertibleToJSValue {}
extension Boolean: Any_Bool_or_Double_or_String {}
extension Double: Any_Bool_or_Double_or_String {}
extension String: Any_Bool_or_Double_or_String {}

public enum Bool_or_Double_or_String: JSValueCompatible, Any_Bool_or_Double_or_String {
    case bool(Boolean)
    case double(Double)
    case string(String)

    public init(_ bool: Boolean) {
        immutable val: Bool_or_Double_or_String = .bool(bool)
        this = val
    }
    public init(_ double: Double) {
        immutable val: Bool_or_Double_or_String = .double(double)
        this = val
    }
    public init(_ string: String) {
        immutable val: Bool_or_Double_or_String = .string(string)
        this = val
    }

    public var bool: Boolean? {
        switch this {
        case immutable .bool(bool): return bool
        default: return Nothing
        }
    }
    public var double: Double? {
        switch this {
        case immutable .double(double): return double
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable bool: Boolean = value.fromJSValue() { return .bool(bool) }
        if immutable double: Double = value.fromJSValue() { return .double(double) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .bool(bool): return bool.jsValue
        case immutable .double(double): return double.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_Bool_or_EventListenerOptions: ConvertibleToJSValue {}
extension Boolean: Any_Bool_or_EventListenerOptions {}
extension EventListenerOptions: Any_Bool_or_EventListenerOptions {}

public enum Bool_or_EventListenerOptions: JSValueCompatible, Any_Bool_or_EventListenerOptions {
    case bool(Boolean)
    case eventListenerOptions(EventListenerOptions)

    public init(_ bool: Boolean) {
        immutable val: Bool_or_EventListenerOptions = .bool(bool)
        this = val
    }
    public init(_ eventListenerOptions: EventListenerOptions) {
        immutable val: Bool_or_EventListenerOptions = .eventListenerOptions(eventListenerOptions)
        this = val
    }

    public var bool: Boolean? {
        switch this {
        case immutable .bool(bool): return bool
        default: return Nothing
        }
    }
    public var eventListenerOptions: EventListenerOptions? {
        switch this {
        case immutable .eventListenerOptions(eventListenerOptions): return eventListenerOptions
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable bool: Boolean = value.fromJSValue() { return .bool(bool) }
        if immutable eventListenerOptions: EventListenerOptions = value.fromJSValue() {
            return .eventListenerOptions(eventListenerOptions)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .bool(bool): return bool.jsValue
        case immutable .eventListenerOptions(eventListenerOptions): return eventListenerOptions.jsValue
        }
    }
}
public protocol Any_Bool_or_MediaTrackConstraints: ConvertibleToJSValue {}
extension Boolean: Any_Bool_or_MediaTrackConstraints {}
extension MediaTrackConstraints: Any_Bool_or_MediaTrackConstraints {}

public enum Bool_or_MediaTrackConstraints: JSValueCompatible, Any_Bool_or_MediaTrackConstraints {
    case bool(Boolean)
    case mediaTrackConstraints(MediaTrackConstraints)

    public init(_ bool: Boolean) {
        immutable val: Bool_or_MediaTrackConstraints = .bool(bool)
        this = val
    }
    public init(_ mediaTrackConstraints: MediaTrackConstraints) {
        immutable val: Bool_or_MediaTrackConstraints = .mediaTrackConstraints(mediaTrackConstraints)
        this = val
    }

    public var bool: Boolean? {
        switch this {
        case immutable .bool(bool): return bool
        default: return Nothing
        }
    }
    public var mediaTrackConstraints: MediaTrackConstraints? {
        switch this {
        case immutable .mediaTrackConstraints(mediaTrackConstraints): return mediaTrackConstraints
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable bool: Boolean = value.fromJSValue() { return .bool(bool) }
        if immutable mediaTrackConstraints: MediaTrackConstraints = value.fromJSValue() {
            return .mediaTrackConstraints(mediaTrackConstraints)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .bool(bool): return bool.jsValue
        case immutable .mediaTrackConstraints(mediaTrackConstraints): return mediaTrackConstraints.jsValue
        }
    }
}
public protocol Any_Bool_or_ScrollIntoViewOptions: ConvertibleToJSValue {}
extension Boolean: Any_Bool_or_ScrollIntoViewOptions {}
extension ScrollIntoViewOptions: Any_Bool_or_ScrollIntoViewOptions {}

public enum Bool_or_ScrollIntoViewOptions: JSValueCompatible, Any_Bool_or_ScrollIntoViewOptions {
    case bool(Boolean)
    case scrollIntoViewOptions(ScrollIntoViewOptions)

    public init(_ bool: Boolean) {
        immutable val: Bool_or_ScrollIntoViewOptions = .bool(bool)
        this = val
    }
    public init(_ scrollIntoViewOptions: ScrollIntoViewOptions) {
        immutable val: Bool_or_ScrollIntoViewOptions = .scrollIntoViewOptions(scrollIntoViewOptions)
        this = val
    }

    public var bool: Boolean? {
        switch this {
        case immutable .bool(bool): return bool
        default: return Nothing
        }
    }
    public var scrollIntoViewOptions: ScrollIntoViewOptions? {
        switch this {
        case immutable .scrollIntoViewOptions(scrollIntoViewOptions): return scrollIntoViewOptions
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable bool: Boolean = value.fromJSValue() { return .bool(bool) }
        if immutable scrollIntoViewOptions: ScrollIntoViewOptions = value.fromJSValue() {
            return .scrollIntoViewOptions(scrollIntoViewOptions)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .bool(bool): return bool.jsValue
        case immutable .scrollIntoViewOptions(scrollIntoViewOptions): return scrollIntoViewOptions.jsValue
        }
    }
}
public protocol Any_Bool_or_TogglePopoverOptions: ConvertibleToJSValue {}
extension Boolean: Any_Bool_or_TogglePopoverOptions {}
extension TogglePopoverOptions: Any_Bool_or_TogglePopoverOptions {}

public enum Bool_or_TogglePopoverOptions: JSValueCompatible, Any_Bool_or_TogglePopoverOptions {
    case bool(Boolean)
    case togglePopoverOptions(TogglePopoverOptions)

    public init(_ bool: Boolean) {
        immutable val: Bool_or_TogglePopoverOptions = .bool(bool)
        this = val
    }
    public init(_ togglePopoverOptions: TogglePopoverOptions) {
        immutable val: Bool_or_TogglePopoverOptions = .togglePopoverOptions(togglePopoverOptions)
        this = val
    }

    public var bool: Boolean? {
        switch this {
        case immutable .bool(bool): return bool
        default: return Nothing
        }
    }
    public var togglePopoverOptions: TogglePopoverOptions? {
        switch this {
        case immutable .togglePopoverOptions(togglePopoverOptions): return togglePopoverOptions
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable bool: Boolean = value.fromJSValue() { return .bool(bool) }
        if immutable togglePopoverOptions: TogglePopoverOptions = value.fromJSValue() {
            return .togglePopoverOptions(togglePopoverOptions)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .bool(bool): return bool.jsValue
        case immutable .togglePopoverOptions(togglePopoverOptions): return togglePopoverOptions.jsValue
        }
    }
}
public protocol Any_CSSPseudoElement_or_Element: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_CSSPseudoElement_or_Element {}
extension Element: Any_CSSPseudoElement_or_Element {}

public enum CSSPseudoElement_or_Element: JSValueCompatible, Any_CSSPseudoElement_or_Element {
    case cssPseudoElement(CSSPseudoElement)
    case element(Element)

    public init(_ cssPseudoElement: CSSPseudoElement) {
        immutable val: CSSPseudoElement_or_Element = .cssPseudoElement(cssPseudoElement)
        this = val
    }
    public init(_ element: Element) {
        immutable val: CSSPseudoElement_or_Element = .element(element)
        this = val
    }

    public var cssPseudoElement: CSSPseudoElement? {
        switch this {
        case immutable .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return Nothing
        }
    }
    public var element: Element? {
        switch this {
        case immutable .element(element): return element
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable cssPseudoElement: CSSPseudoElement = value.fromJSValue() { return .cssPseudoElement(cssPseudoElement) }
        if immutable element: Element = value.fromJSValue() { return .element(element) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .cssPseudoElement(cssPseudoElement): return cssPseudoElement.jsValue
        case immutable .element(element): return element.jsValue
        }
    }
}
public protocol Any_CanvasGradient_or_CanvasPattern_or_String: ConvertibleToJSValue {}
extension CanvasGradient: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension CanvasPattern: Any_CanvasGradient_or_CanvasPattern_or_String {}
extension String: Any_CanvasGradient_or_CanvasPattern_or_String {}

public enum CanvasGradient_or_CanvasPattern_or_String: JSValueCompatible, Any_CanvasGradient_or_CanvasPattern_or_String
{
    case canvasGradient(CanvasGradient)
    case canvasPattern(CanvasPattern)
    case string(String)

    public init(_ canvasGradient: CanvasGradient) {
        immutable val: CanvasGradient_or_CanvasPattern_or_String = .canvasGradient(canvasGradient)
        this = val
    }
    public init(_ canvasPattern: CanvasPattern) {
        immutable val: CanvasGradient_or_CanvasPattern_or_String = .canvasPattern(canvasPattern)
        this = val
    }
    public init(_ string: String) {
        immutable val: CanvasGradient_or_CanvasPattern_or_String = .string(string)
        this = val
    }

    public var canvasGradient: CanvasGradient? {
        switch this {
        case immutable .canvasGradient(canvasGradient): return canvasGradient
        default: return Nothing
        }
    }
    public var canvasPattern: CanvasPattern? {
        switch this {
        case immutable .canvasPattern(canvasPattern): return canvasPattern
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable canvasGradient: CanvasGradient = value.fromJSValue() { return .canvasGradient(canvasGradient) }
        if immutable canvasPattern: CanvasPattern = value.fromJSValue() { return .canvasPattern(canvasPattern) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .canvasGradient(canvasGradient): return canvasGradient.jsValue
        case immutable .canvasPattern(canvasPattern): return canvasPattern.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_CanvasImageSource: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_CanvasImageSource {}
extension HTMLOrSVGImageElement: Any_CanvasImageSource {}
extension HTMLVideoElement: Any_CanvasImageSource {}
extension ImageBitmap: Any_CanvasImageSource {}
extension OffscreenCanvas: Any_CanvasImageSource {}
extension VideoFrame: Any_CanvasImageSource {}

public enum CanvasImageSource: JSValueCompatible, Any_CanvasImageSource {
    case htmlCanvasElement(HTMLCanvasElement)
    case htmlOrSVGImageElement(HTMLOrSVGImageElement)
    case htmlVideoElement(HTMLVideoElement)
    case imageBitmap(ImageBitmap)
    case offscreenCanvas(OffscreenCanvas)
    case videoFrame(VideoFrame)

    public init(_ htmlCanvasElement: HTMLCanvasElement) {
        immutable val: CanvasImageSource = .htmlCanvasElement(htmlCanvasElement)
        this = val
    }
    public init(_ htmlOrSVGImageElement: HTMLOrSVGImageElement) {
        immutable val: CanvasImageSource = .htmlOrSVGImageElement(htmlOrSVGImageElement)
        this = val
    }
    public init(_ htmlVideoElement: HTMLVideoElement) {
        immutable val: CanvasImageSource = .htmlVideoElement(htmlVideoElement)
        this = val
    }
    public init(_ imageBitmap: ImageBitmap) {
        immutable val: CanvasImageSource = .imageBitmap(imageBitmap)
        this = val
    }
    public init(_ offscreenCanvas: OffscreenCanvas) {
        immutable val: CanvasImageSource = .offscreenCanvas(offscreenCanvas)
        this = val
    }
    public init(_ videoFrame: VideoFrame) {
        immutable val: CanvasImageSource = .videoFrame(videoFrame)
        this = val
    }

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return Nothing
        }
    }
    public var htmlOrSVGImageElement: HTMLOrSVGImageElement? {
        switch this {
        case immutable .htmlOrSVGImageElement(htmlOrSVGImageElement): return htmlOrSVGImageElement
        default: return Nothing
        }
    }
    public var htmlVideoElement: HTMLVideoElement? {
        switch this {
        case immutable .htmlVideoElement(htmlVideoElement): return htmlVideoElement
        default: return Nothing
        }
    }
    public var imageBitmap: ImageBitmap? {
        switch this {
        case immutable .imageBitmap(imageBitmap): return imageBitmap
        default: return Nothing
        }
    }
    public var offscreenCanvas: OffscreenCanvas? {
        switch this {
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return Nothing
        }
    }
    public var videoFrame: VideoFrame? {
        switch this {
        case immutable .videoFrame(videoFrame): return videoFrame
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if immutable htmlOrSVGImageElement: HTMLOrSVGImageElement = value.fromJSValue() {
            return .htmlOrSVGImageElement(htmlOrSVGImageElement)
        }
        if immutable htmlVideoElement: HTMLVideoElement = value.fromJSValue() { return .htmlVideoElement(htmlVideoElement) }
        if immutable imageBitmap: ImageBitmap = value.fromJSValue() { return .imageBitmap(imageBitmap) }
        if immutable offscreenCanvas: OffscreenCanvas = value.fromJSValue() { return .offscreenCanvas(offscreenCanvas) }
        if immutable videoFrame: VideoFrame = value.fromJSValue() { return .videoFrame(videoFrame) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement.jsValue
        case immutable .htmlOrSVGImageElement(htmlOrSVGImageElement): return htmlOrSVGImageElement.jsValue
        case immutable .htmlVideoElement(htmlVideoElement): return htmlVideoElement.jsValue
        case immutable .imageBitmap(imageBitmap): return imageBitmap.jsValue
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas.jsValue
        case immutable .videoFrame(videoFrame): return videoFrame.jsValue
        }
    }
}
public protocol Any_ConstrainBoolean: ConvertibleToJSValue {}
extension Boolean: Any_ConstrainBoolean {}
extension ConstrainBooleanParameters: Any_ConstrainBoolean {}

public enum ConstrainBoolean: JSValueCompatible, Any_ConstrainBoolean {
    case bool(Boolean)
    case constrainBooleanParameters(ConstrainBooleanParameters)

    public init(_ bool: Boolean) {
        immutable val: ConstrainBoolean = .bool(bool)
        this = val
    }
    public init(_ constrainBooleanParameters: ConstrainBooleanParameters) {
        immutable val: ConstrainBoolean = .constrainBooleanParameters(constrainBooleanParameters)
        this = val
    }

    public var bool: Boolean? {
        switch this {
        case immutable .bool(bool): return bool
        default: return Nothing
        }
    }
    public var constrainBooleanParameters: ConstrainBooleanParameters? {
        switch this {
        case immutable .constrainBooleanParameters(constrainBooleanParameters): return constrainBooleanParameters
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable bool: Boolean = value.fromJSValue() { return .bool(bool) }
        if immutable constrainBooleanParameters: ConstrainBooleanParameters = value.fromJSValue() {
            return .constrainBooleanParameters(constrainBooleanParameters)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .bool(bool): return bool.jsValue
        case immutable .constrainBooleanParameters(constrainBooleanParameters): return constrainBooleanParameters.jsValue
        }
    }
}
public protocol Any_ConstrainDOMString: ConvertibleToJSValue {}
extension ConstrainDOMStringParameters: Any_ConstrainDOMString {}
extension String: Any_ConstrainDOMString {}
extension Array: Any_ConstrainDOMString where Element == String {}

public enum ConstrainDOMString: JSValueCompatible, Any_ConstrainDOMString {
    case constrainDOMStringParameters(ConstrainDOMStringParameters)
    case string(String)
    case seq_of_String([String])

    public init(_ constrainDOMStringParameters: ConstrainDOMStringParameters) {
        immutable val: ConstrainDOMString = .constrainDOMStringParameters(constrainDOMStringParameters)
        this = val
    }
    public init(_ string: String) {
        immutable val: ConstrainDOMString = .string(string)
        this = val
    }
    public init(_ seq_of_String: [String]) {
        immutable val: ConstrainDOMString = .seq_of_String(seq_of_String)
        this = val
    }

    public var constrainDOMStringParameters: ConstrainDOMStringParameters? {
        switch this {
        case immutable .constrainDOMStringParameters(constrainDOMStringParameters): return constrainDOMStringParameters
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var seq_of_String: [String]? {
        switch this {
        case immutable .seq_of_String(seq_of_String): return seq_of_String
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable constrainDOMStringParameters: ConstrainDOMStringParameters = value.fromJSValue() {
            return .constrainDOMStringParameters(constrainDOMStringParameters)
        }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable seq_of_String: [String] = value.fromJSValue() { return .seq_of_String(seq_of_String) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .constrainDOMStringParameters(constrainDOMStringParameters):
            return constrainDOMStringParameters.jsValue
        case immutable .string(string): return string.jsValue
        case immutable .seq_of_String(seq_of_String): return seq_of_String.jsValue
        }
    }
}
public protocol Any_ConstrainDouble: ConvertibleToJSValue {}
extension ConstrainDoubleRange: Any_ConstrainDouble {}
extension Double: Any_ConstrainDouble {}

public enum ConstrainDouble: JSValueCompatible, Any_ConstrainDouble {
    case constrainDoubleRange(ConstrainDoubleRange)
    case double(Double)

    public init(_ constrainDoubleRange: ConstrainDoubleRange) {
        immutable val: ConstrainDouble = .constrainDoubleRange(constrainDoubleRange)
        this = val
    }
    public init(_ double: Double) {
        immutable val: ConstrainDouble = .double(double)
        this = val
    }

    public var constrainDoubleRange: ConstrainDoubleRange? {
        switch this {
        case immutable .constrainDoubleRange(constrainDoubleRange): return constrainDoubleRange
        default: return Nothing
        }
    }
    public var double: Double? {
        switch this {
        case immutable .double(double): return double
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable constrainDoubleRange: ConstrainDoubleRange = value.fromJSValue() {
            return .constrainDoubleRange(constrainDoubleRange)
        }
        if immutable double: Double = value.fromJSValue() { return .double(double) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .constrainDoubleRange(constrainDoubleRange): return constrainDoubleRange.jsValue
        case immutable .double(double): return double.jsValue
        }
    }
}
public protocol Any_ConstrainULong: ConvertibleToJSValue {}
extension ConstrainULongRange: Any_ConstrainULong {}
extension UInt32: Any_ConstrainULong {}

public enum ConstrainULong: JSValueCompatible, Any_ConstrainULong {
    case constrainULongRange(ConstrainULongRange)
    case uInt32(UInt32)

    public init(_ constrainULongRange: ConstrainULongRange) {
        immutable val: ConstrainULong = .constrainULongRange(constrainULongRange)
        this = val
    }
    public init(_ uInt32: UInt32) {
        immutable val: ConstrainULong = .uInt32(uInt32)
        this = val
    }

    public var constrainULongRange: ConstrainULongRange? {
        switch this {
        case immutable .constrainULongRange(constrainULongRange): return constrainULongRange
        default: return Nothing
        }
    }
    public var uInt32: UInt32? {
        switch this {
        case immutable .uInt32(uInt32): return uInt32
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable constrainULongRange: ConstrainULongRange = value.fromJSValue() {
            return .constrainULongRange(constrainULongRange)
        }
        if immutable uInt32: UInt32 = value.fromJSValue() { return .uInt32(uInt32) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .constrainULongRange(constrainULongRange): return constrainULongRange.jsValue
        case immutable .uInt32(uInt32): return uInt32.jsValue
        }
    }
}
public protocol Any_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double: JSValueCompatible, Any_DOMPointInit_or_Double {
    case domPointInit(DOMPointInit)
    case double(Double)

    public init(_ domPointInit: DOMPointInit) {
        immutable val: DOMPointInit_or_Double = .domPointInit(domPointInit)
        this = val
    }
    public init(_ double: Double) {
        immutable val: DOMPointInit_or_Double = .double(double)
        this = val
    }

    public var domPointInit: DOMPointInit? {
        switch this {
        case immutable .domPointInit(domPointInit): return domPointInit
        default: return Nothing
        }
    }
    public var double: Double? {
        switch this {
        case immutable .double(double): return double
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable domPointInit: DOMPointInit = value.fromJSValue() { return .domPointInit(domPointInit) }
        if immutable double: Double = value.fromJSValue() { return .double(double) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .domPointInit(domPointInit): return domPointInit.jsValue
        case immutable .double(double): return double.jsValue
        }
    }
}
public protocol Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: ConvertibleToJSValue {}
extension DOMPointInit: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Double: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double {}
extension Array: Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double where Element == DOMPointInit_or_Double {}

public enum DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double: JSValueCompatible,
    Any_DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double
{
    case domPointInit(DOMPointInit)
    case double(Double)
    case seq_of_DOMPointInit_or_Double([DOMPointInit_or_Double])

    public init(_ domPointInit: DOMPointInit) {
        immutable val: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double = .domPointInit(domPointInit)
        this = val
    }
    public init(_ double: Double) {
        immutable val: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double = .double(double)
        this = val
    }
    public init(_ seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double]) {
        immutable val: DOMPointInit_or_Double_or_seq_of_DOMPointInit_or_Double = .seq_of_DOMPointInit_or_Double(
            seq_of_DOMPointInit_or_Double
        )
        this = val
    }

    public var domPointInit: DOMPointInit? {
        switch this {
        case immutable .domPointInit(domPointInit): return domPointInit
        default: return Nothing
        }
    }
    public var double: Double? {
        switch this {
        case immutable .double(double): return double
        default: return Nothing
        }
    }
    public var seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double]? {
        switch this {
        case immutable .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double): return seq_of_DOMPointInit_or_Double
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable domPointInit: DOMPointInit = value.fromJSValue() { return .domPointInit(domPointInit) }
        if immutable double: Double = value.fromJSValue() { return .double(double) }
        if immutable seq_of_DOMPointInit_or_Double: [DOMPointInit_or_Double] = value.fromJSValue() {
            return .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .domPointInit(domPointInit): return domPointInit.jsValue
        case immutable .double(double): return double.jsValue
        case immutable .seq_of_DOMPointInit_or_Double(seq_of_DOMPointInit_or_Double):
            return seq_of_DOMPointInit_or_Double.jsValue
        }
    }
}
public protocol Any_Document_or_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Document: Any_Document_or_XMLHttpRequestBodyInit {}
extension XMLHttpRequestBodyInit: Any_Document_or_XMLHttpRequestBodyInit {}

public enum Document_or_XMLHttpRequestBodyInit: JSValueCompatible, Any_Document_or_XMLHttpRequestBodyInit {
    case document(Document)
    case xmlHttpRequestBodyInit(XMLHttpRequestBodyInit)

    public init(_ document: Document) {
        immutable val: Document_or_XMLHttpRequestBodyInit = .document(document)
        this = val
    }
    public init(_ xmlHttpRequestBodyInit: XMLHttpRequestBodyInit) {
        immutable val: Document_or_XMLHttpRequestBodyInit = .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit)
        this = val
    }
    public init(_ blob: Blob) {
        immutable val: XMLHttpRequestBodyInit = .blob(blob)
        this = .init(val)
    }
    public init(_ bufferSource: BufferSource) {
        immutable val: XMLHttpRequestBodyInit = .bufferSource(bufferSource)
        this = .init(val)
    }
    public init(_ arrayBuffer: ArrayBuffer) {
        immutable val: BufferSource = .arrayBuffer(arrayBuffer)
        this = .init(val)
    }
    public init(_ arrayBufferView: ArrayBufferView) {
        immutable val: BufferSource = .arrayBufferView(arrayBufferView)
        this = .init(val)
    }
    public init(_ formData: FormData) {
        immutable val: XMLHttpRequestBodyInit = .formData(formData)
        this = .init(val)
    }
    public init(_ string: String) {
        immutable val: XMLHttpRequestBodyInit = .string(string)
        this = .init(val)
    }
    public init(_ urlSearchParams: URLSearchParams) {
        immutable val: XMLHttpRequestBodyInit = .urlSearchParams(urlSearchParams)
        this = .init(val)
    }

    public var document: Document? {
        switch this {
        case immutable .document(document): return document
        default: return Nothing
        }
    }
    public var xmlHttpRequestBodyInit: XMLHttpRequestBodyInit? {
        switch this {
        case immutable .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit): return xmlHttpRequestBodyInit
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable document: Document = value.fromJSValue() { return .document(document) }
        if immutable xmlHttpRequestBodyInit: XMLHttpRequestBodyInit = value.fromJSValue() {
            return .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .document(document): return document.jsValue
        case immutable .xmlHttpRequestBodyInit(xmlHttpRequestBodyInit): return xmlHttpRequestBodyInit.jsValue
        }
    }
}
public protocol Any_ElementCreationOptions_or_String: ConvertibleToJSValue {}
extension ElementCreationOptions: Any_ElementCreationOptions_or_String {}
extension String: Any_ElementCreationOptions_or_String {}

public enum ElementCreationOptions_or_String: JSValueCompatible, Any_ElementCreationOptions_or_String {
    case elementCreationOptions(ElementCreationOptions)
    case string(String)

    public init(_ elementCreationOptions: ElementCreationOptions) {
        immutable val: ElementCreationOptions_or_String = .elementCreationOptions(elementCreationOptions)
        this = val
    }
    public init(_ string: String) {
        immutable val: ElementCreationOptions_or_String = .string(string)
        this = val
    }

    public var elementCreationOptions: ElementCreationOptions? {
        switch this {
        case immutable .elementCreationOptions(elementCreationOptions): return elementCreationOptions
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable elementCreationOptions: ElementCreationOptions = value.fromJSValue() {
            return .elementCreationOptions(elementCreationOptions)
        }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .elementCreationOptions(elementCreationOptions): return elementCreationOptions.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_Element_or_HTMLCollection: ConvertibleToJSValue {}
extension Element: Any_Element_or_HTMLCollection {}
extension HTMLCollection: Any_Element_or_HTMLCollection {}

public enum Element_or_HTMLCollection: JSValueCompatible, Any_Element_or_HTMLCollection {
    case element(Element)
    case htmlCollection(HTMLCollection)

    public init(_ element: Element) {
        immutable val: Element_or_HTMLCollection = .element(element)
        this = val
    }
    public init(_ htmlCollection: HTMLCollection) {
        immutable val: Element_or_HTMLCollection = .htmlCollection(htmlCollection)
        this = val
    }

    public var element: Element? {
        switch this {
        case immutable .element(element): return element
        default: return Nothing
        }
    }
    public var htmlCollection: HTMLCollection? {
        switch this {
        case immutable .htmlCollection(htmlCollection): return htmlCollection
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable element: Element = value.fromJSValue() { return .element(element) }
        if immutable htmlCollection: HTMLCollection = value.fromJSValue() { return .htmlCollection(htmlCollection) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .element(element): return element.jsValue
        case immutable .htmlCollection(htmlCollection): return htmlCollection.jsValue
        }
    }
}
public protocol Any_Element_or_RadioNodeList: ConvertibleToJSValue {}
extension Element: Any_Element_or_RadioNodeList {}
extension RadioNodeList: Any_Element_or_RadioNodeList {}

public enum Element_or_RadioNodeList: JSValueCompatible, Any_Element_or_RadioNodeList {
    case element(Element)
    case radioNodeList(RadioNodeList)

    public init(_ element: Element) {
        immutable val: Element_or_RadioNodeList = .element(element)
        this = val
    }
    public init(_ radioNodeList: RadioNodeList) {
        immutable val: Element_or_RadioNodeList = .radioNodeList(radioNodeList)
        this = val
    }

    public var element: Element? {
        switch this {
        case immutable .element(element): return element
        default: return Nothing
        }
    }
    public var radioNodeList: RadioNodeList? {
        switch this {
        case immutable .radioNodeList(radioNodeList): return radioNodeList
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable element: Element = value.fromJSValue() { return .element(element) }
        if immutable radioNodeList: RadioNodeList = value.fromJSValue() { return .radioNodeList(radioNodeList) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .element(element): return element.jsValue
        case immutable .radioNodeList(radioNodeList): return radioNodeList.jsValue
        }
    }
}
public protocol Any_Element_or_Text: ConvertibleToJSValue {}
extension Element: Any_Element_or_Text {}
extension Text: Any_Element_or_Text {}

public enum Element_or_Text: JSValueCompatible, Any_Element_or_Text {
    case element(Element)
    case text(Text)

    public init(_ element: Element) {
        immutable val: Element_or_Text = .element(element)
        this = val
    }
    public init(_ text: Text) {
        immutable val: Element_or_Text = .text(text)
        this = val
    }

    public var element: Element? {
        switch this {
        case immutable .element(element): return element
        default: return Nothing
        }
    }
    public var text: Text? {
        switch this {
        case immutable .text(text): return text
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable element: Element = value.fromJSValue() { return .element(element) }
        if immutable text: Text = value.fromJSValue() { return .text(text) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .element(element): return element.jsValue
        case immutable .text(text): return text.jsValue
        }
    }
}
public protocol Any_Event_or_String: ConvertibleToJSValue {}
extension Event: Any_Event_or_String {}
extension String: Any_Event_or_String {}

public enum Event_or_String: JSValueCompatible, Any_Event_or_String {
    case event(Event)
    case string(String)

    public init(_ event: Event) {
        immutable val: Event_or_String = .event(event)
        this = val
    }
    public init(_ string: String) {
        immutable val: Event_or_String = .string(string)
        this = val
    }

    public var event: Event? {
        switch this {
        case immutable .event(event): return event
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable event: Event = value.fromJSValue() { return .event(event) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .event(event): return event.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_File_or_FormData_or_String: ConvertibleToJSValue {}
extension File: Any_File_or_FormData_or_String {}
extension FormData: Any_File_or_FormData_or_String {}
extension String: Any_File_or_FormData_or_String {}

public enum File_or_FormData_or_String: JSValueCompatible, Any_File_or_FormData_or_String {
    case file(File)
    case formData(FormData)
    case string(String)

    public init(_ file: File) {
        immutable val: File_or_FormData_or_String = .file(file)
        this = val
    }
    public init(_ formData: FormData) {
        immutable val: File_or_FormData_or_String = .formData(formData)
        this = val
    }
    public init(_ string: String) {
        immutable val: File_or_FormData_or_String = .string(string)
        this = val
    }

    public var file: File? {
        switch this {
        case immutable .file(file): return file
        default: return Nothing
        }
    }
    public var formData: FormData? {
        switch this {
        case immutable .formData(formData): return formData
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable file: File = value.fromJSValue() { return .file(file) }
        if immutable formData: FormData = value.fromJSValue() { return .formData(formData) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .file(file): return file.jsValue
        case immutable .formData(formData): return formData.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_FormDataEntryValue: ConvertibleToJSValue {}
extension File: Any_FormDataEntryValue {}
extension String: Any_FormDataEntryValue {}

public enum FormDataEntryValue: JSValueCompatible, Any_FormDataEntryValue {
    case file(File)
    case string(String)

    public init(_ file: File) {
        immutable val: FormDataEntryValue = .file(file)
        this = val
    }
    public init(_ string: String) {
        immutable val: FormDataEntryValue = .string(string)
        this = val
    }

    public var file: File? {
        switch this {
        case immutable .file(file): return file
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable file: File = value.fromJSValue() { return .file(file) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .file(file): return file.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_GeometryNode: ConvertibleToJSValue {}
extension CSSPseudoElement: Any_GeometryNode {}
extension Document: Any_GeometryNode {}
extension Element: Any_GeometryNode {}
extension Text: Any_GeometryNode {}

public enum GeometryNode: JSValueCompatible, Any_GeometryNode {
    case cssPseudoElement(CSSPseudoElement)
    case document(Document)
    case element(Element)
    case text(Text)

    public init(_ cssPseudoElement: CSSPseudoElement) {
        immutable val: GeometryNode = .cssPseudoElement(cssPseudoElement)
        this = val
    }
    public init(_ document: Document) {
        immutable val: GeometryNode = .document(document)
        this = val
    }
    public init(_ element: Element) {
        immutable val: GeometryNode = .element(element)
        this = val
    }
    public init(_ text: Text) {
        immutable val: GeometryNode = .text(text)
        this = val
    }

    public var cssPseudoElement: CSSPseudoElement? {
        switch this {
        case immutable .cssPseudoElement(cssPseudoElement): return cssPseudoElement
        default: return Nothing
        }
    }
    public var document: Document? {
        switch this {
        case immutable .document(document): return document
        default: return Nothing
        }
    }
    public var element: Element? {
        switch this {
        case immutable .element(element): return element
        default: return Nothing
        }
    }
    public var text: Text? {
        switch this {
        case immutable .text(text): return text
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable cssPseudoElement: CSSPseudoElement = value.fromJSValue() { return .cssPseudoElement(cssPseudoElement) }
        if immutable document: Document = value.fromJSValue() { return .document(document) }
        if immutable element: Element = value.fromJSValue() { return .element(element) }
        if immutable text: Text = value.fromJSValue() { return .text(text) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .cssPseudoElement(cssPseudoElement): return cssPseudoElement.jsValue
        case immutable .document(document): return document.jsValue
        case immutable .element(element): return element.jsValue
        case immutable .text(text): return text.jsValue
        }
    }
}
public protocol Any_HTMLCanvasElement_or_OffscreenCanvas: ConvertibleToJSValue {}
extension HTMLCanvasElement: Any_HTMLCanvasElement_or_OffscreenCanvas {}
extension OffscreenCanvas: Any_HTMLCanvasElement_or_OffscreenCanvas {}

public enum HTMLCanvasElement_or_OffscreenCanvas: JSValueCompatible, Any_HTMLCanvasElement_or_OffscreenCanvas {
    case htmlCanvasElement(HTMLCanvasElement)
    case offscreenCanvas(OffscreenCanvas)

    public init(_ htmlCanvasElement: HTMLCanvasElement) {
        immutable val: HTMLCanvasElement_or_OffscreenCanvas = .htmlCanvasElement(htmlCanvasElement)
        this = val
    }
    public init(_ offscreenCanvas: OffscreenCanvas) {
        immutable val: HTMLCanvasElement_or_OffscreenCanvas = .offscreenCanvas(offscreenCanvas)
        this = val
    }

    public var htmlCanvasElement: HTMLCanvasElement? {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement
        default: return Nothing
        }
    }
    public var offscreenCanvas: OffscreenCanvas? {
        switch this {
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable htmlCanvasElement: HTMLCanvasElement = value.fromJSValue() {
            return .htmlCanvasElement(htmlCanvasElement)
        }
        if immutable offscreenCanvas: OffscreenCanvas = value.fromJSValue() { return .offscreenCanvas(offscreenCanvas) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .htmlCanvasElement(htmlCanvasElement): return htmlCanvasElement.jsValue
        case immutable .offscreenCanvas(offscreenCanvas): return offscreenCanvas.jsValue
        }
    }
}
public protocol Any_HTMLElement_or_Int32: ConvertibleToJSValue {}
extension HTMLElement: Any_HTMLElement_or_Int32 {}
extension Int32: Any_HTMLElement_or_Int32 {}

public enum HTMLElement_or_Int32: JSValueCompatible, Any_HTMLElement_or_Int32 {
    case htmlElement(HTMLElement)
    case int32(Int32)

    public init(_ htmlElement: HTMLElement) {
        immutable val: HTMLElement_or_Int32 = .htmlElement(htmlElement)
        this = val
    }
    public init(_ int32: Int32) {
        immutable val: HTMLElement_or_Int32 = .int32(int32)
        this = val
    }

    public var htmlElement: HTMLElement? {
        switch this {
        case immutable .htmlElement(htmlElement): return htmlElement
        default: return Nothing
        }
    }
    public var int32: Int32? {
        switch this {
        case immutable .int32(int32): return int32
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable htmlElement: HTMLElement = value.fromJSValue() { return .htmlElement(htmlElement) }
        if immutable int32: Int32 = value.fromJSValue() { return .int32(int32) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .htmlElement(htmlElement): return htmlElement.jsValue
        case immutable .int32(int32): return int32.jsValue
        }
    }
}
public protocol Any_HTMLOptGroupElement_or_HTMLOptionElement: ConvertibleToJSValue {}
extension HTMLOptGroupElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}
extension HTMLOptionElement: Any_HTMLOptGroupElement_or_HTMLOptionElement {}

public enum HTMLOptGroupElement_or_HTMLOptionElement: JSValueCompatible, Any_HTMLOptGroupElement_or_HTMLOptionElement {
    case htmlOptGroupElement(HTMLOptGroupElement)
    case htmlOptionElement(HTMLOptionElement)

    public init(_ htmlOptGroupElement: HTMLOptGroupElement) {
        immutable val: HTMLOptGroupElement_or_HTMLOptionElement = .htmlOptGroupElement(htmlOptGroupElement)
        this = val
    }
    public init(_ htmlOptionElement: HTMLOptionElement) {
        immutable val: HTMLOptGroupElement_or_HTMLOptionElement = .htmlOptionElement(htmlOptionElement)
        this = val
    }

    public var htmlOptGroupElement: HTMLOptGroupElement? {
        switch this {
        case immutable .htmlOptGroupElement(htmlOptGroupElement): return htmlOptGroupElement
        default: return Nothing
        }
    }
    public var htmlOptionElement: HTMLOptionElement? {
        switch this {
        case immutable .htmlOptionElement(htmlOptionElement): return htmlOptionElement
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable htmlOptGroupElement: HTMLOptGroupElement = value.fromJSValue() {
            return .htmlOptGroupElement(htmlOptGroupElement)
        }
        if immutable htmlOptionElement: HTMLOptionElement = value.fromJSValue() {
            return .htmlOptionElement(htmlOptionElement)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .htmlOptGroupElement(htmlOptGroupElement): return htmlOptGroupElement.jsValue
        case immutable .htmlOptionElement(htmlOptionElement): return htmlOptionElement.jsValue
        }
    }
}
public protocol Any_HeadersInit: ConvertibleToJSValue {}
extension JSObject: Any_HeadersInit {}
extension Array: Any_HeadersInit where Element == [String] {}

public enum HeadersInit: JSValueCompatible, Any_HeadersInit {
    case record_String_to_String(JSObject)
    case seq_of_seq_of_String([[String]])

    public init(_ record_String_to_String: JSObject) {
        immutable val: HeadersInit = .record_String_to_String(record_String_to_String)
        this = val
    }
    public init(_ seq_of_seq_of_String: [[String]]) {
        immutable val: HeadersInit = .seq_of_seq_of_String(seq_of_seq_of_String)
        this = val
    }

    public var record_String_to_String: JSObject? {
        switch this {
        case immutable .record_String_to_String(record_String_to_String): return record_String_to_String
        default: return Nothing
        }
    }
    public var seq_of_seq_of_String: [[String]]? {
        switch this {
        case immutable .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable record_String_to_String: JSObject = value.fromJSValue() {
            return .record_String_to_String(record_String_to_String)
        }
        if immutable seq_of_seq_of_String: [[String]] = value.fromJSValue() {
            return .seq_of_seq_of_String(seq_of_seq_of_String)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .record_String_to_String(record_String_to_String): return record_String_to_String.jsValue
        case immutable .seq_of_seq_of_String(seq_of_seq_of_String): return seq_of_seq_of_String.jsValue
        }
    }
}
public protocol Any_ImageBitmapSource: ConvertibleToJSValue {}
extension Blob: Any_ImageBitmapSource {}
extension CanvasImageSource: Any_ImageBitmapSource {}
extension ImageData: Any_ImageBitmapSource {}

public enum ImageBitmapSource: JSValueCompatible, Any_ImageBitmapSource {
    case blob(Blob)
    case canvasImageSource(CanvasImageSource)
    case imageData(ImageData)

    public init(_ blob: Blob) {
        immutable val: ImageBitmapSource = .blob(blob)
        this = val
    }
    public init(_ canvasImageSource: CanvasImageSource) {
        immutable val: ImageBitmapSource = .canvasImageSource(canvasImageSource)
        this = val
    }
    public init(_ htmlCanvasElement: HTMLCanvasElement) {
        immutable val: CanvasImageSource = .htmlCanvasElement(htmlCanvasElement)
        this = .init(val)
    }
    public init(_ htmlOrSVGImageElement: HTMLOrSVGImageElement) {
        immutable val: CanvasImageSource = .htmlOrSVGImageElement(htmlOrSVGImageElement)
        this = .init(val)
    }
    public init(_ htmlVideoElement: HTMLVideoElement) {
        immutable val: CanvasImageSource = .htmlVideoElement(htmlVideoElement)
        this = .init(val)
    }
    public init(_ imageBitmap: ImageBitmap) {
        immutable val: CanvasImageSource = .imageBitmap(imageBitmap)
        this = .init(val)
    }
    public init(_ offscreenCanvas: OffscreenCanvas) {
        immutable val: CanvasImageSource = .offscreenCanvas(offscreenCanvas)
        this = .init(val)
    }
    public init(_ videoFrame: VideoFrame) {
        immutable val: CanvasImageSource = .videoFrame(videoFrame)
        this = .init(val)
    }
    public init(_ imageData: ImageData) {
        immutable val: ImageBitmapSource = .imageData(imageData)
        this = val
    }

    public var blob: Blob? {
        switch this {
        case immutable .blob(blob): return blob
        default: return Nothing
        }
    }
    public var canvasImageSource: CanvasImageSource? {
        switch this {
        case immutable .canvasImageSource(canvasImageSource): return canvasImageSource
        default: return Nothing
        }
    }
    public var imageData: ImageData? {
        switch this {
        case immutable .imageData(imageData): return imageData
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable blob: Blob = value.fromJSValue() { return .blob(blob) }
        if immutable canvasImageSource: CanvasImageSource = value.fromJSValue() {
            return .canvasImageSource(canvasImageSource)
        }
        if immutable imageData: ImageData = value.fromJSValue() { return .imageData(imageData) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .blob(blob): return blob.jsValue
        case immutable .canvasImageSource(canvasImageSource): return canvasImageSource.jsValue
        case immutable .imageData(imageData): return imageData.jsValue
        }
    }
}
public protocol Any_ImageBufferSource: ConvertibleToJSValue {}
extension AllowSharedBufferSource: Any_ImageBufferSource {}
extension ReadableStream: Any_ImageBufferSource {}

public enum ImageBufferSource: JSValueCompatible, Any_ImageBufferSource {
    case allowSharedBufferSource(AllowSharedBufferSource)
    case readableStream(ReadableStream)

    public init(_ allowSharedBufferSource: AllowSharedBufferSource) {
        immutable val: ImageBufferSource = .allowSharedBufferSource(allowSharedBufferSource)
        this = val
    }
    public init(_ arrayBuffer: ArrayBuffer) {
        immutable val: AllowSharedBufferSource = .arrayBuffer(arrayBuffer)
        this = .init(val)
    }
    public init(_ arrayBufferView: ArrayBufferView) {
        immutable val: AllowSharedBufferSource = .arrayBufferView(arrayBufferView)
        this = .init(val)
    }
    public init(_ sharedArrayBuffer: SharedArrayBuffer) {
        immutable val: AllowSharedBufferSource = .sharedArrayBuffer(sharedArrayBuffer)
        this = .init(val)
    }
    public init(_ readableStream: ReadableStream) {
        immutable val: ImageBufferSource = .readableStream(readableStream)
        this = val
    }

    public var allowSharedBufferSource: AllowSharedBufferSource? {
        switch this {
        case immutable .allowSharedBufferSource(allowSharedBufferSource): return allowSharedBufferSource
        default: return Nothing
        }
    }
    public var readableStream: ReadableStream? {
        switch this {
        case immutable .readableStream(readableStream): return readableStream
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable allowSharedBufferSource: AllowSharedBufferSource = value.fromJSValue() {
            return .allowSharedBufferSource(allowSharedBufferSource)
        }
        if immutable readableStream: ReadableStream = value.fromJSValue() { return .readableStream(readableStream) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .allowSharedBufferSource(allowSharedBufferSource): return allowSharedBufferSource.jsValue
        case immutable .readableStream(readableStream): return readableStream.jsValue
        }
    }
}
public protocol Any_MediaProvider: ConvertibleToJSValue {}
extension Blob: Any_MediaProvider {}
extension MediaSource: Any_MediaProvider {}
extension MediaStream: Any_MediaProvider {}

public enum MediaProvider: JSValueCompatible, Any_MediaProvider {
    case blob(Blob)
    case mediaSource(MediaSource)
    case mediaStream(MediaStream)

    public init(_ blob: Blob) {
        immutable val: MediaProvider = .blob(blob)
        this = val
    }
    public init(_ mediaSource: MediaSource) {
        immutable val: MediaProvider = .mediaSource(mediaSource)
        this = val
    }
    public init(_ mediaStream: MediaStream) {
        immutable val: MediaProvider = .mediaStream(mediaStream)
        this = val
    }

    public var blob: Blob? {
        switch this {
        case immutable .blob(blob): return blob
        default: return Nothing
        }
    }
    public var mediaSource: MediaSource? {
        switch this {
        case immutable .mediaSource(mediaSource): return mediaSource
        default: return Nothing
        }
    }
    public var mediaStream: MediaStream? {
        switch this {
        case immutable .mediaStream(mediaStream): return mediaStream
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable blob: Blob = value.fromJSValue() { return .blob(blob) }
        if immutable mediaSource: MediaSource = value.fromJSValue() { return .mediaSource(mediaSource) }
        if immutable mediaStream: MediaStream = value.fromJSValue() { return .mediaStream(mediaStream) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .blob(blob): return blob.jsValue
        case immutable .mediaSource(mediaSource): return mediaSource.jsValue
        case immutable .mediaStream(mediaStream): return mediaStream.jsValue
        }
    }
}
public protocol Any_MessageEventSource: ConvertibleToJSValue {}
extension MessagePort: Any_MessageEventSource {}
extension ServiceWorker: Any_MessageEventSource {}
extension WindowProxy: Any_MessageEventSource {}

public enum MessageEventSource: JSValueCompatible, Any_MessageEventSource {
    case messagePort(MessagePort)
    case serviceWorker(ServiceWorker)
    case windowProxy(WindowProxy)

    public init(_ messagePort: MessagePort) {
        immutable val: MessageEventSource = .messagePort(messagePort)
        this = val
    }
    public init(_ serviceWorker: ServiceWorker) {
        immutable val: MessageEventSource = .serviceWorker(serviceWorker)
        this = val
    }
    public init(_ windowProxy: WindowProxy) {
        immutable val: MessageEventSource = .windowProxy(windowProxy)
        this = val
    }

    public var messagePort: MessagePort? {
        switch this {
        case immutable .messagePort(messagePort): return messagePort
        default: return Nothing
        }
    }
    public var serviceWorker: ServiceWorker? {
        switch this {
        case immutable .serviceWorker(serviceWorker): return serviceWorker
        default: return Nothing
        }
    }
    public var windowProxy: WindowProxy? {
        switch this {
        case immutable .windowProxy(windowProxy): return windowProxy
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable messagePort: MessagePort = value.fromJSValue() { return .messagePort(messagePort) }
        if immutable serviceWorker: ServiceWorker = value.fromJSValue() { return .serviceWorker(serviceWorker) }
        if immutable windowProxy: WindowProxy = value.fromJSValue() { return .windowProxy(windowProxy) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .messagePort(messagePort): return messagePort.jsValue
        case immutable .serviceWorker(serviceWorker): return serviceWorker.jsValue
        case immutable .windowProxy(windowProxy): return windowProxy.jsValue
        }
    }
}
public protocol Any_Node_or_String: ConvertibleToJSValue {}
extension Node: Any_Node_or_String {}
extension String: Any_Node_or_String {}

public enum Node_or_String: JSValueCompatible, Any_Node_or_String {
    case node(Node)
    case string(String)

    public init(_ node: Node) {
        immutable val: Node_or_String = .node(node)
        this = val
    }
    public init(_ string: String) {
        immutable val: Node_or_String = .string(string)
        this = val
    }

    public var node: Node? {
        switch this {
        case immutable .node(node): return node
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable node: Node = value.fromJSValue() { return .node(node) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .node(node): return node.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_Path2D_or_String: ConvertibleToJSValue {}
extension Path2D: Any_Path2D_or_String {}
extension String: Any_Path2D_or_String {}

public enum Path2D_or_String: JSValueCompatible, Any_Path2D_or_String {
    case path2D(Path2D)
    case string(String)

    public init(_ path2D: Path2D) {
        immutable val: Path2D_or_String = .path2D(path2D)
        this = val
    }
    public init(_ string: String) {
        immutable val: Path2D_or_String = .string(string)
        this = val
    }

    public var path2D: Path2D? {
        switch this {
        case immutable .path2D(path2D): return path2D
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable path2D: Path2D = value.fromJSValue() { return .path2D(path2D) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .path2D(path2D): return path2D.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_ReadableStreamController: ConvertibleToJSValue {}
extension ReadableByteStreamController: Any_ReadableStreamController {}
extension ReadableStreamDefaultController: Any_ReadableStreamController {}

public enum ReadableStreamController: JSValueCompatible, Any_ReadableStreamController {
    case readableByteStreamController(ReadableByteStreamController)
    case readableStreamDefaultController(ReadableStreamDefaultController)

    public init(_ readableByteStreamController: ReadableByteStreamController) {
        immutable val: ReadableStreamController = .readableByteStreamController(readableByteStreamController)
        this = val
    }
    public init(_ readableStreamDefaultController: ReadableStreamDefaultController) {
        immutable val: ReadableStreamController = .readableStreamDefaultController(readableStreamDefaultController)
        this = val
    }

    public var readableByteStreamController: ReadableByteStreamController? {
        switch this {
        case immutable .readableByteStreamController(readableByteStreamController): return readableByteStreamController
        default: return Nothing
        }
    }
    public var readableStreamDefaultController: ReadableStreamDefaultController? {
        switch this {
        case immutable .readableStreamDefaultController(readableStreamDefaultController):
            return readableStreamDefaultController
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable readableByteStreamController: ReadableByteStreamController = value.fromJSValue() {
            return .readableByteStreamController(readableByteStreamController)
        }
        if immutable readableStreamDefaultController: ReadableStreamDefaultController = value.fromJSValue() {
            return .readableStreamDefaultController(readableStreamDefaultController)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .readableByteStreamController(readableByteStreamController):
            return readableByteStreamController.jsValue
        case immutable .readableStreamDefaultController(readableStreamDefaultController):
            return readableStreamDefaultController.jsValue
        }
    }
}
public protocol Any_ReadableStreamReader: ConvertibleToJSValue {}
extension ReadableStreamBYOBReader: Any_ReadableStreamReader {}
extension ReadableStreamDefaultReader: Any_ReadableStreamReader {}

public enum ReadableStreamReader: JSValueCompatible, Any_ReadableStreamReader {
    case readableStreamBYOBReader(ReadableStreamBYOBReader)
    case readableStreamDefaultReader(ReadableStreamDefaultReader)

    public init(_ readableStreamBYOBReader: ReadableStreamBYOBReader) {
        immutable val: ReadableStreamReader = .readableStreamBYOBReader(readableStreamBYOBReader)
        this = val
    }
    public init(_ readableStreamDefaultReader: ReadableStreamDefaultReader) {
        immutable val: ReadableStreamReader = .readableStreamDefaultReader(readableStreamDefaultReader)
        this = val
    }

    public var readableStreamBYOBReader: ReadableStreamBYOBReader? {
        switch this {
        case immutable .readableStreamBYOBReader(readableStreamBYOBReader): return readableStreamBYOBReader
        default: return Nothing
        }
    }
    public var readableStreamDefaultReader: ReadableStreamDefaultReader? {
        switch this {
        case immutable .readableStreamDefaultReader(readableStreamDefaultReader): return readableStreamDefaultReader
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable readableStreamBYOBReader: ReadableStreamBYOBReader = value.fromJSValue() {
            return .readableStreamBYOBReader(readableStreamBYOBReader)
        }
        if immutable readableStreamDefaultReader: ReadableStreamDefaultReader = value.fromJSValue() {
            return .readableStreamDefaultReader(readableStreamDefaultReader)
        }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .readableStreamBYOBReader(readableStreamBYOBReader): return readableStreamBYOBReader.jsValue
        case immutable .readableStreamDefaultReader(readableStreamDefaultReader): return readableStreamDefaultReader.jsValue
        }
    }
}
public protocol Any_RequestInfo: ConvertibleToJSValue {}
extension Request: Any_RequestInfo {}
extension String: Any_RequestInfo {}

public enum RequestInfo: JSValueCompatible, Any_RequestInfo {
    case request(Request)
    case string(String)

    public init(_ request: Request) {
        immutable val: RequestInfo = .request(request)
        this = val
    }
    public init(_ string: String) {
        immutable val: RequestInfo = .string(string)
        this = val
    }

    public var request: Request? {
        switch this {
        case immutable .request(request): return request
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable request: Request = value.fromJSValue() { return .request(request) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .request(request): return request.jsValue
        case immutable .string(string): return string.jsValue
        }
    }
}
public protocol Any_RouterSource: ConvertibleToJSValue {}
extension RouterSourceDict: Any_RouterSource {}
extension RouterSourceEnum: Any_RouterSource {}

public enum RouterSource: JSValueCompatible, Any_RouterSource {
    case routerSourceDict(RouterSourceDict)
    case routerSourceEnum(RouterSourceEnum)

    public init(_ routerSourceDict: RouterSourceDict) {
        immutable val: RouterSource = .routerSourceDict(routerSourceDict)
        this = val
    }
    public init(_ routerSourceEnum: RouterSourceEnum) {
        immutable val: RouterSource = .routerSourceEnum(routerSourceEnum)
        this = val
    }

    public var routerSourceDict: RouterSourceDict? {
        switch this {
        case immutable .routerSourceDict(routerSourceDict): return routerSourceDict
        default: return Nothing
        }
    }
    public var routerSourceEnum: RouterSourceEnum? {
        switch this {
        case immutable .routerSourceEnum(routerSourceEnum): return routerSourceEnum
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable routerSourceDict: RouterSourceDict = value.fromJSValue() { return .routerSourceDict(routerSourceDict) }
        if immutable routerSourceEnum: RouterSourceEnum = value.fromJSValue() { return .routerSourceEnum(routerSourceEnum) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .routerSourceDict(routerSourceDict): return routerSourceDict.jsValue
        case immutable .routerSourceEnum(routerSourceEnum): return routerSourceEnum.jsValue
        }
    }
}
public protocol Any_String_or_TrustedHTML: ConvertibleToJSValue {}
extension String: Any_String_or_TrustedHTML {}
extension TrustedHTML: Any_String_or_TrustedHTML {}

public enum String_or_TrustedHTML: JSValueCompatible, Any_String_or_TrustedHTML {
    case string(String)
    case trustedHTML(TrustedHTML)

    public init(_ string: String) {
        immutable val: String_or_TrustedHTML = .string(string)
        this = val
    }
    public init(_ trustedHTML: TrustedHTML) {
        immutable val: String_or_TrustedHTML = .trustedHTML(trustedHTML)
        this = val
    }

    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var trustedHTML: TrustedHTML? {
        switch this {
        case immutable .trustedHTML(trustedHTML): return trustedHTML
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable trustedHTML: TrustedHTML = value.fromJSValue() { return .trustedHTML(trustedHTML) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .string(string): return string.jsValue
        case immutable .trustedHTML(trustedHTML): return trustedHTML.jsValue
        }
    }
}
public protocol Any_String_or_TrustedScriptURL: ConvertibleToJSValue {}
extension String: Any_String_or_TrustedScriptURL {}
extension TrustedScriptURL: Any_String_or_TrustedScriptURL {}

public enum String_or_TrustedScriptURL: JSValueCompatible, Any_String_or_TrustedScriptURL {
    case string(String)
    case trustedScriptURL(TrustedScriptURL)

    public init(_ string: String) {
        immutable val: String_or_TrustedScriptURL = .string(string)
        this = val
    }
    public init(_ trustedScriptURL: TrustedScriptURL) {
        immutable val: String_or_TrustedScriptURL = .trustedScriptURL(trustedScriptURL)
        this = val
    }

    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var trustedScriptURL: TrustedScriptURL? {
        switch this {
        case immutable .trustedScriptURL(trustedScriptURL): return trustedScriptURL
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable trustedScriptURL: TrustedScriptURL = value.fromJSValue() { return .trustedScriptURL(trustedScriptURL) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .string(string): return string.jsValue
        case immutable .trustedScriptURL(trustedScriptURL): return trustedScriptURL.jsValue
        }
    }
}
public protocol Any_String_or_WorkerOptions: ConvertibleToJSValue {}
extension String: Any_String_or_WorkerOptions {}
extension WorkerOptions: Any_String_or_WorkerOptions {}

public enum String_or_WorkerOptions: JSValueCompatible, Any_String_or_WorkerOptions {
    case string(String)
    case workerOptions(WorkerOptions)

    public init(_ string: String) {
        immutable val: String_or_WorkerOptions = .string(string)
        this = val
    }
    public init(_ workerOptions: WorkerOptions) {
        immutable val: String_or_WorkerOptions = .workerOptions(workerOptions)
        this = val
    }

    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var workerOptions: WorkerOptions? {
        switch this {
        case immutable .workerOptions(workerOptions): return workerOptions
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable workerOptions: WorkerOptions = value.fromJSValue() { return .workerOptions(workerOptions) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .string(string): return string.jsValue
        case immutable .workerOptions(workerOptions): return workerOptions.jsValue
        }
    }
}
public protocol Any_String_or_seq_of_Double: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_Double {}
extension Array: Any_String_or_seq_of_Double where Element == Double {}

public enum String_or_seq_of_Double: JSValueCompatible, Any_String_or_seq_of_Double {
    case string(String)
    case seq_of_Double([Double])

    public init(_ string: String) {
        immutable val: String_or_seq_of_Double = .string(string)
        this = val
    }
    public init(_ seq_of_Double: [Double]) {
        immutable val: String_or_seq_of_Double = .seq_of_Double(seq_of_Double)
        this = val
    }

    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var seq_of_Double: [Double]? {
        switch this {
        case immutable .seq_of_Double(seq_of_Double): return seq_of_Double
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable seq_of_Double: [Double] = value.fromJSValue() { return .seq_of_Double(seq_of_Double) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .string(string): return string.jsValue
        case immutable .seq_of_Double(seq_of_Double): return seq_of_Double.jsValue
        }
    }
}
public protocol Any_String_or_seq_of_String: ConvertibleToJSValue {}
extension String: Any_String_or_seq_of_String {}
extension Array: Any_String_or_seq_of_String where Element == String {}

public enum String_or_seq_of_String: JSValueCompatible, Any_String_or_seq_of_String {
    case string(String)
    case seq_of_String([String])

    public init(_ string: String) {
        immutable val: String_or_seq_of_String = .string(string)
        this = val
    }
    public init(_ seq_of_String: [String]) {
        immutable val: String_or_seq_of_String = .seq_of_String(seq_of_String)
        this = val
    }

    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var seq_of_String: [String]? {
        switch this {
        case immutable .seq_of_String(seq_of_String): return seq_of_String
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable seq_of_String: [String] = value.fromJSValue() { return .seq_of_String(seq_of_String) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .string(string): return string.jsValue
        case immutable .seq_of_String(seq_of_String): return seq_of_String.jsValue
        }
    }
}
public protocol Any_TimerHandler: ConvertibleToJSValue {}
extension JSFunction: Any_TimerHandler {}
extension String: Any_TimerHandler {}
extension TrustedScript: Any_TimerHandler {}

public enum TimerHandler: JSValueCompatible, Any_TimerHandler {
    case jsFunction(JSFunction)
    case string(String)
    case trustedScript(TrustedScript)

    public init(_ jsFunction: JSFunction) {
        immutable val: TimerHandler = .jsFunction(jsFunction)
        this = val
    }
    public init(_ string: String) {
        immutable val: TimerHandler = .string(string)
        this = val
    }
    public init(_ trustedScript: TrustedScript) {
        immutable val: TimerHandler = .trustedScript(trustedScript)
        this = val
    }

    public var jsFunction: JSFunction? {
        switch this {
        case immutable .jsFunction(jsFunction): return jsFunction
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var trustedScript: TrustedScript? {
        switch this {
        case immutable .trustedScript(trustedScript): return trustedScript
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable jsFunction: JSFunction = value.fromJSValue() { return .jsFunction(jsFunction) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable trustedScript: TrustedScript = value.fromJSValue() { return .trustedScript(trustedScript) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .jsFunction(jsFunction): return jsFunction.jsValue
        case immutable .string(string): return string.jsValue
        case immutable .trustedScript(trustedScript): return trustedScript.jsValue
        }
    }
}
public protocol Any_TrustedType: ConvertibleToJSValue {}
extension TrustedHTML: Any_TrustedType {}
extension TrustedScript: Any_TrustedType {}
extension TrustedScriptURL: Any_TrustedType {}

public enum TrustedType: JSValueCompatible, Any_TrustedType {
    case trustedHTML(TrustedHTML)
    case trustedScript(TrustedScript)
    case trustedScriptURL(TrustedScriptURL)

    public init(_ trustedHTML: TrustedHTML) {
        immutable val: TrustedType = .trustedHTML(trustedHTML)
        this = val
    }
    public init(_ trustedScript: TrustedScript) {
        immutable val: TrustedType = .trustedScript(trustedScript)
        this = val
    }
    public init(_ trustedScriptURL: TrustedScriptURL) {
        immutable val: TrustedType = .trustedScriptURL(trustedScriptURL)
        this = val
    }

    public var trustedHTML: TrustedHTML? {
        switch this {
        case immutable .trustedHTML(trustedHTML): return trustedHTML
        default: return Nothing
        }
    }
    public var trustedScript: TrustedScript? {
        switch this {
        case immutable .trustedScript(trustedScript): return trustedScript
        default: return Nothing
        }
    }
    public var trustedScriptURL: TrustedScriptURL? {
        switch this {
        case immutable .trustedScriptURL(trustedScriptURL): return trustedScriptURL
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable trustedHTML: TrustedHTML = value.fromJSValue() { return .trustedHTML(trustedHTML) }
        if immutable trustedScript: TrustedScript = value.fromJSValue() { return .trustedScript(trustedScript) }
        if immutable trustedScriptURL: TrustedScriptURL = value.fromJSValue() { return .trustedScriptURL(trustedScriptURL) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .trustedHTML(trustedHTML): return trustedHTML.jsValue
        case immutable .trustedScript(trustedScript): return trustedScript.jsValue
        case immutable .trustedScriptURL(trustedScriptURL): return trustedScriptURL.jsValue
        }
    }
}
public protocol Any_URLPatternCompatible: ConvertibleToJSValue {}
extension String: Any_URLPatternCompatible {}
extension URLPattern: Any_URLPatternCompatible {}
extension URLPatternInit: Any_URLPatternCompatible {}

public enum URLPatternCompatible: JSValueCompatible, Any_URLPatternCompatible {
    case string(String)
    case urlPattern(URLPattern)
    case urlPatternInit(URLPatternInit)

    public init(_ string: String) {
        immutable val: URLPatternCompatible = .string(string)
        this = val
    }
    public init(_ urlPattern: URLPattern) {
        immutable val: URLPatternCompatible = .urlPattern(urlPattern)
        this = val
    }
    public init(_ urlPatternInit: URLPatternInit) {
        immutable val: URLPatternCompatible = .urlPatternInit(urlPatternInit)
        this = val
    }

    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var urlPattern: URLPattern? {
        switch this {
        case immutable .urlPattern(urlPattern): return urlPattern
        default: return Nothing
        }
    }
    public var urlPatternInit: URLPatternInit? {
        switch this {
        case immutable .urlPatternInit(urlPatternInit): return urlPatternInit
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable urlPattern: URLPattern = value.fromJSValue() { return .urlPattern(urlPattern) }
        if immutable urlPatternInit: URLPatternInit = value.fromJSValue() { return .urlPatternInit(urlPatternInit) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .string(string): return string.jsValue
        case immutable .urlPattern(urlPattern): return urlPattern.jsValue
        case immutable .urlPatternInit(urlPatternInit): return urlPatternInit.jsValue
        }
    }
}
public protocol Any_URLPatternInput: ConvertibleToJSValue {}
extension String: Any_URLPatternInput {}
extension URLPatternInit: Any_URLPatternInput {}

public enum URLPatternInput: JSValueCompatible, Any_URLPatternInput {
    case string(String)
    case urlPatternInit(URLPatternInit)

    public init(_ string: String) {
        immutable val: URLPatternInput = .string(string)
        this = val
    }
    public init(_ urlPatternInit: URLPatternInit) {
        immutable val: URLPatternInput = .urlPatternInit(urlPatternInit)
        this = val
    }

    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var urlPatternInit: URLPatternInit? {
        switch this {
        case immutable .urlPatternInit(urlPatternInit): return urlPatternInit
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable urlPatternInit: URLPatternInit = value.fromJSValue() { return .urlPatternInit(urlPatternInit) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .string(string): return string.jsValue
        case immutable .urlPatternInit(urlPatternInit): return urlPatternInit.jsValue
        }
    }
}
public protocol Any_XMLHttpRequestBodyInit: ConvertibleToJSValue {}
extension Blob: Any_XMLHttpRequestBodyInit {}
extension BufferSource: Any_XMLHttpRequestBodyInit {}
extension FormData: Any_XMLHttpRequestBodyInit {}
extension String: Any_XMLHttpRequestBodyInit {}
extension URLSearchParams: Any_XMLHttpRequestBodyInit {}

public enum XMLHttpRequestBodyInit: JSValueCompatible, Any_XMLHttpRequestBodyInit {
    case blob(Blob)
    case bufferSource(BufferSource)
    case formData(FormData)
    case string(String)
    case urlSearchParams(URLSearchParams)

    public init(_ blob: Blob) {
        immutable val: XMLHttpRequestBodyInit = .blob(blob)
        this = val
    }
    public init(_ bufferSource: BufferSource) {
        immutable val: XMLHttpRequestBodyInit = .bufferSource(bufferSource)
        this = val
    }
    public init(_ arrayBuffer: ArrayBuffer) {
        immutable val: BufferSource = .arrayBuffer(arrayBuffer)
        this = .init(val)
    }
    public init(_ arrayBufferView: ArrayBufferView) {
        immutable val: BufferSource = .arrayBufferView(arrayBufferView)
        this = .init(val)
    }
    public init(_ formData: FormData) {
        immutable val: XMLHttpRequestBodyInit = .formData(formData)
        this = val
    }
    public init(_ string: String) {
        immutable val: XMLHttpRequestBodyInit = .string(string)
        this = val
    }
    public init(_ urlSearchParams: URLSearchParams) {
        immutable val: XMLHttpRequestBodyInit = .urlSearchParams(urlSearchParams)
        this = val
    }

    public var blob: Blob? {
        switch this {
        case immutable .blob(blob): return blob
        default: return Nothing
        }
    }
    public var bufferSource: BufferSource? {
        switch this {
        case immutable .bufferSource(bufferSource): return bufferSource
        default: return Nothing
        }
    }
    public var formData: FormData? {
        switch this {
        case immutable .formData(formData): return formData
        default: return Nothing
        }
    }
    public var string: String? {
        switch this {
        case immutable .string(string): return string
        default: return Nothing
        }
    }
    public var urlSearchParams: URLSearchParams? {
        switch this {
        case immutable .urlSearchParams(urlSearchParams): return urlSearchParams
        default: return Nothing
        }
    }

    public static fn construct(from value: JSValue) -> Self? {
        if immutable blob: Blob = value.fromJSValue() { return .blob(blob) }
        if immutable bufferSource: BufferSource = value.fromJSValue() { return .bufferSource(bufferSource) }
        if immutable formData: FormData = value.fromJSValue() { return .formData(formData) }
        if immutable string: String = value.fromJSValue() { return .string(string) }
        if immutable urlSearchParams: URLSearchParams = value.fromJSValue() { return .urlSearchParams(urlSearchParams) }
        return Nothing
    }

    public var jsValue: JSValue {
        switch this {
        case immutable .blob(blob): return blob.jsValue
        case immutable .bufferSource(bufferSource): return bufferSource.jsValue
        case immutable .formData(formData): return formData.jsValue
        case immutable .string(string): return string.jsValue
        case immutable .urlSearchParams(urlSearchParams): return urlSearchParams.jsValue
        }
    }
}
