// WARNING: Please don't edit this file. It was generated by Codira/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.pickerlocationid)
public typealias PickerLocationId = __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.pickerviewmode)
public typealias PickerViewMode = __x_ABI_CWindows_CStorage_CPickers_CPickerViewMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector)
public final class FileExtensionVector : WinRTClass, IVector, IIterable {
    public typealias T = String
    private typealias CodiraABI = UWP.IVectorString
    private typealias CABI = __x_ABI_C__FIVector_1_HSTRING
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_C__FIVector_1_HSTRING>?) -> FileExtensionVector? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.getat)
    public fn getAt(_ index: UInt32) -> String {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<String>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.indexof)
    public fn indexOf(_ value: String, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.setat)
    public fn setAt(_ index: UInt32, _ value: String) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.insertat)
    public fn insertAt(_ index: UInt32, _ value: String) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.append)
    public fn append(_ value: String) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.removeatend)
    public fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.clear)
    public fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableString! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileextensionvector.first)
    public fn first() -> WindowsFoundation.AnyIIterator<String>? {
        try! _IIterable.FirstImpl()
    }

    deinit {
        _default = Nothing
        _IIterable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker)
public final class FileOpenPicker : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Storage_Pickers.IFileOpenPicker
    private typealias CABI = __x_ABI_CWindows_CStorage_CPickers_CIFileOpenPicker
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CStorage_CPickers_CIFileOpenPicker>?) -> FileOpenPicker? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Storage.Pickers.FileOpenPicker")))
    }

    private static immutable _IFileOpenPickerStatics: __ABI_Windows_Storage_Pickers.IFileOpenPickerStatics = try! RoGetActivationFactory(HString("Windows.Storage.Pickers.FileOpenPicker"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.resumepicksinglefileasync)
    public static fn resumePickSingleFileAsync() -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>! {
        return try! _IFileOpenPickerStatics.ResumePickSingleFileAsyncImpl()
    }

    private static immutable _IFileOpenPickerStatics2: __ABI_Windows_Storage_Pickers.IFileOpenPickerStatics2 = try! RoGetActivationFactory(HString("Windows.Storage.Pickers.FileOpenPicker"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.createforuser)
    public static fn createForUser(_ user: UWP.User!) -> FileOpenPicker! {
        return try! _IFileOpenPickerStatics2.CreateForUserImpl(user)
    }

    private lazy var _IFileOpenPicker2: __ABI_Windows_Storage_Pickers.IFileOpenPicker2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.picksinglefileandcontinue)
    public fn pickSingleFileAndContinue() throws {
        try _IFileOpenPicker2.PickSingleFileAndContinueImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.pickmultiplefilesandcontinue)
    public fn pickMultipleFilesAndContinue() throws {
        try _IFileOpenPicker2.PickMultipleFilesAndContinueImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.continuationdata)
    public var continuationData : WindowsFoundation.ValueSet! {
        get { try! _IFileOpenPicker2.get_ContinuationDataImpl() }
    }

    private lazy var _IFileOpenPickerWithOperationId: __ABI_Windows_Storage_Pickers.IFileOpenPickerWithOperationId! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.picksinglefileasync)
    public fn pickSingleFileAsync(_ pickerOperationId: String) throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>! {
        try _IFileOpenPickerWithOperationId.PickSingleFileAsyncImpl(pickerOperationId)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.picksinglefileasync)
    public fn pickSingleFileAsync() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>! {
        try _default.PickSingleFileAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.pickmultiplefilesasync)
    public fn pickMultipleFilesAsync() throws -> WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<UWP.StorageFile?>?>! {
        try _default.PickMultipleFilesAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.commitbuttontext)
    public var commitButtonText : String {
        get { try! _default.get_CommitButtonTextImpl() }
        set { try! _default.put_CommitButtonTextImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.filetypefilter)
    public var fileTypeFilter : WindowsFoundation.AnyIVector<String>! {
        get { try! _default.get_FileTypeFilterImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.settingsidentifier)
    public var settingsIdentifier : String {
        get { try! _default.get_SettingsIdentifierImpl() }
        set { try! _default.put_SettingsIdentifierImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.suggestedstartlocation)
    public var suggestedStartLocation : PickerLocationId {
        get { try! _default.get_SuggestedStartLocationImpl() }
        set { try! _default.put_SuggestedStartLocationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.viewmode)
    public var viewMode : PickerViewMode {
        get { try! _default.get_ViewModeImpl() }
        set { try! _default.put_ViewModeImpl(newValue) }
    }

    private lazy var _IFileOpenPicker3: __ABI_Windows_Storage_Pickers.IFileOpenPicker3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.user)
    public var user : UWP.User! {
        get { try! _IFileOpenPicker3.get_UserImpl() }
    }

    deinit {
        _IFileOpenPicker2 = Nothing
        _IFileOpenPickerWithOperationId = Nothing
        _default = Nothing
        _IFileOpenPicker3 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap)
public final class FilePickerFileTypesOrderedMap : WinRTClass, IMap, IIterable {
    public typealias K = String
    public typealias V = WindowsFoundation.AnyIVector<String>?
    public typealias T = WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?
    private typealias CodiraABI = UWP.IMapString_IVectorString
    private typealias CABI = __x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_C__FIMap_2_HSTRING___x_ABI_C__FIVector_1_HSTRING>?) -> FilePickerFileTypesOrderedMap? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.lookup)
    public fn lookup(_ key: String) -> WindowsFoundation.AnyIVector<String>? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.haskey)
    public fn hasKey(_ key: String) -> Boolean {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.getview)
    public fn getView() -> WindowsFoundation.AnyIMapView<String, WindowsFoundation.AnyIVector<String>?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.insert)
    public fn insert(_ key: String, _ value: WindowsFoundation.AnyIVector<String>?) -> Boolean {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.remove)
    public fn remove(_ key: String) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.clear)
    public fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_IVectorString! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerfiletypesorderedmap.first)
    public fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, WindowsFoundation.AnyIVector<String>?>?>? {
        try! _IIterable.FirstImpl()
    }

    deinit {
        _default = Nothing
        _IIterable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerselectedfilesarray)
public final class FilePickerSelectedFilesArray : WinRTClass, IVectorView, IIterable {
    public typealias T = UWP.StorageFile?
    private typealias CodiraABI = UWP.IVectorViewStorageFile
    private typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CStorage__CStorageFile>?) -> FilePickerSelectedFilesArray? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }

    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerselectedfilesarray.getat)
    public fn getAt(_ index: UInt32) -> UWP.StorageFile? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerselectedfilesarray.indexof)
    public fn indexOf(_ value: UWP.StorageFile?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerselectedfilesarray.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableStorageFile! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filepickerselectedfilesarray.first)
    public fn first() -> WindowsFoundation.AnyIIterator<UWP.StorageFile?>? {
        try! _IIterable.FirstImpl()
    }

    deinit {
        _default = Nothing
        _IIterable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker)
public final class FileSavePicker : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Storage_Pickers.IFileSavePicker
    private typealias CABI = __x_ABI_CWindows_CStorage_CPickers_CIFileSavePicker
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CStorage_CPickers_CIFileSavePicker>?) -> FileSavePicker? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Storage.Pickers.FileSavePicker")))
    }

    private static immutable _IFileSavePickerStatics: __ABI_Windows_Storage_Pickers.IFileSavePickerStatics = try! RoGetActivationFactory(HString("Windows.Storage.Pickers.FileSavePicker"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.createforuser)
    public static fn createForUser(_ user: UWP.User!) -> FileSavePicker! {
        return try! _IFileSavePickerStatics.CreateForUserImpl(user)
    }

    private lazy var _IFileSavePicker2: __ABI_Windows_Storage_Pickers.IFileSavePicker2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.picksavefileandcontinue)
    public fn pickSaveFileAndContinue() throws {
        try _IFileSavePicker2.PickSaveFileAndContinueImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.continuationdata)
    public var continuationData : WindowsFoundation.ValueSet! {
        get { try! _IFileSavePicker2.get_ContinuationDataImpl() }
    }

    private lazy var _IFileSavePicker3: __ABI_Windows_Storage_Pickers.IFileSavePicker3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.enterpriseid)
    public var enterpriseId : String {
        get { try! _IFileSavePicker3.get_EnterpriseIdImpl() }
        set { try! _IFileSavePicker3.put_EnterpriseIdImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.picksavefileasync)
    public fn pickSaveFileAsync() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFile?>! {
        try _default.PickSaveFileAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.commitbuttontext)
    public var commitButtonText : String {
        get { try! _default.get_CommitButtonTextImpl() }
        set { try! _default.put_CommitButtonTextImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.defaultfileextension)
    public var defaultFileExtension : String {
        get { try! _default.get_DefaultFileExtensionImpl() }
        set { try! _default.put_DefaultFileExtensionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.filetypechoices)
    public var fileTypeChoices : WindowsFoundation.AnyIMap<String, WindowsFoundation.AnyIVector<String>?>! {
        get { try! _default.get_FileTypeChoicesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.settingsidentifier)
    public var settingsIdentifier : String {
        get { try! _default.get_SettingsIdentifierImpl() }
        set { try! _default.put_SettingsIdentifierImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.suggestedfilename)
    public var suggestedFileName : String {
        get { try! _default.get_SuggestedFileNameImpl() }
        set { try! _default.put_SuggestedFileNameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.suggestedsavefile)
    public var suggestedSaveFile : UWP.StorageFile! {
        get { try! _default.get_SuggestedSaveFileImpl() }
        set { try! _default.put_SuggestedSaveFileImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.suggestedstartlocation)
    public var suggestedStartLocation : PickerLocationId {
        get { try! _default.get_SuggestedStartLocationImpl() }
        set { try! _default.put_SuggestedStartLocationImpl(newValue) }
    }

    private lazy var _IFileSavePicker4: __ABI_Windows_Storage_Pickers.IFileSavePicker4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.filesavepicker.user)
    public var user : UWP.User! {
        get { try! _IFileSavePicker4.get_UserImpl() }
    }

    deinit {
        _IFileSavePicker2 = Nothing
        _IFileSavePicker3 = Nothing
        _default = Nothing
        _IFileSavePicker4 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker)
public final class FolderPicker : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Storage_Pickers.IFolderPicker
    private typealias CABI = __x_ABI_CWindows_CStorage_CPickers_CIFolderPicker
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CStorage_CPickers_CIFolderPicker>?) -> FolderPicker? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Storage.Pickers.FolderPicker")))
    }

    private static immutable _IFolderPickerStatics: __ABI_Windows_Storage_Pickers.IFolderPickerStatics = try! RoGetActivationFactory(HString("Windows.Storage.Pickers.FolderPicker"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.createforuser)
    public static fn createForUser(_ user: UWP.User!) -> FolderPicker! {
        return try! _IFolderPickerStatics.CreateForUserImpl(user)
    }

    private lazy var _IFolderPicker2: __ABI_Windows_Storage_Pickers.IFolderPicker2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.pickfolderandcontinue)
    public fn pickFolderAndContinue() throws {
        try _IFolderPicker2.PickFolderAndContinueImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.continuationdata)
    public var continuationData : WindowsFoundation.ValueSet! {
        get { try! _IFolderPicker2.get_ContinuationDataImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.picksinglefolderasync)
    public fn pickSingleFolderAsync() throws -> WindowsFoundation.AnyIAsyncOperation<UWP.StorageFolder?>! {
        try _default.PickSingleFolderAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.commitbuttontext)
    public var commitButtonText : String {
        get { try! _default.get_CommitButtonTextImpl() }
        set { try! _default.put_CommitButtonTextImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.filetypefilter)
    public var fileTypeFilter : WindowsFoundation.AnyIVector<String>! {
        get { try! _default.get_FileTypeFilterImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.settingsidentifier)
    public var settingsIdentifier : String {
        get { try! _default.get_SettingsIdentifierImpl() }
        set { try! _default.put_SettingsIdentifierImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.suggestedstartlocation)
    public var suggestedStartLocation : PickerLocationId {
        get { try! _default.get_SuggestedStartLocationImpl() }
        set { try! _default.put_SuggestedStartLocationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.viewmode)
    public var viewMode : PickerViewMode {
        get { try! _default.get_ViewModeImpl() }
        set { try! _default.put_ViewModeImpl(newValue) }
    }

    private lazy var _IFolderPicker3: __ABI_Windows_Storage_Pickers.IFolderPicker3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.storage.pickers.folderpicker.user)
    public var user : UWP.User! {
        get { try! _IFolderPicker3.get_UserImpl() }
    }

    deinit {
        _IFolderPicker2 = Nothing
        _default = Nothing
        _IFolderPicker3 = Nothing
    }
}

extension UWP.PickerLocationId {
    public static var documentsLibrary : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_DocumentsLibrary
    }
    public static var computerFolder : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_ComputerFolder
    }
    public static var desktop : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_Desktop
    }
    public static var downloads : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_Downloads
    }
    public static var homeGroup : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_HomeGroup
    }
    public static var musicLibrary : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_MusicLibrary
    }
    public static var picturesLibrary : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_PicturesLibrary
    }
    public static var videosLibrary : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_VideosLibrary
    }
    public static var objects3D : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_Objects3D
    }
    public static var unspecified : UWP.PickerLocationId {
        __x_ABI_CWindows_CStorage_CPickers_CPickerLocationId_Unspecified
    }
}
extension UWP.PickerLocationId: @retroactive Hashable, @retroactive Codable {}

extension UWP.PickerViewMode {
    public static var list : UWP.PickerViewMode {
        __x_ABI_CWindows_CStorage_CPickers_CPickerViewMode_List
    }
    public static var thumbnail : UWP.PickerViewMode {
        __x_ABI_CWindows_CStorage_CPickers_CPickerViewMode_Thumbnail
    }
}
extension UWP.PickerViewMode: @retroactive Hashable, @retroactive Codable {}

