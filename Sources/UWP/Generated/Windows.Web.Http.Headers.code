// WARNING: Please don't edit this file. It was generated by Codira/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection)
public final class HttpCacheDirectiveHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpNameValueHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpCacheDirectiveHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCacheDirectiveHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCacheDirectiveHeaderValueCollection>?) -> HttpCacheDirectiveHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.maxage)
    public var maxAge : WindowsFoundation.TimeSpan? {
        get { try! _default.get_MaxAgeImpl() }
        set { try! _default.put_MaxAgeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.maxstale)
    public var maxStale : WindowsFoundation.TimeSpan? {
        get { try! _default.get_MaxStaleImpl() }
        set { try! _default.put_MaxStaleImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.minfresh)
    public var minFresh : WindowsFoundation.TimeSpan? {
        get { try! _default.get_MinFreshImpl() }
        set { try! _default.put_MinFreshImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.sharedmaxage)
    public var sharedMaxAge : WindowsFoundation.TimeSpan? {
        get { try! _default.get_SharedMaxAgeImpl() }
        set { try! _default.put_SharedMaxAgeImpl(newValue) }
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpNameValueHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpNameValueHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpNameValueHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpNameValueHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpNameValueHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpNameValueHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.append)
    public fn append(_ value: HttpNameValueHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpNameValueHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpNameValueHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcachedirectiveheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervalue)
public final class HttpChallengeHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpChallengeHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpChallengeHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpChallengeHeaderValue>?) -> HttpChallengeHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpChallengeHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpChallengeHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpChallengeHeaderValue"))
    public init(_ scheme: String) {
        super.init(try! Self._IHttpChallengeHeaderValueFactory.CreateFromSchemeImpl(scheme))
    }

    public init(_ scheme: String, _ token: String) {
        super.init(try! Self._IHttpChallengeHeaderValueFactory.CreateFromSchemeWithTokenImpl(scheme, token))
    }

    private static immutable _IHttpChallengeHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpChallengeHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpChallengeHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervalue.parse)
    public static fn parse(_ input: String) -> HttpChallengeHeaderValue! {
        return try! _IHttpChallengeHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ challengeHeaderValue: inout HttpChallengeHeaderValue!) -> Boolean {
        return try! _IHttpChallengeHeaderValueStatics.TryParseImpl(input, &challengeHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervalue.parameters)
    public var parameters : WindowsFoundation.AnyIVector<HttpNameValueHeaderValue?>! {
        get { try! _default.get_ParametersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervalue.scheme)
    public var scheme : String {
        get { try! _default.get_SchemeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervalue.token)
    public var token : String {
        get { try! _default.get_TokenImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection)
public final class HttpChallengeHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpChallengeHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpChallengeHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpChallengeHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpChallengeHeaderValueCollection>?) -> HttpChallengeHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpChallengeHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpChallengeHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpChallengeHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpChallengeHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpChallengeHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpChallengeHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.append)
    public fn append(_ value: HttpChallengeHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpChallengeHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpChallengeHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpchallengeheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervalue)
public final class HttpConnectionOptionHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpConnectionOptionHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpConnectionOptionHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpConnectionOptionHeaderValue>?) -> HttpConnectionOptionHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpConnectionOptionHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpConnectionOptionHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue"))
    public init(_ token: String) {
        super.init(try! Self._IHttpConnectionOptionHeaderValueFactory.CreateImpl(token))
    }

    private static immutable _IHttpConnectionOptionHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpConnectionOptionHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervalue.parse)
    public static fn parse(_ input: String) -> HttpConnectionOptionHeaderValue! {
        return try! _IHttpConnectionOptionHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ connectionOptionHeaderValue: inout HttpConnectionOptionHeaderValue!) -> Boolean {
        return try! _IHttpConnectionOptionHeaderValueStatics.TryParseImpl(input, &connectionOptionHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervalue.token)
    public var token : String {
        get { try! _default.get_TokenImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection)
public final class HttpConnectionOptionHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpConnectionOptionHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpConnectionOptionHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpConnectionOptionHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpConnectionOptionHeaderValueCollection>?) -> HttpConnectionOptionHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpConnectionOptionHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpConnectionOptionHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpConnectionOptionHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpConnectionOptionHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpConnectionOptionHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpConnectionOptionHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.append)
    public fn append(_ value: HttpConnectionOptionHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpConnectionOptionHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpConnectionOptionHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpconnectionoptionheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervalue)
public final class HttpContentCodingHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpContentCodingHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingHeaderValue>?) -> HttpContentCodingHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpContentCodingHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpContentCodingHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentCodingHeaderValue"))
    public init(_ contentCoding: String) {
        super.init(try! Self._IHttpContentCodingHeaderValueFactory.CreateImpl(contentCoding))
    }

    private static immutable _IHttpContentCodingHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpContentCodingHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentCodingHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervalue.parse)
    public static fn parse(_ input: String) -> HttpContentCodingHeaderValue! {
        return try! _IHttpContentCodingHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ contentCodingHeaderValue: inout HttpContentCodingHeaderValue!) -> Boolean {
        return try! _IHttpContentCodingHeaderValueStatics.TryParseImpl(input, &contentCodingHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervalue.contentcoding)
    public var contentCoding : String {
        get { try! _default.get_ContentCodingImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection)
public final class HttpContentCodingHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpContentCodingHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpContentCodingHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingHeaderValueCollection>?) -> HttpContentCodingHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpContentCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpContentCodingHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpContentCodingHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpContentCodingHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpContentCodingHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpContentCodingHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.append)
    public fn append(_ value: HttpContentCodingHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpContentCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpContentCodingHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervalue)
public final class HttpContentCodingWithQualityHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpContentCodingWithQualityHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingWithQualityHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingWithQualityHeaderValue>?) -> HttpContentCodingWithQualityHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpContentCodingWithQualityHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpContentCodingWithQualityHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue"))
    public init(_ contentCoding: String) {
        super.init(try! Self._IHttpContentCodingWithQualityHeaderValueFactory.CreateFromValueImpl(contentCoding))
    }

    public init(_ contentCoding: String, _ quality: Double) {
        super.init(try! Self._IHttpContentCodingWithQualityHeaderValueFactory.CreateFromValueWithQualityImpl(contentCoding, quality))
    }

    private static immutable _IHttpContentCodingWithQualityHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpContentCodingWithQualityHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervalue.parse)
    public static fn parse(_ input: String) -> HttpContentCodingWithQualityHeaderValue! {
        return try! _IHttpContentCodingWithQualityHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ contentCodingWithQualityHeaderValue: inout HttpContentCodingWithQualityHeaderValue!) -> Boolean {
        return try! _IHttpContentCodingWithQualityHeaderValueStatics.TryParseImpl(input, &contentCodingWithQualityHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervalue.contentcoding)
    public var contentCoding : String {
        get { try! _default.get_ContentCodingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervalue.quality)
    public var quality : Double? {
        get { try! _default.get_QualityImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection)
public final class HttpContentCodingWithQualityHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpContentCodingWithQualityHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpContentCodingWithQualityHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingWithQualityHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentCodingWithQualityHeaderValueCollection>?) -> HttpContentCodingWithQualityHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpContentCodingWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpContentCodingWithQualityHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpContentCodingWithQualityHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpContentCodingWithQualityHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpContentCodingWithQualityHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpContentCodingWithQualityHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.append)
    public fn append(_ value: HttpContentCodingWithQualityHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpContentCodingWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpContentCodingWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentcodingwithqualityheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue)
public final class HttpContentDispositionHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpContentDispositionHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentDispositionHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentDispositionHeaderValue>?) -> HttpContentDispositionHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpContentDispositionHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpContentDispositionHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentDispositionHeaderValue"))
    public init(_ dispositionType: String) {
        super.init(try! Self._IHttpContentDispositionHeaderValueFactory.CreateImpl(dispositionType))
    }

    private static immutable _IHttpContentDispositionHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpContentDispositionHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentDispositionHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.parse)
    public static fn parse(_ input: String) -> HttpContentDispositionHeaderValue! {
        return try! _IHttpContentDispositionHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ contentDispositionHeaderValue: inout HttpContentDispositionHeaderValue!) -> Boolean {
        return try! _IHttpContentDispositionHeaderValueStatics.TryParseImpl(input, &contentDispositionHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.dispositiontype)
    public var dispositionType : String {
        get { try! _default.get_DispositionTypeImpl() }
        set { try! _default.put_DispositionTypeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.filename)
    public var fileName : String {
        get { try! _default.get_FileNameImpl() }
        set { try! _default.put_FileNameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.filenamestar)
    public var fileNameStar : String {
        get { try! _default.get_FileNameStarImpl() }
        set { try! _default.put_FileNameStarImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
        set { try! _default.put_NameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.parameters)
    public var parameters : WindowsFoundation.AnyIVector<HttpNameValueHeaderValue?>! {
        get { try! _default.get_ParametersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.size)
    public var size : UInt64? {
        get { try! _default.get_SizeImpl() }
        set { try! _default.put_SizeImpl(newValue) }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentdispositionheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection)
public final class HttpContentHeaderCollection : WinRTClass, IMap, IIterable, WindowsFoundation.IStringable {
    public typealias K = String
    public typealias V = String
    public typealias T = WindowsFoundation.AnyIKeyValuePair<String, String>?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpContentHeaderCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentHeaderCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentHeaderCollection>?) -> HttpContentHeaderCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Web.Http.Headers.HttpContentHeaderCollection")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.append)
    public fn append(_ name: String, _ value: String) throws {
        try _default.AppendImpl(name, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.tryappendwithoutvalidation)
    public fn tryAppendWithoutValidation(_ name: String, _ value: String) throws -> Boolean {
        try _default.TryAppendWithoutValidationImpl(name, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contentdisposition)
    public var contentDisposition : HttpContentDispositionHeaderValue! {
        get { try! _default.get_ContentDispositionImpl() }
        set { try! _default.put_ContentDispositionImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contentencoding)
    public var contentEncoding : HttpContentCodingHeaderValueCollection! {
        get { try! _default.get_ContentEncodingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contentlanguage)
    public var contentLanguage : HttpLanguageHeaderValueCollection! {
        get { try! _default.get_ContentLanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contentlength)
    public var contentLength : UInt64? {
        get { try! _default.get_ContentLengthImpl() }
        set { try! _default.put_ContentLengthImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contentlocation)
    public var contentLocation : WindowsFoundation.Uri! {
        get { try! _default.get_ContentLocationImpl() }
        set { try! _default.put_ContentLocationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contentmd5)
    public var contentMD5 : UWP.AnyIBuffer! {
        get { try! _default.get_ContentMD5Impl() }
        set { try! _default.put_ContentMD5Impl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contentrange)
    public var contentRange : HttpContentRangeHeaderValue! {
        get { try! _default.get_ContentRangeImpl() }
        set { try! _default.put_ContentRangeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.contenttype)
    public var contentType : HttpMediaTypeHeaderValue! {
        get { try! _default.get_ContentTypeImpl() }
        set { try! _default.put_ContentTypeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.expires)
    public var expires : WindowsFoundation.DateTime? {
        get { try! _default.get_ExpiresImpl() }
        set { try! _default.put_ExpiresImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.lastmodified)
    public var lastModified : WindowsFoundation.DateTime? {
        get { try! _default.get_LastModifiedImpl() }
        set { try! _default.put_LastModifiedImpl(newValue) }
    }

    private lazy var _IMap: IMapString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.lookup)
    public fn lookup(_ key: String) -> String {
        try! _IMap.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.haskey)
    public fn hasKey(_ key: String) -> Boolean {
        try! _IMap.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.getview)
    public fn getView() -> WindowsFoundation.AnyIMapView<String, String>? {
        try! _IMap.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.insert)
    public fn insert(_ key: String, _ value: String) -> Boolean {
        try! _IMap.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.remove)
    public fn remove(_ key: String) {
        try! _IMap.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.clear)
    public fn clear() {
        try! _IMap.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.size)
    public var size : UInt32 {
        get { try! _IMap.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentheadercollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IMap = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue)
public final class HttpContentRangeHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpContentRangeHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentRangeHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpContentRangeHeaderValue>?) -> HttpContentRangeHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpContentRangeHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpContentRangeHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentRangeHeaderValue"))
    public init(_ length: UInt64) {
        super.init(try! Self._IHttpContentRangeHeaderValueFactory.CreateFromLengthImpl(length))
    }

    public init(_ from: UInt64, _ to: UInt64) {
        super.init(try! Self._IHttpContentRangeHeaderValueFactory.CreateFromRangeImpl(from, to))
    }

    public init(_ from: UInt64, _ to: UInt64, _ length: UInt64) {
        super.init(try! Self._IHttpContentRangeHeaderValueFactory.CreateFromRangeWithLengthImpl(from, to, length))
    }

    private static immutable _IHttpContentRangeHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpContentRangeHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpContentRangeHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue.parse)
    public static fn parse(_ input: String) -> HttpContentRangeHeaderValue! {
        return try! _IHttpContentRangeHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ contentRangeHeaderValue: inout HttpContentRangeHeaderValue!) -> Boolean {
        return try! _IHttpContentRangeHeaderValueStatics.TryParseImpl(input, &contentRangeHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue.firstbyteposition)
    public var firstBytePosition : UInt64? {
        get { try! _default.get_FirstBytePositionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue.lastbyteposition)
    public var lastBytePosition : UInt64? {
        get { try! _default.get_LastBytePositionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue.length)
    public var length : UInt64? {
        get { try! _default.get_LengthImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue.unit)
    public var unit : String {
        get { try! _default.get_UnitImpl() }
        set { try! _default.put_UnitImpl(newValue) }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcontentrangeheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervalue)
public final class HttpCookiePairHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpCookiePairHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCookiePairHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCookiePairHeaderValue>?) -> HttpCookiePairHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpCookiePairHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpCookiePairHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpCookiePairHeaderValue"))
    public init(_ name: String) {
        super.init(try! Self._IHttpCookiePairHeaderValueFactory.CreateFromNameImpl(name))
    }

    public init(_ name: String, _ value: String) {
        super.init(try! Self._IHttpCookiePairHeaderValueFactory.CreateFromNameWithValueImpl(name, value))
    }

    private static immutable _IHttpCookiePairHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpCookiePairHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpCookiePairHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervalue.parse)
    public static fn parse(_ input: String) -> HttpCookiePairHeaderValue! {
        return try! _IHttpCookiePairHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ cookiePairHeaderValue: inout HttpCookiePairHeaderValue!) -> Boolean {
        return try! _IHttpCookiePairHeaderValueStatics.TryParseImpl(input, &cookiePairHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervalue.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervalue.value)
    public var value : String {
        get { try! _default.get_ValueImpl() }
        set { try! _default.put_ValueImpl(newValue) }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection)
public final class HttpCookiePairHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpCookiePairHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpCookiePairHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCookiePairHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCookiePairHeaderValueCollection>?) -> HttpCookiePairHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpCookiePairHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpCookiePairHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpCookiePairHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpCookiePairHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpCookiePairHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpCookiePairHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.append)
    public fn append(_ value: HttpCookiePairHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpCookiePairHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpCookiePairHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcookiepairheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcredentialsheadervalue)
public final class HttpCredentialsHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpCredentialsHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCredentialsHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpCredentialsHeaderValue>?) -> HttpCredentialsHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpCredentialsHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpCredentialsHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpCredentialsHeaderValue"))
    public init(_ scheme: String) {
        super.init(try! Self._IHttpCredentialsHeaderValueFactory.CreateFromSchemeImpl(scheme))
    }

    public init(_ scheme: String, _ token: String) {
        super.init(try! Self._IHttpCredentialsHeaderValueFactory.CreateFromSchemeWithTokenImpl(scheme, token))
    }

    private static immutable _IHttpCredentialsHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpCredentialsHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpCredentialsHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcredentialsheadervalue.parse)
    public static fn parse(_ input: String) -> HttpCredentialsHeaderValue! {
        return try! _IHttpCredentialsHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcredentialsheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ credentialsHeaderValue: inout HttpCredentialsHeaderValue!) -> Boolean {
        return try! _IHttpCredentialsHeaderValueStatics.TryParseImpl(input, &credentialsHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcredentialsheadervalue.parameters)
    public var parameters : WindowsFoundation.AnyIVector<HttpNameValueHeaderValue?>! {
        get { try! _default.get_ParametersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcredentialsheadervalue.scheme)
    public var scheme : String {
        get { try! _default.get_SchemeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcredentialsheadervalue.token)
    public var token : String {
        get { try! _default.get_TokenImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpcredentialsheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpdateordeltaheadervalue)
public final class HttpDateOrDeltaHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpDateOrDeltaHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpDateOrDeltaHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpDateOrDeltaHeaderValue>?) -> HttpDateOrDeltaHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpDateOrDeltaHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpDateOrDeltaHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpdateordeltaheadervalue.parse)
    public static fn parse(_ input: String) -> HttpDateOrDeltaHeaderValue! {
        return try! _IHttpDateOrDeltaHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpdateordeltaheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ dateOrDeltaHeaderValue: inout HttpDateOrDeltaHeaderValue!) -> Boolean {
        return try! _IHttpDateOrDeltaHeaderValueStatics.TryParseImpl(input, &dateOrDeltaHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpdateordeltaheadervalue.date)
    public var date : WindowsFoundation.DateTime? {
        get { try! _default.get_DateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpdateordeltaheadervalue.delta)
    public var delta : WindowsFoundation.TimeSpan? {
        get { try! _default.get_DeltaImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpdateordeltaheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervalue)
public final class HttpExpectationHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpExpectationHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpExpectationHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpExpectationHeaderValue>?) -> HttpExpectationHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpExpectationHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpExpectationHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpExpectationHeaderValue"))
    public init(_ name: String) {
        super.init(try! Self._IHttpExpectationHeaderValueFactory.CreateFromNameImpl(name))
    }

    public init(_ name: String, _ value: String) {
        super.init(try! Self._IHttpExpectationHeaderValueFactory.CreateFromNameWithValueImpl(name, value))
    }

    private static immutable _IHttpExpectationHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpExpectationHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpExpectationHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervalue.parse)
    public static fn parse(_ input: String) -> HttpExpectationHeaderValue! {
        return try! _IHttpExpectationHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ expectationHeaderValue: inout HttpExpectationHeaderValue!) -> Boolean {
        return try! _IHttpExpectationHeaderValueStatics.TryParseImpl(input, &expectationHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervalue.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervalue.parameters)
    public var parameters : WindowsFoundation.AnyIVector<HttpNameValueHeaderValue?>! {
        get { try! _default.get_ParametersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervalue.value)
    public var value : String {
        get { try! _default.get_ValueImpl() }
        set { try! _default.put_ValueImpl(newValue) }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection)
public final class HttpExpectationHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpExpectationHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpExpectationHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpExpectationHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpExpectationHeaderValueCollection>?) -> HttpExpectationHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpExpectationHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpExpectationHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpExpectationHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpExpectationHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpExpectationHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpExpectationHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.append)
    public fn append(_ value: HttpExpectationHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpExpectationHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpExpectationHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpexpectationheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection)
public final class HttpLanguageHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = UWP.Language?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpLanguageHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpLanguageHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpLanguageHeaderValueCollection>?) -> HttpLanguageHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorLanguage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> UWP.Language? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<UWP.Language?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.indexof)
    public fn indexOf(_ value: UWP.Language?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: UWP.Language?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: UWP.Language?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.append)
    public fn append(_ value: UWP.Language?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableLanguage! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<UWP.Language?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguageheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervalue)
public final class HttpLanguageRangeWithQualityHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpLanguageRangeWithQualityHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpLanguageRangeWithQualityHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpLanguageRangeWithQualityHeaderValue>?) -> HttpLanguageRangeWithQualityHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpLanguageRangeWithQualityHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpLanguageRangeWithQualityHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue"))
    public init(_ languageRange: String) {
        super.init(try! Self._IHttpLanguageRangeWithQualityHeaderValueFactory.CreateFromLanguageRangeImpl(languageRange))
    }

    public init(_ languageRange: String, _ quality: Double) {
        super.init(try! Self._IHttpLanguageRangeWithQualityHeaderValueFactory.CreateFromLanguageRangeWithQualityImpl(languageRange, quality))
    }

    private static immutable _IHttpLanguageRangeWithQualityHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpLanguageRangeWithQualityHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervalue.parse)
    public static fn parse(_ input: String) -> HttpLanguageRangeWithQualityHeaderValue! {
        return try! _IHttpLanguageRangeWithQualityHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ languageRangeWithQualityHeaderValue: inout HttpLanguageRangeWithQualityHeaderValue!) -> Boolean {
        return try! _IHttpLanguageRangeWithQualityHeaderValueStatics.TryParseImpl(input, &languageRangeWithQualityHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervalue.languagerange)
    public var languageRange : String {
        get { try! _default.get_LanguageRangeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervalue.quality)
    public var quality : Double? {
        get { try! _default.get_QualityImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection)
public final class HttpLanguageRangeWithQualityHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpLanguageRangeWithQualityHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpLanguageRangeWithQualityHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpLanguageRangeWithQualityHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpLanguageRangeWithQualityHeaderValueCollection>?) -> HttpLanguageRangeWithQualityHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpLanguageRangeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpLanguageRangeWithQualityHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpLanguageRangeWithQualityHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpLanguageRangeWithQualityHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpLanguageRangeWithQualityHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpLanguageRangeWithQualityHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.append)
    public fn append(_ value: HttpLanguageRangeWithQualityHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpLanguageRangeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpLanguageRangeWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httplanguagerangewithqualityheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypeheadervalue)
public final class HttpMediaTypeHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpMediaTypeHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMediaTypeHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMediaTypeHeaderValue>?) -> HttpMediaTypeHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpMediaTypeHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpMediaTypeHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpMediaTypeHeaderValue"))
    public init(_ mediaType: String) {
        super.init(try! Self._IHttpMediaTypeHeaderValueFactory.CreateImpl(mediaType))
    }

    private static immutable _IHttpMediaTypeHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpMediaTypeHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpMediaTypeHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypeheadervalue.parse)
    public static fn parse(_ input: String) -> HttpMediaTypeHeaderValue! {
        return try! _IHttpMediaTypeHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypeheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ mediaTypeHeaderValue: inout HttpMediaTypeHeaderValue!) -> Boolean {
        return try! _IHttpMediaTypeHeaderValueStatics.TryParseImpl(input, &mediaTypeHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypeheadervalue.charset)
    public var charSet : String {
        get { try! _default.get_CharSetImpl() }
        set { try! _default.put_CharSetImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypeheadervalue.mediatype)
    public var mediaType : String {
        get { try! _default.get_MediaTypeImpl() }
        set { try! _default.put_MediaTypeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypeheadervalue.parameters)
    public var parameters : WindowsFoundation.AnyIVector<HttpNameValueHeaderValue?>! {
        get { try! _default.get_ParametersImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypeheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue)
public final class HttpMediaTypeWithQualityHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpMediaTypeWithQualityHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMediaTypeWithQualityHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMediaTypeWithQualityHeaderValue>?) -> HttpMediaTypeWithQualityHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpMediaTypeWithQualityHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpMediaTypeWithQualityHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue"))
    public init(_ mediaType: String) {
        super.init(try! Self._IHttpMediaTypeWithQualityHeaderValueFactory.CreateFromMediaTypeImpl(mediaType))
    }

    public init(_ mediaType: String, _ quality: Double) {
        super.init(try! Self._IHttpMediaTypeWithQualityHeaderValueFactory.CreateFromMediaTypeWithQualityImpl(mediaType, quality))
    }

    private static immutable _IHttpMediaTypeWithQualityHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpMediaTypeWithQualityHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue.parse)
    public static fn parse(_ input: String) -> HttpMediaTypeWithQualityHeaderValue! {
        return try! _IHttpMediaTypeWithQualityHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ mediaTypeWithQualityHeaderValue: inout HttpMediaTypeWithQualityHeaderValue!) -> Boolean {
        return try! _IHttpMediaTypeWithQualityHeaderValueStatics.TryParseImpl(input, &mediaTypeWithQualityHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue.charset)
    public var charSet : String {
        get { try! _default.get_CharSetImpl() }
        set { try! _default.put_CharSetImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue.mediatype)
    public var mediaType : String {
        get { try! _default.get_MediaTypeImpl() }
        set { try! _default.put_MediaTypeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue.parameters)
    public var parameters : WindowsFoundation.AnyIVector<HttpNameValueHeaderValue?>! {
        get { try! _default.get_ParametersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue.quality)
    public var quality : Double? {
        get { try! _default.get_QualityImpl() }
        set { try! _default.put_QualityImpl(newValue) }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection)
public final class HttpMediaTypeWithQualityHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpMediaTypeWithQualityHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpMediaTypeWithQualityHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMediaTypeWithQualityHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMediaTypeWithQualityHeaderValueCollection>?) -> HttpMediaTypeWithQualityHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpMediaTypeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpMediaTypeWithQualityHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpMediaTypeWithQualityHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpMediaTypeWithQualityHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpMediaTypeWithQualityHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpMediaTypeWithQualityHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.append)
    public fn append(_ value: HttpMediaTypeWithQualityHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpMediaTypeWithQualityHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpMediaTypeWithQualityHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmediatypewithqualityheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection)
public final class HttpMethodHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = UWP.HttpMethod?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpMethodHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMethodHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpMethodHeaderValueCollection>?) -> HttpMethodHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpMethod! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> UWP.HttpMethod? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<UWP.HttpMethod?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.indexof)
    public fn indexOf(_ value: UWP.HttpMethod?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: UWP.HttpMethod?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: UWP.HttpMethod?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.append)
    public fn append(_ value: UWP.HttpMethod?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpMethod! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<UWP.HttpMethod?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpmethodheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpnamevalueheadervalue)
public final class HttpNameValueHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpNameValueHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpNameValueHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpNameValueHeaderValue>?) -> HttpNameValueHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpNameValueHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpNameValueHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpNameValueHeaderValue"))
    public init(_ name: String) {
        super.init(try! Self._IHttpNameValueHeaderValueFactory.CreateFromNameImpl(name))
    }

    public init(_ name: String, _ value: String) {
        super.init(try! Self._IHttpNameValueHeaderValueFactory.CreateFromNameWithValueImpl(name, value))
    }

    private static immutable _IHttpNameValueHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpNameValueHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpNameValueHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpnamevalueheadervalue.parse)
    public static fn parse(_ input: String) -> HttpNameValueHeaderValue! {
        return try! _IHttpNameValueHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpnamevalueheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ nameValueHeaderValue: inout HttpNameValueHeaderValue!) -> Boolean {
        return try! _IHttpNameValueHeaderValueStatics.TryParseImpl(input, &nameValueHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpnamevalueheadervalue.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpnamevalueheadervalue.value)
    public var value : String {
        get { try! _default.get_ValueImpl() }
        set { try! _default.put_ValueImpl(newValue) }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpnamevalueheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductheadervalue)
public final class HttpProductHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpProductHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpProductHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpProductHeaderValue>?) -> HttpProductHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpProductHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpProductHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpProductHeaderValue"))
    public init(_ productName: String) {
        super.init(try! Self._IHttpProductHeaderValueFactory.CreateFromNameImpl(productName))
    }

    public init(_ productName: String, _ productVersion: String) {
        super.init(try! Self._IHttpProductHeaderValueFactory.CreateFromNameWithVersionImpl(productName, productVersion))
    }

    private static immutable _IHttpProductHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpProductHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpProductHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductheadervalue.parse)
    public static fn parse(_ input: String) -> HttpProductHeaderValue! {
        return try! _IHttpProductHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ productHeaderValue: inout HttpProductHeaderValue!) -> Boolean {
        return try! _IHttpProductHeaderValueStatics.TryParseImpl(input, &productHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductheadervalue.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductheadervalue.version)
    public var version : String {
        get { try! _default.get_VersionImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervalue)
public final class HttpProductInfoHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpProductInfoHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpProductInfoHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpProductInfoHeaderValue>?) -> HttpProductInfoHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpProductInfoHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpProductInfoHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpProductInfoHeaderValue"))
    public init(_ productComment: String) {
        super.init(try! Self._IHttpProductInfoHeaderValueFactory.CreateFromCommentImpl(productComment))
    }

    public init(_ productName: String, _ productVersion: String) {
        super.init(try! Self._IHttpProductInfoHeaderValueFactory.CreateFromNameWithVersionImpl(productName, productVersion))
    }

    private static immutable _IHttpProductInfoHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpProductInfoHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpProductInfoHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervalue.parse)
    public static fn parse(_ input: String) -> HttpProductInfoHeaderValue! {
        return try! _IHttpProductInfoHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ productInfoHeaderValue: inout HttpProductInfoHeaderValue!) -> Boolean {
        return try! _IHttpProductInfoHeaderValueStatics.TryParseImpl(input, &productInfoHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervalue.comment)
    public var comment : String {
        get { try! _default.get_CommentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervalue.product)
    public var product : HttpProductHeaderValue! {
        get { try! _default.get_ProductImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection)
public final class HttpProductInfoHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpProductInfoHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpProductInfoHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpProductInfoHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpProductInfoHeaderValueCollection>?) -> HttpProductInfoHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpProductInfoHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpProductInfoHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpProductInfoHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpProductInfoHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpProductInfoHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpProductInfoHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.append)
    public fn append(_ value: HttpProductInfoHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpProductInfoHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpProductInfoHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpproductinfoheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection)
public final class HttpRequestHeaderCollection : WinRTClass, IMap, IIterable, WindowsFoundation.IStringable {
    public typealias K = String
    public typealias V = String
    public typealias T = WindowsFoundation.AnyIKeyValuePair<String, String>?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpRequestHeaderCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpRequestHeaderCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpRequestHeaderCollection>?) -> HttpRequestHeaderCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.append)
    public fn append(_ name: String, _ value: String) throws {
        try _default.AppendImpl(name, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.tryappendwithoutvalidation)
    public fn tryAppendWithoutValidation(_ name: String, _ value: String) throws -> Boolean {
        try _default.TryAppendWithoutValidationImpl(name, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.accept)
    public var accept : HttpMediaTypeWithQualityHeaderValueCollection! {
        get { try! _default.get_AcceptImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.acceptencoding)
    public var acceptEncoding : HttpContentCodingWithQualityHeaderValueCollection! {
        get { try! _default.get_AcceptEncodingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.acceptlanguage)
    public var acceptLanguage : HttpLanguageRangeWithQualityHeaderValueCollection! {
        get { try! _default.get_AcceptLanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.authorization)
    public var authorization : HttpCredentialsHeaderValue! {
        get { try! _default.get_AuthorizationImpl() }
        set { try! _default.put_AuthorizationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.cachecontrol)
    public var cacheControl : HttpCacheDirectiveHeaderValueCollection! {
        get { try! _default.get_CacheControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.connection)
    public var connection : HttpConnectionOptionHeaderValueCollection! {
        get { try! _default.get_ConnectionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.cookie)
    public var cookie : HttpCookiePairHeaderValueCollection! {
        get { try! _default.get_CookieImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.date)
    public var date : WindowsFoundation.DateTime? {
        get { try! _default.get_DateImpl() }
        set { try! _default.put_DateImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.expect)
    public var expect : HttpExpectationHeaderValueCollection! {
        get { try! _default.get_ExpectImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.from)
    public var from : String {
        get { try! _default.get_FromImpl() }
        set { try! _default.put_FromImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.host)
    public var host : UWP.HostName! {
        get { try! _default.get_HostImpl() }
        set { try! _default.put_HostImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.ifmodifiedsince)
    public var ifModifiedSince : WindowsFoundation.DateTime? {
        get { try! _default.get_IfModifiedSinceImpl() }
        set { try! _default.put_IfModifiedSinceImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.ifunmodifiedsince)
    public var ifUnmodifiedSince : WindowsFoundation.DateTime? {
        get { try! _default.get_IfUnmodifiedSinceImpl() }
        set { try! _default.put_IfUnmodifiedSinceImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.maxforwards)
    public var maxForwards : UInt32? {
        get { try! _default.get_MaxForwardsImpl() }
        set { try! _default.put_MaxForwardsImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.proxyauthorization)
    public var proxyAuthorization : HttpCredentialsHeaderValue! {
        get { try! _default.get_ProxyAuthorizationImpl() }
        set { try! _default.put_ProxyAuthorizationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.referer)
    public var referer : WindowsFoundation.Uri! {
        get { try! _default.get_RefererImpl() }
        set { try! _default.put_RefererImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.transferencoding)
    public var transferEncoding : HttpTransferCodingHeaderValueCollection! {
        get { try! _default.get_TransferEncodingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.useragent)
    public var userAgent : HttpProductInfoHeaderValueCollection! {
        get { try! _default.get_UserAgentImpl() }
    }

    private lazy var _IMap: IMapString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.lookup)
    public fn lookup(_ key: String) -> String {
        try! _IMap.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.haskey)
    public fn hasKey(_ key: String) -> Boolean {
        try! _IMap.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.getview)
    public fn getView() -> WindowsFoundation.AnyIMapView<String, String>? {
        try! _IMap.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.insert)
    public fn insert(_ key: String, _ value: String) -> Boolean {
        try! _IMap.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.remove)
    public fn remove(_ key: String) {
        try! _IMap.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.clear)
    public fn clear() {
        try! _IMap.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.size)
    public var size : UInt32 {
        get { try! _IMap.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httprequestheadercollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IMap = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection)
public final class HttpResponseHeaderCollection : WinRTClass, IMap, IIterable, WindowsFoundation.IStringable {
    public typealias K = String
    public typealias V = String
    public typealias T = WindowsFoundation.AnyIKeyValuePair<String, String>?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpResponseHeaderCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpResponseHeaderCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpResponseHeaderCollection>?) -> HttpResponseHeaderCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.append)
    public fn append(_ name: String, _ value: String) throws {
        try _default.AppendImpl(name, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.tryappendwithoutvalidation)
    public fn tryAppendWithoutValidation(_ name: String, _ value: String) throws -> Boolean {
        try _default.TryAppendWithoutValidationImpl(name, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.age)
    public var age : WindowsFoundation.TimeSpan? {
        get { try! _default.get_AgeImpl() }
        set { try! _default.put_AgeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.allow)
    public var allow : HttpMethodHeaderValueCollection! {
        get { try! _default.get_AllowImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.cachecontrol)
    public var cacheControl : HttpCacheDirectiveHeaderValueCollection! {
        get { try! _default.get_CacheControlImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.connection)
    public var connection : HttpConnectionOptionHeaderValueCollection! {
        get { try! _default.get_ConnectionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.date)
    public var date : WindowsFoundation.DateTime? {
        get { try! _default.get_DateImpl() }
        set { try! _default.put_DateImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.location)
    public var location : WindowsFoundation.Uri! {
        get { try! _default.get_LocationImpl() }
        set { try! _default.put_LocationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.proxyauthenticate)
    public var proxyAuthenticate : HttpChallengeHeaderValueCollection! {
        get { try! _default.get_ProxyAuthenticateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.retryafter)
    public var retryAfter : HttpDateOrDeltaHeaderValue! {
        get { try! _default.get_RetryAfterImpl() }
        set { try! _default.put_RetryAfterImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.transferencoding)
    public var transferEncoding : HttpTransferCodingHeaderValueCollection! {
        get { try! _default.get_TransferEncodingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.wwwauthenticate)
    public var wwwAuthenticate : HttpChallengeHeaderValueCollection! {
        get { try! _default.get_WwwAuthenticateImpl() }
    }

    private lazy var _IMap: IMapString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.lookup)
    public fn lookup(_ key: String) -> String {
        try! _IMap.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.haskey)
    public fn hasKey(_ key: String) -> Boolean {
        try! _IMap.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.getview)
    public fn getView() -> WindowsFoundation.AnyIMapView<String, String>? {
        try! _IMap.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.insert)
    public fn insert(_ key: String, _ value: String) -> Boolean {
        try! _IMap.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.remove)
    public fn remove(_ key: String) {
        try! _IMap.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.clear)
    public fn clear() {
        try! _IMap.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.size)
    public var size : UInt32 {
        get { try! _IMap.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairString_String! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<String, String>?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httpresponseheadercollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IMap = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervalue)
public final class HttpTransferCodingHeaderValue : WinRTClass, WindowsFoundation.IStringable {
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpTransferCodingHeaderValue
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpTransferCodingHeaderValue
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpTransferCodingHeaderValue>?) -> HttpTransferCodingHeaderValue? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IHttpTransferCodingHeaderValueFactory: __ABI_Windows_Web_Http_Headers.IHttpTransferCodingHeaderValueFactory = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpTransferCodingHeaderValue"))
    public init(_ input: String) {
        super.init(try! Self._IHttpTransferCodingHeaderValueFactory.CreateImpl(input))
    }

    private static immutable _IHttpTransferCodingHeaderValueStatics: __ABI_Windows_Web_Http_Headers.IHttpTransferCodingHeaderValueStatics = try! RoGetActivationFactory(HString("Windows.Web.Http.Headers.HttpTransferCodingHeaderValue"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervalue.parse)
    public static fn parse(_ input: String) -> HttpTransferCodingHeaderValue! {
        return try! _IHttpTransferCodingHeaderValueStatics.ParseImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervalue.tryparse)
    public static fn tryParse(_ input: String, _ transferCodingHeaderValue: inout HttpTransferCodingHeaderValue!) -> Boolean {
        return try! _IHttpTransferCodingHeaderValueStatics.TryParseImpl(input, &transferCodingHeaderValue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervalue.parameters)
    public var parameters : WindowsFoundation.AnyIVector<HttpNameValueHeaderValue?>! {
        get { try! _default.get_ParametersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervalue.value)
    public var value : String {
        get { try! _default.get_ValueImpl() }
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervalue.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IStringable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection)
public final class HttpTransferCodingHeaderValueCollection : WinRTClass, IVector, IIterable, WindowsFoundation.IStringable {
    public typealias T = HttpTransferCodingHeaderValue?
    private typealias CodiraABI = __ABI_Windows_Web_Http_Headers.IHttpTransferCodingHeaderValueCollection
    private typealias CABI = __x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpTransferCodingHeaderValueCollection
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CWeb_CHttp_CHeaders_CIHttpTransferCodingHeaderValueCollection>?) -> HttpTransferCodingHeaderValueCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.parseadd)
    public fn parseAdd(_ input: String) throws {
        try _default.ParseAddImpl(input)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.tryparseadd)
    public fn tryParseAdd(_ input: String) throws -> Boolean {
        try _default.TryParseAddImpl(input)
    }

    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }


    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    public fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    private lazy var _IVector: IVectorHttpTransferCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.getat)
    public fn getAt(_ index: UInt32) -> HttpTransferCodingHeaderValue? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.getview)
    public fn getView() -> WindowsFoundation.AnyIVectorView<HttpTransferCodingHeaderValue?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.indexof)
    public fn indexOf(_ value: HttpTransferCodingHeaderValue?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.setat)
    public fn setAt(_ index: UInt32, _ value: HttpTransferCodingHeaderValue?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.insertat)
    public fn insertAt(_ index: UInt32, _ value: HttpTransferCodingHeaderValue?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.removeat)
    public fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.append)
    public fn append(_ value: HttpTransferCodingHeaderValue?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.removeatend)
    public fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.clear)
    public fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.size)
    public var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableHttpTransferCodingHeaderValue! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<HttpTransferCodingHeaderValue?>? {
        try! _IIterable.FirstImpl()
    }

    private lazy var _IStringable: __ABI_Windows_Foundation.IStringable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.web.http.headers.httptransfercodingheadervaluecollection.tostring)
    public fn toString() throws -> String {
        try _IStringable.ToStringImpl()
    }

    deinit {
        _default = Nothing
        _IVector = Nothing
        _IIterable = Nothing
        _IStringable = Nothing
    }
}

