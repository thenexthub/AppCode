// WARNING: Please don't edit this file. It was generated by Codira/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiodecoderdegradation)
public typealias AudioDecoderDegradation = __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiodecoderdegradationreason)
public typealias AudioDecoderDegradationReason = __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediadecoderstatus)
public typealias MediaDecoderStatus = __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestate)
public typealias MediaSourceState = __x_ABI_CWindows_CMedia_CCore_CMediaSourceState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatus)
public typealias MediaSourceStatus = __x_ABI_CWindows_CMedia_CCore_CMediaSourceStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedreason)
public typealias MediaStreamSourceClosedReason = __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceerrorstatus)
public typealias MediaStreamSourceErrorStatus = __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediatrackkind)
public typealias MediaTrackKind = __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mseappendmode)
public typealias MseAppendMode = __x_ABI_CWindows_CMedia_CCore_CMseAppendMode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mseendofstreamstatus)
public typealias MseEndOfStreamStatus = __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msereadystate)
public typealias MseReadyState = __x_ABI_CWindows_CMedia_CCore_CMseReadyState
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatakind)
public typealias TimedMetadataKind = __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerrorcode)
public typealias TimedMetadataTrackErrorCode = __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack)
public final class AudioTrack : WinRTClass, IMediaTrack {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaTrack
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaTrack
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaTrack>?) -> AudioTrack? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.id)
    public var id : String {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.label)
    public var label : String {
        get { try! _default.get_LabelImpl() }
        set { try! _default.put_LabelImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.language)
    public var language : String {
        get { try! _default.get_LanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.trackkind)
    public var trackKind : MediaTrackKind {
        get { try! _default.get_TrackKindImpl() }
    }

    private lazy var _IAudioTrack: __ABI_Windows_Media_Core.IAudioTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.getencodingproperties)
    public fn getEncodingProperties() throws -> UWP.AudioEncodingProperties! {
        try _IAudioTrack.GetEncodingPropertiesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.name)
    public var name : String {
        get { try! _IAudioTrack.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.playbackitem)
    public var playbackItem : UWP.MediaPlaybackItem! {
        get { try! _IAudioTrack.get_PlaybackItemImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.supportinfo)
    public var supportInfo : AudioTrackSupportInfo! {
        get { try! _IAudioTrack.get_SupportInfoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrack.openfailed)
    public lazy var openFailed : Event<TypedEventHandler<AudioTrack?, AudioTrackOpenFailedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._IAudioTrack else { return .init() }
          return try! this.add_OpenFailedImpl($0)
        },
        remove: { [weak this] in
         try? this?._IAudioTrack.remove_OpenFailedImpl($0)
       }
      )
    }()

    deinit {
        _default = Nothing
        _IAudioTrack = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrackopenfailedeventargs)
public final class AudioTrackOpenFailedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IAudioTrackOpenFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIAudioTrackOpenFailedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIAudioTrackOpenFailedEventArgs>?) -> AudioTrackOpenFailedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotrackopenfailedeventargs.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo)
public final class AudioTrackSupportInfo : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IAudioTrackSupportInfo
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIAudioTrackSupportInfo
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIAudioTrackSupportInfo>?) -> AudioTrackSupportInfo? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.decoderstatus)
    public var decoderStatus : MediaDecoderStatus {
        get { try! _default.get_DecoderStatusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.degradation)
    public var degradation : AudioDecoderDegradation {
        get { try! _default.get_DegradationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.degradationreason)
    public var degradationReason : AudioDecoderDegradationReason {
        get { try! _default.get_DegradationReasonImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.audiotracksupportinfo.mediasourcestatus)
    public var mediaSourceStatus : MediaSourceStatus {
        get { try! _default.get_MediaSourceStatusImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder)
public final class MediaBinder : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaBinder
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaBinder
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaBinder>?) -> MediaBinder? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.MediaBinder")))
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder.source)
    public var source : MediaSource! {
        get { try! _default.get_SourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder.token)
    public var token : String {
        get { try! _default.get_TokenImpl() }
        set { try! _default.put_TokenImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabinder.binding)
    public lazy var binding : Event<TypedEventHandler<MediaBinder?, MediaBindingEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_BindingImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_BindingImpl($0)
       }
      )
    }()

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs)
public final class MediaBindingEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaBindingEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaBindingEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaBindingEventArgs>?) -> MediaBindingEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.getdeferral)
    public fn getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.seturi)
    public fn setUri(_ uri: WindowsFoundation.Uri!) throws {
        try _default.SetUriImpl(uri)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setstream)
    public fn setStream(_ stream: UWP.AnyIRandomAccessStream!, _ contentType: String) throws {
        try _default.SetStreamImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setstreamreference)
    public fn setStreamReference(_ stream: UWP.AnyIRandomAccessStreamReference!, _ contentType: String) throws {
        try _default.SetStreamReferenceImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.mediabinder)
    public var mediaBinder : MediaBinder! {
        get { try! _default.get_MediaBinderImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.canceled)
    public lazy var canceled : Event<TypedEventHandler<MediaBindingEventArgs?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_CanceledImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_CanceledImpl($0)
       }
      )
    }()

    private lazy var _IMediaBindingEventArgs2: __ABI_Windows_Media_Core.IMediaBindingEventArgs2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setadaptivemediasource)
    public fn setAdaptiveMediaSource(_ mediaSource: UWP.AdaptiveMediaSource!) throws {
        try _IMediaBindingEventArgs2.SetAdaptiveMediaSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setstoragefile)
    public fn setStorageFile(_ file: UWP.AnyIStorageFile!) throws {
        try _IMediaBindingEventArgs2.SetStorageFileImpl(file)
    }

    private lazy var _IMediaBindingEventArgs3: __ABI_Windows_Media_Core.IMediaBindingEventArgs3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediabindingeventargs.setdownloadoperation)
    public fn setDownloadOperation(_ downloadOperation: UWP.DownloadOperation!) throws {
        try _IMediaBindingEventArgs3.SetDownloadOperationImpl(downloadOperation)
    }

    deinit {
        _default = Nothing
        _IMediaBindingEventArgs2 = Nothing
        _IMediaBindingEventArgs3 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediacueeventargs)
public final class MediaCueEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaCueEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaCueEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaCueEventArgs>?) -> MediaCueEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediacueeventargs.cue)
    public var cue : AnyIMediaCue! {
        get { try! _default.get_CueImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource)
public final class MediaSource : WinRTClass, UWP.IMediaPlaybackSource, WindowsFoundation.IClosable {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaSource2
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSource2
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSource2>?) -> MediaSource? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IMediaSourceStatics: __ABI_Windows_Media_Core.IMediaSourceStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromadaptivemediasource)
    public static fn createFromAdaptiveMediaSource(_ mediaSource: UWP.AdaptiveMediaSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromAdaptiveMediaSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommediastreamsource)
    public static fn createFromMediaStreamSource(_ mediaSource: MediaStreamSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromMediaStreamSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommsestreamsource)
    public static fn createFromMseStreamSource(_ mediaSource: MseStreamSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromMseStreamSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromimediasource)
    public static fn createFromIMediaSource(_ mediaSource: AnyIMediaSource!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromIMediaSourceImpl(mediaSource)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromstoragefile)
    public static fn createFromStorageFile(_ file: UWP.AnyIStorageFile!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromStorageFileImpl(file)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromstream)
    public static fn createFromStream(_ stream: UWP.AnyIRandomAccessStream!, _ contentType: String) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromStreamImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromstreamreference)
    public static fn createFromStreamReference(_ stream: UWP.AnyIRandomAccessStreamReference!, _ contentType: String) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromStreamReferenceImpl(stream, contentType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromuri)
    public static fn createFromUri(_ uri: WindowsFoundation.Uri!) -> MediaSource! {
        return try! _IMediaSourceStatics.CreateFromUriImpl(uri)
    }

    private static immutable _IMediaSourceStatics2: __ABI_Windows_Media_Core.IMediaSourceStatics2 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommediabinder)
    public static fn createFromMediaBinder(_ binder: MediaBinder!) -> MediaSource! {
        return try! _IMediaSourceStatics2.CreateFromMediaBinderImpl(binder)
    }

    private static immutable _IMediaSourceStatics3: __ABI_Windows_Media_Core.IMediaSourceStatics3 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfrommediaframesource)
    public static fn createFromMediaFrameSource(_ frameSource: UWP.MediaFrameSource!) -> MediaSource! {
        return try! _IMediaSourceStatics3.CreateFromMediaFrameSourceImpl(frameSource)
    }

    private static immutable _IMediaSourceStatics4: __ABI_Windows_Media_Core.IMediaSourceStatics4 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.createfromdownloadoperation)
    public static fn createFromDownloadOperation(_ downloadOperation: UWP.DownloadOperation!) -> MediaSource! {
        return try! _IMediaSourceStatics4.CreateFromDownloadOperationImpl(downloadOperation)
    }

    private lazy var _IMediaPlaybackSource: __ABI_Windows_Media_Playback.IMediaPlaybackSource! = getInterfaceForCaching()
    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.close)
    public fn close() throws {
        try _IClosable.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.customproperties)
    public var customProperties : WindowsFoundation.ValueSet! {
        get { try! _default.get_CustomPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.duration)
    public var duration : WindowsFoundation.TimeSpan? {
        get { try! _default.get_DurationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.externaltimedmetadatatracks)
    public var externalTimedMetadataTracks : WindowsFoundation.AnyIObservableVector<TimedMetadataTrack?>! {
        get { try! _default.get_ExternalTimedMetadataTracksImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.externaltimedtextsources)
    public var externalTimedTextSources : WindowsFoundation.AnyIObservableVector<TimedTextSource?>! {
        get { try! _default.get_ExternalTimedTextSourcesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.isopen)
    public var isOpen : Boolean {
        get { try! _default.get_IsOpenImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.openoperationcompleted)
    public lazy var openOperationCompleted : Event<TypedEventHandler<MediaSource?, MediaSourceOpenOperationCompletedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_OpenOperationCompletedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_OpenOperationCompletedImpl($0)
       }
      )
    }()

    private lazy var _IMediaSource3: __ABI_Windows_Media_Core.IMediaSource3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.reset)
    public fn reset() throws {
        try _IMediaSource3.ResetImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.state)
    public var state : MediaSourceState {
        get { try! _IMediaSource3.get_StateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.statechanged)
    public lazy var stateChanged : Event<TypedEventHandler<MediaSource?, MediaSourceStateChangedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._IMediaSource3 else { return .init() }
          return try! this.add_StateChangedImpl($0)
        },
        remove: { [weak this] in
         try? this?._IMediaSource3.remove_StateChangedImpl($0)
       }
      )
    }()

    private lazy var _IMediaSource4: __ABI_Windows_Media_Core.IMediaSource4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.openasync)
    public fn openAsync() throws -> WindowsFoundation.AnyIAsyncAction! {
        try _IMediaSource4.OpenAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.adaptivemediasource)
    public var adaptiveMediaSource : UWP.AdaptiveMediaSource! {
        get { try! _IMediaSource4.get_AdaptiveMediaSourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.mediastreamsource)
    public var mediaStreamSource : MediaStreamSource! {
        get { try! _IMediaSource4.get_MediaStreamSourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.msestreamsource)
    public var mseStreamSource : MseStreamSource! {
        get { try! _IMediaSource4.get_MseStreamSourceImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.uri)
    public var uri : WindowsFoundation.Uri! {
        get { try! _IMediaSource4.get_UriImpl() }
    }

    private lazy var _IMediaSource5: __ABI_Windows_Media_Core.IMediaSource5! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasource.downloadoperation)
    public var downloadOperation : UWP.DownloadOperation! {
        get { try! _IMediaSource5.get_DownloadOperationImpl() }
    }

    deinit {
        _IMediaPlaybackSource = Nothing
        _IClosable = Nothing
        _default = Nothing
        _IMediaSource3 = Nothing
        _IMediaSource4 = Nothing
        _IMediaSource5 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceerror)
public final class MediaSourceError : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaSourceError
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSourceError
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSourceError>?) -> MediaSourceError? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceerror.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceopenoperationcompletedeventargs)
public final class MediaSourceOpenOperationCompletedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaSourceOpenOperationCompletedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSourceOpenOperationCompletedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSourceOpenOperationCompletedEventArgs>?) -> MediaSourceOpenOperationCompletedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourceopenoperationcompletedeventargs.error)
    public var error : MediaSourceError! {
        get { try! _default.get_ErrorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatechangedeventargs)
public final class MediaSourceStateChangedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaSourceStateChangedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaSourceStateChangedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaSourceStateChangedEventArgs>?) -> MediaSourceStateChangedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatechangedeventargs.newstate)
    public var newState : MediaSourceState {
        get { try! _default.get_NewStateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediasourcestatechangedeventargs.oldstate)
    public var oldState : MediaSourceState {
        get { try! _default.get_OldStateImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample)
public final class MediaStreamSample : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSample
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSample
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSample>?) -> MediaStreamSample? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static immutable _IMediaStreamSampleStatics: __ABI_Windows_Media_Core.IMediaStreamSampleStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaStreamSample"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.createfrombuffer)
    public static fn createFromBuffer(_ buffer: UWP.AnyIBuffer!, _ timestamp: WindowsFoundation.TimeSpan) -> MediaStreamSample! {
        return try! _IMediaStreamSampleStatics.CreateFromBufferImpl(buffer, timestamp)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.createfromstreamasync)
    public static fn createFromStreamAsync(_ stream: UWP.AnyIInputStream!, _ count: UInt32, _ timestamp: WindowsFoundation.TimeSpan) -> WindowsFoundation.AnyIAsyncOperation<MediaStreamSample?>! {
        return try! _IMediaStreamSampleStatics.CreateFromStreamAsyncImpl(stream, count, timestamp)
    }

    private static immutable _IMediaStreamSampleStatics2: __ABI_Windows_Media_Core.IMediaStreamSampleStatics2 = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaStreamSample"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.createfromdirect3d11surface)
    public static fn createFromDirect3D11Surface(_ surface: UWP.AnyIDirect3DSurface!, _ timestamp: WindowsFoundation.TimeSpan) -> MediaStreamSample! {
        return try! _IMediaStreamSampleStatics2.CreateFromDirect3D11SurfaceImpl(surface, timestamp)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.buffer)
    public var buffer : UWP.Buffer! {
        get { try! _default.get_BufferImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.decodetimestamp)
    public var decodeTimestamp : WindowsFoundation.TimeSpan {
        get { try! _default.get_DecodeTimestampImpl() }
        set { try! _default.put_DecodeTimestampImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.discontinuous)
    public var discontinuous : Boolean {
        get { try! _default.get_DiscontinuousImpl() }
        set { try! _default.put_DiscontinuousImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _default.get_DurationImpl() }
        set { try! _default.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.extendedproperties)
    public var extendedProperties : MediaStreamSamplePropertySet! {
        get { try! _default.get_ExtendedPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.keyframe)
    public var keyFrame : Boolean {
        get { try! _default.get_KeyFrameImpl() }
        set { try! _default.put_KeyFrameImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.protection)
    public var protection : MediaStreamSampleProtectionProperties! {
        get { try! _default.get_ProtectionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.timestamp)
    public var timestamp : WindowsFoundation.TimeSpan {
        get { try! _default.get_TimestampImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.processed)
    public lazy var processed : Event<TypedEventHandler<MediaStreamSample?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_ProcessedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_ProcessedImpl($0)
       }
      )
    }()

    private lazy var _IMediaStreamSample2: __ABI_Windows_Media_Core.IMediaStreamSample2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsample.direct3d11surface)
    public var direct3D11Surface : UWP.AnyIDirect3DSurface! {
        get { try! _IMediaStreamSample2.get_Direct3D11SurfaceImpl() }
    }

    deinit {
        _default = Nothing
        _IMediaStreamSample2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset)
public final class MediaStreamSamplePropertySet : WinRTClass, IMap, IIterable {
    public typealias K = Foundation.UUID
    public typealias V = Any?
    public typealias T = WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?
    private typealias CodiraABI = UWP.IMapUUID_Any
    private typealias CABI = __x_ABI_C__FIMap_2_GUID_IInspectable
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_C__FIMap_2_GUID_IInspectable>?) -> MediaStreamSamplePropertySet? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.lookup)
    public fn lookup(_ key: Foundation.UUID) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.haskey)
    public fn hasKey(_ key: Foundation.UUID) -> Boolean {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.getview)
    public fn getView() -> WindowsFoundation.AnyIMapView<Foundation.UUID, Any?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.insert)
    public fn insert(_ key: Foundation.UUID, _ value: Any?) -> Boolean {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.remove)
    public fn remove(_ key: Foundation.UUID) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.clear)
    public fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairUUID_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsamplepropertyset.first)
    public fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Foundation.UUID, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    deinit {
        _default = Nothing
        _IIterable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsampleprotectionproperties)
public final class MediaStreamSampleProtectionProperties : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSampleProtectionProperties
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSampleProtectionProperties
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSampleProtectionProperties>?) -> MediaStreamSampleProtectionProperties? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource)
public final class MediaStreamSource : WinRTClass, IMediaSource {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSource
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSource
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSource>?) -> MediaStreamSource? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _IMediaStreamSourceFactory: __ABI_Windows_Media_Core.IMediaStreamSourceFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.MediaStreamSource"))
    public init(_ descriptor: AnyIMediaStreamDescriptor!) {
        super.init(try! Self._IMediaStreamSourceFactory.CreateFromDescriptorImpl(descriptor))
    }

    public init(_ descriptor: AnyIMediaStreamDescriptor!, _ descriptor2: AnyIMediaStreamDescriptor!) {
        super.init(try! Self._IMediaStreamSourceFactory.CreateFromDescriptorsImpl(descriptor, descriptor2))
    }

    private lazy var _IMediaSource: __ABI_Windows_Media_Core.IMediaSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.notifyerror)
    public fn notifyError(_ errorStatus: MediaStreamSourceErrorStatus) throws {
        try _default.NotifyErrorImpl(errorStatus)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.addstreamdescriptor)
    public fn addStreamDescriptor(_ descriptor: AnyIMediaStreamDescriptor!) throws {
        try _default.AddStreamDescriptorImpl(descriptor)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.setbufferedrange)
    public fn setBufferedRange(_ startOffset: WindowsFoundation.TimeSpan, _ endOffset: WindowsFoundation.TimeSpan) throws {
        try _default.SetBufferedRangeImpl(startOffset, endOffset)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.buffertime)
    public var bufferTime : WindowsFoundation.TimeSpan {
        get { try! _default.get_BufferTimeImpl() }
        set { try! _default.put_BufferTimeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.canseek)
    public var canSeek : Boolean {
        get { try! _default.get_CanSeekImpl() }
        set { try! _default.put_CanSeekImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.duration)
    public var duration : WindowsFoundation.TimeSpan {
        get { try! _default.get_DurationImpl() }
        set { try! _default.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.mediaprotectionmanager)
    public var mediaProtectionManager : UWP.MediaProtectionManager! {
        get { try! _default.get_MediaProtectionManagerImpl() }
        set { try! _default.put_MediaProtectionManagerImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.musicproperties)
    public var musicProperties : UWP.MusicProperties! {
        get { try! _default.get_MusicPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.thumbnail)
    public var thumbnail : UWP.AnyIRandomAccessStreamReference! {
        get { try! _default.get_ThumbnailImpl() }
        set { try! _default.put_ThumbnailImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.videoproperties)
    public var videoProperties : UWP.VideoProperties! {
        get { try! _default.get_VideoPropertiesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.closed)
    public lazy var closed : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceClosedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_ClosedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_ClosedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.paused)
    public lazy var paused : Event<TypedEventHandler<MediaStreamSource?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_PausedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_PausedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.samplerequested)
    public lazy var sampleRequested : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceSampleRequestedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_SampleRequestedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_SampleRequestedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.starting)
    public lazy var starting : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceStartingEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_StartingImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_StartingImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.switchstreamsrequested)
    public lazy var switchStreamsRequested : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceSwitchStreamsRequestedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_SwitchStreamsRequestedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_SwitchStreamsRequestedImpl($0)
       }
      )
    }()

    private lazy var _IMediaStreamSource2: __ABI_Windows_Media_Core.IMediaStreamSource2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.samplerendered)
    public lazy var sampleRendered : Event<TypedEventHandler<MediaStreamSource?, MediaStreamSourceSampleRenderedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._IMediaStreamSource2 else { return .init() }
          return try! this.add_SampleRenderedImpl($0)
        },
        remove: { [weak this] in
         try? this?._IMediaStreamSource2.remove_SampleRenderedImpl($0)
       }
      )
    }()

    private lazy var _IMediaStreamSource3: __ABI_Windows_Media_Core.IMediaStreamSource3! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.maxsupportedplaybackrate)
    public var maxSupportedPlaybackRate : Double? {
        get { try! _IMediaStreamSource3.get_MaxSupportedPlaybackRateImpl() }
        set { try! _IMediaStreamSource3.put_MaxSupportedPlaybackRateImpl(newValue) }
    }

    private lazy var _IMediaStreamSource4: __ABI_Windows_Media_Core.IMediaStreamSource4! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsource.islive)
    public var isLive : Boolean {
        get { try! _IMediaStreamSource4.get_IsLiveImpl() }
        set { try! _IMediaStreamSource4.put_IsLiveImpl(newValue) }
    }

    deinit {
        _IMediaSource = Nothing
        _default = Nothing
        _IMediaStreamSource2 = Nothing
        _IMediaStreamSource3 = Nothing
        _IMediaStreamSource4 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedeventargs)
public final class MediaStreamSourceClosedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceClosedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedEventArgs>?) -> MediaStreamSourceClosedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedeventargs.request)
    public var request : MediaStreamSourceClosedRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedrequest)
public final class MediaStreamSourceClosedRequest : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceClosedRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedRequest
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceClosedRequest>?) -> MediaStreamSourceClosedRequest? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceclosedrequest.reason)
    public var reason : MediaStreamSourceClosedReason {
        get { try! _default.get_ReasonImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerenderedeventargs)
public final class MediaStreamSourceSampleRenderedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRenderedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRenderedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRenderedEventArgs>?) -> MediaStreamSourceSampleRenderedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerenderedeventargs.samplelag)
    public var sampleLag : WindowsFoundation.TimeSpan {
        get { try! _default.get_SampleLagImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest)
public final class MediaStreamSourceSampleRequest : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequest
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequest>?) -> MediaStreamSourceSampleRequest? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.getdeferral)
    public fn getDeferral() throws -> MediaStreamSourceSampleRequestDeferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.reportsampleprogress)
    public fn reportSampleProgress(_ progress: UInt32) throws {
        try _default.ReportSampleProgressImpl(progress)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.sample)
    public var sample : MediaStreamSample! {
        get { try! _default.get_SampleImpl() }
        set { try! _default.put_SampleImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequest.streamdescriptor)
    public var streamDescriptor : AnyIMediaStreamDescriptor! {
        get { try! _default.get_StreamDescriptorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestdeferral)
public final class MediaStreamSourceSampleRequestDeferral : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRequestDeferral
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestDeferral
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestDeferral>?) -> MediaStreamSourceSampleRequestDeferral? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestdeferral.complete)
    public fn complete() throws {
        try _default.CompleteImpl()
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestedeventargs)
public final class MediaStreamSourceSampleRequestedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceSampleRequestedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSampleRequestedEventArgs>?) -> MediaStreamSourceSampleRequestedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcesamplerequestedeventargs.request)
    public var request : MediaStreamSourceSampleRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingeventargs)
public final class MediaStreamSourceStartingEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceStartingEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingEventArgs>?) -> MediaStreamSourceStartingEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingeventargs.request)
    public var request : MediaStreamSourceStartingRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest)
public final class MediaStreamSourceStartingRequest : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceStartingRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequest
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequest>?) -> MediaStreamSourceStartingRequest? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest.getdeferral)
    public fn getDeferral() throws -> MediaStreamSourceStartingRequestDeferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest.setactualstartposition)
    public fn setActualStartPosition(_ position: WindowsFoundation.TimeSpan) throws {
        try _default.SetActualStartPositionImpl(position)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequest.startposition)
    public var startPosition : WindowsFoundation.TimeSpan? {
        get { try! _default.get_StartPositionImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequestdeferral)
public final class MediaStreamSourceStartingRequestDeferral : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceStartingRequestDeferral
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequestDeferral
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceStartingRequestDeferral>?) -> MediaStreamSourceStartingRequestDeferral? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourcestartingrequestdeferral.complete)
    public fn complete() throws {
        try _default.CompleteImpl()
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest)
public final class MediaStreamSourceSwitchStreamsRequest : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceSwitchStreamsRequest
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequest
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequest>?) -> MediaStreamSourceSwitchStreamsRequest? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest.getdeferral)
    public fn getDeferral() throws -> MediaStreamSourceSwitchStreamsRequestDeferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest.newstreamdescriptor)
    public var newStreamDescriptor : AnyIMediaStreamDescriptor! {
        get { try! _default.get_NewStreamDescriptorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequest.oldstreamdescriptor)
    public var oldStreamDescriptor : AnyIMediaStreamDescriptor! {
        get { try! _default.get_OldStreamDescriptorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestdeferral)
public final class MediaStreamSourceSwitchStreamsRequestDeferral : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceSwitchStreamsRequestDeferral
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestDeferral
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestDeferral>?) -> MediaStreamSourceSwitchStreamsRequestDeferral? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestdeferral.complete)
    public fn complete() throws {
        try _default.CompleteImpl()
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestedeventargs)
public final class MediaStreamSourceSwitchStreamsRequestedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaStreamSourceSwitchStreamsRequestedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaStreamSourceSwitchStreamsRequestedEventArgs>?) -> MediaStreamSourceSwitchStreamsRequestedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.mediastreamsourceswitchstreamsrequestedeventargs.request)
    public var request : MediaStreamSourceSwitchStreamsRequest! {
        get { try! _default.get_RequestImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer)
public final class MseSourceBuffer : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMseSourceBuffer
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMseSourceBuffer
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMseSourceBuffer>?) -> MseSourceBuffer? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendbuffer)
    public fn appendBuffer(_ buffer: UWP.AnyIBuffer!) throws {
        try _default.AppendBufferImpl(buffer)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendstream)
    public fn appendStream(_ stream: UWP.AnyIInputStream!) throws {
        try _default.AppendStreamImpl(stream)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendstream)
    public fn appendStream(_ stream: UWP.AnyIInputStream!, _ maxSize: UInt64) throws {
        try _default.AppendStreamMaxSizeImpl(stream, maxSize)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.abort)
    public fn abort() throws {
        try _default.AbortImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.remove)
    public fn remove(_ start: WindowsFoundation.TimeSpan, _ end: WindowsFoundation.TimeSpan?) throws {
        try _default.RemoveImpl(start, end)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendwindowend)
    public var appendWindowEnd : WindowsFoundation.TimeSpan? {
        get { try! _default.get_AppendWindowEndImpl() }
        set { try! _default.put_AppendWindowEndImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.appendwindowstart)
    public var appendWindowStart : WindowsFoundation.TimeSpan {
        get { try! _default.get_AppendWindowStartImpl() }
        set { try! _default.put_AppendWindowStartImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.buffered)
    public var buffered : WindowsFoundation.AnyIVectorView<MseTimeRange>! {
        get { try! _default.get_BufferedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.isupdating)
    public var isUpdating : Boolean {
        get { try! _default.get_IsUpdatingImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.mode)
    public var mode : MseAppendMode {
        get { try! _default.get_ModeImpl() }
        set { try! _default.put_ModeImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.timestampoffset)
    public var timestampOffset : WindowsFoundation.TimeSpan {
        get { try! _default.get_TimestampOffsetImpl() }
        set { try! _default.put_TimestampOffsetImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.aborted)
    public lazy var aborted : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_AbortedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_AbortedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.erroroccurred)
    public lazy var errorOccurred : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_ErrorOccurredImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_ErrorOccurredImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.updateended)
    public lazy var updateEnded : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_UpdateEndedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_UpdateEndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.updatestarting)
    public lazy var updateStarting : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_UpdateStartingImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_UpdateStartingImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebuffer.updated)
    public lazy var updated : Event<TypedEventHandler<MseSourceBuffer?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_UpdatedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_UpdatedImpl($0)
       }
      )
    }()

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist)
public final class MseSourceBufferList : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMseSourceBufferList
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMseSourceBufferList
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMseSourceBufferList>?) -> MseSourceBufferList? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist.buffers)
    public var buffers : WindowsFoundation.AnyIVectorView<MseSourceBuffer?>! {
        get { try! _default.get_BuffersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist.sourcebufferadded)
    public lazy var sourceBufferAdded : Event<TypedEventHandler<MseSourceBufferList?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_SourceBufferAddedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_SourceBufferAddedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msesourcebufferlist.sourcebufferremoved)
    public lazy var sourceBufferRemoved : Event<TypedEventHandler<MseSourceBufferList?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_SourceBufferRemovedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_SourceBufferRemovedImpl($0)
       }
      )
    }()

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource)
public final class MseStreamSource : WinRTClass, IMediaSource {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMseStreamSource
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMseStreamSource
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMseStreamSource>?) -> MseStreamSource? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    override public init() {
        super.init(try! RoActivateInstance(HString("Windows.Media.Core.MseStreamSource")))
    }

    private static immutable _IMseStreamSourceStatics: __ABI_Windows_Media_Core.IMseStreamSourceStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.MseStreamSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.iscontenttypesupported)
    public static fn isContentTypeSupported(_ contentType: String) -> Boolean {
        return try! _IMseStreamSourceStatics.IsContentTypeSupportedImpl(contentType)
    }

    private lazy var _IMediaSource: __ABI_Windows_Media_Core.IMediaSource! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.addsourcebuffer)
    public fn addSourceBuffer(_ mimeType: String) throws -> MseSourceBuffer! {
        try _default.AddSourceBufferImpl(mimeType)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.removesourcebuffer)
    public fn removeSourceBuffer(_ buffer: MseSourceBuffer!) throws {
        try _default.RemoveSourceBufferImpl(buffer)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.endofstream)
    public fn endOfStream(_ status: MseEndOfStreamStatus) throws {
        try _default.EndOfStreamImpl(status)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.activesourcebuffers)
    public var activeSourceBuffers : MseSourceBufferList! {
        get { try! _default.get_ActiveSourceBuffersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.duration)
    public var duration : WindowsFoundation.TimeSpan? {
        get { try! _default.get_DurationImpl() }
        set { try! _default.put_DurationImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.readystate)
    public var readyState : MseReadyState {
        get { try! _default.get_ReadyStateImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.sourcebuffers)
    public var sourceBuffers : MseSourceBufferList! {
        get { try! _default.get_SourceBuffersImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.closed)
    public lazy var closed : Event<TypedEventHandler<MseStreamSource?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_ClosedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_ClosedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.ended)
    public lazy var ended : Event<TypedEventHandler<MseStreamSource?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_EndedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_EndedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.opened)
    public lazy var opened : Event<TypedEventHandler<MseStreamSource?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_OpenedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_OpenedImpl($0)
       }
      )
    }()

    private lazy var _IMseStreamSource2: __ABI_Windows_Media_Core.IMseStreamSource2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msestreamsource.liveseekablerange)
    public var liveSeekableRange : MseTimeRange? {
        get { try! _IMseStreamSource2.get_LiveSeekableRangeImpl() }
        set { try! _IMseStreamSource2.put_LiveSeekableRangeImpl(newValue) }
    }

    deinit {
        _IMediaSource = Nothing
        _default = Nothing
        _IMseStreamSource2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack)
public final class TimedMetadataTrack : WinRTClass, IMediaTrack {
    private typealias CodiraABI = __ABI_Windows_Media_Core.ITimedMetadataTrack
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrack
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrack>?) -> TimedMetadataTrack? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private static immutable _ITimedMetadataTrackFactory: __ABI_Windows_Media_Core.ITimedMetadataTrackFactory = try! RoGetActivationFactory(HString("Windows.Media.Core.TimedMetadataTrack"))
    public init(_ id: String, _ language: String, _ kind: TimedMetadataKind) {
        super.init(try! Self._ITimedMetadataTrackFactory.CreateImpl(id, language, kind))
    }

    private lazy var _IMediaTrack: __ABI_Windows_Media_Core.IMediaTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.id)
    public var id : String {
        get { try! _IMediaTrack.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.label)
    public var label : String {
        get { try! _IMediaTrack.get_LabelImpl() }
        set { try! _IMediaTrack.put_LabelImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.language)
    public var language : String {
        get { try! _IMediaTrack.get_LanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.trackkind)
    public var trackKind : MediaTrackKind {
        get { try! _IMediaTrack.get_TrackKindImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.addcue)
    public fn addCue(_ cue: AnyIMediaCue!) throws {
        try _default.AddCueImpl(cue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.removecue)
    public fn removeCue(_ cue: AnyIMediaCue!) throws {
        try _default.RemoveCueImpl(cue)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.activecues)
    public var activeCues : WindowsFoundation.AnyIVectorView<AnyIMediaCue?>! {
        get { try! _default.get_ActiveCuesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.cues)
    public var cues : WindowsFoundation.AnyIVectorView<AnyIMediaCue?>! {
        get { try! _default.get_CuesImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.dispatchtype)
    public var dispatchType : String {
        get { try! _default.get_DispatchTypeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.timedmetadatakind)
    public var timedMetadataKind : TimedMetadataKind {
        get { try! _default.get_TimedMetadataKindImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.cueentered)
    public lazy var cueEntered : Event<TypedEventHandler<TimedMetadataTrack?, MediaCueEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_CueEnteredImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_CueEnteredImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.cueexited)
    public lazy var cueExited : Event<TypedEventHandler<TimedMetadataTrack?, MediaCueEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_CueExitedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_CueExitedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.trackfailed)
    public lazy var trackFailed : Event<TypedEventHandler<TimedMetadataTrack?, TimedMetadataTrackFailedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_TrackFailedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_TrackFailedImpl($0)
       }
      )
    }()

    private lazy var _ITimedMetadataTrack2: __ABI_Windows_Media_Core.ITimedMetadataTrack2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.name)
    public var name : String {
        get { try! _ITimedMetadataTrack2.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrack.playbackitem)
    public var playbackItem : UWP.MediaPlaybackItem! {
        get { try! _ITimedMetadataTrack2.get_PlaybackItemImpl() }
    }

    deinit {
        _IMediaTrack = Nothing
        _default = Nothing
        _ITimedMetadataTrack2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerror)
public final class TimedMetadataTrackError : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.ITimedMetadataTrackError
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackError
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackError>?) -> TimedMetadataTrackError? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerror.errorcode)
    public var errorCode : TimedMetadataTrackErrorCode {
        get { try! _default.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackerror.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackfailedeventargs)
public final class TimedMetadataTrackFailedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.ITimedMetadataTrackFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackFailedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedMetadataTrackFailedEventArgs>?) -> TimedMetadataTrackFailedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedmetadatatrackfailedeventargs.error)
    public var error : TimedMetadataTrackError! {
        get { try! _default.get_ErrorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource)
public final class TimedTextSource : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.ITimedTextSource
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextSource
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextSource>?) -> TimedTextSource? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static immutable _ITimedTextSourceStatics: __ABI_Windows_Media_Core.ITimedTextSourceStatics = try! RoGetActivationFactory(HString("Windows.Media.Core.TimedTextSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstream)
    public static fn createFromStream(_ stream: UWP.AnyIRandomAccessStream!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromStreamImpl(stream)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuri)
    public static fn createFromUri(_ uri: WindowsFoundation.Uri!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromUriImpl(uri)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstream)
    public static fn createFromStream(_ stream: UWP.AnyIRandomAccessStream!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromStreamWithLanguageImpl(stream, defaultLanguage)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuri)
    public static fn createFromUri(_ uri: WindowsFoundation.Uri!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics.CreateFromUriWithLanguageImpl(uri, defaultLanguage)
    }

    private static immutable _ITimedTextSourceStatics2: __ABI_Windows_Media_Core.ITimedTextSourceStatics2 = try! RoGetActivationFactory(HString("Windows.Media.Core.TimedTextSource"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstreamwithindex)
    public static fn createFromStreamWithIndex(_ stream: UWP.AnyIRandomAccessStream!, _ indexStream: UWP.AnyIRandomAccessStream!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromStreamWithIndexImpl(stream, indexStream)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuriwithindex)
    public static fn createFromUriWithIndex(_ uri: WindowsFoundation.Uri!, _ indexUri: WindowsFoundation.Uri!) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromUriWithIndexImpl(uri, indexUri)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromstreamwithindex)
    public static fn createFromStreamWithIndex(_ stream: UWP.AnyIRandomAccessStream!, _ indexStream: UWP.AnyIRandomAccessStream!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromStreamWithIndexAndLanguageImpl(stream, indexStream, defaultLanguage)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.createfromuriwithindex)
    public static fn createFromUriWithIndex(_ uri: WindowsFoundation.Uri!, _ indexUri: WindowsFoundation.Uri!, _ defaultLanguage: String) -> TimedTextSource! {
        return try! _ITimedTextSourceStatics2.CreateFromUriWithIndexAndLanguageImpl(uri, indexUri, defaultLanguage)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsource.resolved)
    public lazy var resolved : Event<TypedEventHandler<TimedTextSource?, TimedTextSourceResolveResultEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_ResolvedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_ResolvedImpl($0)
       }
      )
    }()

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsourceresolveresulteventargs)
public final class TimedTextSourceResolveResultEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.ITimedTextSourceResolveResultEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CITimedTextSourceResolveResultEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CITimedTextSourceResolveResultEventArgs>?) -> TimedTextSourceResolveResultEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsourceresolveresulteventargs.error)
    public var error : TimedMetadataTrackError! {
        get { try! _default.get_ErrorImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.timedtextsourceresolveresulteventargs.tracks)
    public var tracks : WindowsFoundation.AnyIVectorView<TimedMetadataTrack?>! {
        get { try! _default.get_TracksImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack)
public final class VideoTrack : WinRTClass, IMediaTrack {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IMediaTrack
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIMediaTrack
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIMediaTrack>?) -> VideoTrack? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.id)
    public var id : String {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.label)
    public var label : String {
        get { try! _default.get_LabelImpl() }
        set { try! _default.put_LabelImpl(newValue) }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.language)
    public var language : String {
        get { try! _default.get_LanguageImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.trackkind)
    public var trackKind : MediaTrackKind {
        get { try! _default.get_TrackKindImpl() }
    }

    private lazy var _IVideoTrack: __ABI_Windows_Media_Core.IVideoTrack! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.getencodingproperties)
    public fn getEncodingProperties() throws -> UWP.VideoEncodingProperties! {
        try _IVideoTrack.GetEncodingPropertiesImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.name)
    public var name : String {
        get { try! _IVideoTrack.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.playbackitem)
    public var playbackItem : UWP.MediaPlaybackItem! {
        get { try! _IVideoTrack.get_PlaybackItemImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.supportinfo)
    public var supportInfo : VideoTrackSupportInfo! {
        get { try! _IVideoTrack.get_SupportInfoImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrack.openfailed)
    public lazy var openFailed : Event<TypedEventHandler<VideoTrack?, VideoTrackOpenFailedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._IVideoTrack else { return .init() }
          return try! this.add_OpenFailedImpl($0)
        },
        remove: { [weak this] in
         try? this?._IVideoTrack.remove_OpenFailedImpl($0)
       }
      )
    }()

    deinit {
        _default = Nothing
        _IVideoTrack = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrackopenfailedeventargs)
public final class VideoTrackOpenFailedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IVideoTrackOpenFailedEventArgs
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIVideoTrackOpenFailedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIVideoTrackOpenFailedEventArgs>?) -> VideoTrackOpenFailedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotrackopenfailedeventargs.extendederror)
    public var extendedError : HRESULT {
        get { try! _default.get_ExtendedErrorImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotracksupportinfo)
public final class VideoTrackSupportInfo : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Media_Core.IVideoTrackSupportInfo
    private typealias CABI = __x_ABI_CWindows_CMedia_CCore_CIVideoTrackSupportInfo
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CMedia_CCore_CIVideoTrackSupportInfo>?) -> VideoTrackSupportInfo? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotracksupportinfo.decoderstatus)
    public var decoderStatus : MediaDecoderStatus {
        get { try! _default.get_DecoderStatusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.videotracksupportinfo.mediasourcestatus)
    public var mediaSourceStatus : MediaSourceStatus {
        get { try! _default.get_MediaSourceStatusImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msetimerange)
public struct MseTimeRange: Hashable, Codable {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msetimerange.start)
    public var start: WindowsFoundation.TimeSpan = .init()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.msetimerange.end)
    public var end: WindowsFoundation.TimeSpan = .init()
    public init() {}
    public init(start: WindowsFoundation.TimeSpan, end: WindowsFoundation.TimeSpan) {
        this.start = start
        this.end = end
    }
    public static fn from(abi: __x_ABI_CWindows_CMedia_CCore_CMseTimeRange) -> MseTimeRange {
        .init(start: .from(abi: abi.Start), end: .from(abi: abi.End))
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue)
public protocol IMediaCue : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue.duration)
    var duration: WindowsFoundation.TimeSpan { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue.id)
    var id: String { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediacue.starttime)
    var startTime: WindowsFoundation.TimeSpan { get set }
}

extension IMediaCue {
    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaCueWrapper.IID:
                immutable wrapper = __ABI_Windows_Media_Core.IMediaCueWrapper(this)
                return wrapper!.queryInterface(iid)
            default: return Nothing
        }
    }
}
public typealias AnyIMediaCue = any IMediaCue

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediasource)
public protocol IMediaSource : WinRTInterface {
}

extension IMediaSource {
    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaSourceWrapper.IID:
                immutable wrapper = __ABI_Windows_Media_Core.IMediaSourceWrapper(this)
                return wrapper!.queryInterface(iid)
            default: return Nothing
        }
    }
}
public typealias AnyIMediaSource = any IMediaSource

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor)
public protocol IMediaStreamDescriptor : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor.isselected)
    var isSelected: Boolean { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor.language)
    var language: String { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediastreamdescriptor.name)
    var name: String { get set }
}

extension IMediaStreamDescriptor {
    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaStreamDescriptorWrapper.IID:
                immutable wrapper = __ABI_Windows_Media_Core.IMediaStreamDescriptorWrapper(this)
                return wrapper!.queryInterface(iid)
            default: return Nothing
        }
    }
}
public typealias AnyIMediaStreamDescriptor = any IMediaStreamDescriptor

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack)
public protocol IMediaTrack : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.id)
    var id: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.label)
    var label: String { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.language)
    var language: String { get }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.imediatrack.trackkind)
    var trackKind: UWP.MediaTrackKind { get }
}

extension IMediaTrack {
    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.IMediaTrackWrapper.IID:
                immutable wrapper = __ABI_Windows_Media_Core.IMediaTrackWrapper(this)
                return wrapper!.queryInterface(iid)
            default: return Nothing
        }
    }
}
public typealias AnyIMediaTrack = any IMediaTrack

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.isingleselectmediatracklist)
public protocol ISingleSelectMediaTrackList : WinRTInterface {
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.isingleselectmediatracklist.selectedindex)
    var selectedIndex: Int32 { get set }
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.media.core.isingleselectmediatracklist.selectedindexchanged)
    var selectedIndexChanged: Event<TypedEventHandler<ISingleSelectMediaTrackList?, Any?>> { get }
}

extension ISingleSelectMediaTrackList {
    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Media_Core.ISingleSelectMediaTrackListWrapper.IID:
                immutable wrapper = __ABI_Windows_Media_Core.ISingleSelectMediaTrackListWrapper(this)
                return wrapper!.queryInterface(iid)
            default: return Nothing
        }
    }
}
public typealias AnyISingleSelectMediaTrackList = any ISingleSelectMediaTrackList

extension UWP.AudioDecoderDegradation {
    public static var none : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_None
    }
    public static var downmixTo2Channels : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_DownmixTo2Channels
    }
    public static var downmixTo6Channels : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_DownmixTo6Channels
    }
    public static var downmixTo8Channels : UWP.AudioDecoderDegradation {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradation_DownmixTo8Channels
    }
}
extension UWP.AudioDecoderDegradation: @retroactive Hashable, @retroactive Codable {}

extension UWP.AudioDecoderDegradationReason {
    public static var none : UWP.AudioDecoderDegradationReason {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason_None
    }
    public static var licensingRequirement : UWP.AudioDecoderDegradationReason {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason_LicensingRequirement
    }
    public static var spatialAudioNotSupported : UWP.AudioDecoderDegradationReason {
        __x_ABI_CWindows_CMedia_CCore_CAudioDecoderDegradationReason_SpatialAudioNotSupported
    }
}
extension UWP.AudioDecoderDegradationReason: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaDecoderStatus {
    public static var fullySupported : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_FullySupported
    }
    public static var unsupportedSubtype : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_UnsupportedSubtype
    }
    public static var unsupportedEncoderProperties : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_UnsupportedEncoderProperties
    }
    public static var degraded : UWP.MediaDecoderStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaDecoderStatus_Degraded
    }
}
extension UWP.MediaDecoderStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaSourceState {
    public static var initial : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Initial
    }
    public static var opening : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Opening
    }
    public static var opened : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Opened
    }
    public static var failed : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Failed
    }
    public static var closed : UWP.MediaSourceState {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceState_Closed
    }
}
extension UWP.MediaSourceState: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaSourceStatus {
    public static var fullySupported : UWP.MediaSourceStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceStatus_FullySupported
    }
    public static var unknown : UWP.MediaSourceStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaSourceStatus_Unknown
    }
}
extension UWP.MediaSourceStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaStreamSourceClosedReason {
    public static var done : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_Done
    }
    public static var unknownError : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_UnknownError
    }
    public static var appReportedError : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_AppReportedError
    }
    public static var unsupportedProtectionSystem : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_UnsupportedProtectionSystem
    }
    public static var protectionSystemFailure : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_ProtectionSystemFailure
    }
    public static var unsupportedEncodingFormat : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_UnsupportedEncodingFormat
    }
    public static var missingSampleRequestedEventHandler : UWP.MediaStreamSourceClosedReason {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceClosedReason_MissingSampleRequestedEventHandler
    }
}
extension UWP.MediaStreamSourceClosedReason: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaStreamSourceErrorStatus {
    public static var other : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_Other
    }
    public static var outOfMemory : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_OutOfMemory
    }
    public static var failedToOpenFile : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_FailedToOpenFile
    }
    public static var failedToConnectToServer : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_FailedToConnectToServer
    }
    public static var connectionToServerLost : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_ConnectionToServerLost
    }
    public static var unspecifiedNetworkError : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_UnspecifiedNetworkError
    }
    public static var decodeError : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_DecodeError
    }
    public static var unsupportedMediaFormat : UWP.MediaStreamSourceErrorStatus {
        __x_ABI_CWindows_CMedia_CCore_CMediaStreamSourceErrorStatus_UnsupportedMediaFormat
    }
}
extension UWP.MediaStreamSourceErrorStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MediaTrackKind {
    public static var audio : UWP.MediaTrackKind {
        __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind_Audio
    }
    public static var video : UWP.MediaTrackKind {
        __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind_Video
    }
    public static var timedMetadata : UWP.MediaTrackKind {
        __x_ABI_CWindows_CMedia_CCore_CMediaTrackKind_TimedMetadata
    }
}
extension UWP.MediaTrackKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.MseAppendMode {
    public static var segments : UWP.MseAppendMode {
        __x_ABI_CWindows_CMedia_CCore_CMseAppendMode_Segments
    }
    public static var sequence : UWP.MseAppendMode {
        __x_ABI_CWindows_CMedia_CCore_CMseAppendMode_Sequence
    }
}
extension UWP.MseAppendMode: @retroactive Hashable, @retroactive Codable {}

extension UWP.MseEndOfStreamStatus {
    public static var success : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_Success
    }
    public static var networkError : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_NetworkError
    }
    public static var decodeError : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_DecodeError
    }
    public static var unknownError : UWP.MseEndOfStreamStatus {
        __x_ABI_CWindows_CMedia_CCore_CMseEndOfStreamStatus_UnknownError
    }
}
extension UWP.MseEndOfStreamStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.MseReadyState {
    public static var closed : UWP.MseReadyState {
        __x_ABI_CWindows_CMedia_CCore_CMseReadyState_Closed
    }
    public static var open : UWP.MseReadyState {
        __x_ABI_CWindows_CMedia_CCore_CMseReadyState_Open
    }
    public static var ended : UWP.MseReadyState {
        __x_ABI_CWindows_CMedia_CCore_CMseReadyState_Ended
    }
}
extension UWP.MseReadyState: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedMetadataKind {
    public static var caption : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Caption
    }
    public static var chapter : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Chapter
    }
    public static var custom : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Custom
    }
    public static var data : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Data
    }
    public static var description : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Description
    }
    public static var subtitle : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Subtitle
    }
    public static var imageSubtitle : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_ImageSubtitle
    }
    public static var speech : UWP.TimedMetadataKind {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataKind_Speech
    }
}
extension UWP.TimedMetadataKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.TimedMetadataTrackErrorCode {
    public static var none : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_None
    }
    public static var dataFormatError : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_DataFormatError
    }
    public static var networkError : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_NetworkError
    }
    public static var internalError : UWP.TimedMetadataTrackErrorCode {
        __x_ABI_CWindows_CMedia_CCore_CTimedMetadataTrackErrorCode_InternalError
    }
}
extension UWP.TimedMetadataTrackErrorCode: @retroactive Hashable, @retroactive Codable {}

