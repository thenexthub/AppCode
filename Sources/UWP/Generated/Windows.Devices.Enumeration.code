// WARNING: Please don't edit this file. It was generated by Codira/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceclass)
public typealias DeviceClass = __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationkind)
public typealias DeviceInformationKind = __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingkinds)
public typealias DevicePairingKinds = __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingKinds
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingprotectionlevel)
public typealias DevicePairingProtectionLevel = __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingProtectionLevel
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingresultstatus)
public typealias DevicePairingResultStatus = __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceunpairingresultstatus)
public typealias DeviceUnpairingResultStatus = __x_ABI_CWindows_CDevices_CEnumeration_CDeviceUnpairingResultStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatchereventkind)
public typealias DeviceWatcherEventKind = __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherEventKind
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcherstatus)
public typealias DeviceWatcherStatus = __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherStatus
/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation)
public final class DeviceInformation : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDeviceInformation
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformation
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformation>?) -> DeviceInformation? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static immutable _IDeviceInformationStatics: __ABI_Windows_Devices_Enumeration.IDeviceInformationStatics = try! RoGetActivationFactory(HString("Windows.Devices.Enumeration.DeviceInformation"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createfromidasync)
    public static fn createFromIdAsync(_ deviceId: String) -> WindowsFoundation.AnyIAsyncOperation<DeviceInformation?>! {
        return try! _IDeviceInformationStatics.CreateFromIdAsyncImpl(deviceId)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createfromidasync)
    public static fn createFromIdAsync(_ deviceId: String, _ additionalProperties: WindowsFoundation.AnyIIterable<String>!) -> WindowsFoundation.AnyIAsyncOperation<DeviceInformation?>! {
        return try! _IDeviceInformationStatics.CreateFromIdAsyncAdditionalPropertiesImpl(deviceId, additionalProperties)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.findallasync)
    public static fn findAllAsync() -> WindowsFoundation.AnyIAsyncOperation<DeviceInformationCollection?>! {
        return try! _IDeviceInformationStatics.FindAllAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.findallasync)
    public static fn findAllAsync(_ deviceClass: DeviceClass) -> WindowsFoundation.AnyIAsyncOperation<DeviceInformationCollection?>! {
        return try! _IDeviceInformationStatics.FindAllAsyncDeviceClassImpl(deviceClass)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.findallasync)
    public static fn findAllAsync(_ aqsFilter: String) -> WindowsFoundation.AnyIAsyncOperation<DeviceInformationCollection?>! {
        return try! _IDeviceInformationStatics.FindAllAsyncAqsFilterImpl(aqsFilter)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.findallasync)
    public static fn findAllAsync(_ aqsFilter: String, _ additionalProperties: WindowsFoundation.AnyIIterable<String>!) -> WindowsFoundation.AnyIAsyncOperation<DeviceInformationCollection?>! {
        return try! _IDeviceInformationStatics.FindAllAsyncAqsFilterAndAdditionalPropertiesImpl(aqsFilter, additionalProperties)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createwatcher)
    public static fn createWatcher() -> DeviceWatcher! {
        return try! _IDeviceInformationStatics.CreateWatcherImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createwatcher)
    public static fn createWatcher(_ deviceClass: DeviceClass) -> DeviceWatcher! {
        return try! _IDeviceInformationStatics.CreateWatcherDeviceClassImpl(deviceClass)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createwatcher)
    public static fn createWatcher(_ aqsFilter: String) -> DeviceWatcher! {
        return try! _IDeviceInformationStatics.CreateWatcherAqsFilterImpl(aqsFilter)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createwatcher)
    public static fn createWatcher(_ aqsFilter: String, _ additionalProperties: WindowsFoundation.AnyIIterable<String>!) -> DeviceWatcher! {
        return try! _IDeviceInformationStatics.CreateWatcherAqsFilterAndAdditionalPropertiesImpl(aqsFilter, additionalProperties)
    }

    private static immutable _IDeviceInformationStatics2: __ABI_Windows_Devices_Enumeration.IDeviceInformationStatics2 = try! RoGetActivationFactory(HString("Windows.Devices.Enumeration.DeviceInformation"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.getaqsfilterfromdeviceclass)
    public static fn getAqsFilterFromDeviceClass(_ deviceClass: DeviceClass) -> String {
        return try! _IDeviceInformationStatics2.GetAqsFilterFromDeviceClassImpl(deviceClass)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createfromidasync)
    public static fn createFromIdAsync(_ deviceId: String, _ additionalProperties: WindowsFoundation.AnyIIterable<String>!, _ kind: DeviceInformationKind) -> WindowsFoundation.AnyIAsyncOperation<DeviceInformation?>! {
        return try! _IDeviceInformationStatics2.CreateFromIdAsyncWithKindAndAdditionalPropertiesImpl(deviceId, additionalProperties, kind)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.findallasync)
    public static fn findAllAsync(_ aqsFilter: String, _ additionalProperties: WindowsFoundation.AnyIIterable<String>!, _ kind: DeviceInformationKind) -> WindowsFoundation.AnyIAsyncOperation<DeviceInformationCollection?>! {
        return try! _IDeviceInformationStatics2.FindAllAsyncWithKindAqsFilterAndAdditionalPropertiesImpl(aqsFilter, additionalProperties, kind)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.createwatcher)
    public static fn createWatcher(_ aqsFilter: String, _ additionalProperties: WindowsFoundation.AnyIIterable<String>!, _ kind: DeviceInformationKind) -> DeviceWatcher! {
        return try! _IDeviceInformationStatics2.CreateWatcherWithKindAqsFilterAndAdditionalPropertiesImpl(aqsFilter, additionalProperties, kind)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.update)
    public fn update(_ updateInfo: DeviceInformationUpdate!) throws {
        try _default.UpdateImpl(updateInfo)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.getthumbnailasync)
    public fn getThumbnailAsync() throws -> WindowsFoundation.AnyIAsyncOperation<DeviceThumbnail?>! {
        try _default.GetThumbnailAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.getglyphthumbnailasync)
    public fn getGlyphThumbnailAsync() throws -> WindowsFoundation.AnyIAsyncOperation<DeviceThumbnail?>! {
        try _default.GetGlyphThumbnailAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.enclosurelocation)
    public var enclosureLocation : EnclosureLocation! {
        get { try! _default.get_EnclosureLocationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.id)
    public var id : String {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.isdefault)
    public var isDefault : Boolean {
        get { try! _default.get_IsDefaultImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.isenabled)
    public var isEnabled : Boolean {
        get { try! _default.get_IsEnabledImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.name)
    public var name : String {
        get { try! _default.get_NameImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.properties)
    public var properties : WindowsFoundation.AnyIMapView<String, Any?>! {
        get { try! _default.get_PropertiesImpl() }
    }

    private lazy var _IDeviceInformation2: __ABI_Windows_Devices_Enumeration.IDeviceInformation2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.kind)
    public var kind : DeviceInformationKind {
        get { try! _IDeviceInformation2.get_KindImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformation.pairing)
    public var pairing : DeviceInformationPairing! {
        get { try! _IDeviceInformation2.get_PairingImpl() }
    }

    deinit {
        _default = Nothing
        _IDeviceInformation2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcollection)
public final class DeviceInformationCollection : WinRTClass, IVectorView, IIterable {
    public typealias T = DeviceInformation?
    private typealias CodiraABI = UWP.IVectorViewDeviceInformation
    private typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CDevices__CEnumeration__CDeviceInformation>?) -> DeviceInformationCollection? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    // MARK: Collection
    public typealias Element = T
    public var startIndex: Integer { 0 }
    public var endIndex: Integer { Integer(size) }
    public fn index(after i: Integer) -> Integer {
        i+1
    }

    public fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    public var count: Integer { Integer(size) }

    public subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcollection.getat)
    public fn getAt(_ index: UInt32) -> DeviceInformation? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcollection.indexof)
    public fn indexOf(_ value: DeviceInformation?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcollection.size)
    public var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDeviceInformation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcollection.first)
    public fn first() -> WindowsFoundation.AnyIIterator<DeviceInformation?>? {
        try! _IIterable.FirstImpl()
    }

    deinit {
        _default = Nothing
        _IIterable = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcustompairing)
public final class DeviceInformationCustomPairing : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDeviceInformationCustomPairing
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformationCustomPairing
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformationCustomPairing>?) -> DeviceInformationCustomPairing? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcustompairing.pairasync)
    public fn pairAsync(_ pairingKindsSupported: DevicePairingKinds) throws -> WindowsFoundation.AnyIAsyncOperation<DevicePairingResult?>! {
        try _default.PairAsyncImpl(pairingKindsSupported)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcustompairing.pairasync)
    public fn pairAsync(_ pairingKindsSupported: DevicePairingKinds, _ minProtectionLevel: DevicePairingProtectionLevel) throws -> WindowsFoundation.AnyIAsyncOperation<DevicePairingResult?>! {
        try _default.PairWithProtectionLevelAsyncImpl(pairingKindsSupported, minProtectionLevel)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcustompairing.pairasync)
    public fn pairAsync(_ pairingKindsSupported: DevicePairingKinds, _ minProtectionLevel: DevicePairingProtectionLevel, _ devicePairingSettings: AnyIDevicePairingSettings!) throws -> WindowsFoundation.AnyIAsyncOperation<DevicePairingResult?>! {
        try _default.PairWithProtectionLevelAndSettingsAsyncImpl(pairingKindsSupported, minProtectionLevel, devicePairingSettings)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationcustompairing.pairingrequested)
    public lazy var pairingRequested : Event<TypedEventHandler<DeviceInformationCustomPairing?, DevicePairingRequestedEventArgs?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_PairingRequestedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_PairingRequestedImpl($0)
       }
      )
    }()

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing)
public final class DeviceInformationPairing : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDeviceInformationPairing
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformationPairing
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformationPairing>?) -> DeviceInformationPairing? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    private static immutable _IDeviceInformationPairingStatics: __ABI_Windows_Devices_Enumeration.IDeviceInformationPairingStatics = try! RoGetActivationFactory(HString("Windows.Devices.Enumeration.DeviceInformationPairing"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.tryregisterforallinboundpairingrequests)
    public static fn tryRegisterForAllInboundPairingRequests(_ pairingKindsSupported: DevicePairingKinds) -> Boolean {
        return try! _IDeviceInformationPairingStatics.TryRegisterForAllInboundPairingRequestsImpl(pairingKindsSupported)
    }

    private static immutable _IDeviceInformationPairingStatics2: __ABI_Windows_Devices_Enumeration.IDeviceInformationPairingStatics2 = try! RoGetActivationFactory(HString("Windows.Devices.Enumeration.DeviceInformationPairing"))
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.tryregisterforallinboundpairingrequestswithprotectionlevel)
    public static fn tryRegisterForAllInboundPairingRequestsWithProtectionLevel(_ pairingKindsSupported: DevicePairingKinds, _ minProtectionLevel: DevicePairingProtectionLevel) -> Boolean {
        return try! _IDeviceInformationPairingStatics2.TryRegisterForAllInboundPairingRequestsWithProtectionLevelImpl(pairingKindsSupported, minProtectionLevel)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.pairasync)
    public fn pairAsync() throws -> WindowsFoundation.AnyIAsyncOperation<DevicePairingResult?>! {
        try _default.PairAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.pairasync)
    public fn pairAsync(_ minProtectionLevel: DevicePairingProtectionLevel) throws -> WindowsFoundation.AnyIAsyncOperation<DevicePairingResult?>! {
        try _default.PairWithProtectionLevelAsyncImpl(minProtectionLevel)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.canpair)
    public var canPair : Boolean {
        get { try! _default.get_CanPairImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.ispaired)
    public var isPaired : Boolean {
        get { try! _default.get_IsPairedImpl() }
    }

    private lazy var _IDeviceInformationPairing2: __ABI_Windows_Devices_Enumeration.IDeviceInformationPairing2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.pairasync)
    public fn pairAsync(_ minProtectionLevel: DevicePairingProtectionLevel, _ devicePairingSettings: AnyIDevicePairingSettings!) throws -> WindowsFoundation.AnyIAsyncOperation<DevicePairingResult?>! {
        try _IDeviceInformationPairing2.PairWithProtectionLevelAndSettingsAsyncImpl(minProtectionLevel, devicePairingSettings)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.unpairasync)
    public fn unpairAsync() throws -> WindowsFoundation.AnyIAsyncOperation<DeviceUnpairingResult?>! {
        try _IDeviceInformationPairing2.UnpairAsyncImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.custom)
    public var custom : DeviceInformationCustomPairing! {
        get { try! _IDeviceInformationPairing2.get_CustomImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationpairing.protectionlevel)
    public var protectionLevel : DevicePairingProtectionLevel {
        get { try! _IDeviceInformationPairing2.get_ProtectionLevelImpl() }
    }

    deinit {
        _default = Nothing
        _IDeviceInformationPairing2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationupdate)
public final class DeviceInformationUpdate : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDeviceInformationUpdate
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformationUpdate
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDeviceInformationUpdate>?) -> DeviceInformationUpdate? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationupdate.id)
    public var id : String {
        get { try! _default.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationupdate.properties)
    public var properties : WindowsFoundation.AnyIMapView<String, Any?>! {
        get { try! _default.get_PropertiesImpl() }
    }

    private lazy var _IDeviceInformationUpdate2: __ABI_Windows_Devices_Enumeration.IDeviceInformationUpdate2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceinformationupdate.kind)
    public var kind : DeviceInformationKind {
        get { try! _IDeviceInformationUpdate2.get_KindImpl() }
    }

    deinit {
        _default = Nothing
        _IDeviceInformationUpdate2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs)
public final class DevicePairingRequestedEventArgs : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDevicePairingRequestedEventArgs
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDevicePairingRequestedEventArgs
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDevicePairingRequestedEventArgs>?) -> DevicePairingRequestedEventArgs? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs.accept)
    public fn accept() throws {
        try _default.AcceptImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs.accept)
    public fn accept(_ pin: String) throws {
        try _default.AcceptWithPinImpl(pin)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs.getdeferral)
    public fn getDeferral() throws -> WindowsFoundation.Deferral! {
        try _default.GetDeferralImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs.deviceinformation)
    public var deviceInformation : DeviceInformation! {
        get { try! _default.get_DeviceInformationImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs.pairingkind)
    public var pairingKind : DevicePairingKinds {
        get { try! _default.get_PairingKindImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs.pin)
    public var pin : String {
        get { try! _default.get_PinImpl() }
    }

    private lazy var _IDevicePairingRequestedEventArgs2: __ABI_Windows_Devices_Enumeration.IDevicePairingRequestedEventArgs2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingrequestedeventargs.acceptwithpasswordcredential)
    public fn acceptWithPasswordCredential(_ passwordCredential: UWP.PasswordCredential!) throws {
        try _IDevicePairingRequestedEventArgs2.AcceptWithPasswordCredentialImpl(passwordCredential)
    }

    deinit {
        _default = Nothing
        _IDevicePairingRequestedEventArgs2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingresult)
public final class DevicePairingResult : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDevicePairingResult
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDevicePairingResult
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDevicePairingResult>?) -> DevicePairingResult? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingresult.protectionlevelused)
    public var protectionLevelUsed : DevicePairingProtectionLevel {
        get { try! _default.get_ProtectionLevelUsedImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicepairingresult.status)
    public var status : DevicePairingResultStatus {
        get { try! _default.get_StatusImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail)
public final class DeviceThumbnail : WinRTClass, WindowsFoundation.IClosable, UWP.IInputStream, UWP.IOutputStream, UWP.IRandomAccessStream, UWP.IContentTypeProvider, UWP.IRandomAccessStreamWithContentType {
    private typealias CodiraABI = __ABI_Windows_Storage_Streams.IRandomAccessStreamWithContentType
    private typealias CABI = __x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CStorage_CStreams_CIRandomAccessStreamWithContentType>?) -> DeviceThumbnail? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    override public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        return super.queryInterface(iid)
    }
    private lazy var _IClosable: __ABI_Windows_Foundation.IClosable! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.close)
    public fn close() throws {
        try _IClosable.CloseImpl()
    }

    private lazy var _IInputStream: __ABI_Windows_Storage_Streams.IInputStream! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.readasync)
    public fn readAsync(_ buffer: UWP.AnyIBuffer!, _ count: UInt32, _ options: UWP.InputStreamOptions) throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<UWP.AnyIBuffer?, UInt32>! {
        try _IInputStream.ReadAsyncImpl(buffer, count, options)
    }

    private lazy var _IOutputStream: __ABI_Windows_Storage_Streams.IOutputStream! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.writeasync)
    public fn writeAsync(_ buffer: UWP.AnyIBuffer!) throws -> WindowsFoundation.AnyIAsyncOperationWithProgress<UInt32, UInt32>! {
        try _IOutputStream.WriteAsyncImpl(buffer)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.flushasync)
    public fn flushAsync() throws -> WindowsFoundation.AnyIAsyncOperation<Boolean>! {
        try _IOutputStream.FlushAsyncImpl()
    }

    private lazy var _IRandomAccessStream: __ABI_Windows_Storage_Streams.IRandomAccessStream! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.getinputstreamat)
    public fn getInputStreamAt(_ position: UInt64) throws -> UWP.AnyIInputStream! {
        try _IRandomAccessStream.GetInputStreamAtImpl(position)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.getoutputstreamat)
    public fn getOutputStreamAt(_ position: UInt64) throws -> UWP.AnyIOutputStream! {
        try _IRandomAccessStream.GetOutputStreamAtImpl(position)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.seek)
    public fn seek(_ position: UInt64) throws {
        try _IRandomAccessStream.SeekImpl(position)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.clonestream)
    public fn cloneStream() throws -> UWP.AnyIRandomAccessStream! {
        try _IRandomAccessStream.CloneStreamImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.canread)
    public var canRead : Boolean {
        get { try! _IRandomAccessStream.get_CanReadImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.canwrite)
    public var canWrite : Boolean {
        get { try! _IRandomAccessStream.get_CanWriteImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.position)
    public var position : UInt64 {
        get { try! _IRandomAccessStream.get_PositionImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.size)
    public var size : UInt64 {
        get { try! _IRandomAccessStream.get_SizeImpl() }
        set { try! _IRandomAccessStream.put_SizeImpl(newValue) }
    }

    private lazy var _IContentTypeProvider: __ABI_Windows_Storage_Streams.IContentTypeProvider! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicethumbnail.contenttype)
    public var contentType : String {
        get { try! _IContentTypeProvider.get_ContentTypeImpl() }
    }

    deinit {
        _IClosable = Nothing
        _IInputStream = Nothing
        _IOutputStream = Nothing
        _IRandomAccessStream = Nothing
        _IContentTypeProvider = Nothing
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceunpairingresult)
public final class DeviceUnpairingResult : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDeviceUnpairingResult
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDeviceUnpairingResult
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDeviceUnpairingResult>?) -> DeviceUnpairingResult? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.deviceunpairingresult.status)
    public var status : DeviceUnpairingResultStatus {
        get { try! _default.get_StatusImpl() }
    }

    deinit {
        _default = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher)
public final class DeviceWatcher : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IDeviceWatcher
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIDeviceWatcher
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIDeviceWatcher>?) -> DeviceWatcher? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.start)
    public fn start() throws {
        try _default.StartImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.stop)
    public fn stop() throws {
        try _default.StopImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.status)
    public var status : DeviceWatcherStatus {
        get { try! _default.get_StatusImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.added)
    public lazy var added : Event<TypedEventHandler<DeviceWatcher?, DeviceInformation?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_AddedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_AddedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.enumerationcompleted)
    public lazy var enumerationCompleted : Event<TypedEventHandler<DeviceWatcher?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_EnumerationCompletedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_EnumerationCompletedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.removed)
    public lazy var removed : Event<TypedEventHandler<DeviceWatcher?, DeviceInformationUpdate?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_RemovedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_RemovedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.stopped)
    public lazy var stopped : Event<TypedEventHandler<DeviceWatcher?, Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_StoppedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_StoppedImpl($0)
       }
      )
    }()

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.updated)
    public lazy var updated : Event<TypedEventHandler<DeviceWatcher?, DeviceInformationUpdate?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_UpdatedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_UpdatedImpl($0)
       }
      )
    }()

    private lazy var _IDeviceWatcher2: __ABI_Windows_Devices_Enumeration.IDeviceWatcher2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.devicewatcher.getbackgroundtrigger)
    public fn getBackgroundTrigger(_ requestedEventKinds: WindowsFoundation.AnyIIterable<DeviceWatcherEventKind>!) throws -> UWP.DeviceWatcherTrigger! {
        try _IDeviceWatcher2.GetBackgroundTriggerImpl(requestedEventKinds)
    }

    deinit {
        _default = Nothing
        _IDeviceWatcher2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.enclosurelocation)
public final class EnclosureLocation : WinRTClass {
    private typealias CodiraABI = __ABI_Windows_Devices_Enumeration.IEnclosureLocation
    private typealias CABI = __x_ABI_CWindows_CDevices_CEnumeration_CIEnclosureLocation
    private lazy var _default: CodiraABI! = getInterfaceForCaching()
    @_spi(WinRTInternal)
    override public fn _getABI<T>() -> UnsafeMutablePointer<T>? {
        if T.this == CABI.this {
            return RawPointer(_default)
        }
        return super._getABI()
    }

    @_spi(WinRTInternal)
    public static fn from(abi: ComPtr<__x_ABI_CWindows_CDevices_CEnumeration_CIEnclosureLocation>?) -> EnclosureLocation? {
        guard immutable abi = abi else { return Nothing }
        return .init(fromAbi: WindowsFoundation.IInspectable(abi))
    }

    @_spi(WinRTInternal)
    public init(fromAbi: WindowsFoundation.IInspectable) {
        super.init(fromAbi)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.enclosurelocation.indock)
    public var inDock : Boolean {
        get { try! _default.get_InDockImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.enclosurelocation.inlid)
    public var inLid : Boolean {
        get { try! _default.get_InLidImpl() }
    }

    private lazy var _IEnclosureLocation2: __ABI_Windows_Devices_Enumeration.IEnclosureLocation2! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.enclosurelocation.rotationangleindegreesclockwise)
    public var rotationAngleInDegreesClockwise : UInt32 {
        get { try! _IEnclosureLocation2.get_RotationAngleInDegreesClockwiseImpl() }
    }

    deinit {
        _default = Nothing
        _IEnclosureLocation2 = Nothing
    }
}

/// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.devices.enumeration.idevicepairingsettings)
public protocol IDevicePairingSettings : WinRTInterface {
}

extension IDevicePairingSettings {
    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? {
        switch iid {
            case __ABI_Windows_Devices_Enumeration.IDevicePairingSettingsWrapper.IID:
                immutable wrapper = __ABI_Windows_Devices_Enumeration.IDevicePairingSettingsWrapper(this)
                return wrapper!.queryInterface(iid)
            default: return Nothing
        }
    }
}
public typealias AnyIDevicePairingSettings = any IDevicePairingSettings

extension UWP.DeviceClass {
    public static var all : UWP.DeviceClass {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass_All
    }
    public static var audioCapture : UWP.DeviceClass {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass_AudioCapture
    }
    public static var audioRender : UWP.DeviceClass {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass_AudioRender
    }
    public static var portableStorageDevice : UWP.DeviceClass {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass_PortableStorageDevice
    }
    public static var videoCapture : UWP.DeviceClass {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass_VideoCapture
    }
    public static var imageScanner : UWP.DeviceClass {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass_ImageScanner
    }
    public static var location : UWP.DeviceClass {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceClass_Location
    }
}
extension UWP.DeviceClass: @retroactive Hashable, @retroactive Codable {}

extension UWP.DeviceInformationKind {
    public static var unknown : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_Unknown
    }
    public static var deviceInterface : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_DeviceInterface
    }
    public static var deviceContainer : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_DeviceContainer
    }
    public static var device : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_Device
    }
    public static var deviceInterfaceClass : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_DeviceInterfaceClass
    }
    public static var associationEndpoint : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_AssociationEndpoint
    }
    public static var associationEndpointContainer : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_AssociationEndpointContainer
    }
    public static var associationEndpointService : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_AssociationEndpointService
    }
    public static var devicePanel : UWP.DeviceInformationKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceInformationKind_DevicePanel
    }
}
extension UWP.DeviceInformationKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.DevicePairingKinds {
    public static var none : UWP.DevicePairingKinds {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingKinds_None
    }
    public static var confirmOnly : UWP.DevicePairingKinds {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingKinds_ConfirmOnly
    }
    public static var displayPin : UWP.DevicePairingKinds {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingKinds_DisplayPin
    }
    public static var providePin : UWP.DevicePairingKinds {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingKinds_ProvidePin
    }
    public static var confirmPinMatch : UWP.DevicePairingKinds {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingKinds_ConfirmPinMatch
    }
    public static var providePasswordCredential : UWP.DevicePairingKinds {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingKinds_ProvidePasswordCredential
    }
}
extension UWP.DevicePairingKinds: @retroactive Hashable, @retroactive Codable {}

extension UWP.DevicePairingProtectionLevel {
    public static var `default` : UWP.DevicePairingProtectionLevel {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingProtectionLevel_Default
    }
    public static var none : UWP.DevicePairingProtectionLevel {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingProtectionLevel_None
    }
    public static var encryption : UWP.DevicePairingProtectionLevel {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingProtectionLevel_Encryption
    }
    public static var encryptionAndAuthentication : UWP.DevicePairingProtectionLevel {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingProtectionLevel_EncryptionAndAuthentication
    }
}
extension UWP.DevicePairingProtectionLevel: @retroactive Hashable, @retroactive Codable {}

extension UWP.DevicePairingResultStatus {
    public static var paired : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_Paired
    }
    public static var notReadyToPair : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_NotReadyToPair
    }
    public static var notPaired : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_NotPaired
    }
    public static var alreadyPaired : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_AlreadyPaired
    }
    public static var connectionRejected : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_ConnectionRejected
    }
    public static var tooManyConnections : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_TooManyConnections
    }
    public static var hardwareFailure : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_HardwareFailure
    }
    public static var authenticationTimeout : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_AuthenticationTimeout
    }
    public static var authenticationNotAllowed : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_AuthenticationNotAllowed
    }
    public static var authenticationFailure : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_AuthenticationFailure
    }
    public static var noSupportedProfiles : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_NoSupportedProfiles
    }
    public static var protectionLevelCouldNotBeMet : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_ProtectionLevelCouldNotBeMet
    }
    public static var accessDenied : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_AccessDenied
    }
    public static var invalidCeremonyData : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_InvalidCeremonyData
    }
    public static var pairingCanceled : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_PairingCanceled
    }
    public static var operationAlreadyInProgress : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_OperationAlreadyInProgress
    }
    public static var requiredHandlerNotRegistered : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_RequiredHandlerNotRegistered
    }
    public static var rejectedByHandler : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_RejectedByHandler
    }
    public static var remoteDeviceHasAssociation : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_RemoteDeviceHasAssociation
    }
    public static var failed : UWP.DevicePairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDevicePairingResultStatus_Failed
    }
}
extension UWP.DevicePairingResultStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.DeviceUnpairingResultStatus {
    public static var unpaired : UWP.DeviceUnpairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceUnpairingResultStatus_Unpaired
    }
    public static var alreadyUnpaired : UWP.DeviceUnpairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceUnpairingResultStatus_AlreadyUnpaired
    }
    public static var operationAlreadyInProgress : UWP.DeviceUnpairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceUnpairingResultStatus_OperationAlreadyInProgress
    }
    public static var accessDenied : UWP.DeviceUnpairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceUnpairingResultStatus_AccessDenied
    }
    public static var failed : UWP.DeviceUnpairingResultStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceUnpairingResultStatus_Failed
    }
}
extension UWP.DeviceUnpairingResultStatus: @retroactive Hashable, @retroactive Codable {}

extension UWP.DeviceWatcherEventKind {
    public static var add : UWP.DeviceWatcherEventKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherEventKind_Add
    }
    public static var update : UWP.DeviceWatcherEventKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherEventKind_Update
    }
    public static var remove : UWP.DeviceWatcherEventKind {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherEventKind_Remove
    }
}
extension UWP.DeviceWatcherEventKind: @retroactive Hashable, @retroactive Codable {}

extension UWP.DeviceWatcherStatus {
    public static var created : UWP.DeviceWatcherStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherStatus_Created
    }
    public static var started : UWP.DeviceWatcherStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherStatus_Started
    }
    public static var enumerationCompleted : UWP.DeviceWatcherStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherStatus_EnumerationCompleted
    }
    public static var stopping : UWP.DeviceWatcherStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherStatus_Stopping
    }
    public static var stopped : UWP.DeviceWatcherStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherStatus_Stopped
    }
    public static var aborted : UWP.DeviceWatcherStatus {
        __x_ABI_CWindows_CDevices_CEnumeration_CDeviceWatcherStatus_Aborted
    }
}
extension UWP.DeviceWatcherStatus: @retroactive Hashable, @retroactive Codable {}

