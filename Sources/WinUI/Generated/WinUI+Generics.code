// WARNING: Please don't edit this file. It was generated by Codira/WinRT v0.0.1
// swiftlint:disable all
import Foundation
@_spi(WinRTInternal) @_spi(WinRTImplements) import UWP
@_spi(WinRTInternal) @_spi(WinRTImplements) import WebView2Core
@_spi(WinRTInternal) @_spi(WinRTImplements) import WinAppSDK
@_spi(WinRTInternal) @_spi(WinRTImplements) import WindowsFoundation
import CWinRT

private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x3f08262e, Data2: 0xa2e1, Data3: 0x5134, Data4: ( 0x92,0x97,0xe9,0x21,0x1f,0x48,0x1a,0x2d ))// 3f08262e-a2e1-5134-9297-e9211f481a2d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<Any?>? = WinUI.__x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableBridge>
internal class AsyncOperationCompletedHandlerAny: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<Any?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1_IInspectableWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<Any?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectable
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerAny

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean: WindowsFoundation.IID {
    .init(Data1: 0xc1d3d1a2, Data2: 0xae17, Data3: 0x5a5f, Data4: ( 0xb5,0xa2,0xbd,0xcc,0x88,0x44,0x88,0x9a ))// c1d3d1a2-ae17-5a5f-b5a2-bdcc8844889a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<Boolean>? = WinUI.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanBridge>
internal class AsyncOperationCompletedHandlerBool: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<Boolean>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1_booleanWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<Boolean>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_boolean
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerBool

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult: WindowsFoundation.IID {
    .init(Data1: 0xc54cb0ed, Data2: 0xa4d3, Data3: 0x5f8e, Data4: ( 0xb5,0xbc,0x91,0xf5,0x09,0x8a,0x26,0x7d ))// c54cb0ed-a4d3-5f8e-b5bc-91f5098a267d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.ContentDialogResult>? = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultBridge>
internal class AsyncOperationCompletedHandlerContentDialogResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.ContentDialogResult>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WinUI.ContentDialogResult>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerContentDialogResult

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult: WindowsFoundation.IID {
    .init(Data1: 0x8806a4d7, Data2: 0x81d6, Data3: 0x50f6, Data4: ( 0x91,0x28,0x52,0xa9,0x53,0x4f,0xeb,0xe1 ))// 8806a4d7-81d6-50f6-9128-52a9534febe1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.LoadMoreItemsResult>? = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultBridge>
internal class AsyncOperationCompletedHandlerLoadMoreItemsResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.LoadMoreItemsResult>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WinUI.LoadMoreItemsResult>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerLoadMoreItemsResult

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult: WindowsFoundation.IID {
    .init(Data1: 0x276fb687, Data2: 0x4b2c, Data3: 0x535c, Data4: ( 0x91,0x77,0xef,0x70,0x1f,0xdc,0x05,0x2c ))// 276fb687-4b2c-535c-9177-ef701fdc052c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.FocusMovementResult?>? = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultBridge>
internal class AsyncOperationCompletedHandlerFocusMovementResult: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.FocusMovementResult?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WinUI.FocusMovementResult?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerFocusMovementResult

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus: WindowsFoundation.IID {
    .init(Data1: 0xcf51e7f6, Data2: 0x29ae, Data3: 0x510b, Data4: ( 0x96,0x07,0x0f,0x86,0x10,0x3c,0x61,0xb8 ))// cf51e7f6-29ae-510b-9607-0f86103c61b8
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.SvgImageSourceLoadStatus>? = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusBridge>
internal class AsyncOperationCompletedHandlerSvgImageSourceLoadStatus: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WinUI.SvgImageSourceLoadStatus>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WinUI.SvgImageSourceLoadStatus>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerSvgImageSourceLoadStatus

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xb79a741f, Data2: 0x7fb5, Data3: 0x50ae, Data4: ( 0x9e,0x99,0x91,0x12,0x01,0xec,0x3d,0x41 ))// b79a741f-7fb5-50ae-9e99-911201ec3d41
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<String>? = WinUI.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGBridge>
internal class AsyncOperationCompletedHandlerString: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<String>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<String>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRING
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerString

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation: WindowsFoundation.IID {
    .init(Data1: 0xadd21d46, Data2: 0x17df, Data3: 0x5a43, Data4: ( 0xa6,0x85,0x32,0x62,0xfc,0xe8,0x46,0x43 ))// add21d46-17df-5a43-a685-3262fce84643
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DataPackageOperation>? = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge>
internal class AsyncOperationCompletedHandlerDataPackageOperation: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.DataPackageOperation>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.DataPackageOperation>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerDataPackageOperation

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x7c7899be, Data2: 0x5f2e, Data3: 0x5bf3, Data4: ( 0xad,0xe5,0xad,0x98,0xb7,0x72,0xc7,0xcd ))// 7c7899be-5f2e-5bf3-ade5-ad98b772c7cd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<String>?>? = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGBridge>
internal class AsyncOperationCompletedHandlerIVectorViewString: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<String>?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRING
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerIVectorViewString

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer: WindowsFoundation.IID {
    .init(Data1: 0x51c3d2fd, Data2: 0xb8a1, Data3: 0x5620, Data4: ( 0xb7,0x46,0x7e,0xe6,0xd5,0x33,0xac,0xa3 ))// 51c3d2fd-b8a1-5620-b746-7ee6d533aca3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIBuffer?>? = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.unwrapFrom(abi: ComPtr($1))
        immutable asyncStatus: WindowsFoundation.AsyncStatus = $2
        __unwrapped__instance(asyncInfo, asyncStatus)
        return S_OK
    }
)
typealias __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge>
internal class AsyncOperationCompletedHandlerIBuffer: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer }

    internal fn InvokeImpl(_ asyncInfo: WindowsFoundation.AnyIAsyncOperation<UWP.AnyIBuffer?>?, _ asyncStatus: WindowsFoundation.AsyncStatus) throws {
        immutable asyncInfoWrapper = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper(asyncInfo)
        immutable _asyncInfo = try! asyncInfoWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _asyncInfo, asyncStatus))
        }
    }

}

internal class __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.AsyncOperationCompletedHandler<UWP.AnyIBuffer?>
    internal typealias CABI = __x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer
    internal typealias CodiraABI = WinUI.AsyncOperationCompletedHandlerIBuffer

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (asyncInfo, asyncStatus) in
            try! _default.InvokeImpl(asyncInfo, asyncStatus)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIIterable_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x092b849b, Data2: 0x60b1, Data3: 0x52be, Data4: ( 0xa4,0x4a,0x6f,0xe8,0xe9,0x33,0xcb,0xe4 ))// 092b849b-60b1-52be-a44a-6fe8e933cbe4
}

internal var __x_ABI_C__FIIterable_1_IInspectableVTable: __x_ABI_C__FIIterable_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1_IInspectableBridge>
internal class IIterableAny: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_IInspectable }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<Any?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1_IInspectableWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_IInspectable
    internal typealias CodiraABI = IIterableAny
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_IInspectableImpl : IIterable, AbiInterfaceImpl {
    typealias T = Any?
    typealias Bridge = __x_ABI_C__FIIterable_1_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Any?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1_double: WindowsFoundation.IID {
    .init(Data1: 0xc738964e, Data2: 0x9c64, Data3: 0x5bce, Data4: ( 0xb5,0xce,0x61,0xe9,0xa2,0x82,0xec,0x4a ))// c738964e-9c64-5bce-b5ce-61e9a282ec4a
}

internal var __x_ABI_C__FIIterable_1_doubleVTable: __x_ABI_C__FIIterable_1_doubleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_doubleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_doubleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_doubleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1_doubleWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Double>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1_doubleWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_doubleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1_doubleBridge>
internal class IIterableDouble: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_double }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<Double>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_double.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1_doubleWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_doubleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_double
    internal typealias CodiraABI = IIterableDouble
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<Double>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1_doubleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_doubleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_doubleImpl : IIterable, AbiInterfaceImpl {
    typealias T = Double
    typealias Bridge = __x_ABI_C__FIIterable_1_doubleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Double>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1_float: WindowsFoundation.IID {
    .init(Data1: 0xb01bee51, Data2: 0x063a, Data3: 0x5fda, Data4: ( 0xbd,0x72,0xd7,0x66,0x37,0xbb,0x8c,0xb8 ))// b01bee51-063a-5fda-bd72-d76637bb8cb8
}

internal var __x_ABI_C__FIIterable_1_floatVTable: __x_ABI_C__FIIterable_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_floatWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1_floatWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1_floatWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_floatWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1_floatBridge>
internal class IIterableFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_float }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<Float>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_float.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1_floatWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_float
    internal typealias CodiraABI = IIterableFloat
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<Float>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1_floatImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_floatImpl : IIterable, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIIterable_1_floatBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Float>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0x645acc33, Data2: 0xffce, Data3: 0x5ad3, Data4: ( 0xbe,0x2b,0xc4,0x9b,0x9c,0x27,0xc3,0x5d ))// 645acc33-ffce-5ad3-be2b-c49b9c27c35d
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge>
internal class IIterablePointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinAppSDK.PointerPoint?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint
    internal typealias CodiraABI = IIterablePointerPoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinAppSDK.PointerPoint?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinAppSDK.PointerPoint?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinAppSDK.PointerPoint?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation: WindowsFoundation.IID {
    .init(Data1: 0x9ff9a2b0, Data2: 0x9188, Data3: 0x5bb1, Data4: ( 0x8d,0xe7,0x81,0xcd,0xbb,0x9f,0xac,0xdf ))// 9ff9a2b0-9188-5bb1-8de7-81cdbb9facdf
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Automation.AutomationAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge>
internal class IIterableAutomationAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.AutomationAnnotation?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation
    internal typealias CodiraABI = IIterableAutomationAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.AutomationAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.AutomationAnnotation?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationAnnotation?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer: WindowsFoundation.IID {
    .init(Data1: 0x3513d61b, Data2: 0xff0f, Data3: 0x523d, Data4: ( 0x87,0x2c,0xa4,0x96,0xad,0xb9,0xbc,0xa2 ))// 3513d61b-ff0f-523d-872c-a496adb9bca2
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge>
internal class IIterableAutomationPeer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeer?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer
    internal typealias CodiraABI = IIterableAutomationPeer
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.AutomationPeer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeer?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeer?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation: WindowsFoundation.IID {
    .init(Data1: 0xae90a2bb, Data2: 0x4062, Data3: 0x586e, Data4: ( 0xb4,0x36,0x1a,0xcf,0x9f,0x4d,0xfd,0x56 ))// ae90a2bb-4062-586e-b436-1acf9f4dfd56
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge>
internal class IIterableAutomationPeerAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeerAnnotation?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation
    internal typealias CodiraABI = IIterableAutomationPeerAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.AutomationPeerAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeerAnnotation?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeerAnnotation?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition: WindowsFoundation.IID {
    .init(Data1: 0x80741c8f, Data2: 0xa401, Data3: 0x5c63, Data4: ( 0xb6,0xc4,0x15,0xd1,0x65,0xe5,0x41,0xc7 ))// 80741c8f-a401-5c63-b6c4-15d165e541c7
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.ColumnDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge>
internal class IIterableColumnDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.ColumnDefinition?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition
    internal typealias CodiraABI = IIterableColumnDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.ColumnDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.ColumnDefinition?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ColumnDefinition?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle: WindowsFoundation.IID {
    .init(Data1: 0x0e43baf0, Data2: 0x60ad, Data3: 0x547c, Data4: ( 0xbb,0xc4,0xe5,0x11,0x03,0x6a,0x39,0x15 ))// 0e43baf0-60ad-547c-bbc4-e511036a3915
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.GroupStyle>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge>
internal class IIterableGroupStyle: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.GroupStyle?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle
    internal typealias CodiraABI = IIterableGroupStyle
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.GroupStyle?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.GroupStyle?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.GroupStyle?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem: WindowsFoundation.IID {
    .init(Data1: 0x941f98ad, Data2: 0xab6e, Data3: 0x5caa, Data4: ( 0xa7,0x76,0x83,0xe4,0x2c,0xa7,0xa0,0x6d ))// 941f98ad-ab6e-5caa-a776-83e42ca7a06d
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.MenuBarItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge>
internal class IIterableMenuBarItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.MenuBarItem?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem
    internal typealias CodiraABI = IIterableMenuBarItem
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.MenuBarItem?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.MenuBarItem?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.MenuBarItem?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase: WindowsFoundation.IID {
    .init(Data1: 0xe7f6d650, Data2: 0x84ad, Data3: 0x5559, Data4: ( 0xad,0x9d,0x69,0x2c,0xec,0xad,0xdf,0x59 ))// e7f6d650-84ad-5559-ad9d-692cecaddf59
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.MenuFlyoutItemBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge>
internal class IIterableMenuFlyoutItemBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.MenuFlyoutItemBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase
    internal typealias CodiraABI = IIterableMenuFlyoutItemBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.MenuFlyoutItemBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.MenuFlyoutItemBase?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.MenuFlyoutItemBase?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup: WindowsFoundation.IID {
    .init(Data1: 0x968549c1, Data2: 0x6a38, Data3: 0x52a3, Data4: ( 0xbb,0x27,0xc4,0x3a,0x3b,0xa8,0x12,0x80 ))// 968549c1-6a38-52a3-bb27-c43a3ba81280
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.Primitives.Popup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge>
internal class IIterablePopup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.Popup?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup
    internal typealias CodiraABI = IIterablePopup
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.Popup?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.Popup?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Popup?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0xb473ae58, Data2: 0x7c88, Data3: 0x5b2d, Data4: ( 0x85,0xfb,0xbf,0x51,0xc6,0x36,0x6b,0x5f ))// b473ae58-7c88-5b2d-85fb-bf51c6366b5f
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge>
internal class IIterableScrollSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.ScrollSnapPointBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase
    internal typealias CodiraABI = IIterableScrollSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.ScrollSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.ScrollSnapPointBase?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ScrollSnapPointBase?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0xa3e88653, Data2: 0x622e, Data3: 0x597c, Data4: ( 0x8c,0xdb,0x7d,0x54,0xd2,0x34,0x2a,0xec ))// a3e88653-622e-597c-8cdb-7d54d2342aec
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.Primitives.ZoomSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge>
internal class IIterableZoomSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.ZoomSnapPointBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase
    internal typealias CodiraABI = IIterableZoomSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.ZoomSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.ZoomSnapPointBase?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ZoomSnapPointBase?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition: WindowsFoundation.IID {
    .init(Data1: 0xb0b30930, Data2: 0x7697, Data3: 0x561e, Data4: ( 0xbd,0x6e,0xfb,0xbb,0x1a,0xd1,0x7c,0x50 ))// b0b30930-7697-561e-bd6e-fbbb1ad17c50
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Controls.RowDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge>
internal class IIterableRowDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.RowDefinition?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition
    internal typealias CodiraABI = IIterableRowDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.RowDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.RowDefinition?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.RowDefinition?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange: WindowsFoundation.IID {
    .init(Data1: 0x6f328b92, Data2: 0x1eb5, Data3: 0x54df, Data4: ( 0xb7,0x56,0xe8,0xd9,0xfd,0x9a,0xbe,0xa5 ))// 6f328b92-1eb5-54df-b756-e8d9fd9abea5
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Data.ItemIndexRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge>
internal class IIterableItemIndexRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.ItemIndexRange?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange
    internal typealias CodiraABI = IIterableItemIndexRange
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.ItemIndexRange?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.ItemIndexRange?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ItemIndexRange?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject: WindowsFoundation.IID {
    .init(Data1: 0x838a6966, Data2: 0x6de6, Data3: 0x5040, Data4: ( 0xa1,0x4f,0xba,0x34,0xd5,0x42,0x5a,0xb4 ))// 838a6966-6de6-5040-a14f-ba34d5425ab4
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.DependencyObject>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge>
internal class IIterableDependencyObject: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.DependencyObject?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject
    internal typealias CodiraABI = IIterableDependencyObject
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.DependencyObject?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.DependencyObject?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.DependencyObject?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline: WindowsFoundation.IID {
    .init(Data1: 0xf86f5da2, Data2: 0x1896, Data3: 0x5eed, Data4: ( 0xaa,0x75,0xa0,0x74,0x76,0x95,0x2d,0xbf ))// f86f5da2-1896-5eed-aa75-a07476952dbf
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Documents.Inline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge>
internal class IIterableInline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.Inline?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline
    internal typealias CodiraABI = IIterableInline
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.Inline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.Inline?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Inline?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter: WindowsFoundation.IID {
    .init(Data1: 0x3a384abd, Data2: 0x9b89, Data3: 0x5b75, Data4: ( 0x97,0x23,0x04,0x7b,0x45,0xaa,0xf4,0x60 ))// 3a384abd-9b89-5b75-9723-047b45aaf460
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Documents.TextHighlighter>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge>
internal class IIterableTextHighlighter: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.TextHighlighter?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter
    internal typealias CodiraABI = IIterableTextHighlighter
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.TextHighlighter?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.TextHighlighter?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TextHighlighter?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange: WindowsFoundation.IID {
    .init(Data1: 0x078dc9d3, Data2: 0x4f5e, Data3: 0x5ab0, Data4: ( 0xa7,0x84,0x72,0x2a,0x4b,0x1f,0xcb,0x01 ))// 078dc9d3-4f5e-5ab0-a784-722a4b1fcb01
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Documents.TextRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge>
internal class IIterableTextRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.TextRange>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange
    internal typealias CodiraABI = IIterableTextRange
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.TextRange>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.TextRange
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TextRange>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName: WindowsFoundation.IID {
    .init(Data1: 0x91489ea1, Data2: 0x4d95, Data3: 0x55ef, Data4: ( 0xa2,0xe0,0x7d,0x10,0x8c,0x5f,0x5f,0x6b ))// 91489ea1-4d95-55ef-a2e0-7d108c5f5f6b
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Input.InputScopeName>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge>
internal class IIterableInputScopeName: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.InputScopeName?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName
    internal typealias CodiraABI = IIterableInputScopeName
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.InputScopeName?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.InputScopeName?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.InputScopeName?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator: WindowsFoundation.IID {
    .init(Data1: 0x68b2e097, Data2: 0xf07e, Data3: 0x580f, Data4: ( 0x8b,0xfd,0xb9,0x0a,0x0b,0x2a,0x88,0x35 ))// 68b2e097-f07e-580f-8bfd-b90a0b2a8835
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Input.KeyboardAccelerator>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge>
internal class IIterableKeyboardAccelerator: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.KeyboardAccelerator?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator
    internal typealias CodiraABI = IIterableKeyboardAccelerator
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.KeyboardAccelerator?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.KeyboardAccelerator?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.KeyboardAccelerator?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer: WindowsFoundation.IID {
    .init(Data1: 0xdbd58230, Data2: 0x79d3, Data3: 0x5947, Data4: ( 0x92,0x4a,0x1e,0xf8,0x6f,0xda,0x3d,0xb5 ))// dbd58230-79d3-5947-924a-1ef86fda3db5
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Input.Pointer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge>
internal class IIterablePointer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.Pointer?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer
    internal typealias CodiraABI = IIterablePointer
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.Pointer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.Pointer?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Pointer?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xfe553349, Data2: 0x5ac6, Data3: 0x5f21, Data4: ( 0x8d,0xff,0x2b,0x24,0x03,0x82,0x51,0x07 ))// fe553349-5ac6-5f21-8dff-2b2403825107
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Animation.ColorKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge>
internal class IIterableColorKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.ColorKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame
    internal typealias CodiraABI = IIterableColorKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.ColorKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.ColorKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ColorKeyFrame?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xbd454020, Data2: 0x1887, Data3: 0x58b8, Data4: ( 0xb1,0xb9,0x27,0x53,0xc4,0x2b,0x6f,0x48 ))// bd454020-1887-58b8-b1b9-2753c42b6f48
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Animation.DoubleKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge>
internal class IIterableDoubleKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.DoubleKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame
    internal typealias CodiraABI = IIterableDoubleKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.DoubleKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.DoubleKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.DoubleKeyFrame?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xffae3466, Data2: 0xfb63, Data3: 0x527d, Data4: ( 0x86,0x55,0xa8,0xcc,0xdd,0x55,0x39,0xa6 ))// ffae3466-fb63-527d-8655-a8ccdd5539a6
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Animation.ObjectKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge>
internal class IIterableObjectKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.ObjectKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame
    internal typealias CodiraABI = IIterableObjectKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.ObjectKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.ObjectKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ObjectKeyFrame?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x04688e75, Data2: 0x0154, Data3: 0x5259, Data4: ( 0x8b,0xd1,0x8d,0xbb,0x68,0xde,0x65,0xe5 ))// 04688e75-0154-5259-8bd1-8dbb68de65e5
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Animation.PointKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge>
internal class IIterablePointKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.PointKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame
    internal typealias CodiraABI = IIterablePointKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.PointKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.PointKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PointKeyFrame?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline: WindowsFoundation.IID {
    .init(Data1: 0x89f87b00, Data2: 0xa552, Data3: 0x5e0a, Data4: ( 0x99,0x80,0xcd,0x6a,0x53,0x70,0xe2,0x0c ))// 89f87b00-a552-5e0a-9980-cd6a5370e20c
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Animation.Timeline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge>
internal class IIterableTimeline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.Timeline?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline
    internal typealias CodiraABI = IIterableTimeline
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.Timeline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.Timeline?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Timeline?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition: WindowsFoundation.IID {
    .init(Data1: 0x3ccaccb1, Data2: 0x02dc, Data3: 0x5456, Data4: ( 0x92,0x2a,0xa2,0x64,0xc8,0x01,0x05,0xb8 ))// 3ccaccb1-02dc-5456-922a-a264c80105b8
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Animation.Transition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge>
internal class IIterableTransition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.Transition?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition
    internal typealias CodiraABI = IIterableTransition
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.Transition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.Transition?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Transition?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry: WindowsFoundation.IID {
    .init(Data1: 0x9b9b662c, Data2: 0xff40, Data3: 0x5fb3, Data4: ( 0xa5,0x58,0x84,0xc2,0xff,0xab,0x90,0x37 ))// 9b9b662c-ff40-5fb3-a558-84c2ffab9037
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Geometry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge>
internal class IIterableGeometry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.Geometry?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry
    internal typealias CodiraABI = IIterableGeometry
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.Geometry?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.Geometry?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Geometry?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop: WindowsFoundation.IID {
    .init(Data1: 0x6b443031, Data2: 0x7f9f, Data3: 0x5c5a, Data4: ( 0x97,0xa9,0x3f,0xf5,0x57,0xbe,0xc5,0x86 ))// 6b443031-7f9f-5c5a-97a9-3ff557bec586
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.GradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge>
internal class IIterableGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.GradientStop?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop
    internal typealias CodiraABI = IIterableGradientStop
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.GradientStop?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.GradientStop?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.GradientStop?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure: WindowsFoundation.IID {
    .init(Data1: 0x387967ce, Data2: 0x013f, Data3: 0x57f5, Data4: ( 0x9a,0x6f,0x4c,0xa5,0x96,0xb0,0xd8,0x0a ))// 387967ce-013f-57f5-9a6f-4ca596b0d80a
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.PathFigure>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge>
internal class IIterablePathFigure: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.PathFigure?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure
    internal typealias CodiraABI = IIterablePathFigure
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.PathFigure?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.PathFigure?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PathFigure?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment: WindowsFoundation.IID {
    .init(Data1: 0xfcc860cd, Data2: 0x04a1, Data3: 0x5b10, Data4: ( 0x87,0x27,0xde,0xb2,0xfa,0x51,0xa9,0x6b ))// fcc860cd-04a1-5b10-8727-deb2fa51a96b
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.PathSegment>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge>
internal class IIterablePathSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.PathSegment?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment
    internal typealias CodiraABI = IIterablePathSegment
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.PathSegment?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.PathSegment?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PathSegment?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform: WindowsFoundation.IID {
    .init(Data1: 0x1a701f75, Data2: 0x905e, Data3: 0x59ee, Data4: ( 0x82,0xc8,0x59,0x13,0xb6,0xc3,0x83,0x02 ))// 1a701f75-905e-59ee-82c8-5913b6c38302
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.Transform>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge>
internal class IIterableTransform: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.Transform?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform
    internal typealias CodiraABI = IIterableTransform
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.Transform?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.Transform?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Transform?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight: WindowsFoundation.IID {
    .init(Data1: 0xc166d8ca, Data2: 0xb148, Data3: 0x5241, Data4: ( 0xbe,0xd5,0x13,0x00,0x30,0x63,0xbd,0x3e ))// c166d8ca-b148-5241-bed5-13003063bd3e
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.Media.XamlLight>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge>
internal class IIterableXamlLight: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.XamlLight?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight
    internal typealias CodiraABI = IIterableXamlLight
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.XamlLight?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.XamlLight?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.XamlLight?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary: WindowsFoundation.IID {
    .init(Data1: 0x1da2bea2, Data2: 0x3287, Data3: 0x5edf, Data4: ( 0xb6,0x2e,0x0d,0x07,0x3c,0x68,0xce,0x0b ))// 1da2bea2-3287-5edf-b62e-0d073c68ce0b
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.ResourceDictionary>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge>
internal class IIterableResourceDictionary: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.ResourceDictionary?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary
    internal typealias CodiraABI = IIterableResourceDictionary
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.ResourceDictionary?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.ResourceDictionary?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ResourceDictionary?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase: WindowsFoundation.IID {
    .init(Data1: 0x9fa9cd08, Data2: 0x8676, Data3: 0x51ab, Data4: ( 0xaf,0xf6,0x60,0x4d,0x0d,0xde,0xa1,0x85 ))// 9fa9cd08-8676-51ab-aff6-604d0ddea185
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.SetterBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge>
internal class IIterableSetterBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.SetterBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase
    internal typealias CodiraABI = IIterableSetterBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.SetterBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.SetterBase?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.SetterBase?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase: WindowsFoundation.IID {
    .init(Data1: 0x4fb6a3b8, Data2: 0x0c07, Data3: 0x57c1, Data4: ( 0xac,0xa7,0xa7,0xbc,0x45,0x3b,0x91,0xe2 ))// 4fb6a3b8-0c07-57c1-aca7-a7bc453b91e2
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.TriggerBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge>
internal class IIterableTriggerBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.TriggerBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase
    internal typealias CodiraABI = IIterableTriggerBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.TriggerBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.TriggerBase?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TriggerBase?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement: WindowsFoundation.IID {
    .init(Data1: 0x459bb954, Data2: 0x42a3, Data3: 0x5c74, Data4: ( 0x8f,0x87,0x42,0x45,0x8f,0x19,0xae,0xaa ))// 459bb954-42a3-5c74-8f87-42458f19aeaa
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Microsoft.UI.Xaml.UIElement>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge>
internal class IIterableUIElement: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WinUI.UIElement?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement
    internal typealias CodiraABI = IIterableUIElement
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WinUI.UIElement?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl : IIterable, AbiInterfaceImpl {
    typealias T = WinUI.UIElement?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.UIElement?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0xe2fcc7c1, Data2: 0x3bfc, Data3: 0x5a0b, Data4: ( 0xb2,0xb0,0x72,0xe7,0x69,0xd1,0xcb,0x7e ))// e2fcc7c1-3bfc-5a0b-b2b0-72e769d1cb7e
}

internal var __x_ABI_C__FIIterable_1_HSTRINGVTable: __x_ABI_C__FIIterable_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1_HSTRINGWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1_HSTRINGWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1_HSTRINGBridge>
internal class IIterableString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1_HSTRING }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<String>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1_HSTRING.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1_HSTRING
    internal typealias CodiraABI = IIterableString
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<String>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1_HSTRINGImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1_HSTRINGImpl : IIterable, AbiInterfaceImpl {
    typealias T = String
    typealias Bridge = __x_ABI_C__FIIterable_1_HSTRINGBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<String>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0xae44597e, Data2: 0xd411, Data3: 0x5b7f, Data4: ( 0xbb,0xec,0x6a,0x96,0xc9,0x4a,0x10,0x7a ))// ae44597e-d411-5b7f-bbec-6a96c94a107a
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Point>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge>
internal class IIterableIIterablePoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIIterable<WindowsFoundation.Point>?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint
    internal typealias CodiraABI = IIterableIIterablePoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIIterable<WindowsFoundation.Point>?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIIterable<WindowsFoundation.Point>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIIterable<WindowsFoundation.Point>?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x33ac68f0, Data2: 0x1084, Data3: 0x529a, Data4: ( 0x8a,0x17,0x4e,0x7c,0x8a,0xdb,0x7a,0x0c ))// 33ac68f0-1084-529a-8a17-4e7c8adb7a0c
}

internal var __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVTable: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Collections.IKeyValuePair`2<Any, Any>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge>
internal class IIterableIKeyValuePairAny_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable
    internal typealias CodiraABI = IIterableIKeyValuePairAny_Any
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0xc192280d, Data2: 0x3a09, Data3: 0x5423, Data4: ( 0x9d,0xc5,0x67,0xb8,0x3e,0xbd,0xe4,0x1d ))// c192280d-3a09-5423-9dc5-67b83ebde41d
}

internal var __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Point>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    First: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.first()
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge>
internal class IIterablePoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint }

    internal fn FirstImpl() throws -> WindowsFoundation.AnyIIterator<WindowsFoundation.Point>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.First(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint
    internal typealias CodiraABI = IIterablePoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterable<WindowsFoundation.Point>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointImpl : IIterable, AbiInterfaceImpl {
    typealias T = WindowsFoundation.Point
    typealias Bridge = __x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.Point>? {
        try! _default.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x44a94f2d, Data2: 0x04f8, Data3: 0x5091, Data4: ( 0xb3,0x36,0xbe,0x78,0x92,0xdd,0x10,0xbe ))// 44a94f2d-04f8-5091-b336-be7892dd10be
}

internal var __x_ABI_C__FIIterator_1_IInspectableVTable: __x_ABI_C__FIIterator_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        immutable resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1_IInspectableBridge>
internal class IIteratorAny: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_IInspectable }

    internal fn get_CurrentImpl() throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_IInspectable
    internal typealias CodiraABI = IIteratorAny
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_IInspectableImpl : IIterator, AbiInterfaceImpl {
    typealias T = Any?
    typealias Bridge = __x_ABI_C__FIIterator_1_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : Any? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1_double: WindowsFoundation.IID {
    .init(Data1: 0x638a2cf4, Data2: 0xf474, Data3: 0x5318, Data4: ( 0x90,0x55,0x14,0x1c,0xb9,0x09,0xac,0x4b ))// 638a2cf4-f474-5318-9055-141cb909ac4b
}

internal var __x_ABI_C__FIIterator_1_doubleVTable: __x_ABI_C__FIIterator_1_doubleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_doubleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_doubleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_doubleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1_doubleWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Double>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_doubleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1_doubleBridge>
internal class IIteratorDouble: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_double }

    internal fn get_CurrentImpl() throws -> Double {
        var result: DOUBLE = 0.0
        _ = try perform(as: __x_ABI_C__FIIterator_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_doubleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_double
    internal typealias CodiraABI = IIteratorDouble
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<Double>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1_doubleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_doubleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_doubleImpl : IIterator, AbiInterfaceImpl {
    typealias T = Double
    typealias Bridge = __x_ABI_C__FIIterator_1_doubleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : Double {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1_float: WindowsFoundation.IID {
    .init(Data1: 0x42614e61, Data2: 0xb0aa, Data3: 0x5e72, Data4: ( 0x93,0x54,0x27,0x71,0xdb,0x20,0xb7,0xa8 ))// 42614e61-b0aa-5e72-9354-2771db20b7a8
}

internal var __x_ABI_C__FIIterator_1_floatVTable: __x_ABI_C__FIIterator_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_floatWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1_floatWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        $1?.initialize(to: result)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_floatWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1_floatBridge>
internal class IIteratorFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_float }

    internal fn get_CurrentImpl() throws -> Float {
        var result: FLOAT = 0.0
        _ = try perform(as: __x_ABI_C__FIIterator_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return result
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_float
    internal typealias CodiraABI = IIteratorFloat
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<Float>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1_floatImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_floatImpl : IIterator, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIIterator_1_floatBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : Float {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0x5b63939d, Data2: 0x11cf, Data3: 0x56c4, Data4: ( 0xb0,0xd0,0x11,0xdf,0x9d,0xc4,0x87,0xd1 ))// 5b63939d-11cf-56c4-b0d0-11df9dc487d1
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge>
internal class IIteratorPointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint }

    internal fn get_CurrentImpl() throws -> WinAppSDK.PointerPoint? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint
    internal typealias CodiraABI = IIteratorPointerPoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinAppSDK.PointerPoint?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinAppSDK.PointerPoint?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinAppSDK.PointerPoint? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation: WindowsFoundation.IID {
    .init(Data1: 0xc6650c15, Data2: 0x8d09, Data3: 0x53f4, Data4: ( 0x8e,0x6c,0x62,0x0b,0xce,0x4f,0xf9,0xae ))// c6650c15-8d09-53f4-8e6c-620bce4ff9ae
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Automation.AutomationAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge>
internal class IIteratorAutomationAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation }

    internal fn get_CurrentImpl() throws -> WinUI.AutomationAnnotation? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation
    internal typealias CodiraABI = IIteratorAutomationAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.AutomationAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.AutomationAnnotation?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.AutomationAnnotation? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer: WindowsFoundation.IID {
    .init(Data1: 0xf5322c8c, Data2: 0xbc0a, Data3: 0x56cf, Data4: ( 0x81,0x2c,0x5f,0xe1,0x40,0x02,0x1f,0x62 ))// f5322c8c-bc0a-56cf-812c-5fe140021f62
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge>
internal class IIteratorAutomationPeer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer }

    internal fn get_CurrentImpl() throws -> WinUI.AutomationPeer? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer
    internal typealias CodiraABI = IIteratorAutomationPeer
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.AutomationPeer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeer?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.AutomationPeer? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation: WindowsFoundation.IID {
    .init(Data1: 0x27b3501a, Data2: 0x5cb5, Data3: 0x572b, Data4: ( 0xb3,0xa3,0x10,0xc3,0x8d,0x82,0xea,0xcc ))// 27b3501a-5cb5-572b-b3a3-10c38d82eacc
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge>
internal class IIteratorAutomationPeerAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation }

    internal fn get_CurrentImpl() throws -> WinUI.AutomationPeerAnnotation? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation
    internal typealias CodiraABI = IIteratorAutomationPeerAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.AutomationPeerAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeerAnnotation?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.AutomationPeerAnnotation? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition: WindowsFoundation.IID {
    .init(Data1: 0x9309739c, Data2: 0xa52f, Data3: 0x5130, Data4: ( 0xa0,0x2c,0xc9,0xbc,0xf7,0x05,0xdf,0x7a ))// 9309739c-a52f-5130-a02c-c9bcf705df7a
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.ColumnDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge>
internal class IIteratorColumnDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition }

    internal fn get_CurrentImpl() throws -> WinUI.ColumnDefinition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition
    internal typealias CodiraABI = IIteratorColumnDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.ColumnDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.ColumnDefinition?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.ColumnDefinition? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle: WindowsFoundation.IID {
    .init(Data1: 0x862e10bb, Data2: 0x08be, Data3: 0x5a33, Data4: ( 0x84,0xea,0xda,0x75,0x7e,0xa2,0x8d,0x59 ))// 862e10bb-08be-5a33-84ea-da757ea28d59
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.GroupStyle>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge>
internal class IIteratorGroupStyle: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle }

    internal fn get_CurrentImpl() throws -> WinUI.GroupStyle? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle
    internal typealias CodiraABI = IIteratorGroupStyle
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.GroupStyle?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.GroupStyle?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.GroupStyle? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem: WindowsFoundation.IID {
    .init(Data1: 0x1637d07e, Data2: 0xb223, Data3: 0x5f2f, Data4: ( 0xa3,0x75,0xf0,0x94,0xba,0x90,0x97,0x0b ))// 1637d07e-b223-5f2f-a375-f094ba90970b
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.MenuBarItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge>
internal class IIteratorMenuBarItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem }

    internal fn get_CurrentImpl() throws -> WinUI.MenuBarItem? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem
    internal typealias CodiraABI = IIteratorMenuBarItem
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.MenuBarItem?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.MenuBarItem?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.MenuBarItem? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase: WindowsFoundation.IID {
    .init(Data1: 0x64dc6e15, Data2: 0x7649, Data3: 0x563f, Data4: ( 0x9a,0xbc,0x05,0x3e,0x01,0x0b,0xc9,0xaf ))// 64dc6e15-7649-563f-9abc-053e010bc9af
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.MenuFlyoutItemBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge>
internal class IIteratorMenuFlyoutItemBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase }

    internal fn get_CurrentImpl() throws -> WinUI.MenuFlyoutItemBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase
    internal typealias CodiraABI = IIteratorMenuFlyoutItemBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.MenuFlyoutItemBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.MenuFlyoutItemBase?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.MenuFlyoutItemBase? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup: WindowsFoundation.IID {
    .init(Data1: 0x899ce360, Data2: 0xeade, Data3: 0x504b, Data4: ( 0x8c,0x0f,0xcf,0x3e,0x94,0xa2,0xea,0x4e ))// 899ce360-eade-504b-8c0f-cf3e94a2ea4e
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.Primitives.Popup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge>
internal class IIteratorPopup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup }

    internal fn get_CurrentImpl() throws -> WinUI.Popup? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup
    internal typealias CodiraABI = IIteratorPopup
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.Popup?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.Popup?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.Popup? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0x02f96dea, Data2: 0x8fc0, Data3: 0x535f, Data4: ( 0xbd,0x68,0x0b,0xdb,0xc8,0x5c,0x20,0x7f ))// 02f96dea-8fc0-535f-bd68-0bdbc85c207f
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge>
internal class IIteratorScrollSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase }

    internal fn get_CurrentImpl() throws -> WinUI.ScrollSnapPointBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase
    internal typealias CodiraABI = IIteratorScrollSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.ScrollSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.ScrollSnapPointBase?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.ScrollSnapPointBase? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0x3bb2735f, Data2: 0x224e, Data3: 0x547b, Data4: ( 0xa7,0xba,0x43,0x31,0x19,0x9a,0xf8,0x93 ))// 3bb2735f-224e-547b-a7ba-4331199af893
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.Primitives.ZoomSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge>
internal class IIteratorZoomSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase }

    internal fn get_CurrentImpl() throws -> WinUI.ZoomSnapPointBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase
    internal typealias CodiraABI = IIteratorZoomSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.ZoomSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.ZoomSnapPointBase?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.ZoomSnapPointBase? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition: WindowsFoundation.IID {
    .init(Data1: 0x78108cba, Data2: 0xfc4e, Data3: 0x5b6c, Data4: ( 0x80,0x0d,0x6c,0x09,0x1b,0x0a,0x1c,0x22 ))// 78108cba-fc4e-5b6c-800d-6c091b0a1c22
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Controls.RowDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge>
internal class IIteratorRowDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition }

    internal fn get_CurrentImpl() throws -> WinUI.RowDefinition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition
    internal typealias CodiraABI = IIteratorRowDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.RowDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.RowDefinition?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.RowDefinition? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange: WindowsFoundation.IID {
    .init(Data1: 0x8cbc4e1b, Data2: 0x9d17, Data3: 0x5fec, Data4: ( 0xbb,0xb0,0x0b,0x25,0x60,0x1a,0x4e,0x2d ))// 8cbc4e1b-9d17-5fec-bbb0-0b25601a4e2d
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Data.ItemIndexRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge>
internal class IIteratorItemIndexRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange }

    internal fn get_CurrentImpl() throws -> WinUI.ItemIndexRange? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange
    internal typealias CodiraABI = IIteratorItemIndexRange
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.ItemIndexRange?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.ItemIndexRange?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.ItemIndexRange? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject: WindowsFoundation.IID {
    .init(Data1: 0x62e49306, Data2: 0x76d0, Data3: 0x5cd7, Data4: ( 0x97,0xd5,0xef,0x08,0xc9,0x34,0xfe,0x9a ))// 62e49306-76d0-5cd7-97d5-ef08c934fe9a
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.DependencyObject>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge>
internal class IIteratorDependencyObject: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject }

    internal fn get_CurrentImpl() throws -> WinUI.DependencyObject? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject
    internal typealias CodiraABI = IIteratorDependencyObject
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.DependencyObject?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.DependencyObject?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.DependencyObject? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline: WindowsFoundation.IID {
    .init(Data1: 0x86e55d23, Data2: 0x6538, Data3: 0x5ca8, Data4: ( 0xb9,0x44,0xd6,0x63,0xe1,0x1a,0x51,0x20 ))// 86e55d23-6538-5ca8-b944-d663e11a5120
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Documents.Inline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge>
internal class IIteratorInline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline }

    internal fn get_CurrentImpl() throws -> WinUI.Inline? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline
    internal typealias CodiraABI = IIteratorInline
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.Inline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.Inline?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.Inline? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter: WindowsFoundation.IID {
    .init(Data1: 0xfc6439f0, Data2: 0xabb0, Data3: 0x5228, Data4: ( 0x86,0x22,0xed,0x9b,0x13,0x37,0xbd,0xc9 ))// fc6439f0-abb0-5228-8622-ed9b1337bdc9
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Documents.TextHighlighter>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge>
internal class IIteratorTextHighlighter: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter }

    internal fn get_CurrentImpl() throws -> WinUI.TextHighlighter? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter
    internal typealias CodiraABI = IIteratorTextHighlighter
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.TextHighlighter?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.TextHighlighter?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.TextHighlighter? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange: WindowsFoundation.IID {
    .init(Data1: 0xc70c1944, Data2: 0x933a, Data3: 0x5ae4, Data4: ( 0xbb,0x65,0x93,0xac,0xfc,0x3f,0x3c,0x40 ))// c70c1944-933a-5ae4-bb65-93acfc3f3c40
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Documents.TextRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        $1?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge>
internal class IIteratorTextRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange }

    internal fn get_CurrentImpl() throws -> WinUI.TextRange {
        var result: __x_ABI_CMicrosoft_CUI_CXaml_CDocuments_CTextRange = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange
    internal typealias CodiraABI = IIteratorTextRange
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.TextRange>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.TextRange
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.TextRange {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName: WindowsFoundation.IID {
    .init(Data1: 0x07f0ed85, Data2: 0x97c5, Data3: 0x5d09, Data4: ( 0x98,0xa4,0x7b,0x35,0x4c,0x12,0xae,0x99 ))// 07f0ed85-97c5-5d09-98a4-7b354c12ae99
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Input.InputScopeName>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge>
internal class IIteratorInputScopeName: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName }

    internal fn get_CurrentImpl() throws -> WinUI.InputScopeName? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName
    internal typealias CodiraABI = IIteratorInputScopeName
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.InputScopeName?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.InputScopeName?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.InputScopeName? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator: WindowsFoundation.IID {
    .init(Data1: 0x6a7cb393, Data2: 0x53c9, Data3: 0x5481, Data4: ( 0xba,0x42,0x90,0xd4,0x31,0x24,0x3d,0x14 ))// 6a7cb393-53c9-5481-ba42-90d431243d14
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Input.KeyboardAccelerator>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge>
internal class IIteratorKeyboardAccelerator: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator }

    internal fn get_CurrentImpl() throws -> WinUI.KeyboardAccelerator? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator
    internal typealias CodiraABI = IIteratorKeyboardAccelerator
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.KeyboardAccelerator?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.KeyboardAccelerator?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.KeyboardAccelerator? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer: WindowsFoundation.IID {
    .init(Data1: 0x41b19b91, Data2: 0x7d83, Data3: 0x5bb2, Data4: ( 0x8a,0x98,0x9b,0x20,0xbb,0xc3,0x59,0xcf ))// 41b19b91-7d83-5bb2-8a98-9b20bbc359cf
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Input.Pointer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge>
internal class IIteratorPointer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer }

    internal fn get_CurrentImpl() throws -> WinUI.Pointer? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer
    internal typealias CodiraABI = IIteratorPointer
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.Pointer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.Pointer?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.Pointer? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x2b8a6b92, Data2: 0xf1e3, Data3: 0x5bc4, Data4: ( 0x96,0xd2,0xe4,0x89,0x2d,0x5c,0xd9,0x3a ))// 2b8a6b92-f1e3-5bc4-96d2-e4892d5cd93a
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Animation.ColorKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge>
internal class IIteratorColorKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame }

    internal fn get_CurrentImpl() throws -> WinUI.ColorKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame
    internal typealias CodiraABI = IIteratorColorKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.ColorKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.ColorKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.ColorKeyFrame? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x7b911c76, Data2: 0x50e4, Data3: 0x509f, Data4: ( 0x98,0xfa,0xd3,0x8b,0x19,0xf6,0xe1,0x59 ))// 7b911c76-50e4-509f-98fa-d38b19f6e159
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Animation.DoubleKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge>
internal class IIteratorDoubleKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame }

    internal fn get_CurrentImpl() throws -> WinUI.DoubleKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame
    internal typealias CodiraABI = IIteratorDoubleKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.DoubleKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.DoubleKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.DoubleKeyFrame? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xbcb7f7fd, Data2: 0x21a4, Data3: 0x5b86, Data4: ( 0x85,0x05,0x91,0xa5,0xaa,0xc9,0x5f,0x31 ))// bcb7f7fd-21a4-5b86-8505-91a5aac95f31
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Animation.ObjectKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge>
internal class IIteratorObjectKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame }

    internal fn get_CurrentImpl() throws -> WinUI.ObjectKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame
    internal typealias CodiraABI = IIteratorObjectKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.ObjectKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.ObjectKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.ObjectKeyFrame? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x8db0cfbf, Data2: 0x9976, Data3: 0x53a8, Data4: ( 0xa9,0x9a,0xf4,0x23,0x40,0x80,0x85,0x5d ))// 8db0cfbf-9976-53a8-a99a-f4234080855d
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Animation.PointKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge>
internal class IIteratorPointKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame }

    internal fn get_CurrentImpl() throws -> WinUI.PointKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame
    internal typealias CodiraABI = IIteratorPointKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.PointKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.PointKeyFrame?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.PointKeyFrame? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline: WindowsFoundation.IID {
    .init(Data1: 0x85301b8e, Data2: 0x275f, Data3: 0x57f3, Data4: ( 0x93,0x44,0xcf,0x04,0x41,0xc7,0x37,0xaa ))// 85301b8e-275f-57f3-9344-cf0441c737aa
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Animation.Timeline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge>
internal class IIteratorTimeline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline }

    internal fn get_CurrentImpl() throws -> WinUI.Timeline? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline
    internal typealias CodiraABI = IIteratorTimeline
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.Timeline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.Timeline?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.Timeline? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition: WindowsFoundation.IID {
    .init(Data1: 0x5cfd74c7, Data2: 0x6e4a, Data3: 0x5c7d, Data4: ( 0x93,0x70,0x2f,0x81,0xc6,0x22,0x74,0xf5 ))// 5cfd74c7-6e4a-5c7d-9370-2f81c62274f5
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Animation.Transition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge>
internal class IIteratorTransition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition }

    internal fn get_CurrentImpl() throws -> WinUI.Transition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition
    internal typealias CodiraABI = IIteratorTransition
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.Transition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.Transition?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.Transition? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry: WindowsFoundation.IID {
    .init(Data1: 0x59d847f1, Data2: 0x4b1b, Data3: 0x5b2d, Data4: ( 0xa2,0xcb,0x23,0x62,0x2e,0x95,0x7d,0xc0 ))// 59d847f1-4b1b-5b2d-a2cb-23622e957dc0
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Geometry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge>
internal class IIteratorGeometry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry }

    internal fn get_CurrentImpl() throws -> WinUI.Geometry? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry
    internal typealias CodiraABI = IIteratorGeometry
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.Geometry?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.Geometry?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.Geometry? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop: WindowsFoundation.IID {
    .init(Data1: 0x42d46f68, Data2: 0xdf94, Data3: 0x58f9, Data4: ( 0x8c,0xdf,0x3d,0x40,0x3e,0x7d,0xd1,0xd3 ))// 42d46f68-df94-58f9-8cdf-3d403e7dd1d3
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.GradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge>
internal class IIteratorGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop }

    internal fn get_CurrentImpl() throws -> WinUI.GradientStop? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop
    internal typealias CodiraABI = IIteratorGradientStop
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.GradientStop?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.GradientStop?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.GradientStop? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure: WindowsFoundation.IID {
    .init(Data1: 0x0c15c679, Data2: 0x2952, Data3: 0x5fcd, Data4: ( 0xbf,0xb3,0xc9,0x06,0x4c,0x65,0x00,0x72 ))// 0c15c679-2952-5fcd-bfb3-c9064c650072
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.PathFigure>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge>
internal class IIteratorPathFigure: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure }

    internal fn get_CurrentImpl() throws -> WinUI.PathFigure? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure
    internal typealias CodiraABI = IIteratorPathFigure
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.PathFigure?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.PathFigure?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.PathFigure? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment: WindowsFoundation.IID {
    .init(Data1: 0x434e1321, Data2: 0x9560, Data3: 0x5646, Data4: ( 0x8b,0xf7,0xe1,0xb0,0x67,0x96,0x72,0x3f ))// 434e1321-9560-5646-8bf7-e1b06796723f
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.PathSegment>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge>
internal class IIteratorPathSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment }

    internal fn get_CurrentImpl() throws -> WinUI.PathSegment? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment
    internal typealias CodiraABI = IIteratorPathSegment
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.PathSegment?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.PathSegment?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.PathSegment? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform: WindowsFoundation.IID {
    .init(Data1: 0x5ab75535, Data2: 0x9fba, Data3: 0x54cc, Data4: ( 0x9d,0xb3,0x3f,0xb6,0xc0,0xe4,0xab,0xf5 ))// 5ab75535-9fba-54cc-9db3-3fb6c0e4abf5
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.Transform>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge>
internal class IIteratorTransform: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform }

    internal fn get_CurrentImpl() throws -> WinUI.Transform? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform
    internal typealias CodiraABI = IIteratorTransform
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.Transform?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.Transform?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.Transform? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight: WindowsFoundation.IID {
    .init(Data1: 0xe75863b3, Data2: 0x0b25, Data3: 0x5c28, Data4: ( 0x86,0xc8,0x9e,0xc4,0x9f,0x76,0xd4,0x68 ))// e75863b3-0b25-5c28-86c8-9ec49f76d468
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.Media.XamlLight>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge>
internal class IIteratorXamlLight: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight }

    internal fn get_CurrentImpl() throws -> WinUI.XamlLight? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight
    internal typealias CodiraABI = IIteratorXamlLight
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.XamlLight?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.XamlLight?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.XamlLight? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary: WindowsFoundation.IID {
    .init(Data1: 0x9483d8a0, Data2: 0x2803, Data3: 0x50f1, Data4: ( 0x98,0xdb,0xfa,0x3a,0x7e,0x6a,0x56,0xb3 ))// 9483d8a0-2803-50f1-98db-fa3a7e6a56b3
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.ResourceDictionary>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge>
internal class IIteratorResourceDictionary: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary }

    internal fn get_CurrentImpl() throws -> WinUI.ResourceDictionary? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary
    internal typealias CodiraABI = IIteratorResourceDictionary
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.ResourceDictionary?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.ResourceDictionary?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.ResourceDictionary? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase: WindowsFoundation.IID {
    .init(Data1: 0x555894a1, Data2: 0xcc82, Data3: 0x5af0, Data4: ( 0xb2,0x20,0x53,0xe7,0x3b,0x2d,0xba,0x33 ))// 555894a1-cc82-5af0-b220-53e73b2dba33
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.SetterBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge>
internal class IIteratorSetterBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase }

    internal fn get_CurrentImpl() throws -> WinUI.SetterBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase
    internal typealias CodiraABI = IIteratorSetterBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.SetterBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.SetterBase?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.SetterBase? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase: WindowsFoundation.IID {
    .init(Data1: 0x93d0f9fa, Data2: 0x22d2, Data3: 0x5e84, Data4: ( 0xac,0x72,0xaa,0xcf,0x06,0xf9,0x79,0x00 ))// 93d0f9fa-22d2-5e84-ac72-aacf06f97900
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.TriggerBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge>
internal class IIteratorTriggerBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase }

    internal fn get_CurrentImpl() throws -> WinUI.TriggerBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase
    internal typealias CodiraABI = IIteratorTriggerBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.TriggerBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.TriggerBase?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.TriggerBase? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement: WindowsFoundation.IID {
    .init(Data1: 0xc5f188b0, Data2: 0xc653, Data3: 0x5209, Data4: ( 0x90,0x9a,0xeb,0x97,0xca,0x69,0x16,0x17 ))// c5f188b0-c653-5209-909a-eb97ca691617
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Microsoft.UI.Xaml.UIElement>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        result?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge>
internal class IIteratorUIElement: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement }

    internal fn get_CurrentImpl() throws -> WinUI.UIElement? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement
    internal typealias CodiraABI = IIteratorUIElement
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WinUI.UIElement?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl : IIterator, AbiInterfaceImpl {
    typealias T = WinUI.UIElement?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WinUI.UIElement? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x8c304ebb, Data2: 0x6615, Data3: 0x50a4, Data4: ( 0x88,0x29,0x87,0x9e,0xcd,0x44,0x32,0x36 ))// 8c304ebb-6615-50a4-8829-879ecd443236
}

internal var __x_ABI_C__FIIterator_1_HSTRINGVTable: __x_ABI_C__FIIterator_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1_HSTRINGWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1_HSTRINGWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        $1?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1_HSTRINGWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1_HSTRINGBridge>
internal class IIteratorString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1_HSTRING }

    internal fn get_CurrentImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIIterator_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1_HSTRING
    internal typealias CodiraABI = IIteratorString
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<String>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1_HSTRINGImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1_HSTRINGImpl : IIterator, AbiInterfaceImpl {
    typealias T = String
    typealias Bridge = __x_ABI_C__FIIterator_1_HSTRINGBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : String {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0x377f6162, Data2: 0x6e4d, Data3: 0x574e, Data4: ( 0xbf,0x01,0x77,0xf4,0xfd,0x02,0x1d,0x0e ))// 377f6162-6e4d-574e-bf01-77f4fd021d0e
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IIterable`1<Windows.Foundation.Point>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        immutable resultWrapper = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge>
internal class IIteratorIIterablePoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint }

    internal fn get_CurrentImpl() throws -> WindowsFoundation.AnyIIterable<WindowsFoundation.Point>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.unwrapFrom(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPoint
    internal typealias CodiraABI = IIteratorIIterablePoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIIterable<WindowsFoundation.Point>?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIIterable<WindowsFoundation.Point>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIIterable<WindowsFoundation.Point>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x31e55e8a, Data2: 0x0f05, Data3: 0x52fd, Data4: ( 0x90,0xd3,0xb0,0x4a,0xa3,0x31,0xaa,0xa4 ))// 31e55e8a-0f05-52fd-90d3-b04aa331aaa4
}

internal var __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVTable: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Collections.IKeyValuePair`2<Any, Any>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        immutable resultWrapper = WinUI.__x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge>
internal class IIteratorIKeyValuePairAny_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable }

    internal fn get_CurrentImpl() throws -> WindowsFoundation.AnyIKeyValuePair<Any?, Any?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable
    internal typealias CodiraABI = IIteratorIKeyValuePairAny_Any
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.AnyIKeyValuePair<Any?, Any?>? {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0xc602b59e, Data2: 0x0a8e, Data3: 0x5e99, Data4: ( 0xb4,0x78,0x2b,0x56,0x45,0x85,0x27,0x8d ))// c602b59e-0a8e-5e99-b478-2b564585278d
}

internal var __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IIterator`1<Windows.Foundation.Point>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Current: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.current
        $1?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_HasCurrent: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.hasCurrent
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    MoveNext: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.moveNext()
        $1?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointBridge>
internal class IIteratorPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPoint }

    internal fn get_CurrentImpl() throws -> WindowsFoundation.Point {
        var result: __x_ABI_CWindows_CFoundation_CPoint = .init()
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Current(pThis, &result))
        }
        return .from(abi: result)
    }

    internal fn get_HasCurrentImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_HasCurrent(pThis, &result))
        }
        return .init(from: result)
    }

    internal fn MoveNextImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.MoveNext(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPoint
    internal typealias CodiraABI = IIteratorPoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIIterator<WindowsFoundation.Point>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointImpl : IIterator, AbiInterfaceImpl {
    typealias T = WindowsFoundation.Point
    typealias Bridge = __x_ABI_C__FIIterator_1___x_ABI_CWindows__CFoundation__CPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.movenext)
    fileprivate fn moveNext() -> Boolean {
        try! _default.MoveNextImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.current)
    fileprivate var current : WindowsFoundation.Point {
        get { try! _default.get_CurrentImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iiterator-1.hascurrent)
    fileprivate var hasCurrent : Boolean {
        get { try! _default.get_HasCurrentImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x59e7ae0c, Data2: 0xc29d, Data3: 0x5ad6, Data4: ( 0xbe,0xf5,0xde,0xdb,0x52,0xa1,0x98,0xe1 ))// 59e7ae0c-c29d-5ad6-bef5-dedb52a198e1
}

internal var __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVTable: __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 3).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.IID
        $1!.pointee = 3
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IKeyValuePair`2<Any, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Key: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.key
        immutable resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.value
        immutable resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    }
)
typealias __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge>
internal class IKeyValuePairAny_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable }

    internal fn get_KeyImpl() throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Key(pThis, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal fn get_ValueImpl() throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Value(pThis, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectable
    internal typealias CodiraABI = IKeyValuePairAny_Any
    internal typealias CodiraProjection = WindowsFoundation.AnyIKeyValuePair<Any?, Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableImpl : IKeyValuePair, AbiInterfaceImpl {
    typealias K = Any?
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.key)
    fileprivate var key : Any? {
        get { try! _default.get_KeyImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ikeyvaluepair-2.value)
    fileprivate var value : Any? {
        get { try! _default.get_ValueImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIMapView_2_IInspectable_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xefe76d10, Data2: 0xcb60, Data3: 0x50ad, Data4: ( 0x8a,0x4f,0x68,0x85,0xcd,0x62,0x12,0xa1 ))// efe76d10-cb60-50ad-8a4f-6885cd6212a1
}

internal var __x_ABI_C__FIMapView_2_IInspectable_IInspectableVTable: __x_ABI_C__FIMapView_2_IInspectable_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IMapView`2<Any, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable key: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable result = __unwrapped__instance.lookup(key)
        immutable resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable key: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    Split: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        var first: WindowsFoundation.AnyIMapView<Any?, Any?>?
        var second: WindowsFoundation.AnyIMapView<Any?, Any?>?
        __unwrapped__instance.split(&first, &second)
        immutable firstWrapper = WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper(first)
        firstWrapper?.copyTo($1)
        immutable secondWrapper = WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper(second)
        secondWrapper?.copyTo($2)
        return S_OK
    }
)
typealias __x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableBridge>
internal class IMapViewAny_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMapView_2_IInspectable_IInspectable }

    internal fn LookupImpl(_ key: Any?) throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            immutable keyWrapper = __ABI_.AnyWrapper(key)
            immutable _key = try! keyWrapper?.toABI { $0 }
            _ = try perform(as: __x_ABI_C__FIMapView_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMapView_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn HasKeyImpl(_ key: Any?) throws -> Boolean {
        var result: boolean = 0
        immutable keyWrapper = __ABI_.AnyWrapper(key)
        immutable _key = try! keyWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMapView_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key, &result))
        }
        return .init(from: result)
    }

    internal fn SplitImpl(_ first: inout WindowsFoundation.AnyIMapView<Any?, Any?>?, _ second: inout WindowsFoundation.AnyIMapView<Any?, Any?>?) throws {
        immutable (_first, _second) = try ComPtrs.initialize { (_firstAbi, _secondAbi) in
            _ = try perform(as: __x_ABI_C__FIMapView_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Split(pThis, &_firstAbi, &_secondAbi))
            }
        }
        first = WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.unwrapFrom(abi: _first)
        second = WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.unwrapFrom(abi: _second)
    }

}

internal enum __x_ABI_C__FIMapView_2_IInspectable_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMapView_2_IInspectable_IInspectable
    internal typealias CodiraABI = IMapViewAny_Any
    internal typealias CodiraProjection = WindowsFoundation.AnyIMapView<Any?, Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIMapView_2_IInspectable_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMapView_2_IInspectable_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMapView_2_IInspectable_IInspectableImpl : IMapView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?
    typealias K = Any?
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIMapView_2_IInspectable_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.lookup)
    fileprivate fn lookup(_ key: Any?) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.haskey)
    fileprivate fn hasKey(_ key: Any?) -> Boolean {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.split)
    fileprivate fn split(_ first: inout WindowsFoundation.AnyIMapView<Any?, Any?>?, _ second: inout WindowsFoundation.AnyIMapView<Any?, Any?>?) {
        try! _default.SplitImpl(&first, &second)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairAny_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imapview-2.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIMap_2_IInspectable_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xf5f69427, Data2: 0x55ed, Data3: 0x5512, Data4: ( 0x84,0x29,0xd4,0xf6,0x62,0x6d,0xfc,0xdd ))// f5f69427-55ed-5512-8429-d4f6626dfcdd
}

internal var __x_ABI_C__FIMap_2_IInspectable_IInspectableVTable: __x_ABI_C__FIMap_2_IInspectable_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_C__FIKeyValuePair_2_IInspectable_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IMap`2<Any, Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    Lookup: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable key: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable result = __unwrapped__instance.lookup(key)
        immutable resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    HasKey: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable key: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable result = __unwrapped__instance.hasKey(key)
        $2?.initialize(to: .init(from: result))
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    Insert: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable key: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        immutable result = __unwrapped__instance.insert(key, value)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    Remove: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable key: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        __unwrapped__instance.remove(key)
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    }
)
typealias __x_ABI_C__FIMap_2_IInspectable_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIMap_2_IInspectable_IInspectableBridge>
internal class IMapAny_Any: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIMap_2_IInspectable_IInspectable }

    internal fn LookupImpl(_ key: Any?) throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            immutable keyWrapper = __ABI_.AnyWrapper(key)
            immutable _key = try! keyWrapper?.toABI { $0 }
            _ = try perform(as: __x_ABI_C__FIMap_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.Lookup(pThis, _key, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIMap_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn HasKeyImpl(_ key: Any?) throws -> Boolean {
        var result: boolean = 0
        immutable keyWrapper = __ABI_.AnyWrapper(key)
        immutable _key = try! keyWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.HasKey(pThis, _key, &result))
        }
        return .init(from: result)
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIMapView<Any?, Any?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIMap_2_IInspectable_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIMapView_2_IInspectable_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal fn InsertImpl(_ key: Any?, _ value: Any?) throws -> Boolean {
        var result: boolean = 0
        immutable keyWrapper = __ABI_.AnyWrapper(key)
        immutable _key = try! keyWrapper?.toABI { $0 }
        immutable valueWrapper = __ABI_.AnyWrapper(value)
        immutable _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Insert(pThis, _key, _value, &result))
        }
        return .init(from: result)
    }

    internal fn RemoveImpl(_ key: Any?) throws {
        immutable keyWrapper = __ABI_.AnyWrapper(key)
        immutable _key = try! keyWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIMap_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, _key))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIMap_2_IInspectable_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIMap_2_IInspectable_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIMap_2_IInspectable_IInspectable
    internal typealias CodiraABI = IMapAny_Any
    internal typealias CodiraProjection = WindowsFoundation.AnyIMap<Any?, Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIMap_2_IInspectable_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIMap_2_IInspectable_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIMap_2_IInspectable_IInspectableImpl : IMap, AbiInterfaceImpl {
    typealias T = WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?
    typealias K = Any?
    typealias V = Any?
    typealias Bridge = __x_ABI_C__FIMap_2_IInspectable_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.lookup)
    fileprivate fn lookup(_ key: Any?) -> Any? {
        try! _default.LookupImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.haskey)
    fileprivate fn hasKey(_ key: Any?) -> Boolean {
        try! _default.HasKeyImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIMapView<Any?, Any?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.insert)
    fileprivate fn insert(_ key: Any?, _ value: Any?) -> Boolean {
        try! _default.InsertImpl(key, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.remove)
    fileprivate fn remove(_ key: Any?) {
        try! _default.RemoveImpl(key)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableIKeyValuePairAny_Any! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.imap-2.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.AnyIKeyValuePair<Any?, Any?>?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIObservableVector_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x7b81c56a, Data2: 0x0985, Data3: 0x518d, Data4: ( 0xba,0xa9,0x0d,0xa9,0xae,0x00,0x9f,0x65 ))// 7b81c56a-0985-518d-baa9-0da9ae009f65
}

internal var __x_ABI_C__FIObservableVector_1_IInspectableVTable: __x_ABI_C__FIObservableVector_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIObservableVector_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIObservableVector_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIObservableVector_1_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 5).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIObservableVector_1_IInspectableWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIVector_1_IInspectableWrapper.IID
        iids[4] = WinUI.__x_ABI_C__FIIterable_1_IInspectableWrapper.IID
        $1!.pointee = 5
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IObservableVector`1<Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    add_VectorChanged: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIObservableVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable vhnd = WinUI.__x_ABI_C__FVectorChangedEventHandler_1_IInspectableWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.vectorChanged.addHandler(vhnd)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    remove_VectorChanged: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIObservableVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable token: EventRegistrationToken = $1
        __unwrapped__instance.vectorChanged.removeHandler(token)
        return S_OK
    }
)
typealias __x_ABI_C__FIObservableVector_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIObservableVector_1_IInspectableBridge>
internal class IObservableVectorAny: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIObservableVector_1_IInspectable }

    internal fn add_VectorChangedImpl(_ vhnd: VectorChangedEventHandler<Any?>?) throws -> EventRegistrationToken {
        var result: EventRegistrationToken = .init()
        immutable vhndWrapper = WinUI.__x_ABI_C__FVectorChangedEventHandler_1_IInspectableWrapper(vhnd)
        immutable _vhnd = try! vhndWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIObservableVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_VectorChanged(pThis, _vhnd, &result))
        }
        return result
    }

    internal fn remove_VectorChangedImpl(_ token: EventRegistrationToken) throws {
        _ = try perform(as: __x_ABI_C__FIObservableVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_VectorChanged(pThis, token))
        }
    }

}

internal enum __x_ABI_C__FIObservableVector_1_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIObservableVector_1_IInspectable
    internal typealias CodiraABI = IObservableVectorAny
    internal typealias CodiraProjection = WindowsFoundation.AnyIObservableVector<Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIObservableVector_1_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIObservableVector_1_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIObservableVector_1_IInspectableImpl : IObservableVector, AbiInterfaceImpl {
    typealias T = Any?
    typealias Bridge = __x_ABI_C__FIObservableVector_1_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.vectorchanged)
    fileprivate lazy var vectorChanged : Event<VectorChangedEventHandler<Any?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_VectorChangedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_VectorChangedImpl($0)
       }
      )
    }()

    private lazy var _IVector: IVectorAny! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> Any? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<Any?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.indexof)
    fileprivate fn indexOf(_ value: Any?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: Any?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: Any?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.append)
    fileprivate fn append(_ value: Any?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.clear)
    fileprivate fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.size)
    fileprivate var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAny! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Any?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle: WindowsFoundation.IID {
    .init(Data1: 0x80dae4e3, Data2: 0x4fce, Data3: 0x5788, Data4: ( 0x92,0x3b,0xc1,0xb7,0x5b,0x82,0xa6,0x11 ))// 80dae4e3-4fce-5788-923b-c1b75b82a611
}

internal var __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable: __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 5).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        iids[4] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        $1!.pointee = 5
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IObservableVector`1<Microsoft.UI.Xaml.Controls.GroupStyle>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    add_VectorChanged: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable vhnd = WinUI.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.vectorChanged.addHandler(vhnd)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    remove_VectorChanged: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable token: EventRegistrationToken = $1
        __unwrapped__instance.vectorChanged.removeHandler(token)
        return S_OK
    }
)
typealias __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge>
internal class IObservableVectorGroupStyle: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle }

    internal fn add_VectorChangedImpl(_ vhnd: VectorChangedEventHandler<WinUI.GroupStyle?>?) throws -> EventRegistrationToken {
        var result: EventRegistrationToken = .init()
        immutable vhndWrapper = WinUI.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper(vhnd)
        immutable _vhnd = try! vhndWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_VectorChanged(pThis, _vhnd, &result))
        }
        return result
    }

    internal fn remove_VectorChangedImpl(_ token: EventRegistrationToken) throws {
        _ = try perform(as: __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_VectorChanged(pThis, token))
        }
    }

}

internal enum __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle
    internal typealias CodiraABI = IObservableVectorGroupStyle
    internal typealias CodiraProjection = WindowsFoundation.AnyIObservableVector<WinUI.GroupStyle?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl : IObservableVector, AbiInterfaceImpl {
    typealias T = WinUI.GroupStyle?
    typealias Bridge = __x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.vectorchanged)
    fileprivate lazy var vectorChanged : Event<VectorChangedEventHandler<GroupStyle?>> = {
      .init(
        add: { [weak this] in
          guard immutable this = this?._default else { return .init() }
          return try! this.add_VectorChangedImpl($0)
        },
        remove: { [weak this] in
         try? this?._default.remove_VectorChangedImpl($0)
       }
      )
    }()

    private lazy var _IVector: IVectorGroupStyle! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.GroupStyle? {
        try! _IVector.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.GroupStyle?>? {
        try! _IVector.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.GroupStyle?, _ index: inout UInt32) -> Boolean {
        try! _IVector.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.GroupStyle?) {
        try! _IVector.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.GroupStyle?) {
        try! _IVector.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _IVector.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.append)
    fileprivate fn append(_ value: WinUI.GroupStyle?) {
        try! _IVector.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _IVector.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.clear)
    fileprivate fn clear() {
        try! _IVector.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.size)
    fileprivate var size : UInt32 {
        get { try! _IVector.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableGroupStyle! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.iobservablevector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.GroupStyle?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xa6487363, Data2: 0xb074, Data3: 0x5c60, Data4: ( 0xab,0x16,0x86,0x6d,0xce,0x4e,0xe5,0x4d ))// a6487363-b074-5c60-ab16-866dce4ee54d
}

internal var __x_ABI_C__FIVectorView_1_IInspectableVTable: __x_ABI_C__FIVectorView_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1_IInspectableWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        immutable resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1_IInspectableBridge>
internal class IVectorViewAny: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_IInspectable }

    internal fn GetAtImpl(_ index: UInt32) throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: Any?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        immutable valueWrapper = __ABI_.AnyWrapper(value)
        immutable _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVectorView_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_IInspectable
    internal typealias CodiraABI = IVectorViewAny
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_IInspectableImpl : IVectorView, AbiInterfaceImpl {
    typealias T = Any?
    typealias Bridge = __x_ABI_C__FIVectorView_1_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> Any? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: Any?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAny! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Any?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1_double: WindowsFoundation.IID {
    .init(Data1: 0xaf7586a8, Data2: 0x6b21, Data3: 0x5f61, Data4: ( 0xbf,0xf1,0x1b,0x68,0x22,0x93,0xad,0x96 ))// af7586a8-6b21-5f61-bff1-1b682293ad96
}

internal var __x_ABI_C__FIVectorView_1_doubleVTable: __x_ABI_C__FIVectorView_1_doubleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_doubleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_doubleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_doubleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1_doubleWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1_doubleWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Double>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Double = $1
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_doubleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1_doubleBridge>
internal class IVectorViewDouble: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_double }

    internal fn GetAtImpl(_ index: UInt32) throws -> Double {
        var result: DOUBLE = 0.0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: Double, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_doubleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_double
    internal typealias CodiraABI = IVectorViewDouble
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<Double>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1_doubleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_doubleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_doubleImpl : IVectorView, AbiInterfaceImpl {
    typealias T = Double
    typealias Bridge = __x_ABI_C__FIVectorView_1_doubleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> Double {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: Double, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDouble! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Double>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1_float: WindowsFoundation.IID {
    .init(Data1: 0x7bca64fd, Data2: 0x150c, Data3: 0x5d50, Data4: ( 0xb5,0x6b,0x9f,0x4f,0x47,0x4c,0x59,0x30 ))// 7bca64fd-150c-5d50-b56b-9f4f474c5930
}

internal var __x_ABI_C__FIVectorView_1_floatVTable: __x_ABI_C__FIVectorView_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_floatWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1_floatWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1_floatWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Float = $1
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_floatWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1_floatBridge>
internal class IVectorViewFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_float }

    internal fn GetAtImpl(_ index: UInt32) throws -> Float {
        var result: FLOAT = 0.0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: Float, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_float
    internal typealias CodiraABI = IVectorViewFloat
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<Float>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1_floatImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_floatImpl : IVectorView, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIVectorView_1_floatBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> Float {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: Float, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFloat! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Float>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0x5fbb224b, Data2: 0x8430, Data3: 0x5086, Data4: ( 0xab,0x85,0xe7,0x1d,0xfa,0xa8,0x4c,0x90 ))// 5fbb224b-8430-5086-ab85-e71dfaa84c90
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinAppSDK.PointerPoint? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge>
internal class IVectorViewPointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinAppSDK.PointerPoint? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinAppSDK.PointerPoint?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint
    internal typealias CodiraABI = IVectorViewPointerPoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinAppSDK.PointerPoint?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinAppSDK.PointerPoint?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinAppSDK.PointerPoint? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinAppSDK.PointerPoint?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointerPoint! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinAppSDK.PointerPoint?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation: WindowsFoundation.IID {
    .init(Data1: 0x15c04825, Data2: 0xb975, Data3: 0x5bc5, Data4: ( 0xad,0xf9,0xe3,0xb6,0x06,0x2a,0x7a,0xfa ))// 15c04825-b975-5bc5-adf9-e3b6062a7afa
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Automation.AutomationAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationAnnotation? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge>
internal class IVectorViewAutomationAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.AutomationAnnotation? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.AutomationAnnotation?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation
    internal typealias CodiraABI = IVectorViewAutomationAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.AutomationAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.AutomationAnnotation?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.AutomationAnnotation? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.AutomationAnnotation?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAutomationAnnotation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationAnnotation?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer: WindowsFoundation.IID {
    .init(Data1: 0x26501cc8, Data2: 0x81ab, Data3: 0x54e0, Data4: ( 0x80,0x49,0x2b,0xbd,0x47,0xc9,0xff,0x36 ))// 26501cc8-81ab-54e0-8049-2bbd47c9ff36
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationPeer? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge>
internal class IVectorViewAutomationPeer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.AutomationPeer? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.AutomationPeer?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer
    internal typealias CodiraABI = IVectorViewAutomationPeer
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.AutomationPeer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeer?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.AutomationPeer? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.AutomationPeer?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAutomationPeer! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeer?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation: WindowsFoundation.IID {
    .init(Data1: 0x7a5622c2, Data2: 0x354b, Data3: 0x5d4e, Data4: ( 0xb8,0x6d,0x34,0x82,0xeb,0x35,0x51,0x3e ))// 7a5622c2-354b-5d4e-b86d-3482eb35513e
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationPeerAnnotation? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge>
internal class IVectorViewAutomationPeerAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.AutomationPeerAnnotation? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.AutomationPeerAnnotation?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation
    internal typealias CodiraABI = IVectorViewAutomationPeerAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.AutomationPeerAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeerAnnotation?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.AutomationPeerAnnotation? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.AutomationPeerAnnotation?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAutomationPeerAnnotation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeerAnnotation?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition: WindowsFoundation.IID {
    .init(Data1: 0xcdfba81a, Data2: 0x54fa, Data3: 0x557d, Data4: ( 0xa7,0x12,0x21,0x64,0x0f,0x16,0xc5,0x34 ))// cdfba81a-54fa-557d-a712-21640f16c534
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.ColumnDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ColumnDefinition? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge>
internal class IVectorViewColumnDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ColumnDefinition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.ColumnDefinition?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition
    internal typealias CodiraABI = IVectorViewColumnDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.ColumnDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.ColumnDefinition?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ColumnDefinition? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ColumnDefinition?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableColumnDefinition! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ColumnDefinition?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle: WindowsFoundation.IID {
    .init(Data1: 0x52279bfd, Data2: 0x81a6, Data3: 0x5497, Data4: ( 0x93,0x30,0x16,0x12,0x88,0x6e,0x72,0x31 ))// 52279bfd-81a6-5497-9330-1612886e7231
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.GroupStyle>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.GroupStyle? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge>
internal class IVectorViewGroupStyle: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.GroupStyle? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.GroupStyle?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle
    internal typealias CodiraABI = IVectorViewGroupStyle
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.GroupStyle?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.GroupStyle?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.GroupStyle? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.GroupStyle?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableGroupStyle! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.GroupStyle?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem: WindowsFoundation.IID {
    .init(Data1: 0xd99a99f0, Data2: 0xd72d, Data3: 0x5172, Data4: ( 0x87,0x81,0x3d,0xe6,0xee,0x29,0x27,0x49 ))// d99a99f0-d72d-5172-8781-3de6ee292749
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.MenuBarItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.MenuBarItem? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge>
internal class IVectorViewMenuBarItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.MenuBarItem? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.MenuBarItem?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem
    internal typealias CodiraABI = IVectorViewMenuBarItem
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.MenuBarItem?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.MenuBarItem?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.MenuBarItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.MenuBarItem?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMenuBarItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.MenuBarItem?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase: WindowsFoundation.IID {
    .init(Data1: 0xf817bdda, Data2: 0x4853, Data3: 0x503a, Data4: ( 0x86,0xc3,0x06,0x2d,0xb9,0x9d,0x04,0x19 ))// f817bdda-4853-503a-86c3-062db99d0419
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.MenuFlyoutItemBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.MenuFlyoutItemBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge>
internal class IVectorViewMenuFlyoutItemBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.MenuFlyoutItemBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.MenuFlyoutItemBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase
    internal typealias CodiraABI = IVectorViewMenuFlyoutItemBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.MenuFlyoutItemBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.MenuFlyoutItemBase?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.MenuFlyoutItemBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.MenuFlyoutItemBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMenuFlyoutItemBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.MenuFlyoutItemBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup: WindowsFoundation.IID {
    .init(Data1: 0xef55f12e, Data2: 0x1ca7, Data3: 0x51f3, Data4: ( 0x99,0x55,0x46,0xde,0x46,0x22,0xf0,0xaa ))// ef55f12e-1ca7-51f3-9955-46de4622f0aa
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.Primitives.Popup>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Popup? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge>
internal class IVectorViewPopup: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Popup? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.Popup?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopup
    internal typealias CodiraABI = IVectorViewPopup
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.Popup?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.Popup?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CPopupBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Popup? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Popup?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePopup! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Popup?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0xffd69432, Data2: 0x94da, Data3: 0x50ae, Data4: ( 0xac,0x63,0x1d,0xad,0xc0,0xe9,0x90,0x0f ))// ffd69432-94da-50ae-ac63-1dadc0e9900f
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ScrollSnapPointBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge>
internal class IVectorViewScrollSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ScrollSnapPointBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.ScrollSnapPointBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase
    internal typealias CodiraABI = IVectorViewScrollSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.ScrollSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.ScrollSnapPointBase?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ScrollSnapPointBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ScrollSnapPointBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableScrollSnapPointBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ScrollSnapPointBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0x09386c00, Data2: 0x10c1, Data3: 0x5ae0, Data4: ( 0x8e,0x62,0x3d,0xfb,0x51,0x98,0xc4,0x89 ))// 09386c00-10c1-5ae0-8e62-3dfb5198c489
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.Primitives.ZoomSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ZoomSnapPointBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge>
internal class IVectorViewZoomSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ZoomSnapPointBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.ZoomSnapPointBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase
    internal typealias CodiraABI = IVectorViewZoomSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.ZoomSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.ZoomSnapPointBase?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ZoomSnapPointBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ZoomSnapPointBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableZoomSnapPointBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ZoomSnapPointBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition: WindowsFoundation.IID {
    .init(Data1: 0xeaa65d85, Data2: 0x3fa0, Data3: 0x5bc2, Data4: ( 0xb1,0xbe,0x7b,0xc7,0x22,0x25,0x3e,0xae ))// eaa65d85-3fa0-5bc2-b1be-7bc722253eae
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Controls.RowDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.RowDefinition? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge>
internal class IVectorViewRowDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.RowDefinition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.RowDefinition?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition
    internal typealias CodiraABI = IVectorViewRowDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.RowDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.RowDefinition?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.RowDefinition? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.RowDefinition?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableRowDefinition! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.RowDefinition?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange: WindowsFoundation.IID {
    .init(Data1: 0x465af292, Data2: 0xd97c, Data3: 0x5407, Data4: ( 0x9c,0xbe,0x6d,0x35,0xd6,0x7a,0x03,0x0f ))// 465af292-d97c-5407-9cbe-6d35d67a030f
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Data.ItemIndexRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ItemIndexRange? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge>
internal class IVectorViewItemIndexRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ItemIndexRange? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.ItemIndexRange?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRange
    internal typealias CodiraABI = IVectorViewItemIndexRange
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.ItemIndexRange?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.ItemIndexRange?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CItemIndexRangeBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ItemIndexRange? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ItemIndexRange?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableItemIndexRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ItemIndexRange?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject: WindowsFoundation.IID {
    .init(Data1: 0x9eddd815, Data2: 0x4420, Data3: 0x5639, Data4: ( 0x9b,0x26,0xea,0xb8,0x01,0x3f,0xa2,0x94 ))// 9eddd815-4420-5639-9b26-eab8013fa294
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.DependencyObject>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.DependencyObject? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge>
internal class IVectorViewDependencyObject: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.DependencyObject? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.DependencyObject?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject
    internal typealias CodiraABI = IVectorViewDependencyObject
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.DependencyObject?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.DependencyObject?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.DependencyObject? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.DependencyObject?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDependencyObject! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.DependencyObject?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline: WindowsFoundation.IID {
    .init(Data1: 0xb0525fd0, Data2: 0xf83c, Data3: 0x54a4, Data4: ( 0xbc,0x08,0xf2,0x57,0x4b,0x42,0xc5,0x36 ))// b0525fd0-f83c-54a4-bc08-f2574b42c536
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Documents.Inline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Inline? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge>
internal class IVectorViewInline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Inline? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.Inline?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline
    internal typealias CodiraABI = IVectorViewInline
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.Inline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.Inline?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Inline? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Inline?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableInline! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Inline?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter: WindowsFoundation.IID {
    .init(Data1: 0x20f348a9, Data2: 0x4ef5, Data3: 0x5f8f, Data4: ( 0xa3,0xce,0xbd,0xc1,0xd8,0x3a,0x2f,0xda ))// 20f348a9-4ef5-5f8f-a3ce-bdc1d83a2fda
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Documents.TextHighlighter>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TextHighlighter? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge>
internal class IVectorViewTextHighlighter: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.TextHighlighter? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.TextHighlighter?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter
    internal typealias CodiraABI = IVectorViewTextHighlighter
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.TextHighlighter?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.TextHighlighter?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.TextHighlighter? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.TextHighlighter?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTextHighlighter! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TextHighlighter?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange: WindowsFoundation.IID {
    .init(Data1: 0x9d4ea607, Data2: 0x632b, Data3: 0x50f1, Data4: ( 0x95,0x39,0xdd,0xe9,0x8c,0x1e,0xed,0x29 ))// 9d4ea607-632b-50f1-9539-dde98c1eed29
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Documents.TextRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TextRange = .from(abi: $1)
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge>
internal class IVectorViewTextRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.TextRange {
        var result: __x_ABI_CMicrosoft_CUI_CXaml_CDocuments_CTextRange = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.TextRange, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange
    internal typealias CodiraABI = IVectorViewTextRange
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.TextRange>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.TextRange
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.TextRange {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.TextRange, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTextRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TextRange>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName: WindowsFoundation.IID {
    .init(Data1: 0x183ab292, Data2: 0xd2b3, Data3: 0x568d, Data4: ( 0x84,0x31,0x4e,0x3f,0xf1,0x8b,0x03,0x7e ))// 183ab292-d2b3-568d-8431-4e3ff18b037e
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Input.InputScopeName>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.InputScopeName? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge>
internal class IVectorViewInputScopeName: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.InputScopeName? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.InputScopeName?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName
    internal typealias CodiraABI = IVectorViewInputScopeName
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.InputScopeName?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.InputScopeName?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.InputScopeName? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.InputScopeName?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableInputScopeName! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.InputScopeName?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator: WindowsFoundation.IID {
    .init(Data1: 0x4d4dfa1a, Data2: 0x7153, Data3: 0x51f3, Data4: ( 0x80,0x36,0x6b,0x61,0xde,0x68,0xbc,0xa8 ))// 4d4dfa1a-7153-51f3-8036-6b61de68bca8
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Input.KeyboardAccelerator>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.KeyboardAccelerator? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge>
internal class IVectorViewKeyboardAccelerator: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.KeyboardAccelerator? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.KeyboardAccelerator?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator
    internal typealias CodiraABI = IVectorViewKeyboardAccelerator
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.KeyboardAccelerator?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.KeyboardAccelerator?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.KeyboardAccelerator? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.KeyboardAccelerator?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableKeyboardAccelerator! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.KeyboardAccelerator?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer: WindowsFoundation.IID {
    .init(Data1: 0x81082898, Data2: 0xc342, Data3: 0x5b9f, Data4: ( 0x9f,0xcc,0x09,0x27,0x88,0x1f,0x30,0xad ))// 81082898-c342-5b9f-9fcc-0927881f30ad
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Input.Pointer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Pointer? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge>
internal class IVectorViewPointer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Pointer? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.Pointer?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointer
    internal typealias CodiraABI = IVectorViewPointer
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.Pointer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.Pointer?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CPointerBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Pointer? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Pointer?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointer! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Pointer?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x7559d8a9, Data2: 0xc9b3, Data3: 0x5450, Data4: ( 0x9a,0x9b,0xd5,0xff,0xba,0x0c,0xe2,0x7f ))// 7559d8a9-c9b3-5450-9a9b-d5ffba0ce27f
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Animation.ColorKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ColorKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge>
internal class IVectorViewColorKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ColorKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.ColorKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame
    internal typealias CodiraABI = IVectorViewColorKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.ColorKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.ColorKeyFrame?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ColorKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ColorKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableColorKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ColorKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xf8a1ab9d, Data2: 0xcecd, Data3: 0x5857, Data4: ( 0x8e,0xae,0x6e,0x40,0xda,0xac,0xd8,0xbf ))// f8a1ab9d-cecd-5857-8eae-6e40daacd8bf
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Animation.DoubleKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.DoubleKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge>
internal class IVectorViewDoubleKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.DoubleKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.DoubleKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame
    internal typealias CodiraABI = IVectorViewDoubleKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.DoubleKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.DoubleKeyFrame?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.DoubleKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.DoubleKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDoubleKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.DoubleKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xe5873499, Data2: 0xef10, Data3: 0x52fc, Data4: ( 0x93,0xb3,0xc8,0xf7,0xb2,0xa8,0x12,0x20 ))// e5873499-ef10-52fc-93b3-c8f7b2a81220
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Animation.ObjectKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ObjectKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge>
internal class IVectorViewObjectKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ObjectKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.ObjectKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame
    internal typealias CodiraABI = IVectorViewObjectKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.ObjectKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.ObjectKeyFrame?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ObjectKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ObjectKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableObjectKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ObjectKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xd299bfa3, Data2: 0x7087, Data3: 0x518b, Data4: ( 0x80,0x8e,0xeb,0xa1,0x4b,0x28,0x54,0xf1 ))// d299bfa3-7087-518b-808e-eba14b2854f1
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Animation.PointKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PointKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge>
internal class IVectorViewPointKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.PointKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.PointKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame
    internal typealias CodiraABI = IVectorViewPointKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.PointKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.PointKeyFrame?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.PointKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.PointKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PointKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline: WindowsFoundation.IID {
    .init(Data1: 0xe30abc22, Data2: 0x0631, Data3: 0x5c17, Data4: ( 0xa2,0xcb,0xd1,0xf7,0xcd,0x05,0x25,0x15 ))// e30abc22-0631-5c17-a2cb-d1f7cd052515
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Animation.Timeline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Timeline? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge>
internal class IVectorViewTimeline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Timeline? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.Timeline?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline
    internal typealias CodiraABI = IVectorViewTimeline
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.Timeline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.Timeline?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Timeline? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Timeline?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimeline! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Timeline?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition: WindowsFoundation.IID {
    .init(Data1: 0x6fe2632e, Data2: 0x3c2a, Data3: 0x5087, Data4: ( 0xbd,0xbc,0x8b,0xc5,0x1d,0xa7,0x52,0x0b ))// 6fe2632e-3c2a-5087-bdbc-8bc51da7520b
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Animation.Transition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Transition? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge>
internal class IVectorViewTransition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Transition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.Transition?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition
    internal typealias CodiraABI = IVectorViewTransition
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.Transition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.Transition?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Transition? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Transition?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTransition! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Transition?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry: WindowsFoundation.IID {
    .init(Data1: 0x6149b1f9, Data2: 0x59ab, Data3: 0x52aa, Data4: ( 0x8a,0x45,0x26,0x75,0x5d,0xca,0x5b,0x90 ))// 6149b1f9-59ab-52aa-8a45-26755dca5b90
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Geometry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Geometry? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge>
internal class IVectorViewGeometry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Geometry? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.Geometry?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry
    internal typealias CodiraABI = IVectorViewGeometry
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.Geometry?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.Geometry?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Geometry? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Geometry?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableGeometry! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Geometry?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop: WindowsFoundation.IID {
    .init(Data1: 0x48c5bc90, Data2: 0x5bf9, Data3: 0x50ee, Data4: ( 0xae,0x5d,0x07,0x90,0xf7,0xb8,0x1f,0x49 ))// 48c5bc90-5bf9-50ee-ae5d-0790f7b81f49
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.GradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.GradientStop? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge>
internal class IVectorViewGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.GradientStop? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.GradientStop?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop
    internal typealias CodiraABI = IVectorViewGradientStop
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.GradientStop?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.GradientStop?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.GradientStop? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.GradientStop?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableGradientStop! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.GradientStop?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure: WindowsFoundation.IID {
    .init(Data1: 0xee4d5b1b, Data2: 0xf452, Data3: 0x5397, Data4: ( 0x91,0x44,0x86,0x74,0x64,0x54,0xea,0xa4 ))// ee4d5b1b-f452-5397-9144-86746454eaa4
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.PathFigure>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PathFigure? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge>
internal class IVectorViewPathFigure: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.PathFigure? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.PathFigure?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure
    internal typealias CodiraABI = IVectorViewPathFigure
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.PathFigure?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.PathFigure?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.PathFigure? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.PathFigure?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePathFigure! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PathFigure?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment: WindowsFoundation.IID {
    .init(Data1: 0xfff30db4, Data2: 0x7bae, Data3: 0x5c90, Data4: ( 0x92,0xbf,0xdb,0x58,0x81,0xf7,0x6c,0x30 ))// fff30db4-7bae-5c90-92bf-db5881f76c30
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.PathSegment>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PathSegment? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge>
internal class IVectorViewPathSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.PathSegment? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.PathSegment?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment
    internal typealias CodiraABI = IVectorViewPathSegment
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.PathSegment?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.PathSegment?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.PathSegment? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.PathSegment?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePathSegment! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PathSegment?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform: WindowsFoundation.IID {
    .init(Data1: 0x00ec5143, Data2: 0x06da, Data3: 0x5002, Data4: ( 0x8c,0x66,0xda,0xc9,0x78,0x95,0x9f,0xce ))// 00ec5143-06da-5002-8c66-dac978959fce
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.Transform>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Transform? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge>
internal class IVectorViewTransform: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Transform? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.Transform?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform
    internal typealias CodiraABI = IVectorViewTransform
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.Transform?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.Transform?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Transform? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Transform?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTransform! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Transform?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight: WindowsFoundation.IID {
    .init(Data1: 0xcf393ba1, Data2: 0x2605, Data3: 0x543e, Data4: ( 0x8b,0x4e,0xe8,0x00,0xeb,0x17,0x94,0x92 ))// cf393ba1-2605-543e-8b4e-e800eb179492
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.Media.XamlLight>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.XamlLight? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge>
internal class IVectorViewXamlLight: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.XamlLight? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.XamlLight?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight
    internal typealias CodiraABI = IVectorViewXamlLight
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.XamlLight?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.XamlLight?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.XamlLight? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.XamlLight?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableXamlLight! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.XamlLight?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary: WindowsFoundation.IID {
    .init(Data1: 0x1afc35b6, Data2: 0xd46b, Data3: 0x5d29, Data4: ( 0xa9,0xf6,0xe2,0x1e,0x68,0xb0,0x58,0x46 ))// 1afc35b6-d46b-5d29-a9f6-e21e68b05846
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.ResourceDictionary>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ResourceDictionary? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge>
internal class IVectorViewResourceDictionary: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ResourceDictionary? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.ResourceDictionary?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary
    internal typealias CodiraABI = IVectorViewResourceDictionary
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.ResourceDictionary?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.ResourceDictionary?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ResourceDictionary? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ResourceDictionary?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableResourceDictionary! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ResourceDictionary?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase: WindowsFoundation.IID {
    .init(Data1: 0x01f305aa, Data2: 0x8ef8, Data3: 0x5237, Data4: ( 0x87,0x67,0x5a,0xda,0xa3,0xb4,0xa5,0x24 ))// 01f305aa-8ef8-5237-8767-5adaa3b4a524
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.SetterBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.SetterBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge>
internal class IVectorViewSetterBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.SetterBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.SetterBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase
    internal typealias CodiraABI = IVectorViewSetterBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.SetterBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.SetterBase?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.SetterBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.SetterBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableSetterBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.SetterBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase: WindowsFoundation.IID {
    .init(Data1: 0x4b947794, Data2: 0x8e5c, Data3: 0x5fed, Data4: ( 0x87,0xbe,0x4d,0x2b,0x37,0x29,0xbd,0xd7 ))// 4b947794-8e5c-5fed-87be-4d2b3729bdd7
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.TriggerBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TriggerBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge>
internal class IVectorViewTriggerBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.TriggerBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.TriggerBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase
    internal typealias CodiraABI = IVectorViewTriggerBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.TriggerBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.TriggerBase?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.TriggerBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.TriggerBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTriggerBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TriggerBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement: WindowsFoundation.IID {
    .init(Data1: 0x4fdea5ee, Data2: 0xc725, Data3: 0x5026, Data4: ( 0xba,0x83,0x24,0xe5,0x77,0x13,0x57,0xc6 ))// 4fdea5ee-c725-5026-ba83-24e5771357c6
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Microsoft.UI.Xaml.UIElement>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.UIElement? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge>
internal class IVectorViewUIElement: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.UIElement? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WinUI.UIElement?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement
    internal typealias CodiraABI = IVectorViewUIElement
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WinUI.UIElement?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WinUI.UIElement?
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.UIElement? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.UIElement?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableUIElement! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.UIElement?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x2f13c006, Data2: 0xa03a, Data3: 0x5f69, Data4: ( 0xb0,0x90,0x75,0xa4,0x3e,0x33,0x42,0x3e ))// 2f13c006-a03a-5f69-b090-75a43e33423e
}

internal var __x_ABI_C__FIVectorView_1_HSTRINGVTable: __x_ABI_C__FIVectorView_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1_HSTRINGWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1_HSTRINGWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1_HSTRINGWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: try! HString(result).detach())
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: String = .init(from: $1)
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1_HSTRINGWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1_HSTRINGBridge>
internal class IVectorViewString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1_HSTRING }

    internal fn GetAtImpl(_ index: UInt32) throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIVectorView_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .init(from: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: String, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        immutable _value = try! HString(value)
        _ = try perform(as: __x_ABI_C__FIVectorView_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value.get(), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1_HSTRING
    internal typealias CodiraABI = IVectorViewString
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<String>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1_HSTRINGImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1_HSTRINGImpl : IVectorView, AbiInterfaceImpl {
    typealias T = String
    typealias Bridge = __x_ABI_C__FIVectorView_1_HSTRINGBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> String {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: String, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableString! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<String>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0x0b7b4c9d, Data2: 0x182f, Data3: 0x582a, Data4: ( 0xbd,0xdb,0x42,0xb1,0xaa,0xc3,0x0c,0xad ))// 0b7b4c9d-182f-582a-bddb-42b1aac30cad
}

internal var __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVectorView`1<Windows.Foundation.Point>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WindowsFoundation.Point = .from(abi: $1)
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointBridge>
internal class IVectorViewPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPoint }

    internal fn GetAtImpl(_ index: UInt32) throws -> WindowsFoundation.Point {
        var result: __x_ABI_CWindows_CFoundation_CPoint = .init()
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn IndexOfImpl(_ value: WindowsFoundation.Point, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPoint
    internal typealias CodiraABI = IVectorViewPoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIVectorView<WindowsFoundation.Point>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointImpl : IVectorView, AbiInterfaceImpl {
    typealias T = WindowsFoundation.Point
    typealias Bridge = __x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }

    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
    }
    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WindowsFoundation.Point {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.indexof)
    fileprivate fn indexOf(_ value: WindowsFoundation.Point, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePoint! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivectorview-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.Point>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xb32bdca4, Data2: 0x5e52, Data3: 0x5b27, Data4: ( 0xbc,0x5d,0xd6,0x6a,0x1a,0x26,0x8c,0x2a ))// b32bdca4-5e52-5b27-bc5d-d66a1a268c2a
}

internal var __x_ABI_C__FIVector_1_IInspectableVTable: __x_ABI_C__FIVector_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1_IInspectableWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1_IInspectableWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        immutable resultWrapper = __ABI_.AnyWrapper(result)
        resultWrapper?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1_IInspectableBridge>
internal class IVectorAny: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1_IInspectable }

    internal fn GetAtImpl(_ index: UInt32) throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<Any?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: Any?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        immutable valueWrapper = __ABI_.AnyWrapper(value)
        immutable _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, _value, &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: Any?) throws {
        immutable valueWrapper = __ABI_.AnyWrapper(value)
        immutable _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, _value))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: Any?) throws {
        immutable valueWrapper = __ABI_.AnyWrapper(value)
        immutable _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, _value))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: Any?) throws {
        immutable valueWrapper = __ABI_.AnyWrapper(value)
        immutable _value = try! valueWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, _value))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1_IInspectable
    internal typealias CodiraABI = IVectorAny
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1_IInspectableImpl : IVector, AbiInterfaceImpl {
    typealias T = Any?
    typealias Bridge = __x_ABI_C__FIVector_1_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> Any? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<Any?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: Any?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: Any?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: Any?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: Any?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAny! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Any?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1_double: WindowsFoundation.IID {
    .init(Data1: 0xf452d23c, Data2: 0xbf05, Data3: 0x5f3e, Data4: ( 0x88,0xe7,0xd1,0x7a,0x67,0x16,0xb9,0x11 ))// f452d23c-bf05-5f3e-88e7-d17a6716b911
}

internal var __x_ABI_C__FIVector_1_doubleVTable: __x_ABI_C__FIVector_1_doubleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1_doubleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1_doubleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1_doubleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1_doubleWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1_doubleWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Double>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1_doubleWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Double = $1
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: Double = $2
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: Double = $2
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Double = $1
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1_doubleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1_doubleBridge>
internal class IVectorDouble: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1_double }

    internal fn GetAtImpl(_ index: UInt32) throws -> Double {
        var result: DOUBLE = 0.0
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<Double>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1_doubleWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: Double, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: Double) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, value))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: Double) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, value))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: Double) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, value))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_double.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1_doubleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1_double
    internal typealias CodiraABI = IVectorDouble
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<Double>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1_doubleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1_doubleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1_doubleImpl : IVector, AbiInterfaceImpl {
    typealias T = Double
    typealias Bridge = __x_ABI_C__FIVector_1_doubleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> Double {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<Double>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: Double, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: Double) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: Double) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: Double) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDouble! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Double>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1_float: WindowsFoundation.IID {
    .init(Data1: 0x61cf693f, Data2: 0xdb4c, Data3: 0x579f, Data4: ( 0xb9,0x05,0x5d,0xd3,0xd2,0x3c,0xfd,0x4d ))// 61cf693f-db4c-579f-b905-5dd3d23cfd4d
}

internal var __x_ABI_C__FIVector_1_floatVTable: __x_ABI_C__FIVector_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1_floatWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1_floatWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1_floatWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: result)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1_floatWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Float = $1
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: Float = $2
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: Float = $2
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: Float = $1
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1_floatWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1_floatBridge>
internal class IVectorFloat: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1_float }

    internal fn GetAtImpl(_ index: UInt32) throws -> Float {
        var result: FLOAT = 0.0
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return result
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<Float>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1_floatWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: Float, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, value, &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: Float) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, value))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: Float) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, value))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: Float) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, value))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1_float.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1_floatBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1_float
    internal typealias CodiraABI = IVectorFloat
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<Float>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1_floatImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1_floatImpl : IVector, AbiInterfaceImpl {
    typealias T = Float
    typealias Bridge = __x_ABI_C__FIVector_1_floatBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> Float {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<Float>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: Float, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: Float) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: Float) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: Float) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableFloat! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<Float>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint: WindowsFoundation.IID {
    .init(Data1: 0x8220cf33, Data2: 0x5d76, Data3: 0x5607, Data4: ( 0xbb,0x7d,0xb7,0xcd,0x07,0xd2,0x7f,0x33 ))// 8220cf33-5d76-5607-bb7d-b7cd07d27f33
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Input.PointerPoint>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinAppSDK.PointerPoint? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinAppSDK.PointerPoint? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinAppSDK.PointerPoint? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinAppSDK.PointerPoint? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge>
internal class IVectorPointerPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinAppSDK.PointerPoint? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinAppSDK.PointerPoint?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinAppSDK.PointerPoint?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinAppSDK.PointerPoint?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinAppSDK.PointerPoint?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinAppSDK.PointerPoint?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPoint
    internal typealias CodiraABI = IVectorPointerPoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinAppSDK.PointerPoint?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointImpl : IVector, AbiInterfaceImpl {
    typealias T = WinAppSDK.PointerPoint?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CInput__CPointerPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinAppSDK.PointerPoint? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinAppSDK.PointerPoint?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinAppSDK.PointerPoint?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinAppSDK.PointerPoint?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinAppSDK.PointerPoint?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinAppSDK.PointerPoint?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointerPoint! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinAppSDK.PointerPoint?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation: WindowsFoundation.IID {
    .init(Data1: 0xe047e428, Data2: 0x66a6, Data3: 0x5759, Data4: ( 0xa7,0x51,0x84,0xf2,0xbf,0x6f,0xdb,0x30 ))// e047e428-66a6-5759-a751-84f2bf6fdb30
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Automation.AutomationAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationAnnotation? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.AutomationAnnotation? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.AutomationAnnotation? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationAnnotation? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge>
internal class IVectorAutomationAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.AutomationAnnotation? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.AutomationAnnotation?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.AutomationAnnotation?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.AutomationAnnotation?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.AutomationAnnotation?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.AutomationAnnotation?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotation
    internal typealias CodiraABI = IVectorAutomationAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.AutomationAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.AutomationAnnotation?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CAutomationAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.AutomationAnnotation? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.AutomationAnnotation?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.AutomationAnnotation?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.AutomationAnnotation?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.AutomationAnnotation?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.AutomationAnnotation?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAutomationAnnotation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationAnnotation?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer: WindowsFoundation.IID {
    .init(Data1: 0x91d7782f, Data2: 0xc53a, Data3: 0x5620, Data4: ( 0x8c,0xe1,0x0d,0x94,0x19,0x24,0x93,0x22 ))// 91d7782f-c53a-5620-8ce1-0d9419249322
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationPeer? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.AutomationPeer? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.AutomationPeer? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationPeer? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge>
internal class IVectorAutomationPeer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.AutomationPeer? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.AutomationPeer?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.AutomationPeer?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.AutomationPeer?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.AutomationPeer?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.AutomationPeer?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeer
    internal typealias CodiraABI = IVectorAutomationPeer
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.AutomationPeer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeer?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.AutomationPeer? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.AutomationPeer?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.AutomationPeer?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.AutomationPeer?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.AutomationPeer?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.AutomationPeer?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAutomationPeer! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeer?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation: WindowsFoundation.IID {
    .init(Data1: 0xfe9ed1b7, Data2: 0x7185, Data3: 0x52e9, Data4: ( 0xb0,0x37,0xbf,0x99,0x02,0xac,0x35,0x61 ))// fe9ed1b7-7185-52e9-b037-bf9902ac3561
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationPeerAnnotation? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.AutomationPeerAnnotation? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.AutomationPeerAnnotation? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.AutomationPeerAnnotation? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge>
internal class IVectorAutomationPeerAnnotation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.AutomationPeerAnnotation? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.AutomationPeerAnnotation?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.AutomationPeerAnnotation?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.AutomationPeerAnnotation?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.AutomationPeerAnnotation?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.AutomationPeerAnnotation?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotation
    internal typealias CodiraABI = IVectorAutomationPeerAnnotation
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.AutomationPeerAnnotation?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.AutomationPeerAnnotation?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CAutomation__CPeers__CAutomationPeerAnnotationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.AutomationPeerAnnotation? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.AutomationPeerAnnotation?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.AutomationPeerAnnotation?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.AutomationPeerAnnotation?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.AutomationPeerAnnotation?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.AutomationPeerAnnotation?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableAutomationPeerAnnotation! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.AutomationPeerAnnotation?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition: WindowsFoundation.IID {
    .init(Data1: 0x749bc47c, Data2: 0x1743, Data3: 0x5c21, Data4: ( 0x9c,0xed,0xc8,0xa1,0x13,0x4c,0x7b,0xa7 ))// 749bc47c-1743-5c21-9ced-c8a1134c7ba7
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.ColumnDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ColumnDefinition? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ColumnDefinition? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ColumnDefinition? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ColumnDefinition? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge>
internal class IVectorColumnDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ColumnDefinition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.ColumnDefinition?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.ColumnDefinition?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.ColumnDefinition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.ColumnDefinition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.ColumnDefinition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinition
    internal typealias CodiraABI = IVectorColumnDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.ColumnDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.ColumnDefinition?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CColumnDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ColumnDefinition? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.ColumnDefinition?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ColumnDefinition?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.ColumnDefinition?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.ColumnDefinition?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.ColumnDefinition?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableColumnDefinition! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ColumnDefinition?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle: WindowsFoundation.IID {
    .init(Data1: 0x8fba608e, Data2: 0xf076, Data3: 0x5f2a, Data4: ( 0x89,0x72,0x4f,0x97,0xd9,0x2c,0xa8,0x45 ))// 8fba608e-f076-5f2a-8972-4f97d92ca845
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.GroupStyle>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.GroupStyle? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.GroupStyle? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.GroupStyle? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.GroupStyle? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge>
internal class IVectorGroupStyle: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.GroupStyle? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.GroupStyle?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.GroupStyle?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.GroupStyle?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.GroupStyle?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.GroupStyle?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle
    internal typealias CodiraABI = IVectorGroupStyle
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.GroupStyle?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.GroupStyle?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.GroupStyle? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.GroupStyle?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.GroupStyle?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.GroupStyle?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.GroupStyle?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.GroupStyle?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableGroupStyle! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.GroupStyle?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem: WindowsFoundation.IID {
    .init(Data1: 0x94c4dfcf, Data2: 0x1af2, Data3: 0x5621, Data4: ( 0x8b,0x99,0x4e,0x56,0x43,0xd1,0xb5,0x2f ))// 94c4dfcf-1af2-5621-8b99-4e5643d1b52f
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.MenuBarItem>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.MenuBarItem? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.MenuBarItem? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.MenuBarItem? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.MenuBarItem? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge>
internal class IVectorMenuBarItem: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.MenuBarItem? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.MenuBarItem?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.MenuBarItem?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.MenuBarItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.MenuBarItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.MenuBarItem?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItem
    internal typealias CodiraABI = IVectorMenuBarItem
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.MenuBarItem?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.MenuBarItem?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuBarItemBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.MenuBarItem? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.MenuBarItem?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.MenuBarItem?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.MenuBarItem?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.MenuBarItem?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.MenuBarItem?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMenuBarItem! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.MenuBarItem?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase: WindowsFoundation.IID {
    .init(Data1: 0xebe273f7, Data2: 0x4731, Data3: 0x5ac8, Data4: ( 0x85,0x13,0xde,0x76,0x48,0x68,0xfb,0x9b ))// ebe273f7-4731-5ac8-8513-de764868fb9b
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.MenuFlyoutItemBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.MenuFlyoutItemBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.MenuFlyoutItemBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.MenuFlyoutItemBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.MenuFlyoutItemBase? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge>
internal class IVectorMenuFlyoutItemBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.MenuFlyoutItemBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.MenuFlyoutItemBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.MenuFlyoutItemBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.MenuFlyoutItemBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.MenuFlyoutItemBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.MenuFlyoutItemBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBase
    internal typealias CodiraABI = IVectorMenuFlyoutItemBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.MenuFlyoutItemBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.MenuFlyoutItemBase?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CMenuFlyoutItemBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.MenuFlyoutItemBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.MenuFlyoutItemBase?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.MenuFlyoutItemBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.MenuFlyoutItemBase?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.MenuFlyoutItemBase?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.MenuFlyoutItemBase?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableMenuFlyoutItemBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.MenuFlyoutItemBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0x44786fbd, Data2: 0xd376, Data3: 0x5b07, Data4: ( 0xb4,0xfd,0x54,0x11,0x32,0x68,0xd3,0xa6 ))// 44786fbd-d376-5b07-b4fd-54113268d3a6
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.Primitives.ScrollSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ScrollSnapPointBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ScrollSnapPointBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ScrollSnapPointBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ScrollSnapPointBase? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge>
internal class IVectorScrollSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ScrollSnapPointBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.ScrollSnapPointBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.ScrollSnapPointBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.ScrollSnapPointBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.ScrollSnapPointBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.ScrollSnapPointBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBase
    internal typealias CodiraABI = IVectorScrollSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.ScrollSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.ScrollSnapPointBase?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ScrollSnapPointBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.ScrollSnapPointBase?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ScrollSnapPointBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.ScrollSnapPointBase?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.ScrollSnapPointBase?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.ScrollSnapPointBase?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableScrollSnapPointBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ScrollSnapPointBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase: WindowsFoundation.IID {
    .init(Data1: 0x2705789a, Data2: 0xe69c, Data3: 0x5274, Data4: ( 0xb1,0x5b,0xca,0x24,0x5b,0xe2,0x67,0xe2 ))// 2705789a-e69c-5274-b15b-ca245be267e2
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.Primitives.ZoomSnapPointBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ZoomSnapPointBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ZoomSnapPointBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ZoomSnapPointBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ZoomSnapPointBase? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge>
internal class IVectorZoomSnapPointBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ZoomSnapPointBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.ZoomSnapPointBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.ZoomSnapPointBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.ZoomSnapPointBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.ZoomSnapPointBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.ZoomSnapPointBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBase
    internal typealias CodiraABI = IVectorZoomSnapPointBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.ZoomSnapPointBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.ZoomSnapPointBase?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CZoomSnapPointBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ZoomSnapPointBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.ZoomSnapPointBase?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ZoomSnapPointBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.ZoomSnapPointBase?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.ZoomSnapPointBase?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.ZoomSnapPointBase?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableZoomSnapPointBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ZoomSnapPointBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition: WindowsFoundation.IID {
    .init(Data1: 0x5ddd9577, Data2: 0x3f94, Data3: 0x567f, Data4: ( 0xbe,0xef,0x54,0x05,0x68,0x52,0x22,0x89 ))// 5ddd9577-3f94-567f-beef-540568522289
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Controls.RowDefinition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.RowDefinition? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.RowDefinition? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.RowDefinition? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.RowDefinition? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge>
internal class IVectorRowDefinition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.RowDefinition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.RowDefinition?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.RowDefinition?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.RowDefinition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.RowDefinition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.RowDefinition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinition
    internal typealias CodiraABI = IVectorRowDefinition
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.RowDefinition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.RowDefinition?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CRowDefinitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.RowDefinition? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.RowDefinition?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.RowDefinition?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.RowDefinition?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.RowDefinition?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.RowDefinition?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableRowDefinition! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.RowDefinition?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject: WindowsFoundation.IID {
    .init(Data1: 0x8e6b597a, Data2: 0xab20, Data3: 0x585f, Data4: ( 0x9d,0xb1,0x93,0x94,0xaa,0xc5,0xa4,0x69 ))// 8e6b597a-ab20-585f-9db1-9394aac5a469
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.DependencyObject>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.DependencyObject? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.DependencyObject? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.DependencyObject? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.DependencyObject? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge>
internal class IVectorDependencyObject: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.DependencyObject? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.DependencyObject?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.DependencyObject?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.DependencyObject?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.DependencyObject?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.DependencyObject?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObject
    internal typealias CodiraABI = IVectorDependencyObject
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.DependencyObject?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.DependencyObject?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDependencyObjectBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.DependencyObject? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.DependencyObject?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.DependencyObject?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.DependencyObject?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.DependencyObject?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.DependencyObject?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDependencyObject! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.DependencyObject?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline: WindowsFoundation.IID {
    .init(Data1: 0x0015a441, Data2: 0x4c98, Data3: 0x5d3f, Data4: ( 0x88,0x23,0x03,0xe7,0x22,0x61,0x5c,0x48 ))// 0015a441-4c98-5d3f-8823-03e722615c48
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Documents.Inline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Inline? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Inline? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Inline? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Inline? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge>
internal class IVectorInline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Inline? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.Inline?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.Inline?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.Inline?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.Inline?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.Inline?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInline
    internal typealias CodiraABI = IVectorInline
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.Inline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.Inline?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CInlineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Inline? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.Inline?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Inline?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.Inline?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.Inline?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.Inline?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableInline! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Inline?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter: WindowsFoundation.IID {
    .init(Data1: 0x6d576f67, Data2: 0x1548, Data3: 0x51c9, Data4: ( 0x83,0xa8,0x2b,0x54,0x01,0xb0,0x28,0x1b ))// 6d576f67-1548-51c9-83a8-2b5401b0281b
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Documents.TextHighlighter>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TextHighlighter? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.TextHighlighter? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.TextHighlighter? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TextHighlighter? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge>
internal class IVectorTextHighlighter: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.TextHighlighter? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.TextHighlighter?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.TextHighlighter?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.TextHighlighter?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.TextHighlighter?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.TextHighlighter?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighter
    internal typealias CodiraABI = IVectorTextHighlighter
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.TextHighlighter?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.TextHighlighter?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextHighlighterBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.TextHighlighter? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.TextHighlighter?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.TextHighlighter?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.TextHighlighter?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.TextHighlighter?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.TextHighlighter?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTextHighlighter! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TextHighlighter?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange: WindowsFoundation.IID {
    .init(Data1: 0x5338571c, Data2: 0x77b4, Data3: 0x560e, Data4: ( 0x8d,0xfd,0xa5,0x9d,0xad,0x27,0x0e,0xbb ))// 5338571c-77b4-560e-8dfd-a59dad270ebb
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Documents.TextRange>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TextRange = .from(abi: $1)
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.TextRange = .from(abi: $2)
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.TextRange = .from(abi: $2)
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TextRange = .from(abi: $1)
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge>
internal class IVectorTextRange: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.TextRange {
        var result: __x_ABI_CMicrosoft_CUI_CXaml_CDocuments_CTextRange = .init()
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.TextRange>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.TextRange, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.TextRange) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, .from(swift: value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.TextRange) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, .from(swift: value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.TextRange) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, .from(swift: value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRange
    internal typealias CodiraABI = IVectorTextRange
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.TextRange>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.TextRange
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextRangeBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.TextRange {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.TextRange>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.TextRange, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.TextRange) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.TextRange) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.TextRange) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTextRange! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TextRange>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName: WindowsFoundation.IID {
    .init(Data1: 0xfe4c93e9, Data2: 0xd6fa, Data3: 0x5b96, Data4: ( 0x9c,0x74,0xde,0x96,0x8c,0x79,0xc3,0x6e ))// fe4c93e9-d6fa-5b96-9c74-de968c79c36e
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Input.InputScopeName>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.InputScopeName? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.InputScopeName? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.InputScopeName? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.InputScopeName? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge>
internal class IVectorInputScopeName: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.InputScopeName? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.InputScopeName?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.InputScopeName?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.InputScopeName?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.InputScopeName?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.InputScopeName?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeName
    internal typealias CodiraABI = IVectorInputScopeName
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.InputScopeName?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.InputScopeName?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CInputScopeNameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.InputScopeName? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.InputScopeName?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.InputScopeName?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.InputScopeName?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.InputScopeName?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.InputScopeName?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableInputScopeName! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.InputScopeName?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator: WindowsFoundation.IID {
    .init(Data1: 0x0db091c3, Data2: 0x8538, Data3: 0x5d25, Data4: ( 0x93,0x7f,0xdb,0x6e,0x00,0x3e,0x1f,0x71 ))// 0db091c3-8538-5d25-937f-db6e003e1f71
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Input.KeyboardAccelerator>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.KeyboardAccelerator? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.KeyboardAccelerator? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.KeyboardAccelerator? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.KeyboardAccelerator? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge>
internal class IVectorKeyboardAccelerator: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.KeyboardAccelerator? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.KeyboardAccelerator?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.KeyboardAccelerator?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.KeyboardAccelerator?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.KeyboardAccelerator?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.KeyboardAccelerator?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator
    internal typealias CodiraABI = IVectorKeyboardAccelerator
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.KeyboardAccelerator?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.KeyboardAccelerator?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.KeyboardAccelerator? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.KeyboardAccelerator?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.KeyboardAccelerator?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.KeyboardAccelerator?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.KeyboardAccelerator?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.KeyboardAccelerator?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableKeyboardAccelerator! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.KeyboardAccelerator?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x8e452000, Data2: 0xd3af, Data3: 0x506f, Data4: ( 0x9b,0x09,0x31,0x61,0x75,0x3d,0xfc,0x94 ))// 8e452000-d3af-506f-9b09-3161753dfc94
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Animation.ColorKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ColorKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ColorKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ColorKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ColorKeyFrame? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge>
internal class IVectorColorKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ColorKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.ColorKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.ColorKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.ColorKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.ColorKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.ColorKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrame
    internal typealias CodiraABI = IVectorColorKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.ColorKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.ColorKeyFrame?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CColorKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ColorKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.ColorKeyFrame?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ColorKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.ColorKeyFrame?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.ColorKeyFrame?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.ColorKeyFrame?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableColorKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ColorKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x0ff0eaee, Data2: 0x9514, Data3: 0x5010, Data4: ( 0x9a,0xc4,0x8f,0x6a,0xa6,0xd2,0x94,0xbc ))// 0ff0eaee-9514-5010-9ac4-8f6aa6d294bc
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Animation.DoubleKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.DoubleKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.DoubleKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.DoubleKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.DoubleKeyFrame? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge>
internal class IVectorDoubleKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.DoubleKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.DoubleKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.DoubleKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.DoubleKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.DoubleKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.DoubleKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrame
    internal typealias CodiraABI = IVectorDoubleKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.DoubleKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.DoubleKeyFrame?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CDoubleKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.DoubleKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.DoubleKeyFrame?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.DoubleKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.DoubleKeyFrame?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.DoubleKeyFrame?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.DoubleKeyFrame?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableDoubleKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.DoubleKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0x95f26067, Data2: 0x8cdf, Data3: 0x5639, Data4: ( 0xb4,0xab,0x04,0xca,0x57,0x54,0x57,0xce ))// 95f26067-8cdf-5639-b4ab-04ca575457ce
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Animation.ObjectKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ObjectKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ObjectKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ObjectKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ObjectKeyFrame? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge>
internal class IVectorObjectKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ObjectKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.ObjectKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.ObjectKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.ObjectKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.ObjectKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.ObjectKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrame
    internal typealias CodiraABI = IVectorObjectKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.ObjectKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.ObjectKeyFrame?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CObjectKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ObjectKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.ObjectKeyFrame?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ObjectKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.ObjectKeyFrame?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.ObjectKeyFrame?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.ObjectKeyFrame?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableObjectKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ObjectKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame: WindowsFoundation.IID {
    .init(Data1: 0xa577fe62, Data2: 0xf0e0, Data3: 0x5514, Data4: ( 0x8f,0x88,0x5c,0xe7,0x4f,0xd3,0x85,0xf6 ))// a577fe62-f0e0-5514-8f88-5ce74fd385f6
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Animation.PointKeyFrame>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PointKeyFrame? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.PointKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.PointKeyFrame? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PointKeyFrame? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge>
internal class IVectorPointKeyFrame: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.PointKeyFrame? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.PointKeyFrame?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.PointKeyFrame?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.PointKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.PointKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.PointKeyFrame?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrame
    internal typealias CodiraABI = IVectorPointKeyFrame
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.PointKeyFrame?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.PointKeyFrame?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CPointKeyFrameBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.PointKeyFrame? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.PointKeyFrame?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.PointKeyFrame?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.PointKeyFrame?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.PointKeyFrame?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.PointKeyFrame?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePointKeyFrame! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PointKeyFrame?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline: WindowsFoundation.IID {
    .init(Data1: 0x4107a612, Data2: 0x6757, Data3: 0x5552, Data4: ( 0xa4,0x8b,0x2e,0x30,0x93,0x23,0x0c,0x49 ))// 4107a612-6757-5552-a48b-2e3093230c49
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Animation.Timeline>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Timeline? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Timeline? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Timeline? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Timeline? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge>
internal class IVectorTimeline: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Timeline? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.Timeline?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.Timeline?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.Timeline?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.Timeline?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.Timeline?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimeline
    internal typealias CodiraABI = IVectorTimeline
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.Timeline?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.Timeline?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTimelineBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Timeline? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.Timeline?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Timeline?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.Timeline?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.Timeline?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.Timeline?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTimeline! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Timeline?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition: WindowsFoundation.IID {
    .init(Data1: 0x030a9884, Data2: 0x05db, Data3: 0x57af, Data4: ( 0xae,0x3b,0x4c,0x77,0xff,0xab,0xfe,0x57 ))// 030a9884-05db-57af-ae3b-4c77ffabfe57
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Animation.Transition>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Transition? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Transition? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Transition? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Transition? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge>
internal class IVectorTransition: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Transition? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.Transition?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.Transition?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.Transition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.Transition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.Transition?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransition
    internal typealias CodiraABI = IVectorTransition
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.Transition?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.Transition?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CTransitionBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Transition? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.Transition?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Transition?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.Transition?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.Transition?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.Transition?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTransition! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Transition?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry: WindowsFoundation.IID {
    .init(Data1: 0x62e3ccc0, Data2: 0x41e4, Data3: 0x5903, Data4: ( 0x93,0x3b,0xff,0x91,0x18,0xb1,0x0f,0xfd ))// 62e3ccc0-41e4-5903-933b-ff9118b10ffd
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Geometry>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Geometry? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Geometry? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Geometry? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Geometry? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge>
internal class IVectorGeometry: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Geometry? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.Geometry?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.Geometry?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.Geometry?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.Geometry?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.Geometry?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometry
    internal typealias CodiraABI = IVectorGeometry
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.Geometry?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.Geometry?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGeometryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Geometry? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.Geometry?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Geometry?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.Geometry?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.Geometry?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.Geometry?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableGeometry! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Geometry?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop: WindowsFoundation.IID {
    .init(Data1: 0xa367363d, Data2: 0xdeaf, Data3: 0x5d2c, Data4: ( 0x90,0x9c,0x41,0xb0,0xf2,0x59,0xba,0x7c ))// a367363d-deaf-5d2c-909c-41b0f259ba7c
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.GradientStop>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.GradientStop? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.GradientStop? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.GradientStop? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.GradientStop? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge>
internal class IVectorGradientStop: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.GradientStop? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.GradientStop?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.GradientStop?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.GradientStop?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.GradientStop?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.GradientStop?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStop
    internal typealias CodiraABI = IVectorGradientStop
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.GradientStop?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.GradientStop?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CGradientStopBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.GradientStop? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.GradientStop?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.GradientStop?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.GradientStop?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.GradientStop?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.GradientStop?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableGradientStop! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.GradientStop?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure: WindowsFoundation.IID {
    .init(Data1: 0xff221c4a, Data2: 0x9a65, Data3: 0x544f, Data4: ( 0x86,0xcd,0x0c,0x07,0xbc,0xc4,0x8f,0x8a ))// ff221c4a-9a65-544f-86cd-0c07bcc48f8a
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.PathFigure>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PathFigure? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.PathFigure? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.PathFigure? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PathFigure? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge>
internal class IVectorPathFigure: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.PathFigure? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.PathFigure?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.PathFigure?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.PathFigure?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.PathFigure?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.PathFigure?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigure
    internal typealias CodiraABI = IVectorPathFigure
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.PathFigure?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.PathFigure?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathFigureBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.PathFigure? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.PathFigure?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.PathFigure?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.PathFigure?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.PathFigure?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.PathFigure?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePathFigure! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PathFigure?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment: WindowsFoundation.IID {
    .init(Data1: 0xdbbff207, Data2: 0x32f0, Data3: 0x56fa, Data4: ( 0xb2,0xd8,0xd4,0xc8,0xe8,0x34,0x3e,0xd0 ))// dbbff207-32f0-56fa-b2d8-d4c8e8343ed0
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.PathSegment>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PathSegment? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.PathSegment? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.PathSegment? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.PathSegment? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge>
internal class IVectorPathSegment: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.PathSegment? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.PathSegment?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.PathSegment?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.PathSegment?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.PathSegment?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.PathSegment?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegment
    internal typealias CodiraABI = IVectorPathSegment
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.PathSegment?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.PathSegment?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CPathSegmentBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.PathSegment? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.PathSegment?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.PathSegment?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.PathSegment?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.PathSegment?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.PathSegment?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePathSegment! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.PathSegment?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform: WindowsFoundation.IID {
    .init(Data1: 0x1e1aebf2, Data2: 0xbc80, Data3: 0x501f, Data4: ( 0x94,0x04,0xe0,0x75,0x6a,0x42,0x33,0x55 ))// 1e1aebf2-bc80-501f-9404-e0756a423355
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.Transform>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Transform? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Transform? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.Transform? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.Transform? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge>
internal class IVectorTransform: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.Transform? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.Transform?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.Transform?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.Transform?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.Transform?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.Transform?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransform
    internal typealias CodiraABI = IVectorTransform
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.Transform?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.Transform?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CTransformBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.Transform? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.Transform?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.Transform?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.Transform?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.Transform?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.Transform?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTransform! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.Transform?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight: WindowsFoundation.IID {
    .init(Data1: 0xfb6065bb, Data2: 0x83e0, Data3: 0x57c0, Data4: ( 0xae,0x7f,0x41,0x8f,0xd7,0x63,0xb0,0xce ))// fb6065bb-83e0-57c0-ae7f-418fd763b0ce
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.Media.XamlLight>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.XamlLight? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.XamlLight? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.XamlLight? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.XamlLight? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge>
internal class IVectorXamlLight: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.XamlLight? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.XamlLight?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.XamlLight?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.XamlLight?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.XamlLight?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.XamlLight?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLight
    internal typealias CodiraABI = IVectorXamlLight
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.XamlLight?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.XamlLight?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CXamlLightBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.XamlLight? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.XamlLight?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.XamlLight?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.XamlLight?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.XamlLight?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.XamlLight?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableXamlLight! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.XamlLight?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary: WindowsFoundation.IID {
    .init(Data1: 0xc6fbfe1a, Data2: 0xf015, Data3: 0x5b23, Data4: ( 0x8e,0x7e,0x14,0x49,0x7e,0x97,0x07,0xa1 ))// c6fbfe1a-f015-5b23-8e7e-14497e9707a1
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.ResourceDictionary>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ResourceDictionary? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ResourceDictionary? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.ResourceDictionary? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.ResourceDictionary? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge>
internal class IVectorResourceDictionary: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.ResourceDictionary? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.ResourceDictionary?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.ResourceDictionary?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.ResourceDictionary?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.ResourceDictionary?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.ResourceDictionary?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionary
    internal typealias CodiraABI = IVectorResourceDictionary
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.ResourceDictionary?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.ResourceDictionary?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CResourceDictionaryBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.ResourceDictionary? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.ResourceDictionary?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.ResourceDictionary?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.ResourceDictionary?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.ResourceDictionary?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.ResourceDictionary?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableResourceDictionary! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.ResourceDictionary?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase: WindowsFoundation.IID {
    .init(Data1: 0x4357f913, Data2: 0xf457, Data3: 0x553b, Data4: ( 0x84,0x75,0x52,0xac,0xd4,0xab,0x35,0x99 ))// 4357f913-f457-553b-8475-52acd4ab3599
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.SetterBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.SetterBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.SetterBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.SetterBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.SetterBase? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge>
internal class IVectorSetterBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.SetterBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.SetterBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.SetterBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.SetterBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.SetterBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.SetterBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBase
    internal typealias CodiraABI = IVectorSetterBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.SetterBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.SetterBase?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CSetterBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.SetterBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.SetterBase?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.SetterBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.SetterBase?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.SetterBase?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.SetterBase?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableSetterBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.SetterBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase: WindowsFoundation.IID {
    .init(Data1: 0xef52e000, Data2: 0x0b0f, Data3: 0x52b5, Data4: ( 0xbd,0xfe,0x4f,0x59,0x35,0xdc,0xf1,0xbc ))// ef52e000-0b0f-52b5-bdfe-4f5935dcf1bc
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.TriggerBase>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TriggerBase? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.TriggerBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.TriggerBase? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.TriggerBase? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge>
internal class IVectorTriggerBase: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.TriggerBase? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.TriggerBase?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.TriggerBase?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.TriggerBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.TriggerBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.TriggerBase?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBase
    internal typealias CodiraABI = IVectorTriggerBase
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.TriggerBase?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.TriggerBase?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CTriggerBaseBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.TriggerBase? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.TriggerBase?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.TriggerBase?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.TriggerBase?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.TriggerBase?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.TriggerBase?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableTriggerBase! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.TriggerBase?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement: WindowsFoundation.IID {
    .init(Data1: 0xea4a1af0, Data2: 0x4286, Data3: 0x5f11, Data4: ( 0x81,0x42,0x6b,0x01,0x69,0xf4,0xe9,0xde ))// ea4a1af0-4286-5f11-8142-6b0169f4e9de
}

internal var __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Microsoft.UI.Xaml.UIElement>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        result?.copyTo($2)
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.UIElement? = .from(abi: ComPtr($1))
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.UIElement? = .from(abi: ComPtr($2))
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WinUI.UIElement? = .from(abi: ComPtr($2))
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WinUI.UIElement? = .from(abi: ComPtr($1))
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge>
internal class IVectorUIElement: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement }

    internal fn GetAtImpl(_ index: UInt32) throws -> WinUI.UIElement? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &resultAbi))
            }
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WinUI.UIElement?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WinUI.UIElement?, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, RawPointer(value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WinUI.UIElement?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WinUI.UIElement?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, RawPointer(value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WinUI.UIElement?) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, RawPointer(value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElement
    internal typealias CodiraABI = IVectorUIElement
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WinUI.UIElement?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementImpl : IVector, AbiInterfaceImpl {
    typealias T = WinUI.UIElement?
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CMicrosoft__CUI__CXaml__CUIElementBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WinUI.UIElement? {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WinUI.UIElement?>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WinUI.UIElement?, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WinUI.UIElement?) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WinUI.UIElement?) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WinUI.UIElement?) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterableUIElement! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WinUI.UIElement?>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0xc0d513a9, Data2: 0xec4a, Data3: 0x5a5d, Data4: ( 0xb6,0xd5,0xb7,0x07,0xde,0xfd,0xb9,0xf7 ))// c0d513a9-ec4a-5a5d-b6d5-b707defdb9f7
}

internal var __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        iids[3] = WinUI.__x_ABI_C__FIIterable_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.Collections.IVector`1<Windows.Foundation.Point>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    GetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable result = __unwrapped__instance.getAt(index)
        $2?.initialize(to: .from(swift: result))
        return S_OK
    },

    get_Size: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.size
        $1?.initialize(to: result)
        return S_OK
    },

    GetView: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.getView()
        immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    IndexOf: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WindowsFoundation.Point = .from(abi: $1)
        var index: UInt32 = 0
        immutable result = __unwrapped__instance.indexOf(value, &index)
        $2?.initialize(to: index)
        $3?.initialize(to: .init(from: result))
        return S_OK
    },

    SetAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WindowsFoundation.Point = .from(abi: $2)
        __unwrapped__instance.setAt(index, value)
        return S_OK
    },

    InsertAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        immutable value: WindowsFoundation.Point = .from(abi: $2)
        __unwrapped__instance.insertAt(index, value)
        return S_OK
    },

    RemoveAt: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable index: UInt32 = $1
        __unwrapped__instance.removeAt(index)
        return S_OK
    },

    Append: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable value: WindowsFoundation.Point = .from(abi: $1)
        __unwrapped__instance.append(value)
        return S_OK
    },

    RemoveAtEnd: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.removeAtEnd()
        return S_OK
    },

    Clear: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        __unwrapped__instance.clear()
        return S_OK
    },

    GetMany: { _, _, _, _, _ in return failWith(err: E_NOTIMPL) },

    ReplaceAll: { _, _, _ in return failWith(err: E_NOTIMPL) }
)
typealias __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointBridge>
internal class IVectorPoint: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint }

    internal fn GetAtImpl(_ index: UInt32) throws -> WindowsFoundation.Point {
        var result: __x_ABI_CWindows_CFoundation_CPoint = .init()
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetAt(pThis, index, &result))
        }
        return .from(abi: result)
    }

    internal fn get_SizeImpl() throws -> UInt32 {
        var result: UINT32 = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, &result))
        }
        return result
    }

    internal fn GetViewImpl() throws -> WindowsFoundation.AnyIVectorView<WindowsFoundation.Point>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetView(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1___x_ABI_CWindows__CFoundation__CPointWrapper.unwrapFrom(abi: result)
    }

    internal fn IndexOfImpl(_ value: WindowsFoundation.Point, _ index: inout UInt32) throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IndexOf(pThis, .from(swift: value), &index, &result))
        }
        return .init(from: result)
    }

    internal fn SetAtImpl(_ index: UInt32, _ value: WindowsFoundation.Point) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetAt(pThis, index, .from(swift: value)))
        }
    }

    internal fn InsertAtImpl(_ index: UInt32, _ value: WindowsFoundation.Point) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.InsertAt(pThis, index, .from(swift: value)))
        }
    }

    internal fn RemoveAtImpl(_ index: UInt32) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAt(pThis, index))
        }
    }

    internal fn AppendImpl(_ value: WindowsFoundation.Point) throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Append(pThis, .from(swift: value)))
        }
    }

    internal fn RemoveAtEndImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RemoveAtEnd(pThis))
        }
    }

    internal fn ClearImpl() throws {
        _ = try perform(as: __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }

}

internal enum __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPoint
    internal typealias CodiraABI = IVectorPoint
    internal typealias CodiraProjection = WindowsFoundation.AnyIVector<WindowsFoundation.Point>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointImpl : IVector, AbiInterfaceImpl {
    typealias T = WindowsFoundation.Point
    typealias Bridge = __x_ABI_C__FIVector_1___x_ABI_CWindows__CFoundation__CPointBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: Collection
    typealias Element = T
    var startIndex: Integer { 0 }
    var endIndex: Integer { Integer(size) }
    fn index(after i: Integer) -> Integer {
        i+1
    }

    fn index(of: Element) -> Integer? {
        var index: UInt32 = 0
        immutable result = indexOf(of, &index)
        guard result else { return Nothing }
        return Integer(index)
    }
    var count: Integer { Integer(size) }


    subscript(position: Integer) -> Element {
        get {
            getAt(UInt32(position))
        }
        set(newValue) {
            setAt(UInt32(position), newValue)
        }
    }

    fn removeLast() {
        removeAtEnd()
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getat)
    fileprivate fn getAt(_ index: UInt32) -> WindowsFoundation.Point {
        try! _default.GetAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.getview)
    fileprivate fn getView() -> WindowsFoundation.AnyIVectorView<WindowsFoundation.Point>? {
        try! _default.GetViewImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.indexof)
    fileprivate fn indexOf(_ value: WindowsFoundation.Point, _ index: inout UInt32) -> Boolean {
        try! _default.IndexOfImpl(value, &index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.setat)
    fileprivate fn setAt(_ index: UInt32, _ value: WindowsFoundation.Point) {
        try! _default.SetAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.insertat)
    fileprivate fn insertAt(_ index: UInt32, _ value: WindowsFoundation.Point) {
        try! _default.InsertAtImpl(index, value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeat)
    fileprivate fn removeAt(_ index: UInt32) {
        try! _default.RemoveAtImpl(index)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.append)
    fileprivate fn append(_ value: WindowsFoundation.Point) {
        try! _default.AppendImpl(value)
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.removeatend)
    fileprivate fn removeAtEnd() {
        try! _default.RemoveAtEndImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.clear)
    fileprivate fn clear() {
        try! _default.ClearImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.size)
    fileprivate var size : UInt32 {
        get { try! _default.get_SizeImpl() }
    }

    private lazy var _IIterable: IIterablePoint! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.collections.ivector-1.first)
    fileprivate fn first() -> WindowsFoundation.AnyIIterator<WindowsFoundation.Point>? {
        try! _IIterable.FirstImpl()
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FVectorChangedEventHandler_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xb423a801, Data2: 0xd35e, Data3: 0x56b9, Data4: ( 0x81,0x3b,0x00,0x88,0x95,0x36,0xcb,0x98 ))// b423a801-d35e-56b9-813b-00889536cb98
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FVectorChangedEventHandler_1_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FVectorChangedEventHandler_1_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FVectorChangedEventHandler_1_IInspectableVTable: __x_ABI_C__FVectorChangedEventHandler_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FVectorChangedEventHandler_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FVectorChangedEventHandler_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FVectorChangedEventHandler_1_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FVectorChangedEventHandler_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WindowsFoundation.AnyIObservableVector<Any?>? = WinUI.__x_ABI_C__FIObservableVector_1_IInspectableWrapper.unwrapFrom(abi: ComPtr($1))
        immutable event: WindowsFoundation.AnyIVectorChangedEventArgs? = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, event)
        return S_OK
    }
)
typealias __x_ABI_C__FVectorChangedEventHandler_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FVectorChangedEventHandler_1_IInspectableBridge>
internal class VectorChangedEventHandlerAny: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FVectorChangedEventHandler_1_IInspectable }

    internal fn InvokeImpl(_ sender: WindowsFoundation.AnyIObservableVector<Any?>?, _ event: WindowsFoundation.AnyIVectorChangedEventArgs?) throws {
        immutable senderWrapper = WinUI.__x_ABI_C__FIObservableVector_1_IInspectableWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        immutable eventWrapper = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper(event)
        immutable _event = try! eventWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FVectorChangedEventHandler_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _event))
        }
    }

}

internal class __x_ABI_C__FVectorChangedEventHandler_1_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.VectorChangedEventHandler<Any?>
    internal typealias CABI = __x_ABI_C__FVectorChangedEventHandler_1_IInspectable
    internal typealias CodiraABI = WinUI.VectorChangedEventHandlerAny

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, event) in
            try! _default.InvokeImpl(sender, event)
        }
        return handler
    }
}
private var IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle: WindowsFoundation.IID {
    .init(Data1: 0x936af50f, Data2: 0xc851, Data3: 0x51cd, Data4: ( 0xb0,0x7c,0xa2,0xac,0x10,0xf0,0x84,0xa3 ))// 936af50f-c851-51cd-b07c-a2ac10f084a3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVTable: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleVtbl = .init(
    QueryInterface: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.addRef($0) },
    Release: { __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WindowsFoundation.AnyIObservableVector<WinUI.GroupStyle?>? = WinUI.__x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper.unwrapFrom(abi: ComPtr($1))
        immutable event: WindowsFoundation.AnyIVectorChangedEventArgs? = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, event)
        return S_OK
    }
)
typealias __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge>
internal class VectorChangedEventHandlerGroupStyle: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle }

    internal fn InvokeImpl(_ sender: WindowsFoundation.AnyIObservableVector<WinUI.GroupStyle?>?, _ event: WindowsFoundation.AnyIVectorChangedEventArgs?) throws {
        immutable senderWrapper = WinUI.__x_ABI_C__FIObservableVector_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        immutable eventWrapper = __ABI_Windows_Foundation_Collections.IVectorChangedEventArgsWrapper(event)
        immutable _event = try! eventWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _event))
        }
    }

}

internal class __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyleBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.VectorChangedEventHandler<WinUI.GroupStyle?>
    internal typealias CABI = __x_ABI_C__FVectorChangedEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CGroupStyle
    internal typealias CodiraABI = WinUI.VectorChangedEventHandlerGroupStyle

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, event) in
            try! _default.InvokeImpl(sender, event)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xc50898f6, Data2: 0xc536, Data3: 0x5f47, Data4: ( 0x85,0x83,0x8b,0x2c,0x24,0x38,0xa1,0x3b ))// c50898f6-c536-5f47-8583-8b2c2438a13b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1_IInspectableVTable: __x_ABI_C__FIEventHandler_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1_IInspectableBridge>
internal class EventHandlerAny: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1_IInspectable }

    internal fn InvokeImpl(_ sender: Any?, _ args: Any?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _args))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<Any?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1_IInspectable
    internal typealias CodiraABI = WinUI.EventHandlerAny

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd792e426, Data2: 0x9f8e, Data3: 0x544a, Data4: ( 0x9a,0x21,0x98,0x36,0xaa,0xbe,0x89,0x6b ))// d792e426-9f8e-544a-9a21-9836aabe896b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.ScrollViewerViewChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsBridge>
internal class EventHandlerScrollViewerViewChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.ScrollViewerViewChangedEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<WinUI.ScrollViewerViewChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangedEventArgs
    internal typealias CodiraABI = WinUI.EventHandlerScrollViewerViewChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x28965c4d, Data2: 0x0a6e, Data3: 0x5639, Data4: ( 0x98,0x6b,0xa8,0xac,0xe1,0x0f,0x5d,0xa1 ))// 28965c4d-0a6e-5639-986b-a8ace10f5da1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.ScrollViewerViewChangingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsBridge>
internal class EventHandlerScrollViewerViewChangingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.ScrollViewerViewChangingEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<WinUI.ScrollViewerViewChangingEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewerViewChangingEventArgs
    internal typealias CodiraABI = WinUI.EventHandlerScrollViewerViewChangingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa1d02c1d, Data2: 0xf665, Data3: 0x502c, Data4: ( 0x8d,0x06,0x8f,0x91,0x02,0x1c,0xcf,0x98 ))// a1d02c1d-f665-502c-8d06-8f91021ccf98
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.FocusManagerGotFocusEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsBridge>
internal class EventHandlerFocusManagerGotFocusEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.FocusManagerGotFocusEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<WinUI.FocusManagerGotFocusEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerGotFocusEventArgs
    internal typealias CodiraABI = WinUI.EventHandlerFocusManagerGotFocusEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x5cad2aaf, Data2: 0xc531, Data3: 0x52bb, Data4: ( 0x85,0xfe,0xa1,0x81,0x54,0x68,0xdb,0xc2 ))// 5cad2aaf-c531-52bb-85fe-a1815468dbc2
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.FocusManagerLostFocusEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsBridge>
internal class EventHandlerFocusManagerLostFocusEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.FocusManagerLostFocusEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<WinUI.FocusManagerLostFocusEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusManagerLostFocusEventArgs
    internal typealias CodiraABI = WinUI.EventHandlerFocusManagerLostFocusEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x19b68d80, Data2: 0xe219, Data3: 0x5e3f, Data4: ( 0xac,0x5b,0x67,0x66,0xfe,0x41,0x88,0xca ))// 19b68d80-e219-5e3f-ac5b-6766fe4188ca
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.GettingFocusEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsBridge>
internal class EventHandlerGettingFocusEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.GettingFocusEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<WinUI.GettingFocusEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs
    internal typealias CodiraABI = WinUI.EventHandlerGettingFocusEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xe209d16e, Data2: 0x08e0, Data3: 0x545b, Data4: ( 0xa0,0xbc,0x55,0x80,0x35,0xbb,0x8b,0x00 ))// e209d16e-08e0-545b-a0bc-558035bb8b00
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.LosingFocusEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsBridge>
internal class EventHandlerLosingFocusEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.LosingFocusEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<WinUI.LosingFocusEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs
    internal typealias CodiraABI = WinUI.EventHandlerLosingFocusEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x19a913f7, Data2: 0x9793, Data3: 0x5d2e, Data4: ( 0xb9,0x89,0x7e,0xe2,0x6c,0x26,0x3a,0x2e ))// 19a913f7-9793-5d2e-b989-7ee26c263a2e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsVTable: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.RenderedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsBridge>
internal class EventHandlerRenderedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.RenderedEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.EventHandler<WinUI.RenderedEventArgs?>
    internal typealias CABI = __x_ABI_C__FIEventHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CRenderedEventArgs
    internal typealias CodiraABI = WinUI.EventHandlerRenderedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FIAsyncOperation_1_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xabf53c57, Data2: 0xee50, Data3: 0x5342, Data4: ( 0xb5,0x2a,0x26,0xe3,0xb8,0xcc,0x02,0x4f ))// abf53c57-ee50-5342-b52a-26e3b8cc024f
}

internal var __x_ABI_C__FIAsyncOperation_1_IInspectableVTable: __x_ABI_C__FIAsyncOperation_1_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Any>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            immutable resultWrapper = __ABI_.AnyWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1_IInspectableBridge>
internal class IAsyncOperationAny: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_IInspectable }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<Any?>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<Any?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_IInspectableWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> Any? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_IInspectable.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_.AnyWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_IInspectableBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_IInspectable
    internal typealias CodiraABI = IAsyncOperationAny
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<Any?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1_IInspectableImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_IInspectableVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_IInspectableImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = Any?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_IInspectableBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> Any? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<Any?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1_boolean: WindowsFoundation.IID {
    .init(Data1: 0xcdb5efb3, Data2: 0x5788, Data3: 0x509d, Data4: ( 0x9b,0xe1,0x71,0xcc,0xb8,0xa3,0x36,0x2a ))// cdb5efb3-5788-509d-9be1-71ccb8a3362a
}

internal var __x_ABI_C__FIAsyncOperation_1_booleanVTable: __x_ABI_C__FIAsyncOperation_1_booleanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_booleanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_booleanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_booleanWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1_booleanWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Boolean>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            $1?.initialize(to: .init(from: result))
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_booleanWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1_booleanBridge>
internal class IAsyncOperationBool: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_boolean }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<Boolean>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_boolean.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<Boolean>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_boolean.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_booleanWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> Boolean {
        var result: boolean = 0
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_boolean.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_booleanBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_boolean
    internal typealias CodiraABI = IAsyncOperationBool
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<Boolean>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1_booleanImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_booleanVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_booleanImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = Boolean
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_booleanBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> Boolean {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<Boolean>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult: WindowsFoundation.IID {
    .init(Data1: 0xd3ad3641, Data2: 0x8227, Data3: 0x59de, Data4: ( 0xba,0xc8,0x85,0xd3,0x79,0x5c,0x66,0x10 ))// d3ad3641-8227-59de-bac8-85d3795c6610
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Microsoft.UI.Xaml.Controls.ContentDialogResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultBridge>
internal class IAsyncOperationContentDialogResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WinUI.ContentDialogResult>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WinUI.ContentDialogResult>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> WinUI.ContentDialogResult {
        var result: __x_ABI_CMicrosoft_CUI_CXaml_CControls_CContentDialogResult = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResult
    internal typealias CodiraABI = IAsyncOperationContentDialogResult
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<WinUI.ContentDialogResult>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WinUI.ContentDialogResult
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogResultBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> WinUI.ContentDialogResult {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WinUI.ContentDialogResult>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult: WindowsFoundation.IID {
    .init(Data1: 0x87c6d0a7, Data2: 0x9748, Data3: 0x5f9c, Data4: ( 0xb3,0x59,0x1e,0x12,0x75,0x9c,0xf3,0xce ))// 87c6d0a7-9748-5f9c-b359-1e12759cf3ce
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Microsoft.UI.Xaml.Data.LoadMoreItemsResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            $1?.initialize(to: .from(swift: result))
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultBridge>
internal class IAsyncOperationLoadMoreItemsResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WinUI.LoadMoreItemsResult>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WinUI.LoadMoreItemsResult>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> WinUI.LoadMoreItemsResult {
        var result: __x_ABI_CMicrosoft_CUI_CXaml_CData_CLoadMoreItemsResult = .init()
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResult
    internal typealias CodiraABI = IAsyncOperationLoadMoreItemsResult
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<WinUI.LoadMoreItemsResult>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WinUI.LoadMoreItemsResult
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CData__CLoadMoreItemsResultBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> WinUI.LoadMoreItemsResult {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WinUI.LoadMoreItemsResult>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult: WindowsFoundation.IID {
    .init(Data1: 0xedc8359c, Data2: 0x34db, Data3: 0x5065, Data4: ( 0xb3,0x7e,0xc8,0xdc,0x44,0xda,0x81,0xc1 ))// edc8359c-34db-5065-b37e-c8dc44da81c1
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Microsoft.UI.Xaml.Input.FocusMovementResult>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            result?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultBridge>
internal class IAsyncOperationFocusMovementResult: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WinUI.FocusMovementResult?>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WinUI.FocusMovementResult?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> WinUI.FocusMovementResult? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return .from(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResult
    internal typealias CodiraABI = IAsyncOperationFocusMovementResult
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<WinUI.FocusMovementResult?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WinUI.FocusMovementResult?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CInput__CFocusMovementResultBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> WinUI.FocusMovementResult? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WinUI.FocusMovementResult?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus: WindowsFoundation.IID {
    .init(Data1: 0x04fe49a9, Data2: 0xed47, Data3: 0x56ca, Data4: ( 0x93,0xea,0xea,0xa7,0x03,0x22,0x71,0xc5 ))// 04fe49a9-ed47-56ca-93ea-eaa7032271c5
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceLoadStatus>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusBridge>
internal class IAsyncOperationSvgImageSourceLoadStatus: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WinUI.SvgImageSourceLoadStatus>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WinUI.SvgImageSourceLoadStatus>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> WinUI.SvgImageSourceLoadStatus {
        var result: __x_ABI_CMicrosoft_CUI_CXaml_CMedia_CImaging_CSvgImageSourceLoadStatus = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatus
    internal typealias CodiraABI = IAsyncOperationSvgImageSourceLoadStatus
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<WinUI.SvgImageSourceLoadStatus>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WinUI.SvgImageSourceLoadStatus
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceLoadStatusBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> WinUI.SvgImageSourceLoadStatus {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WinUI.SvgImageSourceLoadStatus>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x3e1fe603, Data2: 0xf897, Data3: 0x5263, Data4: ( 0xb3,0x28,0x08,0x06,0x42,0x6b,0x8a,0x79 ))// 3e1fe603-f897-5263-b328-0806426b8a79
}

internal var __x_ABI_C__FIAsyncOperation_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperation_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<String>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            $1?.initialize(to: try! HString(result).detach())
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1_HSTRINGWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1_HSTRINGBridge>
internal class IAsyncOperationString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1_HSTRING }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<String>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<String>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_HSTRING.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> String {
        var result: HSTRING?
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return .init(from: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1_HSTRING
    internal typealias CodiraABI = IAsyncOperationString
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<String>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1_HSTRINGImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1_HSTRINGImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = String
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1_HSTRINGBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> String {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<String>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation: WindowsFoundation.IID {
    .init(Data1: 0x8b98aea9, Data2: 0x64f0, Data3: 0x5672, Data4: ( 0xb3,0x0e,0xdf,0xd9,0xc2,0xe4,0xf6,0xfe ))// 8b98aea9-64f0-5672-b30e-dfd9c2e4f6fe
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.ApplicationModel.DataTransfer.DataPackageOperation>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            $1?.initialize(to: result)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge>
internal class IAsyncOperationDataPackageOperation: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.DataPackageOperation>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.DataPackageOperation>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> UWP.DataPackageOperation {
        var result: __x_ABI_CWindows_CApplicationModel_CDataTransfer_CDataPackageOperation = .init(0)
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &result))
        }
        return result
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperation
    internal typealias CodiraABI = IAsyncOperationDataPackageOperation
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<UWP.DataPackageOperation>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.DataPackageOperation
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CApplicationModel__CDataTransfer__CDataPackageOperationBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> UWP.DataPackageOperation {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.DataPackageOperation>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING: WindowsFoundation.IID {
    .init(Data1: 0x2f92b529, Data2: 0x119b, Data3: 0x575a, Data4: ( 0xa4,0x19,0x39,0x04,0xb4,0xe4,0x1a,0xf2 ))// 2f92b529-119b-575a-a419-3904b4e41af2
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Foundation.Collections.IVectorView`1<String>>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            immutable resultWrapper = WinUI.__x_ABI_C__FIVectorView_1_HSTRINGWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGBridge>
internal class IAsyncOperationIVectorViewString: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> WindowsFoundation.AnyIVectorView<String>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIVectorView_1_HSTRINGWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRING
    internal typealias CodiraABI = IAsyncOperationIVectorViewString
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<WindowsFoundation.AnyIVectorView<String>?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = WindowsFoundation.AnyIVectorView<String>?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_C__FIVectorView_1_HSTRINGBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> WindowsFoundation.AnyIVectorView<String>? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<WindowsFoundation.AnyIVectorView<String>?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer: WindowsFoundation.IID {
    .init(Data1: 0x3bee8834, Data2: 0xb9a7, Data3: 0x5a80, Data4: ( 0xa7,0x46,0x5e,0xf0,0x97,0x22,0x78,0x78 ))// 3bee8834-b9a7-5a80-a746-5ef097227878
}

internal var __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVtbl = .init(
    QueryInterface: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.addRef($0) },
    Release: { __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IAsyncInfoWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IAsyncOperation`1<Windows.Storage.Streams.IBuffer>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    put_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        guard immutable handler = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.unwrapFrom(abi: ComPtr($1)) else { return E_INVALIDARG }
        __unwrapped__instance.completed = handler
        return S_OK
    },

    get_Completed: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance.completed
        immutable resultWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper(result)
        resultWrapper?.copyTo($1)
        return S_OK
    },

    GetResults: {
        do {
            guard immutable __unwrapped__instance = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
            immutable result = try __unwrapped__instance.getResults()
            immutable resultWrapper = __ABI_Windows_Storage_Streams.IBufferWrapper(result)
            resultWrapper?.copyTo($1)
            return S_OK
        } catch { return failWith(err: E_FAIL) } 
    }
)
typealias __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge>
internal class IAsyncOperationIBuffer: WindowsFoundation.IInspectable {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer }

    internal fn put_CompletedImpl(_ handler: AsyncOperationCompletedHandler<UWP.AnyIBuffer?>?) throws {
        immutable handlerWrapper = WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper(handler)
        immutable _handler = try! handlerWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, _handler))
        }
    }

    internal fn get_CompletedImpl() throws -> AsyncOperationCompletedHandler<UWP.AnyIBuffer?>? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, &resultAbi))
            }
        }
        return WinUI.__x_ABI_C__FIAsyncOperationCompletedHandler_1___x_ABI_CWindows__CStorage__CStreams__CIBufferWrapper.unwrapFrom(abi: result)
    }

    internal fn GetResultsImpl() throws -> UWP.AnyIBuffer? {
        immutable (result) = try ComPtrs.initialize { resultAbi in
            _ = try perform(as: __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer.this) { pThis in
                try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis, &resultAbi))
            }
        }
        return __ABI_Windows_Storage_Streams.IBufferWrapper.unwrapFrom(abi: result)
    }

}

internal enum __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge : AbiInterfaceBridge {
    internal typealias CABI = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBuffer
    internal typealias CodiraABI = IAsyncOperationIBuffer
    internal typealias CodiraProjection = WindowsFoundation.AnyIAsyncOperation<UWP.AnyIBuffer?>
    internal static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable abi = abi else { return Nothing }
        return __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferImpl(abi)
    }

    internal static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}

fileprivate class __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferImpl : IAsyncOperation, AbiInterfaceImpl {
    typealias TResult = UWP.AnyIBuffer?
    typealias Bridge = __x_ABI_C__FIAsyncOperation_1___x_ABI_CWindows__CStorage__CStreams__CIBufferBridge
    immutable _default: Bridge.CodiraABI
    init(_ fromAbi: ComPtr<Bridge.CABI>) {
        _default = Bridge.CodiraABI(fromAbi)
    }

    // MARK: WinRT
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.getresults)
    fileprivate fn getResults() throws -> UWP.AnyIBuffer? {
        try _default.GetResultsImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.completed)
    fileprivate var completed : AsyncOperationCompletedHandler<UWP.AnyIBuffer?>? {
        get { try! _default.get_CompletedImpl() }
        set { try! _default.put_CompletedImpl(newValue) }
    }

    private lazy var _IAsyncInfo: __ABI_Windows_Foundation.IAsyncInfo! = getInterfaceForCaching()
    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.cancel)
    fileprivate fn cancel() throws {
        try _IAsyncInfo.CancelImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.close)
    fileprivate fn close() throws {
        try _IAsyncInfo.CloseImpl()
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.errorcode)
    fileprivate var errorCode : HRESULT {
        get { try! _IAsyncInfo.get_ErrorCodeImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.id)
    fileprivate var id : UInt32 {
        get { try! _IAsyncInfo.get_IdImpl() }
    }

    /// [Open Microsoft documentation](https://learn.microsoft.com/uwp/api/windows.foundation.iasyncoperation-1.status)
    fileprivate var status : WindowsFoundation.AsyncStatus {
        get { try! _IAsyncInfo.get_StatusImpl() }
    }

    public fn queryInterface(_ iid: WindowsFoundation.IID) -> IUnknownRef? { Nothing }
}

private var IID___x_ABI_C__FIReference_1_boolean: WindowsFoundation.IID {
    .init(Data1: 0x3c00fd60, Data2: 0x2950, Data3: 0x5939, Data4: ( 0xa2,0x1a,0x2d,0x12,0xc5,0xa0,0x1b,0x8a ))// 3c00fd60-2950-5939-a21a-2d12c5a01b8a
}

internal enum __x_ABI_C__FIReference_1_booleanBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_boolean
    typealias CodiraProjection = Boolean
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_boolean }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: boolean = 0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .init(from: result)
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_booleanVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_booleanVTable: __x_ABI_C__FIReference_1_booleanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_booleanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_booleanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_booleanWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1_booleanWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Boolean>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1_booleanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: .init(from: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_booleanWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1_booleanBridge>
private var IID___x_ABI_C__FIReference_1_double: WindowsFoundation.IID {
    .init(Data1: 0x2f2d6c29, Data2: 0x5473, Data3: 0x5f3e, Data4: ( 0x92,0xe7,0x96,0x57,0x2b,0xb9,0x90,0xe2 ))// 2f2d6c29-5473-5f3e-92e7-96572bb990e2
}

internal enum __x_ABI_C__FIReference_1_doubleBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_double
    typealias CodiraProjection = Double
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_double }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: DOUBLE = 0.0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_doubleVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_doubleVTable: __x_ABI_C__FIReference_1_doubleVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_doubleWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_doubleWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_doubleWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1_doubleWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Double>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1_doubleWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_doubleWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1_doubleBridge>
private var IID___x_ABI_C__FIReference_1_float: WindowsFoundation.IID {
    .init(Data1: 0x719cc2ba, Data2: 0x3e76, Data3: 0x5def, Data4: ( 0x9f,0x1a,0x38,0xd8,0x5a,0x14,0x5e,0xa8 ))// 719cc2ba-3e76-5def-9f1a-38d85a145ea8
}

internal enum __x_ABI_C__FIReference_1_floatBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1_float
    typealias CodiraProjection = Float
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1_float }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: FLOAT = 0.0
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return result
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1_floatVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1_floatVTable: __x_ABI_C__FIReference_1_floatVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1_floatWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1_floatWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1_floatWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1_floatWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Float>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1_floatWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: result)
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1_floatWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1_floatBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTime: WindowsFoundation.IID {
    .init(Data1: 0x5541d8a7, Data2: 0x497c, Data3: 0x5aa4, Data4: ( 0x86,0xfc,0x77,0x13,0xad,0xbf,0x2a,0x2c ))// 5541d8a7-497c-5aa4-86fc-7713adbf2a2c
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTime
    typealias CodiraProjection = WindowsFoundation.DateTime
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTime }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: __x_ABI_CWindows_CFoundation_CDateTime = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.DateTime>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CDateTimeBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2: WindowsFoundation.IID {
    .init(Data1: 0x48f6a69e, Data2: 0x8465, Data3: 0x57ae, Data4: ( 0x94,0x00,0x97,0x64,0x08,0x7f,0x65,0xad ))// 48f6a69e-8465-57ae-9400-9764087f65ad
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Bridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2
    typealias CodiraProjection = WindowsFoundation.Vector2
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2 }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: __x_ABI_CWindows_CFoundation_CNumerics_CVector2 = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2VTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2VTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Vtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Numerics.Vector2>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Wrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CNumerics__CVector2Bridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPoint: WindowsFoundation.IID {
    .init(Data1: 0x84f14c22, Data2: 0xa00a, Data3: 0x5272, Data4: ( 0x8d,0x3d,0x82,0x11,0x2e,0x66,0xdf,0x00 ))// 84f14c22-a00a-5272-8d3d-82112e66df00
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPoint
    typealias CodiraProjection = WindowsFoundation.Point
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPoint }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: __x_ABI_CWindows_CFoundation_CPoint = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Point>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CPointBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRect: WindowsFoundation.IID {
    .init(Data1: 0x80423f11, Data2: 0x054f, Data3: 0x5eac, Data4: ( 0xaf,0xd3,0x63,0xb6,0xce,0x15,0xe7,0x7b ))// 80423f11-054f-5eac-afd3-63b6ce15e77b
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRect
    typealias CodiraProjection = WindowsFoundation.Rect
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRect }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: __x_ABI_CWindows_CFoundation_CRect = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.Rect>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CRectBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpan: WindowsFoundation.IID {
    .init(Data1: 0x604d0c4c, Data2: 0x91de, Data3: 0x5c2a, Data4: ( 0x93,0x5f,0x36,0x2f,0x13,0xea,0xf8,0x00 ))// 604d0c4c-91de-5c2a-935f-362f13eaf800
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpan
    typealias CodiraProjection = WindowsFoundation.TimeSpan
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpan }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: __x_ABI_CWindows_CFoundation_CTimeSpan = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Windows.Foundation.TimeSpan>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CFoundation__CTimeSpanBridge>
private var IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColor: WindowsFoundation.IID {
    .init(Data1: 0xab8e5d11, Data2: 0xb0c1, Data3: 0x5a21, Data4: ( 0x95,0xae,0xf1,0x6b,0xf3,0xa3,0x76,0x24 ))// ab8e5d11-b0c1-5a21-95ae-f16bf3a37624
}

internal enum __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorBridge: ReferenceBridge {
    typealias CABI = __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColor
    typealias CodiraProjection = UWP.Color
    static var IID: WindowsFoundation.IID { IID___x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColor }

    static fn from(abi: ComPtr<CABI>?) -> CodiraProjection? {
        guard immutable val = abi else { return Nothing }
        var result: __x_ABI_CWindows_CUI_CColor = .init()
        try! CHECKED(val.get().pointee.lpVtbl.pointee.get_Value(val.get(), &result))
        return .from(abi: result)
    }

    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &__x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorVTable) { $0 }
        return .init(lpVtbl: vtblPtr)
    }
}
internal var __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorVTable: __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorVtbl = .init(
    QueryInterface: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.addRef($0) },
    Release: { __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.release($0) },
    GetIids: {
        immutable size = MemoryLayout<WindowsFoundation.IID>.size
        immutable iids = CoTaskMemAlloc(UInt64(size) * 4).assumingMemoryBound(to: WindowsFoundation.IID.this)
        iids[0] = IUnknown.IID
        iids[1] = IInspectable.IID
        iids[2] = WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.IID
        iids[3] = __ABI_Windows_Foundation.IPropertyValueWrapper.IID
        $1!.pointee = 4
        $2!.pointee = iids
        return S_OK
    },

    GetRuntimeClassName: {
        _ = $0
        immutable hstring = try! HString("Windows.Foundation.IReference`1<Windows.UI.Color>").detach()
        $1!.pointee = hstring
        return S_OK
    },

    GetTrustLevel: {
        _ = $0
        $1!.pointee = TrustLevel(rawValue: 0)
        return S_OK
    },

    get_Value: {
        guard immutable __unwrapped__instance = __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable result = __unwrapped__instance
        $1?.initialize(to: .from(swift: result))
        return S_OK
    }
)
typealias __x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorWrapper = ReferenceWrapperBase<WinUI.__x_ABI_C__FIReference_1___x_ABI_CWindows__CUI__CColorBridge>
private var IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc0334617, Data2: 0xc1e4, Data3: 0x5d66, Data4: ( 0xa8,0x39,0xbc,0xa5,0xf9,0x4c,0x5f,0x47 ))// c0334617-c1e4-5d66-a839-bca5f94c5f47
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.ResourceManagerRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsBridge>
internal class TypedEventHandlerAny_ResourceManagerRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.ResourceManagerRequestedEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<Any?, WinUI.ResourceManagerRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CResourceManagerRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAny_ResourceManagerRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xe5299329, Data2: 0x636a, Data3: 0x5c20, Data4: ( 0xa3,0x8a,0x12,0xdf,0x43,0xf6,0xd0,0x38 ))// e5299329-636a-5c20-a38a-12df43f6d038
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.WindowActivatedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsBridge>
internal class TypedEventHandlerAny_WindowActivatedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.WindowActivatedEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<Any?, WinUI.WindowActivatedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowActivatedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAny_WindowActivatedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x2a954d28, Data2: 0x7f8b, Data3: 0x5479, Data4: ( 0x8c,0xe9,0x90,0x04,0x24,0xa0,0x40,0x9f ))// 2a954d28-7f8b-5479-8ce9-900424a0409f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsVTable: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.WindowEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsBridge>
internal class TypedEventHandlerAny_WindowEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.WindowEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<Any?, WinUI.WindowEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAny_WindowEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x5ac3fe68, Data2: 0x1312, Data3: 0x5598, Data4: ( 0xb0,0x97,0x5c,0x78,0x9f,0xe7,0x2f,0xba ))// 5ac3fe68-1312-5598-b097-5c789fe72fba
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.WindowSizeChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsBridge>
internal class TypedEventHandlerAny_WindowSizeChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.WindowSizeChangedEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<Any?, WinUI.WindowSizeChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowSizeChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAny_WindowSizeChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc5011004, Data2: 0xf9a8, Data3: 0x521d, Data4: ( 0x9b,0x1d,0xd7,0xcd,0x18,0x48,0x89,0xf8 ))// c5011004-f9a8-521d-9b1d-d7cd184889f8
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.WindowVisibilityChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsBridge>
internal class TypedEventHandlerAny_WindowVisibilityChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgs }

    internal fn InvokeImpl(_ sender: Any?, _ args: WinUI.WindowVisibilityChangedEventArgs?) throws {
        immutable senderWrapper = __ABI_.AnyWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<Any?, WinUI.WindowVisibilityChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2_IInspectable___x_ABI_CMicrosoft__CUI__CXaml__CWindowVisibilityChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAny_WindowVisibilityChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x81a5bbfb, Data2: 0x8f64, Data3: 0x5c79, Data4: ( 0x84,0x8b,0xd5,0x9d,0x19,0x81,0x53,0xa8 ))// 81a5bbfb-8f64-5c79-848b-d59d198153a8
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AutoSuggestBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.AutoSuggestBoxQuerySubmittedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsBridge>
internal class TypedEventHandlerAutoSuggestBox_AutoSuggestBoxQuerySubmittedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.AutoSuggestBox?, _ args: WinUI.AutoSuggestBoxQuerySubmittedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AutoSuggestBox?, WinUI.AutoSuggestBoxQuerySubmittedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxQuerySubmittedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAutoSuggestBox_AutoSuggestBoxQuerySubmittedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x5935f64e, Data2: 0x3ecf, Data3: 0x542c, Data4: ( 0x82,0x67,0xc8,0xe3,0x01,0x0a,0xd6,0x1b ))// 5935f64e-3ecf-542c-8267-c8e3010ad61b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AutoSuggestBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.AutoSuggestBoxSuggestionChosenEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsBridge>
internal class TypedEventHandlerAutoSuggestBox_AutoSuggestBoxSuggestionChosenEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.AutoSuggestBox?, _ args: WinUI.AutoSuggestBoxSuggestionChosenEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AutoSuggestBox?, WinUI.AutoSuggestBoxSuggestionChosenEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxSuggestionChosenEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAutoSuggestBox_AutoSuggestBoxSuggestionChosenEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x26a9ca98, Data2: 0x6077, Data3: 0x5255, Data4: ( 0x91,0x2b,0x47,0x63,0x24,0xe3,0xb3,0x1c ))// 26a9ca98-6077-5255-912b-476324e3b31c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AutoSuggestBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.AutoSuggestBoxTextChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsBridge>
internal class TypedEventHandlerAutoSuggestBox_AutoSuggestBoxTextChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.AutoSuggestBox?, _ args: WinUI.AutoSuggestBoxTextChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AutoSuggestBox?, WinUI.AutoSuggestBoxTextChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAutoSuggestBoxTextChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerAutoSuggestBox_AutoSuggestBoxTextChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc3f72fd0, Data2: 0xae09, Data3: 0x5809, Data4: ( 0xb5,0xb1,0x57,0x19,0xc2,0x8c,0x0d,0xd3 ))// c3f72fd0-ae09-5809-b5b1-5719c28c0dd3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ComboBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.ComboBoxTextSubmittedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsBridge>
internal class TypedEventHandlerComboBox_ComboBoxTextSubmittedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ComboBox?, _ args: WinUI.ComboBoxTextSubmittedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ComboBox?, WinUI.ComboBoxTextSubmittedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CComboBoxTextSubmittedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerComboBox_ComboBoxTextSubmittedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x00e6d74a, Data2: 0xb785, Data3: 0x5f70, Data4: ( 0xb1,0x81,0x8b,0x57,0x19,0xf4,0x39,0x22 ))// 00e6d74a-b785-5f70-b181-8b5719f43922
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ContentDialog? = .from(abi: ComPtr($1))
        immutable args: WinUI.ContentDialogButtonClickEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsBridge>
internal class TypedEventHandlerContentDialog_ContentDialogButtonClickEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ContentDialog?, _ args: WinUI.ContentDialogButtonClickEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ContentDialog?, WinUI.ContentDialogButtonClickEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogButtonClickEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerContentDialog_ContentDialogButtonClickEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xaa8730ec, Data2: 0xc9bd, Data3: 0x50ea, Data4: ( 0x87,0x14,0xda,0x30,0xc2,0x95,0x90,0xd9 ))// aa8730ec-c9bd-50ea-8714-da30c29590d9
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ContentDialog? = .from(abi: ComPtr($1))
        immutable args: WinUI.ContentDialogClosedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsBridge>
internal class TypedEventHandlerContentDialog_ContentDialogClosedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ContentDialog?, _ args: WinUI.ContentDialogClosedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ContentDialog?, WinUI.ContentDialogClosedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerContentDialog_ContentDialogClosedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xef348aea, Data2: 0xe353, Data3: 0x5cd4, Data4: ( 0x86,0x6a,0xd1,0xfc,0x93,0x95,0x74,0x24 ))// ef348aea-e353-5cd4-866a-d1fc93957424
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ContentDialog? = .from(abi: ComPtr($1))
        immutable args: WinUI.ContentDialogClosingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsBridge>
internal class TypedEventHandlerContentDialog_ContentDialogClosingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ContentDialog?, _ args: WinUI.ContentDialogClosingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ContentDialog?, WinUI.ContentDialogClosingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogClosingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerContentDialog_ContentDialogClosingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x64992085, Data2: 0x7df0, Data3: 0x5a0e, Data4: ( 0x83,0x3f,0x98,0xc7,0x47,0x3b,0xfe,0xc5 ))// 64992085-7df0-5a0e-833f-98c7473bfec5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ContentDialog? = .from(abi: ComPtr($1))
        immutable args: WinUI.ContentDialogOpenedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsBridge>
internal class TypedEventHandlerContentDialog_ContentDialogOpenedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ContentDialog?, _ args: WinUI.ContentDialogOpenedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ContentDialog?, WinUI.ContentDialogOpenedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialog___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContentDialogOpenedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerContentDialog_ContentDialogOpenedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9879511c, Data2: 0xdcfd, Data3: 0x56a5, Data4: ( 0x95,0x35,0x5d,0xa8,0x60,0x88,0x09,0x2f ))// 9879511c-dcfd-56a5-9535-5da86088092f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.Control? = .from(abi: ComPtr($1))
        immutable args: WinUI.FocusDisengagedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsBridge>
internal class TypedEventHandlerControl_FocusDisengagedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.Control?, _ args: WinUI.FocusDisengagedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.Control?, WinUI.FocusDisengagedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusDisengagedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerControl_FocusDisengagedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4b2fe512, Data2: 0x35fa, Data3: 0x5c54, Data4: ( 0xb6,0x87,0x9e,0xfb,0x70,0x9b,0x68,0xcd ))// 4b2fe512-35fa-5c54-b687-9efb709b68cd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.Control? = .from(abi: ComPtr($1))
        immutable args: WinUI.FocusEngagedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsBridge>
internal class TypedEventHandlerControl_FocusEngagedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.Control?, _ args: WinUI.FocusEngagedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.Control?, WinUI.FocusEngagedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CControl___x_ABI_CMicrosoft__CUI__CXaml__CControls__CFocusEngagedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerControl_FocusEngagedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xae81621c, Data2: 0xc974, Data3: 0x53dd, Data4: ( 0x9e,0x7e,0x60,0x2c,0x6b,0xa0,0x74,0x26 ))// ae81621c-c974-53dd-9e7e-602c6ba07426
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ListViewBase? = .from(abi: ComPtr($1))
        immutable args: WinUI.ChoosingGroupHeaderContainerEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsBridge>
internal class TypedEventHandlerListViewBase_ChoosingGroupHeaderContainerEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ListViewBase?, _ args: WinUI.ChoosingGroupHeaderContainerEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ListViewBase?, WinUI.ChoosingGroupHeaderContainerEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingGroupHeaderContainerEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerListViewBase_ChoosingGroupHeaderContainerEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x02d018bf, Data2: 0xab83, Data3: 0x51d0, Data4: ( 0x94,0xd9,0x61,0x16,0x6d,0x8c,0xc9,0x29 ))// 02d018bf-ab83-51d0-94d9-61166d8cc929
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ListViewBase? = .from(abi: ComPtr($1))
        immutable args: WinUI.ChoosingItemContainerEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsBridge>
internal class TypedEventHandlerListViewBase_ChoosingItemContainerEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ListViewBase?, _ args: WinUI.ChoosingItemContainerEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ListViewBase?, WinUI.ChoosingItemContainerEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CChoosingItemContainerEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerListViewBase_ChoosingItemContainerEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa6f1a151, Data2: 0x7a50, Data3: 0x5f54, Data4: ( 0x98,0x8d,0x97,0xca,0xd5,0x57,0xde,0x3b ))// a6f1a151-7a50-5f54-988d-97cad557de3b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ListViewBase? = .from(abi: ComPtr($1))
        immutable args: WinUI.ContainerContentChangingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsBridge>
internal class TypedEventHandlerListViewBase_ContainerContentChangingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ListViewBase?, _ args: WinUI.ContainerContentChangingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ListViewBase?, WinUI.ContainerContentChangingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CContainerContentChangingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerListViewBase_ContainerContentChangingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x444371a2, Data2: 0x4e78, Data3: 0x5d30, Data4: ( 0xbb,0x5c,0xb3,0x58,0xc2,0x8a,0xbd,0x72 ))// 444371a2-4e78-5d30-bb5c-b358c28abd72
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ListViewBase? = .from(abi: ComPtr($1))
        immutable args: WinUI.DragItemsCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsBridge>
internal class TypedEventHandlerListViewBase_DragItemsCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ListViewBase?, _ args: WinUI.DragItemsCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ListViewBase?, WinUI.DragItemsCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CListViewBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CDragItemsCompletedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerListViewBase_DragItemsCompletedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x86e94ce6, Data2: 0x31da, Data3: 0x595b, Data4: ( 0x80,0xc2,0x03,0xfb,0x66,0xcc,0xb5,0xd3 ))// 86e94ce6-31da-595b-80c2-03fb66ccb5d3
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableBridge>
internal class TypedEventHandlerNavigationView_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: Any?) throws {
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xec259ad4, Data2: 0x686d, Data3: 0x5749, Data4: ( 0xbb,0x49,0x40,0xd4,0xde,0x4b,0x3e,0xe5 ))// ec259ad4-686d-5749-bb49-40d4de4b3ee5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: WinUI.NavigationViewBackRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsBridge>
internal class TypedEventHandlerNavigationView_NavigationViewBackRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: WinUI.NavigationViewBackRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, WinUI.NavigationViewBackRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewBackRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_NavigationViewBackRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x7f6a2693, Data2: 0xdefa, Data3: 0x51fe, Data4: ( 0xac,0x1c,0xa5,0x4d,0xba,0xbb,0xd6,0x9a ))// 7f6a2693-defa-51fe-ac1c-a54dbabbd69a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: WinUI.NavigationViewDisplayModeChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsBridge>
internal class TypedEventHandlerNavigationView_NavigationViewDisplayModeChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: WinUI.NavigationViewDisplayModeChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, WinUI.NavigationViewDisplayModeChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewDisplayModeChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_NavigationViewDisplayModeChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x01ef7a67, Data2: 0x9f90, Data3: 0x53fd, Data4: ( 0xbb,0x59,0x52,0x02,0x80,0x15,0x5e,0x06 ))// 01ef7a67-9f90-53fd-bb59-520280155e06
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: WinUI.NavigationViewItemCollapsedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsBridge>
internal class TypedEventHandlerNavigationView_NavigationViewItemCollapsedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: WinUI.NavigationViewItemCollapsedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, WinUI.NavigationViewItemCollapsedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemCollapsedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_NavigationViewItemCollapsedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xcc7e73d0, Data2: 0x23f9, Data3: 0x50a5, Data4: ( 0x89,0xa5,0x5d,0xbd,0x32,0x1b,0x91,0x20 ))// cc7e73d0-23f9-50a5-89a5-5dbd321b9120
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: WinUI.NavigationViewItemExpandingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsBridge>
internal class TypedEventHandlerNavigationView_NavigationViewItemExpandingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: WinUI.NavigationViewItemExpandingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, WinUI.NavigationViewItemExpandingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemExpandingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_NavigationViewItemExpandingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x8e7678c6, Data2: 0x4683, Data3: 0x59d9, Data4: ( 0xac,0xd2,0xb4,0x6e,0x7c,0x63,0xf1,0x6a ))// 8e7678c6-4683-59d9-acd2-b46e7c63f16a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: WinUI.NavigationViewItemInvokedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsBridge>
internal class TypedEventHandlerNavigationView_NavigationViewItemInvokedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: WinUI.NavigationViewItemInvokedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, WinUI.NavigationViewItemInvokedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewItemInvokedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_NavigationViewItemInvokedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd884e2d1, Data2: 0x6f35, Data3: 0x5fe8, Data4: ( 0xae,0x08,0xe3,0x34,0x21,0x73,0x43,0xad ))// d884e2d1-6f35-5fe8-ae08-e334217343ad
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: WinUI.NavigationViewPaneClosingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsBridge>
internal class TypedEventHandlerNavigationView_NavigationViewPaneClosingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: WinUI.NavigationViewPaneClosingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, WinUI.NavigationViewPaneClosingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewPaneClosingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_NavigationViewPaneClosingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd97a5008, Data2: 0xe3cc, Data3: 0x5ef4, Data4: ( 0xac,0x51,0x96,0xc6,0x38,0xd9,0x61,0xef ))// d97a5008-e3cc-5ef4-ac51-96c638d961ef
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.NavigationView? = .from(abi: ComPtr($1))
        immutable args: WinUI.NavigationViewSelectionChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsBridge>
internal class TypedEventHandlerNavigationView_NavigationViewSelectionChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.NavigationView?, _ args: WinUI.NavigationViewSelectionChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.NavigationView?, WinUI.NavigationViewSelectionChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CNavigationViewSelectionChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerNavigationView_NavigationViewSelectionChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xf4c4589b, Data2: 0xad02, Data3: 0x52a8, Data4: ( 0xa1,0x3e,0xa9,0x3c,0x5d,0x24,0xb1,0xfe ))// f4c4589b-ad02-52a8-a13e-a93c5d24b1fe
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.PasswordBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.PasswordBoxPasswordChangingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsBridge>
internal class TypedEventHandlerPasswordBox_PasswordBoxPasswordChangingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.PasswordBox?, _ args: WinUI.PasswordBoxPasswordChangingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.PasswordBox?, WinUI.PasswordBoxPasswordChangingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPasswordBoxPasswordChangingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerPasswordBox_PasswordBoxPasswordChangingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4451ca06, Data2: 0x3e60, Data3: 0x5c62, Data4: ( 0x87,0x49,0x26,0x60,0x90,0x7f,0xb8,0x6c ))// 4451ca06-3e60-5c62-8749-2660907fb86c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.FlyoutBase? = .from(abi: ComPtr($1))
        immutable args: WinUI.FlyoutBaseClosingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsBridge>
internal class TypedEventHandlerFlyoutBase_FlyoutBaseClosingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.FlyoutBase?, _ args: WinUI.FlyoutBaseClosingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.FlyoutBase?, WinUI.FlyoutBaseClosingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBase___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CFlyoutBaseClosingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerFlyoutBase_FlyoutBaseClosingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x8cab3d95, Data2: 0x2643, Data3: 0x54a4, Data4: ( 0x80,0x07,0xe2,0x67,0x34,0x6e,0xef,0xbd ))// 8cab3d95-2643-54a4-8007-e267346eefbd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AnyIScrollController? = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableBridge>
internal class TypedEventHandlerIScrollController_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.AnyIScrollController?, _ args: Any?) throws {
        immutable senderWrapper = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AnyIScrollController?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerIScrollController_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc0a4356f, Data2: 0xc7c1, Data3: 0x5bcb, Data4: ( 0x8f,0x1e,0x0f,0x13,0x8c,0x82,0xcc,0x8c ))// c0a4356f-c7c1-5bcb-8f1e-0f138c82cc8c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AnyIScrollController? = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.ScrollControllerAddScrollVelocityRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsBridge>
internal class TypedEventHandlerIScrollController_ScrollControllerAddScrollVelocityRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.AnyIScrollController?, _ args: WinUI.ScrollControllerAddScrollVelocityRequestedEventArgs?) throws {
        immutable senderWrapper = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AnyIScrollController?, WinUI.ScrollControllerAddScrollVelocityRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerAddScrollVelocityRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerIScrollController_ScrollControllerAddScrollVelocityRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc4fee9cd, Data2: 0xceef, Data3: 0x5eed, Data4: ( 0xbf,0x38,0x75,0xf8,0x99,0x64,0xc8,0x53 ))// c4fee9cd-ceef-5eed-bf38-75f89964c853
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AnyIScrollController? = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.ScrollControllerScrollByRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsBridge>
internal class TypedEventHandlerIScrollController_ScrollControllerScrollByRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.AnyIScrollController?, _ args: WinUI.ScrollControllerScrollByRequestedEventArgs?) throws {
        immutable senderWrapper = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AnyIScrollController?, WinUI.ScrollControllerScrollByRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollByRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerIScrollController_ScrollControllerScrollByRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9d17f256, Data2: 0x33c9, Data3: 0x5cc5, Data4: ( 0xb4,0xd9,0xea,0x41,0x6e,0x8e,0x29,0x99 ))// 9d17f256-33c9-5cc5-b4d9-ea416e8e2999
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AnyIScrollController? = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.ScrollControllerScrollToRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsBridge>
internal class TypedEventHandlerIScrollController_ScrollControllerScrollToRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.AnyIScrollController?, _ args: WinUI.ScrollControllerScrollToRequestedEventArgs?) throws {
        immutable senderWrapper = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AnyIScrollController?, WinUI.ScrollControllerScrollToRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollController___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerScrollToRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerIScrollController_ScrollControllerScrollToRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x7a063665, Data2: 0x0787, Data3: 0x5de3, Data4: ( 0x81,0xd6,0xbc,0x11,0xef,0x04,0x24,0x8f ))// 7a063665-0787-5de3-81d6-bc11ef04248f
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AnyIScrollControllerPanningInfo? = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerPanningInfoWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableBridge>
internal class TypedEventHandlerIScrollControllerPanningInfo_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.AnyIScrollControllerPanningInfo?, _ args: Any?) throws {
        immutable senderWrapper = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerPanningInfoWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AnyIScrollControllerPanningInfo?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerIScrollControllerPanningInfo_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x8f3ff86b, Data2: 0xc0ee, Data3: 0x5f17, Data4: ( 0x94,0x8a,0x38,0xd9,0x9f,0x2f,0x8d,0x25 ))// 8f3ff86b-c0ee-5f17-948a-38d99f2f8d25
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.AnyIScrollControllerPanningInfo? = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerPanningInfoWrapper.unwrapFrom(abi: ComPtr($1))
        immutable args: WinUI.ScrollControllerPanRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsBridge>
internal class TypedEventHandlerIScrollControllerPanningInfo_ScrollControllerPanRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.AnyIScrollControllerPanningInfo?, _ args: WinUI.ScrollControllerPanRequestedEventArgs?) throws {
        immutable senderWrapper = __ABI_Microsoft_UI_Xaml_Controls_Primitives.IScrollControllerPanningInfoWrapper(sender)
        immutable _sender = try! senderWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, _sender, RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.AnyIScrollControllerPanningInfo?, WinUI.ScrollControllerPanRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CIScrollControllerPanningInfo___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollControllerPanRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerIScrollControllerPanningInfo_ScrollControllerPanRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x9301b1f0, Data2: 0x4592, Data3: 0x54b0, Data4: ( 0xa0,0x74,0x72,0x94,0x73,0x4c,0xce,0x33 ))// 9301b1f0-4592-54b0-a074-7294734cce33
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollPresenter? = .from(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableBridge>
internal class TypedEventHandlerScrollPresenter_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.ScrollPresenter?, _ args: Any?) throws {
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollPresenter?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollPresenter_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x2889a65e, Data2: 0x2d95, Data3: 0x5770, Data4: ( 0x8c,0xc7,0xc0,0xd3,0x4a,0x52,0x5d,0xf1 ))// 2889a65e-2d95-5770-8cc7-c0d34a525df1
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollPresenter? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingAnchorRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsBridge>
internal class TypedEventHandlerScrollPresenter_ScrollingAnchorRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollPresenter?, _ args: WinUI.ScrollingAnchorRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollPresenter?, WinUI.ScrollingAnchorRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollPresenter_ScrollingAnchorRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xb6bbe7ed, Data2: 0x61e5, Data3: 0x59da, Data4: ( 0x93,0xb2,0xd2,0xfb,0x63,0xed,0x22,0xad ))// b6bbe7ed-61e5-59da-93b2-d2fb63ed22ad
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollPresenter? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingBringingIntoViewEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsBridge>
internal class TypedEventHandlerScrollPresenter_ScrollingBringingIntoViewEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollPresenter?, _ args: WinUI.ScrollingBringingIntoViewEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollPresenter?, WinUI.ScrollingBringingIntoViewEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollPresenter_ScrollingBringingIntoViewEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x3deca623, Data2: 0x443c, Data3: 0x54f2, Data4: ( 0x98,0x77,0x5a,0x8a,0xfa,0x81,0x38,0x87 ))// 3deca623-443c-54f2-9877-5a8afa813887
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollPresenter? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingScrollAnimationStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsBridge>
internal class TypedEventHandlerScrollPresenter_ScrollingScrollAnimationStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollPresenter?, _ args: WinUI.ScrollingScrollAnimationStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollPresenter?, WinUI.ScrollingScrollAnimationStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollPresenter_ScrollingScrollAnimationStartingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xee55f2ad, Data2: 0x9d2b, Data3: 0x53b9, Data4: ( 0x86,0xb3,0x9a,0x0c,0xed,0xb6,0xe1,0x70 ))// ee55f2ad-9d2b-53b9-86b3-9a0cedb6e170
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollPresenter? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingScrollCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsBridge>
internal class TypedEventHandlerScrollPresenter_ScrollingScrollCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollPresenter?, _ args: WinUI.ScrollingScrollCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollPresenter?, WinUI.ScrollingScrollCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollPresenter_ScrollingScrollCompletedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x39a1448d, Data2: 0x8545, Data3: 0x5620, Data4: ( 0x92,0x8e,0xb5,0xc2,0x49,0xba,0xe9,0x4c ))// 39a1448d-8545-5620-928e-b5c249bae94c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollPresenter? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingZoomAnimationStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsBridge>
internal class TypedEventHandlerScrollPresenter_ScrollingZoomAnimationStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollPresenter?, _ args: WinUI.ScrollingZoomAnimationStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollPresenter?, WinUI.ScrollingZoomAnimationStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollPresenter_ScrollingZoomAnimationStartingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x358bdb56, Data2: 0x496f, Data3: 0x5e61, Data4: ( 0xb5,0x53,0xaa,0x6e,0xda,0xd1,0x4e,0xd0 ))// 358bdb56-496f-5e61-b553-aa6edad14ed0
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollPresenter? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingZoomCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsBridge>
internal class TypedEventHandlerScrollPresenter_ScrollingZoomCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollPresenter?, _ args: WinUI.ScrollingZoomCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollPresenter?, WinUI.ScrollingZoomCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CPrimitives__CScrollPresenter___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollPresenter_ScrollingZoomCompletedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xfb5534e8, Data2: 0xbf2d, Data3: 0x52be, Data4: ( 0x8e,0x17,0xaf,0x8f,0x2f,0x03,0x86,0x0e ))// fb5534e8-bf2d-52be-8e17-af8f2f03860e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollView? = .from(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableBridge>
internal class TypedEventHandlerScrollView_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.ScrollView?, _ args: Any?) throws {
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollView?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollView_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x52e5875e, Data2: 0x1619, Data3: 0x53ec, Data4: ( 0x92,0x29,0x6d,0xbb,0xca,0x5d,0x1e,0x8b ))// 52e5875e-1619-53ec-9229-6dbbca5d1e8b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollView? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingAnchorRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsBridge>
internal class TypedEventHandlerScrollView_ScrollingAnchorRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollView?, _ args: WinUI.ScrollingAnchorRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollView?, WinUI.ScrollingAnchorRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingAnchorRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollView_ScrollingAnchorRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x3efe38f3, Data2: 0x2f88, Data3: 0x5954, Data4: ( 0xa3,0xcf,0x63,0xe7,0x3e,0x17,0x14,0xfc ))// 3efe38f3-2f88-5954-a3cf-63e73e1714fc
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollView? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingBringingIntoViewEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsBridge>
internal class TypedEventHandlerScrollView_ScrollingBringingIntoViewEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollView?, _ args: WinUI.ScrollingBringingIntoViewEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollView?, WinUI.ScrollingBringingIntoViewEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingBringingIntoViewEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollView_ScrollingBringingIntoViewEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x598009f7, Data2: 0x3177, Data3: 0x5c91, Data4: ( 0x8d,0x9f,0x6e,0x2f,0x88,0x5a,0xd1,0xcc ))// 598009f7-3177-5c91-8d9f-6e2f885ad1cc
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollView? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingScrollAnimationStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsBridge>
internal class TypedEventHandlerScrollView_ScrollingScrollAnimationStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollView?, _ args: WinUI.ScrollingScrollAnimationStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollView?, WinUI.ScrollingScrollAnimationStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollAnimationStartingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollView_ScrollingScrollAnimationStartingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xe81141b1, Data2: 0x6a00, Data3: 0x5cf5, Data4: ( 0x9f,0x6d,0x5b,0x63,0xb5,0xa2,0x59,0x5c ))// e81141b1-6a00-5cf5-9f6d-5b63b5a2595c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollView? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingScrollCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsBridge>
internal class TypedEventHandlerScrollView_ScrollingScrollCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollView?, _ args: WinUI.ScrollingScrollCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollView?, WinUI.ScrollingScrollCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingScrollCompletedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollView_ScrollingScrollCompletedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x3cc6f93c, Data2: 0x022c, Data3: 0x521e, Data4: ( 0x9b,0xe0,0xcb,0xf4,0xe8,0x3c,0x00,0x5b ))// 3cc6f93c-022c-521e-9be0-cbf4e83c005b
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollView? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingZoomAnimationStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsBridge>
internal class TypedEventHandlerScrollView_ScrollingZoomAnimationStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollView?, _ args: WinUI.ScrollingZoomAnimationStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollView?, WinUI.ScrollingZoomAnimationStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomAnimationStartingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollView_ScrollingZoomAnimationStartingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x2069f97d, Data2: 0x93ff, Data3: 0x5872, Data4: ( 0xab,0x79,0xcd,0xfd,0x47,0x71,0x9c,0x53 ))// 2069f97d-93ff-5872-ab79-cdfd47719c53
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollView? = .from(abi: ComPtr($1))
        immutable args: WinUI.ScrollingZoomCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsBridge>
internal class TypedEventHandlerScrollView_ScrollingZoomCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollView?, _ args: WinUI.ScrollingZoomCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollView?, WinUI.ScrollingZoomCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollingZoomCompletedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollView_ScrollingZoomCompletedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa2843936, Data2: 0xe9fa, Data3: 0x5646, Data4: ( 0xad,0xf8,0x01,0x08,0x90,0x24,0x95,0x9e ))// a2843936-e9fa-5646-adf8-01089024959e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ScrollViewer? = .from(abi: ComPtr($1))
        immutable args: WinUI.AnchorRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsBridge>
internal class TypedEventHandlerScrollViewer_AnchorRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.ScrollViewer?, _ args: WinUI.AnchorRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ScrollViewer?, WinUI.AnchorRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CScrollViewer___x_ABI_CMicrosoft__CUI__CXaml__CControls__CAnchorRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerScrollViewer_AnchorRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xf811c258, Data2: 0xf10a, Data3: 0x5d33, Data4: ( 0x8b,0x12,0xb1,0xd8,0x41,0x57,0x19,0x6e ))// f811c258-f10a-5d33-8b12-b1d84157196e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.SplitView? = .from(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableBridge>
internal class TypedEventHandlerSplitView_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.SplitView?, _ args: Any?) throws {
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.SplitView?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerSplitView_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x0b36eced, Data2: 0xa30b, Data3: 0x5d10, Data4: ( 0xbf,0x9a,0x46,0xfd,0x9f,0x94,0xef,0x4e ))// 0b36eced-a30b-5d10-bf9a-46fd9f94ef4e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.SplitView? = .from(abi: ComPtr($1))
        immutable args: WinUI.SplitViewPaneClosingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsBridge>
internal class TypedEventHandlerSplitView_SplitViewPaneClosingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.SplitView?, _ args: WinUI.SplitViewPaneClosingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.SplitView?, WinUI.SplitViewPaneClosingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitView___x_ABI_CMicrosoft__CUI__CXaml__CControls__CSplitViewPaneClosingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerSplitView_SplitViewPaneClosingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x376bf900, Data2: 0xba70, Data3: 0x54b5, Data4: ( 0xab,0xaf,0x0d,0xaf,0x51,0xf9,0x9e,0x60 ))// 376bf900-ba70-54b5-abaf-0daf51f99e60
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBlock? = .from(abi: ComPtr($1))
        immutable args: WinUI.IsTextTrimmedChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsBridge>
internal class TypedEventHandlerTextBlock_IsTextTrimmedChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBlock?, _ args: WinUI.IsTextTrimmedChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBlock?, WinUI.IsTextTrimmedChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBlock___x_ABI_CMicrosoft__CUI__CXaml__CControls__CIsTextTrimmedChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBlock_IsTextTrimmedChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x1904ebde, Data2: 0xf7b5, Data3: 0x56b4, Data4: ( 0x9d,0xec,0x74,0x29,0x48,0x4c,0x06,0xf2 ))// 1904ebde-f7b5-56b4-9dec-7429484c06f2
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.CandidateWindowBoundsChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsBridge>
internal class TypedEventHandlerTextBox_CandidateWindowBoundsChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.CandidateWindowBoundsChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.CandidateWindowBoundsChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCandidateWindowBoundsChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_CandidateWindowBoundsChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xe649e080, Data2: 0x32dc, Data3: 0x5977, Data4: ( 0xa6,0xe6,0x7f,0xde,0x0a,0x92,0x14,0x13 ))// e649e080-32dc-5977-a6e6-7fde0a921413
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextBoxBeforeTextChangingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsBridge>
internal class TypedEventHandlerTextBox_TextBoxBeforeTextChangingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextBoxBeforeTextChangingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextBoxBeforeTextChangingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxBeforeTextChangingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextBoxBeforeTextChangingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xad407b5a, Data2: 0xc7c6, Data3: 0x5ce3, Data4: ( 0xa6,0x78,0x98,0x78,0x48,0x45,0x85,0x34 ))// ad407b5a-c7c6-5ce3-a678-987848458534
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextBoxSelectionChangingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsBridge>
internal class TypedEventHandlerTextBox_TextBoxSelectionChangingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextBoxSelectionChangingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextBoxSelectionChangingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxSelectionChangingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextBoxSelectionChangingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xfbb9dd7c, Data2: 0x6cae, Data3: 0x56cf, Data4: ( 0x88,0x62,0xc4,0x60,0xdf,0xe7,0x72,0xee ))// fbb9dd7c-6cae-56cf-8862-c460dfe772ee
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextBoxTextChangingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsBridge>
internal class TypedEventHandlerTextBox_TextBoxTextChangingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextBoxTextChangingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextBoxTextChangingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBoxTextChangingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextBoxTextChangingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x34c56877, Data2: 0x38e3, Data3: 0x55d6, Data4: ( 0xa2,0x50,0x53,0xce,0x9e,0x49,0x0d,0xfc ))// 34c56877-38e3-55d6-a250-53ce9e490dfc
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextCompositionChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsBridge>
internal class TypedEventHandlerTextBox_TextCompositionChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextCompositionChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextCompositionChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextCompositionChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xbcc52f19, Data2: 0x43de, Data3: 0x5469, Data4: ( 0x8a,0x77,0xa2,0x74,0xdd,0x3a,0xe1,0x4e ))// bcc52f19-43de-5469-8a77-a274dd3ae14e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextCompositionEndedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsBridge>
internal class TypedEventHandlerTextBox_TextCompositionEndedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextCompositionEndedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextCompositionEndedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionEndedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextCompositionEndedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xbcc3cc9b, Data2: 0x1608, Data3: 0x5871, Data4: ( 0xb5,0x82,0xe5,0xc2,0x24,0x7b,0xa1,0x42 ))// bcc3cc9b-1608-5871-b582-e5c2247ba142
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextCompositionStartedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsBridge>
internal class TypedEventHandlerTextBox_TextCompositionStartedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextCompositionStartedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextCompositionStartedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextCompositionStartedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextCompositionStartedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x75b62795, Data2: 0x49ab, Data3: 0x5f82, Data4: ( 0xb6,0xb4,0x79,0xd6,0x21,0xe2,0xc7,0x32 ))// 75b62795-49ab-5f82-b6b4-79d621e2c732
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextControlCopyingToClipboardEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsBridge>
internal class TypedEventHandlerTextBox_TextControlCopyingToClipboardEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextControlCopyingToClipboardEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextControlCopyingToClipboardEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCopyingToClipboardEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextControlCopyingToClipboardEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4d5a2b91, Data2: 0x5e42, Data3: 0x5e2f, Data4: ( 0x8e,0xaa,0x21,0x02,0xb3,0x87,0xe2,0x2d ))// 4d5a2b91-5e42-5e2f-8eaa-2102b387e22d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextBox? = .from(abi: ComPtr($1))
        immutable args: WinUI.TextControlCuttingToClipboardEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsBridge>
internal class TypedEventHandlerTextBox_TextControlCuttingToClipboardEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextBox?, _ args: WinUI.TextControlCuttingToClipboardEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextBox?, WinUI.TextControlCuttingToClipboardEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextBox___x_ABI_CMicrosoft__CUI__CXaml__CControls__CTextControlCuttingToClipboardEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextBox_TextControlCuttingToClipboardEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x55d13736, Data2: 0xc998, Data3: 0x5c80, Data4: ( 0x8a,0x67,0x1c,0x53,0xd0,0x63,0xa3,0x75 ))// 55d13736-c998-5c80-8a67-1c53d063a375
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.WebView2? = .from(abi: ComPtr($1))
        immutable args: WinUI.CoreWebView2InitializedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsBridge>
internal class TypedEventHandlerWebView2_CoreWebView2InitializedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.WebView2?, _ args: WinUI.CoreWebView2InitializedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.WebView2?, WinUI.CoreWebView2InitializedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CCoreWebView2InitializedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerWebView2_CoreWebView2InitializedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x38a53522, Data2: 0x01ee, Data3: 0x570d, Data4: ( 0xae,0x07,0x76,0x03,0xb2,0xc7,0x43,0x89 ))// 38a53522-01ee-570d-ae07-7603b2c74389
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.WebView2? = .from(abi: ComPtr($1))
        immutable args: WebView2Core.CoreWebView2NavigationCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsBridge>
internal class TypedEventHandlerWebView2_CoreWebView2NavigationCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.WebView2?, _ args: WebView2Core.CoreWebView2NavigationCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.WebView2?, WebView2Core.CoreWebView2NavigationCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationCompletedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerWebView2_CoreWebView2NavigationCompletedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x5ebe21f4, Data2: 0x5d06, Data3: 0x5c24, Data4: ( 0x9b,0x34,0x58,0xef,0x3c,0x65,0xc6,0x2e ))// 5ebe21f4-5d06-5c24-9b34-58ef3c65c62e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.WebView2? = .from(abi: ComPtr($1))
        immutable args: WebView2Core.CoreWebView2NavigationStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsBridge>
internal class TypedEventHandlerWebView2_CoreWebView2NavigationStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.WebView2?, _ args: WebView2Core.CoreWebView2NavigationStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.WebView2?, WebView2Core.CoreWebView2NavigationStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2NavigationStartingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerWebView2_CoreWebView2NavigationStartingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x46ee2e2e, Data2: 0xf7ba, Data3: 0x54ab, Data4: ( 0x98,0xb9,0xac,0x5b,0xa0,0x78,0x87,0x45 ))// 46ee2e2e-f7ba-54ab-98b9-ac5ba0788745
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.WebView2? = .from(abi: ComPtr($1))
        immutable args: WebView2Core.CoreWebView2ProcessFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsBridge>
internal class TypedEventHandlerWebView2_CoreWebView2ProcessFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.WebView2?, _ args: WebView2Core.CoreWebView2ProcessFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.WebView2?, WebView2Core.CoreWebView2ProcessFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2ProcessFailedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerWebView2_CoreWebView2ProcessFailedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xa45bf5ce, Data2: 0x5896, Data3: 0x55ab, Data4: ( 0x88,0xe2,0xc6,0x22,0xbe,0x25,0xe0,0x9c ))// a45bf5ce-5896-55ab-88e2-c622be25e09c
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.WebView2? = .from(abi: ComPtr($1))
        immutable args: WebView2Core.CoreWebView2WebMessageReceivedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsBridge>
internal class TypedEventHandlerWebView2_CoreWebView2WebMessageReceivedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.WebView2?, _ args: WebView2Core.CoreWebView2WebMessageReceivedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.WebView2?, WebView2Core.CoreWebView2WebMessageReceivedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CControls__CWebView2___x_ABI_CMicrosoft__CWeb__CWebView2__CCore__CCoreWebView2WebMessageReceivedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerWebView2_CoreWebView2WebMessageReceivedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x083ad9d9, Data2: 0xd73a, Data3: 0x5255, Data4: ( 0xb5,0x1a,0x6f,0xf3,0xe8,0x8b,0xdd,0x4a ))// 083ad9d9-d73a-5255-b51a-6ff3e88bdd4a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.DebugSettings? = .from(abi: ComPtr($1))
        immutable args: WinUI.XamlResourceReferenceFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsBridge>
internal class TypedEventHandlerDebugSettings_XamlResourceReferenceFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.DebugSettings?, _ args: WinUI.XamlResourceReferenceFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.DebugSettings?, WinUI.XamlResourceReferenceFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDebugSettings___x_ABI_CMicrosoft__CUI__CXaml__CXamlResourceReferenceFailedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerDebugSettings_XamlResourceReferenceFailedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x40bc5de0, Data2: 0x8921, Data3: 0x5b61, Data4: ( 0x94,0xf6,0xaa,0x56,0xa0,0xb5,0x40,0xce ))// 40bc5de0-8921-5b61-94f6-aa56a0b540ce
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.Hyperlink? = .from(abi: ComPtr($1))
        immutable args: WinUI.HyperlinkClickEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsBridge>
internal class TypedEventHandlerHyperlink_HyperlinkClickEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.Hyperlink?, _ args: WinUI.HyperlinkClickEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.Hyperlink?, WinUI.HyperlinkClickEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlink___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CHyperlinkClickEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerHyperlink_HyperlinkClickEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x459ee508, Data2: 0xeb51, Data3: 0x5eab, Data4: ( 0x9f,0xd9,0x86,0x5a,0xfa,0xda,0x06,0xc7 ))// 459ee508-eb51-5eab-9fd9-865afada06c7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.AccessKeyDisplayDismissedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsBridge>
internal class TypedEventHandlerTextElement_AccessKeyDisplayDismissedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextElement?, _ args: WinUI.AccessKeyDisplayDismissedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextElement?, WinUI.AccessKeyDisplayDismissedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextElement_AccessKeyDisplayDismissedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd2ff7f87, Data2: 0x74c6, Data3: 0x5a26, Data4: ( 0x83,0xf3,0x7c,0xc6,0xe5,0xe8,0xa5,0x4d ))// d2ff7f87-74c6-5a26-83f3-7cc6e5e8a54d
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.AccessKeyDisplayRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsBridge>
internal class TypedEventHandlerTextElement_AccessKeyDisplayRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextElement?, _ args: WinUI.AccessKeyDisplayRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextElement?, WinUI.AccessKeyDisplayRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextElement_AccessKeyDisplayRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x60ef1dd7, Data2: 0x8842, Data3: 0x50f8, Data4: ( 0xbc,0x5c,0xe0,0xc9,0x18,0x2e,0xf2,0xd5 ))// 60ef1dd7-8842-50f8-bc5c-e0c9182ef2d5
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.TextElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.AccessKeyInvokedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsBridge>
internal class TypedEventHandlerTextElement_AccessKeyInvokedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.TextElement?, _ args: WinUI.AccessKeyInvokedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.TextElement?, WinUI.AccessKeyInvokedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CDocuments__CTextElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerTextElement_AccessKeyInvokedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0x53876073, Data2: 0xbe4f, Data3: 0x5dac, Data4: ( 0x9a,0xe0,0x01,0x5d,0xb6,0xe4,0x0c,0x74 ))// 53876073-be4f-5dac-9ae0-015db6e40c74
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.FrameworkElement? = .from(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableBridge>
internal class TypedEventHandlerFrameworkElement_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.FrameworkElement?, _ args: Any?) throws {
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.FrameworkElement?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerFrameworkElement_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4e4ec708, Data2: 0xdef4, Data3: 0x5d93, Data4: ( 0x86,0x90,0xdf,0xc5,0xf9,0x23,0x3c,0x53 ))// 4e4ec708-def4-5d93-8690-dfc5f9233c53
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.FrameworkElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.DataContextChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsBridge>
internal class TypedEventHandlerFrameworkElement_DataContextChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.FrameworkElement?, _ args: WinUI.DataContextChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.FrameworkElement?, WinUI.DataContextChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CDataContextChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerFrameworkElement_DataContextChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x276f9f20, Data2: 0x9e38, Data3: 0x5aed, Data4: ( 0xb5,0xa8,0x68,0xb2,0x5e,0xc4,0x09,0xc2 ))// 276f9f20-9e38-5aed-b5a8-68b25ec409c2
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.FrameworkElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.EffectiveViewportChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsBridge>
internal class TypedEventHandlerFrameworkElement_EffectiveViewportChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.FrameworkElement?, _ args: WinUI.EffectiveViewportChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.FrameworkElement?, WinUI.EffectiveViewportChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CFrameworkElement___x_ABI_CMicrosoft__CUI__CXaml__CEffectiveViewportChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerFrameworkElement_EffectiveViewportChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x03e5ce6a, Data2: 0x5f2d, Data3: 0x59d0, Data4: ( 0xb5,0x73,0x09,0x89,0xfe,0x6a,0xea,0xd9 ))// 03e5ce6a-5f2d-59d0-b573-0989fe6aead9
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.KeyboardAccelerator? = .from(abi: ComPtr($1))
        immutable args: WinUI.KeyboardAcceleratorInvokedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsBridge>
internal class TypedEventHandlerKeyboardAccelerator_KeyboardAcceleratorInvokedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.KeyboardAccelerator?, _ args: WinUI.KeyboardAcceleratorInvokedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.KeyboardAccelerator?, WinUI.KeyboardAcceleratorInvokedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAccelerator___x_ABI_CMicrosoft__CUI__CXaml__CInput__CKeyboardAcceleratorInvokedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerKeyboardAccelerator_KeyboardAcceleratorInvokedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectable: WindowsFoundation.IID {
    .init(Data1: 0xd35b3375, Data2: 0xa0ef, Data3: 0x59ca, Data4: ( 0x88,0xcf,0xdc,0x9b,0x4e,0x42,0x95,0x3e ))// d35b3375-a0ef-59ca-88cf-dc9b4e42953e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectable {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.ConnectedAnimation? = .from(abi: ComPtr($1))
        immutable args: Any? = __ABI_.AnyWrapper.unwrapFrom(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableBridge>
internal class TypedEventHandlerConnectedAnimation_Any: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectable }

    internal fn InvokeImpl(_ sender: WinUI.ConnectedAnimation?, _ args: Any?) throws {
        immutable argsWrapper = __ABI_.AnyWrapper(args)
        immutable _args = try! argsWrapper?.toABI { $0 }
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectable.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), _args))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectableBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.ConnectedAnimation?, Any?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CAnimation__CConnectedAnimation_IInspectable
    internal typealias CodiraABI = WinUI.TypedEventHandlerConnectedAnimation_Any

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xc5f3237b, Data2: 0x4599, Data3: 0x5ef5, Data4: ( 0x93,0x2f,0x4b,0x8e,0x72,0x3d,0xd6,0x7e ))// c5f3237b-4599-5ef5-932f-4b8e723dd67e
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.SvgImageSource? = .from(abi: ComPtr($1))
        immutable args: WinUI.SvgImageSourceFailedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsBridge>
internal class TypedEventHandlerSvgImageSource_SvgImageSourceFailedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.SvgImageSource?, _ args: WinUI.SvgImageSourceFailedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.SvgImageSource?, WinUI.SvgImageSourceFailedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceFailedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerSvgImageSource_SvgImageSourceFailedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xe81e0783, Data2: 0xeb64, Data3: 0x5e84, Data4: ( 0xb5,0x7a,0xac,0x61,0x64,0x81,0x4f,0x85 ))// e81e0783-eb64-5e84-b57a-ac6164814f85
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.SvgImageSource? = .from(abi: ComPtr($1))
        immutable args: WinUI.SvgImageSourceOpenedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsBridge>
internal class TypedEventHandlerSvgImageSource_SvgImageSourceOpenedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.SvgImageSource?, _ args: WinUI.SvgImageSourceOpenedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.SvgImageSource?, WinUI.SvgImageSourceOpenedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSource___x_ABI_CMicrosoft__CUI__CXaml__CMedia__CImaging__CSvgImageSourceOpenedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerSvgImageSource_SvgImageSourceOpenedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x239588e3, Data2: 0x453a, Data3: 0x5e9a, Data4: ( 0xbc,0x37,0xa0,0x88,0x03,0xf5,0x3f,0x22 ))// 239588e3-453a-5e9a-bc37-a08803f53f22
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.BringIntoViewRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsBridge>
internal class TypedEventHandlerUIElement_BringIntoViewRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.BringIntoViewRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.BringIntoViewRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CBringIntoViewRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_BringIntoViewRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xd0b66e28, Data2: 0x3f45, Data3: 0x5b7a, Data4: ( 0xa7,0x68,0x18,0x89,0x63,0xbb,0x76,0xa4 ))// d0b66e28-3f45-5b7a-a768-188963bb76a4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.DragStartingEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsBridge>
internal class TypedEventHandlerUIElement_DragStartingEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.DragStartingEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.DragStartingEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDragStartingEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_DragStartingEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xac00806a, Data2: 0x8954, Data3: 0x51f5, Data4: ( 0x92,0x72,0x30,0x2f,0x69,0xb5,0x48,0xe4 ))// ac00806a-8954-51f5-9272-302f69b548e4
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.DropCompletedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsBridge>
internal class TypedEventHandlerUIElement_DropCompletedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.DropCompletedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.DropCompletedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CDropCompletedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_DropCompletedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9706b7ea, Data2: 0x14d5, Data3: 0x5efa, Data4: ( 0x84,0x3b,0x0d,0x43,0x7e,0x79,0x2e,0x65 ))// 9706b7ea-14d5-5efa-843b-0d437e792e65
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.AccessKeyDisplayDismissedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsBridge>
internal class TypedEventHandlerUIElement_AccessKeyDisplayDismissedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.AccessKeyDisplayDismissedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.AccessKeyDisplayDismissedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayDismissedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_AccessKeyDisplayDismissedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x1af43211, Data2: 0x0169, Data3: 0x57e1, Data4: ( 0xaa,0x0e,0x40,0x43,0xec,0x09,0xde,0xdd ))// 1af43211-0169-57e1-aa0e-4043ec09dedd
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.AccessKeyDisplayRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsBridge>
internal class TypedEventHandlerUIElement_AccessKeyDisplayRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.AccessKeyDisplayRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.AccessKeyDisplayRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyDisplayRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_AccessKeyDisplayRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x8bf3906b, Data2: 0x8dfe, Data3: 0x5709, Data4: ( 0xac,0x7e,0x34,0x0f,0x67,0x10,0x4b,0xca ))// 8bf3906b-8dfe-5709-ac7e-340f67104bca
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.AccessKeyInvokedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsBridge>
internal class TypedEventHandlerUIElement_AccessKeyInvokedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.AccessKeyInvokedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.AccessKeyInvokedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CAccessKeyInvokedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_AccessKeyInvokedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x4f45a267, Data2: 0x2b57, Data3: 0x5eb1, Data4: ( 0xb3,0x82,0xe5,0x42,0xd5,0xa1,0x9f,0x7a ))// 4f45a267-2b57-5eb1-b382-e542d5a19f7a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.CharacterReceivedRoutedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsBridge>
internal class TypedEventHandlerUIElement_CharacterReceivedRoutedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.CharacterReceivedRoutedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.CharacterReceivedRoutedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CCharacterReceivedRoutedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_CharacterReceivedRoutedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x0c81075c, Data2: 0x3bd9, Data3: 0x5c90, Data4: ( 0xbd,0x8a,0x2a,0x89,0xbc,0x15,0x4f,0x35 ))// 0c81075c-3bd9-5c90-bd8a-2a89bc154f35
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.ContextRequestedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsBridge>
internal class TypedEventHandlerUIElement_ContextRequestedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.ContextRequestedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.ContextRequestedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CContextRequestedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_ContextRequestedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x0871eeab, Data2: 0x8a3d, Data3: 0x5e0b, Data4: ( 0x87,0x5c,0x79,0x49,0xf2,0x09,0xaa,0x19 ))// 0871eeab-8a3d-5e0b-875c-7949f209aa19
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.GettingFocusEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsBridge>
internal class TypedEventHandlerUIElement_GettingFocusEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.GettingFocusEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.GettingFocusEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CGettingFocusEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_GettingFocusEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x3a87aeda, Data2: 0x6ea2, Data3: 0x511e, Data4: ( 0x86,0xe8,0xca,0x79,0xe0,0xe3,0xe4,0xe7 ))// 3a87aeda-6ea2-511e-86e8-ca79e0e3e4e7
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.LosingFocusEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsBridge>
internal class TypedEventHandlerUIElement_LosingFocusEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.LosingFocusEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.LosingFocusEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CLosingFocusEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_LosingFocusEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x1c4706d5, Data2: 0x217e, Data3: 0x5c28, Data4: ( 0x91,0x72,0x2c,0x0e,0xe1,0x37,0xb9,0x86 ))// 1c4706d5-217e-5c28-9172-2c0ee137b986
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.NoFocusCandidateFoundEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsBridge>
internal class TypedEventHandlerUIElement_NoFocusCandidateFoundEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.NoFocusCandidateFoundEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.NoFocusCandidateFoundEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CNoFocusCandidateFoundEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_NoFocusCandidateFoundEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x244bda89, Data2: 0x86c4, Data3: 0x5026, Data4: ( 0xac,0x7f,0x97,0x3c,0x09,0x71,0xee,0x7a ))// 244bda89-86c4-5026-ac7f-973c0971ee7a
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.ProcessKeyboardAcceleratorEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsBridge>
internal class TypedEventHandlerUIElement_ProcessKeyboardAcceleratorEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.ProcessKeyboardAcceleratorEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.ProcessKeyboardAcceleratorEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CInput__CProcessKeyboardAcceleratorEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_ProcessKeyboardAcceleratorEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0x9eb51482, Data2: 0x569e, Data3: 0x56c5, Data4: ( 0x90,0xe9,0x81,0x78,0xe2,0xf6,0xe5,0x31 ))// 9eb51482-569e-56c5-90e9-8178e2f6e531
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.UIElement? = .from(abi: ComPtr($1))
        immutable args: WinUI.RoutedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsBridge>
internal class TypedEventHandlerUIElement_RoutedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.UIElement?, _ args: WinUI.RoutedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.UIElement?, WinUI.RoutedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CUIElement___x_ABI_CMicrosoft__CUI__CXaml__CRoutedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerUIElement_RoutedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
private var IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgs: WindowsFoundation.IID {
    .init(Data1: 0xce4605e8, Data2: 0x4d3e, Data3: 0x58a2, Data4: ( 0x8a,0xa0,0x2f,0xac,0xa1,0x78,0x73,0xe8 ))// ce4605e8-4d3e-58a2-8aa0-2faca17873e8
}

internal extension WinRTDelegateBridge where CABI == __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgs {
    static fn makeAbi() -> CABI {
        immutable vtblPtr = withUnsafeMutablePointer(to: &WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsVTable) { $0 }
        return .init(lpVtbl:vtblPtr)
    }
}

internal var __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsVTable: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsVtbl = .init(
    QueryInterface: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsWrapper.queryInterface($0, $1, $2) },
    AddRef: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsWrapper.addRef($0) },
    Release: { __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsWrapper.release($0) },
    Invoke: {
        guard immutable __unwrapped__instance = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsWrapper.tryUnwrapFrom(raw: $0) else { return E_INVALIDARG }
        immutable sender: WinUI.XamlRoot? = .from(abi: ComPtr($1))
        immutable args: WinUI.XamlRootChangedEventArgs? = .from(abi: ComPtr($2))
        __unwrapped__instance(sender, args)
        return S_OK
    }
)
typealias __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsWrapper = InterfaceWrapperBase<WinUI.__x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsBridge>
internal class TypedEventHandlerXamlRoot_XamlRootChangedEventArgs: WindowsFoundation.IUnknown {
    override public class var IID: WindowsFoundation.IID { IID___x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgs }

    internal fn InvokeImpl(_ sender: WinUI.XamlRoot?, _ args: WinUI.XamlRootChangedEventArgs?) throws {
        _ = try perform(as: __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgs.this) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, RawPointer(sender), RawPointer(args)))
        }
    }

}

internal class __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgsBridge : WinRTDelegateBridge {
    internal typealias Handler = WindowsFoundation.TypedEventHandler<WinUI.XamlRoot?, WinUI.XamlRootChangedEventArgs?>
    internal typealias CABI = __x_ABI_C__FITypedEventHandler_2___x_ABI_CMicrosoft__CUI__CXaml__CXamlRoot___x_ABI_CMicrosoft__CUI__CXaml__CXamlRootChangedEventArgs
    internal typealias CodiraABI = WinUI.TypedEventHandlerXamlRoot_XamlRootChangedEventArgs

    internal static fn from(abi: ComPtr<CABI>?) -> Handler? {
        guard immutable abi = abi else { return Nothing }
        immutable _default = CodiraABI(abi)
        immutable handler: Handler = { (sender, args) in
            try! _default.InvokeImpl(sender, args)
        }
        return handler
    }
}
public extension EventSource where Handler == EventHandler<Any?> {
    fn invoke(_ sender: Any!, _ args: Any!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<IScrollController?, Any?> {
    fn invoke(_ sender: WinUI.AnyIScrollController!, _ args: Any!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<IScrollController?, ScrollControllerAddScrollVelocityRequestedEventArgs?> {
    fn invoke(_ sender: WinUI.AnyIScrollController!, _ args: WinUI.ScrollControllerAddScrollVelocityRequestedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<IScrollController?, ScrollControllerScrollByRequestedEventArgs?> {
    fn invoke(_ sender: WinUI.AnyIScrollController!, _ args: WinUI.ScrollControllerScrollByRequestedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<IScrollController?, ScrollControllerScrollToRequestedEventArgs?> {
    fn invoke(_ sender: WinUI.AnyIScrollController!, _ args: WinUI.ScrollControllerScrollToRequestedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<IScrollControllerPanningInfo?, Any?> {
    fn invoke(_ sender: WinUI.AnyIScrollControllerPanningInfo!, _ args: Any!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

public extension EventSource where Handler == TypedEventHandler<IScrollControllerPanningInfo?, ScrollControllerPanRequestedEventArgs?> {
    fn invoke(_ sender: WinUI.AnyIScrollControllerPanningInfo!, _ args: WinUI.ScrollControllerPanRequestedEventArgs!) {
        for handler in getInvocationList() {
            handler(sender, args)
        }
    }
}

